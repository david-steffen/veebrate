{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap a0d7a85bd5170a56e286","webpack:///./app-client.js","webpack:///./app/root.js","webpack:///./~/ractive/ractive.js","webpack:///./app/views/root.html","webpack:///./app/components/header.js","webpack:///./app/views/components/header.html","webpack:///./~/vertx3-eventbus-client/vertx-eventbus.js","webpack:///./~/sockjs-client/lib/entry.js","webpack:///./~/sockjs-client/lib/transport-list.js","webpack:///./~/sockjs-client/lib/transport/websocket.js","webpack:///./~/process/browser.js","webpack:///./~/sockjs-client/lib/utils/event.js","webpack:///./~/sockjs-client/lib/utils/random.js","webpack:///./~/sockjs-client/lib/utils/browser-crypto.js","webpack:///./~/sockjs-client/lib/utils/url.js","webpack:///./~/url-parse/index.js","webpack:///./~/requires-port/index.js","webpack:///./~/url-parse/lolcation.js","webpack:///./~/querystringify/index.js","webpack:///./~/debug/browser.js","webpack:///./~/debug/debug.js","webpack:///./~/ms/index.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/sockjs-client/lib/event/emitter.js","webpack:///./~/sockjs-client/lib/event/eventtarget.js","webpack:///./~/sockjs-client/lib/transport/browser/websocket.js","webpack:///./~/sockjs-client/lib/transport/xhr-streaming.js","webpack:///./~/sockjs-client/lib/transport/lib/ajax-based.js","webpack:///./~/sockjs-client/lib/transport/lib/sender-receiver.js","webpack:///./~/sockjs-client/lib/transport/lib/buffered-sender.js","webpack:///./~/sockjs-client/lib/transport/lib/polling.js","webpack:///./~/sockjs-client/lib/transport/receiver/xhr.js","webpack:///./~/sockjs-client/lib/transport/sender/xhr-cors.js","webpack:///./~/sockjs-client/lib/transport/browser/abstract-xhr.js","webpack:///./~/sockjs-client/lib/transport/sender/xhr-local.js","webpack:///./~/sockjs-client/lib/utils/browser.js","webpack:///./~/sockjs-client/lib/transport/xdr-streaming.js","webpack:///./~/sockjs-client/lib/transport/sender/xdr.js","webpack:///./~/sockjs-client/lib/transport/eventsource.js","webpack:///./~/sockjs-client/lib/transport/receiver/eventsource.js","webpack:///./~/sockjs-client/lib/transport/browser/eventsource.js","webpack:///./~/sockjs-client/lib/transport/lib/iframe-wrap.js","webpack:///./~/sockjs-client/lib/transport/iframe.js","webpack:///./~/json3/lib/json3.js","webpack:///(webpack)/buildin/module.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./~/sockjs-client/lib/version.js","webpack:///./~/sockjs-client/lib/utils/iframe.js","webpack:///./~/sockjs-client/lib/utils/object.js","webpack:///./~/sockjs-client/lib/transport/htmlfile.js","webpack:///./~/sockjs-client/lib/transport/receiver/htmlfile.js","webpack:///./~/sockjs-client/lib/transport/xhr-polling.js","webpack:///./~/sockjs-client/lib/transport/xdr-polling.js","webpack:///./~/sockjs-client/lib/transport/jsonp-polling.js","webpack:///./~/sockjs-client/lib/transport/receiver/jsonp.js","webpack:///./~/sockjs-client/lib/transport/sender/jsonp.js","webpack:///./~/sockjs-client/lib/main.js","webpack:///./~/sockjs-client/lib/shims.js","webpack:///./~/sockjs-client/lib/utils/escape.js","webpack:///./~/sockjs-client/lib/utils/transport.js","webpack:///./~/sockjs-client/lib/utils/log.js","webpack:///./~/sockjs-client/lib/event/event.js","webpack:///./~/sockjs-client/lib/location.js","webpack:///./~/sockjs-client/lib/event/close.js","webpack:///./~/sockjs-client/lib/event/trans-message.js","webpack:///./~/sockjs-client/lib/info-receiver.js","webpack:///./~/sockjs-client/lib/transport/sender/xhr-fake.js","webpack:///./~/sockjs-client/lib/info-iframe.js","webpack:///./~/sockjs-client/lib/info-iframe-receiver.js","webpack:///./~/sockjs-client/lib/info-ajax.js","webpack:///./~/sockjs-client/lib/iframe-bootstrap.js","webpack:///./~/sockjs-client/lib/facade.js","webpack:///./~/ractive-touch/index.js","webpack:///./~/hammerjs/hammer.js","webpack:///./~/ractive-events-tap/dist/ractive-events-tap.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_root","_root2","document","getElementById","Root","root","eb","navigator","vibrate","webkitVibrate","mozVibrate","msVibrate","Ractive","DEBUG","view","el","template","magic","data","speed","recipient","sender","signupOpen","menuOpen","user","conn","sending","selectUser","events","tap","components","Header","headerComponent","oninit","this","on","handleInput","event","set","original","target","name","value","hideUserForm","get","toggle","connect","startVibrate","model","sendMessage","endVibrate","selectSpeed","node","changeUser","eventbusUrl","window","location","hostname","EventBus","onopen","registerHandler","error","msg","vibrate.vibrate","body","vibrate.speed","vibrate.sender","msgHandler","bind","send","onclose","unregisterHandler","start","step","timestamp","progress","requestAnimationFrame","global","factory","createDocumentFragment","doc","getElement","input","output","win","nodeType","querySelector","detachNode","parentNode","removeChild","safeToStringValue","toString","safeAttributeString","string","replace","camelize","camel","s","charAt","toUpperCase","decamelize","decamel","toLowerCase","extendObj","sources","len","arguments","length","prop","forEach","source","hasOwn","fillGaps","key","isArray","thing","isEqual","a","b","isNumeric","isNaN","parseFloat","isFinite","isObject","noop","format","message","args","shift","fatal","Error","logIfDebug","log","apply","warn","printWarning","warnOnce","alreadyWarned","warnIfDebug","warnOnceIfDebug","findInViewHierarchy","registryName","ractive","instance","findInstance","isolated","parent","interpolate","from","to","type","interpol","missingPlugin","interpolators","number","array","object","snap","addToArray","index","indexOf","push","arrayContains","i","arrayContentsMatch","ensureArray","x","undefined","lastItem","removeFromArray","member","splice","toArray","arrayLike","wait","callback","setTimeout","makeDispatcher","handlers","result","handler","resolve","promise","fulfil","reject","then","TypeError","_Promise","e","called","resolvePromise","rejectPromise","y","r","detach","element","_detachNodes","tm","detachNodes","check","ready","outros","outroChildren","outrosComplete","decrementOutros","intros","totalChildren","notifiedTotal","decrementTotal","detachImmediate","manager","trans","queue","detachQueue","collectAllOutros","j","contains","list","children","concat","dispatch","observer","flushChanges","which","batch","immediateObservers","fragment","fragments","ractives","Object","keys","viewmodel","changes","changeHook","fire","update","ractive$1","transitionManager","deferredObservers","tasks","escapeKey","escapeKeyPattern","normalise","ref","refPattern","splitKeypathI","keypath","match","splitPattern","exec","substr","unescapeKey","unescapeKeyPattern","fn","context","test","bound","pairs","runloop","end","gather","base","star","findMatches","joinAll","build","sets","loop","k","hasOwnProperty","map","add","d","pair","errorMessage","Ractive$add","getOptions","options","easing","linear","duration","complete","protoAnimate","noAnimation","interpolator","animate","Ractive$animate","join","Ractive$detach","isDetached","__ractive_instances__","detachHook","Ractive$find","selector","find","sortByDocumentPosition","otherNode","compareDocumentPosition","bitmask","sortByItemPosition","mutualAncestor","ancestryA","getAncestry","component","_ractive","proxy","ancestryB","oldestA","oldestB","pop","fragmentA","parentFragment","fragmentB","indexA","items","indexB","iterations","indexA$1","indexB$1","getParent","item","owner","ancestry","ancestor","Ractive$findAll","liveQueries","_liveQueries","query","live","slice","Query","findAll","init","Ractive$findAllComponents","_liveComponentQueries","findAllComponents","Ractive$findComponent","findComponent","Ractive$findContainer","container","findContainer","Ractive$findParent","findParent","enqueue","_eventQueue","dequeue","getPotentialWildcardMatches","starMap","mapper","wildcardKeypath","starMaps","getStarMap","num","max","binary","l","ones","parseInt","digit","fireEvent","eventName","_noArg","eventNames","getWildcardNames","fireEventAs","wildcardCache","initialFire","subscribers","bubble","_subs","notifySubscribers","fullName","originalEvent","stopEvent","off","preventDefault","stopPropagation","Ractive$fire","badReference","resolveAmbiguousReference","hasContextChain","crossedComponentBoundary","aliases","localViewmodel","findContext","isIteration","keyRef","getKeyModel","indexRef","isRoot","has","createLink","joinKey","componentParent","startCapturing","stack","captureGroup","stopCapturing","dependencies","capture","bind$1","cancel","handleChange","mark","marked","notifiedUpstream","render","teardown","unbind","unrender","unrenderAndDestroy","toString$1","toEscapedString","updateFromBindings","findBoundValue","checked","fireShuffleTasks","stage","shuffleTasks","register","registerQueue","rebindMatch","next","previous","isKey","isKeypath","parts","split","shuffling","tick","ticker","now","getTime","tickers","rAF","running","prefixKeypath","prefix","prefixed","getPrefixer","rootKeypath","rootDot","prefixers","relativeKeypath","recreateArray","childByKey","resolveReference","keypathExpr","getKeypathModel","match$1","model$1","repeater","findRepeatingFragment","getRactiveModel","GlobalModel$1","part","Ractive$get","opts","gatherRefs","getNewIndices","methodName","spliceArguments","removeStart","removeEnd","balance","newIndices","getSpliceEquivalent","Math","min","startIndex","touchedFrom","makeArrayMethod","path","mdl","result$1","arrayProto","promise$1","getKeypath","shuffle","getComparator","option","JSON","stringify","comparators","merge$1","comparator","compare","merge","thisRactive$merge","update$2","wrapper","adapt","registerChange","clearUnresolveds","notifyUpstream","updateHook","Ractive$update","build$1","findModel","_element","resolve$1","frag","add$1","val","link","dest","there","here","modelPop","values","modelPush","reverse","modelReverse","set$1","modelShift","drop","unshift","modelSplice","sort","modelSort","subtract","unlink","_link","modelUnshift","update$1","updateModel","cascade","isBound","getBindingModel","getBindingPath","getBinding","ctx","binding","setBinding","rootpath","addHelpers","defineProperties","staticInfo","storage","getNodeInfo","Ractive$insert","anchor","rendered","insertBefore","fireInsertHook","insertHook","child","link$1","sourcePath","observe","this$1","observers","keypaths","filter","createObserver","_observers","wildcardIndex","Observer","baseModel","PatternObserver","observeList","ListObserver","negativeOne","observeOnce","onceOptions","trim","str","notEmptyString","Ractive$off","Ractive$on","n","listeners","listener","Ractive$once","addCSS","styleDefinition","styleDefinitions","isDirty","applyCSS","useCssText","styleElement","styleSheet","cssText","getCSS","innerHTML","cssIds","filteredStyleDefinitions","style","reduce","styles","PREFIX","render$1","occupants","transitionsEnabled","noIntro","scheduleTask","renderHook","cssId","docFrag","completeHook","Ractive$render","torndown","Promise","append","others","enhance","childNodes","combine","trim$1","extractString","unit","transformSelector","selectorUnits","selectorUnitPattern","modifiers","transformed","appended","prepended","transformCss","css","dataAttr","dataRvcGuidPattern","commentsPattern","selectorsPattern","$1","excludePattern","selectors","s4","floor","random","substring","uuid","validate","constructor","combine$1","parentValue","childValue","parentIsFn","childIsFn","callDataFunction","fromProperties","primary","secondary","fromExpression","Array","Function","fromComputationString","bindTo","hasThis","functionBody","pattern","getFunction","functions","createFunction","addFunctions","exp","readDelimiterChange","parser","opening","closing","matchString","pos","allowWhitespace","matchPattern","delimiterChangePattern","whitespacePattern","readNumberLiteral","regexpPattern","t","REGEXP_LITERAL","v","escapeRegExp","pattern$1","getLowestIndex","haystack","needles","search","regExpCache","RegExp","decodeCharacterReferences","html","entityPattern","entity","code","htmlEntities","codeToChar","validateCode","escapeHtml","amp","lessThan","greaterThan","controlCharacters","invalid","codePointSupport","readNumberLiteral$1","numberPattern","NUMBER_LITERAL","readBooleanLiteral","remaining","BOOLEAN_LITERAL","makeQuotedStringMatcher","okQuote","literal","done","stringMiddlePattern","escapeSequencePattern","lineContinuationPattern","charCodeAt","parse","readStringLiteral","getDoubleQuotedString","STRING_LITERAL","getSingleQuotedString","readKey","token","identifier","namePattern","readKeyValuePair","refKey","nextChar","readExpression","KEY_VALUE_PAIR","REFERENCE","readKeyValuePairs","keyValuePairs","readObjectLiteral","OBJECT_LITERAL","readExpressionList","expr","expressions","expectedExpression","readArrayLiteral","expressionList","ARRAY_LITERAL","readLiteral","readReference","startPos","reference","fullLength","lastDotIndex","spread","specials","specialCall","spreadArgs","spreadPattern","prefixPattern","relaxedNames","relaxedName","legalReference","keywords","globals","GLOBAL","lastIndexOf","refLength","readBracketedExpression","expectedParen","BRACKETED","readPrimary","readRefinement","strictRefinement","REFINEMENT","readMemberOrInvocation","expression","refinement","MEMBER","INVOCATION","o","getConditional","ifTrue","ifFalse","readLogicalOr$1","CONDITIONAL","flattenExpression","getVars","vars","count","String","PREFIX_OPERATOR","INFIX_OPERATOR","refs","stringified","extractRefs","getKeyValuePair","valueToken","read","parseJSON","JsonParser","processDirective","tokens","parentParser","colonIndex","directiveName","directiveArgs","parsed","DECORATOR","TRANSITION","ExpressionParser","EVENT","methodCallPattern","getContextMessage","parser$1","readAttribute","attr","nearest","idx","attributeNamePattern","tags","open","readAttributeValue","f","valueStart","startDepth","sectionDepth","readQuotedAttributeValue","readUnquotedAttributeValue","readUnquotedAttributeValueToken","text","unquotedAttributeValueTextPattern","inAttribute","readMustache","quoteMark","readQuotedStringToken","readAttributeOrDirective","attribute","directive","directives","decoratorPattern","transitionPattern","proxyEventPattern","reservedEventNames","sanitizeEventAttributes","onPattern","exclude","ATTRIBUTE","mustache","inside","readMustacheOfType","inTag","tag","reader","close","sortMustacheTags","delimiterChangeToken","rewind","readers","isStatic","includeLinePositions","getLinePos","refineExpression","referenceExpression","getReferenceExpression","rx","members","readTriple","triple","TRIPLE","readUnescaped","readAliases","alias","readAlias","asRE","legalAlias","readPartial","partial","PARTIAL","ALIAS","z","SECTION","SECTION_WITH","readComment","COMMENT","readExpressionOrReference","expectedFollowers","readInterpolator","err","INTERPOLATOR","readYielder","yieldPattern","yielder","YIELDER","readClosing","CLOSING","readElse","elsePattern","ELSE","readElseIf","elsePattern$1","ELSEIF","readSection","section","hasElse","block","unlessBlock","conditions","closed","expectedClose","aliasOnly","SECTION_UNLESS","standardDelimiters","handlebarsBlockPattern","handlebarsBlockCodes","indexRefPattern","extra","keyIndexRefPattern","SECTION_IF","READERS","readHtmlComment","content","endIndex","comment","textOnlyMode","OPEN_COMMENT","CLOSE_COMMENT","stripStandalones","current","backOne","backTwo","lastSectionItem","isString","isComment","trailingLinebreak","leadingLinebreak","isSection","DELIMCHANGE","INVERTED","trimWhitespace","leadingPattern","trailingPattern","cleanup","stripComments","preserveWhitespace","removeLeadingWhitespace","removeTrailingWhitespace","previousItem","nextItem","preserveWhitespaceInsideFragment","removeLeadingWhitespaceInsideFragment","removeTrailingWhitespaceInsideFragment","leadingWhitespace$1","trailingWhitespace","isPreserveWhitespaceElement","ELEMENT","preserveWhitespaceElements","leadingNewLine","trailingNewLine","contiguousWhitespace","readClosingTag","closingTagPattern","CLOSING_TAG","readElement","selfClosing","partials","hasPartials","closingTag","DOCTYPE","tagNamePattern","validTagNameFollower","lowerCaseName","voidElementNames","elementStack","create","canContain","closingTagName","PARTIAL_READERS","sanitizeElements","disallowed","disallowedContents","readText","barrier","readPartialDefinitionComment","startPattern","namePattern$1","finishPattern","endPattern","INLINE_PARTIAL","readPartialDefinitionSection","delimiters","partialDefinitionSectionPattern","readTemplate","TEMPLATE_VERSION","insertExpressions","isExpression","addTo","hasChildren","StandardParser","throwNoParse","method","instructions","TEMPLATE_INSTRUCTIONS","createFunctionFromString","COMPUTATION_INSTRUCTIONS","resetValue","initial","_config","getDynamicTemplate","fromId","isParsed","getParseOptions","parseTemplate","parseAsString","validate$1","parseFor","extendPartials","existingPartials","newPartials","overwrite","wrap","superMethod","getSuperMethod","_parent","hasSuper","oldSuper","_super","_method","getMessage","deprecated","correct","isError","deprecateOption","deprecatedOption","deprecate","adaptors","configure","Parent","isStandardKey","registries","registry","adaptConfigurator","templateConfigurator","cssConfigurator","extendOtherMethods","prototype","isBlacklisted","makeObj","Ractive$reset","dataConfigurator","reset","rerender","config","shouldRerender","unrenderHook","resetTemplate","renderHook$1","completeHook$1","resetHook","collect","refName","COMPONENT","attributes","forceResetTemplate","resetPartial","collection","createResolver","resolver","resolvers","models","resolve$2","ExpressionProxy","ReferenceExpressionProxy","resolveAliases","findElement","orComponent","containerFragment","camelCase","hyphenatedStr","readStyle","escape","remove","rule","rules","specials$2","readClass","space","getUpdateDelegate","updateId","getAttribute","updateMultipleSelectValue","updateSelectValue","updateStringValue","updateContentEditableValue","updateRadioValue","textTypes","updateValue","isTwoway","updateRadioName","updateCheckboxName","updateStyleAttribute","updateInlineStyle","namespaceURI","updateClassName","updateInlineClass","isBoolean","type$1","updateBoolean","namespace","updateNamespacedAttribute","updateAttribute","getValue","nodes","removeAttribute","selected","optionValue","locked","wasSelected","disabled","selectedIndex","wasChecked","group","setAttribute","valueAttribute","isChecked","props","prev","styleName","className","inlineClass","useProperty","propertyName","getString","removeAttributeNS","setAttributeNS","lookupNamespace","qualified","hasAttribute","namespaces","set$2","flag","recreateTwowayBinding","inAttributes","doInAttributes","parseAttributes","isSvg","tagName","div$1","notIn","needle","processWrapper","__model","createOrWrapDescriptor","originalDescriptor","__magic","dependants","setting","descriptor","enumerable","revert","dependant","prettify","fnBody","lines","tabs","minIndent","line","Infinity","truncateStack","Computation","truncated","getComputationSignature","signature","getter","setter","getterString","getterUseStack","setterString","construct","welcome","initialiseProperties","defineProperty","deprecateRactiveData","constructHook","registryNames$1","RootModel","getAdaptors","computed","compute","combine$2","arrays","res","protoAdapt","lookup","adaptor","builtins","srcs","modifyArrays","magicSupported","magicArrayAdaptor","magicAdaptor$1","arrayAdaptor","_guid","uid","getChildQueue","hookQueue","childQueue","hook","initialise","userOptions","computations","computation","configHook","initHook","begin","Fragment","DEBUG_PROMISES","updateLiveQueries","removeFromLiveComponentQueries","makeDirty","updateLiveQueries$1","warnAboutAmbiguity","description","handleDomEvent","getBindingGroup","hash","BindingGroup","all","bindings","handleBlur","handleDelay","delay","timeout","clearTimeout","getSelectedOptions","select","selectedOptions","getSiblings","siblings","getValue$1","isBindable","selectBinding","attributeByName","contenteditable","ContentEditableBinding","bindName","bindChecked","CheckboxBinding","RadioNameBinding","CheckboxNameBinding","RadioBinding","FileBinding","NumericBinding","GenericBinding","MultipleSelectBinding","SingleSelectBinding","makeDirty$1","inputIsCheckedRadio","typeAttribute","nameAttribute","stringifyAttribute","removeFromLiveQueries","getNamespace","xmlns","svg$1","handleReset","formBindings","updateModel$1","createMapping","childData","boundFragment","valueOf","getPartialTemplate","getPartialFromRegistry","noThrow","findParentPartial","isOwner","noRegistryFunctionReturn","findOwner","_fn","findConstructor","_Parent","parsePartial","isEmpty","getType","hasIndexRef","SECTION_EACH","SECTION_IF_WITH","valueContains","selectValue","onChange","visible","hidden","onHide","onShow","unprefix","unprefixPattern","hyphenate","vendorPattern","resetStyle","insertHtml","selectedOption","ieBug","ieBlacklist","createElement","textContent","firstChild","appendChild","elementCache","getComponentConstructor","Component","createItem","Text","ComponentConstructor","ElementConstructor","specialElements","Element","Item","Mapping","Attribute","constructors","processItems","guid","counter","TEXT","placeholderId","newModel","wrapperValue","unrenderAndDestroy$1","Ractive$resetTemplate","shouldDestroy","findParentNode","findNextNode","Ractive$set","Ractive$subtract","Ractive$teardown","Promise$1","teardownHook$1","Ractive$toggle","badArguments","Ractive$toCSS","uniqueCssIds","ids","Ractive$toHTML","toText","Ractive$transition","params","HTMLElement","transition","Transition","registerTransition","unlink$1","lastLink","Ractive$unrender","unrenderHook$1","Ractive$updateModel","wrap$1","force","needsSuper","unwrap","Child","addRegistries","addOtherOptions","addRegistry","useDefaults","extend","extendOne","proto","defaults","writable","configurable","joinKeys","splitKeypath","tripleDelimiters","staticDelimiters","staticTripleDelimiters","csp","sanitize","contextLines","twoway","lazy","noCssTransform","easeIn","pow","easeOut","easeInOut","legacy","isClient","hasConsole","appName","console","matches","div","methodNames","unprefixed","makeFunction","svg","implementation","hasFeature","vendors","mathml","xlink","xml","ns","createElementNS","cloneNode","querySelectorAll","desc","F","welcomeIntro","welcomeMessage","WELCOME_MESSAGE","hasGroup","groupCollapsed","groupEnd","delta","intermediate","properties","deprecations","replacement","Hook","arg","PENDING","FULFILLED","REJECTED","dispatchHandlers","makeResolver","fulfilledHandlers","rejectedHandlers","state","newState","onFulfilled","onRejected","promise2","processResolutionHandler","forward","p1result","promises","pending","processPromise","reason","TransitionManager","addChild","isIntro","returnPromise","fulfilPromise","previousBatch","addFragment","addFragmentToRoot","addInstance","addObserver","defer","_manager","detachWhenReady","task","postRender","_batch","isComponentQuery","dirty","nodeOrComponent","KeyModel","isReadonly","deps","links","shouldCapture","rebinding","registerLink","unregister","unregisterLink","KeypathModel","getChild","rebindChildren","dep","hasProp","early","ModelBase","keyModels","unresolved","unresolvedByKey","patternObservers","addUnresolved","addShuffleTask","addShuffleRegister","specificKey","hasKey","attemptResolution","resolved","existingMatches","getValueChildren","skip","getVirtual","virtual","child$1","notify","safe","relinking","keypathModel","registerPatternObserver","registerTwowayBinding","removeUnresolved","shuffled","rewrap","unregisterPatternObserver","unregisterTwowayBinding","oneway","LinkModel","isLink","applyValue","relinked","upstream","lnk","ln","lastTime","currTime","timeToCall","Date","performance","Ticker","elapsed","eased","stop","abort","Model","newWrapperValue","shouldTeardown","createBranch","branch","retrieve","old","oldArray","newArray","oldLength","usedIndices","firstUnusedIndex","GlobalModel","ReferenceResolver","contexts","forceResolution","oldValue","newValue","once","strict","cancelled","baseKeypath","oldValues","newValues","changed","newKeys","wildcards","suffix","i$1","ok","sliced","inserted","deleted","hadIndex","newIndex","oldIndex","pop$1","push$1","getElementsByTagName","Parser","ParseError","leadingWhitespace","lineStart","lineEnds","lineEnd","leftover","postProcess","converters","lineNum","columnNum","contextUp","contextDown","numTabs","annotation","char","character","shortMessage","Parser$1","BINDING_FLAG","booleanAttributes","quot","apos","lt","gt","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","tilde","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","fromCodePoint","fromCharCode","readTypeOf","makePrefixSequenceMatcher","symbol","fallthrough","matcher","prefixOperators","readLogicalOr","makeInfixSequenceMatcher","readTypeof","left","right","infixOperators","specials$1","true","false","null","specialsPattern","numberPattern$1","placeholderPattern","placeholderAtStartPattern","onlyWhitespace","placeholder","special","stringLiteral","intro-outro","intro","outro","decorator","each","if","with","unless","li","dt","dd","rt","rp","optgroup","thead","tbody","tfoot","tr","td","th","STANDARD_READERS","TRIPLE_READERS","STATIC_READERS","computedStrings","isTriple","script","textarea","elements","eventAttributes","parseOptions","registryNames","Registry","custom","defaultKeys","order","destroyed","ComputationChild","actuallyChanged","registered","ReferenceExpressionChild","baseResolver","intermediary","isUnresolved","Alias","firstNode","skipParent","float","propertyNames","accept-charset","accesskey","bgcolor","class","codebase","colspan","datetime","dirname","for","http-equiv","ismap","maxlength","novalidate","pubdate","readonly","rowspan","tabindex","usemap","updateDelegate","twowayBinding","lastVal","BindingFlag","ConditionalAttribute","attrs","mutatorMethods","patchedArrayProto","wrappers","patchArrayMethods","unpatchArrayMethods","__proto__","unpatch","patch","errorMessage$1","ArrayWrapper","instances","magicAdaptor","MagicWrapper","originalDescriptors","getOwnPropertyDescriptor","childKeypath","MagicArrayWrapper","magicWrapper","arrayWrapper","computationContext","setDependencies","dependent","RactiveModel","hasProp$1","applyChanges","_changeHash","flush","targetPath","ractiveModel","localKey","origin","local","HookQueue","inProcess","DOMEvent","listen","addEventListener","unlisten","removeEventListener","CustomEvent","eventPlugin","RactiveEvent","specialPattern","dollarArgsPattern","EventDirective","action","specialMatch","dollarMatch","passedArgs","oldEvent","getArgsList","teardownHook","_partials","yielders","_inlinePartials","leftovers","eventHandlers","setupEvents","checkYielders","toHTML","missingDecorator","Decorator","dynamicName","dynamicArgs","nameFragment","argsFragment","decorators","argsFn","nameChanged","args$1","Doctype","Binding","wasUndefined","getInitialValue","parentForm","lastValue","setFromNode","attachEvent","push$2","checkboxName","noInitialValue","existingValue","bindingValue","valueSoFar","files","forceUpdate","selectedValues","previousValue","setValue","initialValue","nameAttributeBinding","optionWasSelected","endsWithSemi","isVoid","deferContent","createTwowayBinding","shouldBind","existing","nodeName","foundNode","_introTransition","isSelected","cls","_outroTransition","Form","Mustache","Interpolator","nodeValue","createTextNode","Input","defaultValue","Option","selectedAttribute","Partial","templateObj","named","setTemplate","partialTemplate","RepeatedFragment","pendingNewIndices","previousIterations","createIteration","found","iteration","updatePostShuffle","updating","toRemove","oldKeys","wasArray","fragment$1","newLength","indices","oldLen","removed","contiguous","Section","sectionType","templateSectionType","subordinate","sibling","nextSibling","isTruthy","siblingFalsey","lastType","newFragment","fragmentShouldExist","Select","sync","defaultSelected","selectNode","isMultiple","shouldSelect","Textarea","prefixCache","testStyle","capped","vendor","prefix$1","prefix$2","createTransitions","TRANSITION$1","TRANSITIONEND","CSS_TRANSITIONS_ENABLED","TRANSITION_DURATION","TRANSITION_PROPERTY","TRANSITION_TIMING_FUNCTION","testStyle$1","linear$1","canUseCssTransitions","cannotUseCssTransitions","webkitTransition","changedProperties","transitionDone","cssTimeout","checkComplete","jsTransitionsComplete","cssTransitionsComplete","unregisterCompleteHandler","transitionEndHandler","cssTransitionsDone","property","timing","hashPrefix","registerCompleteHandler","originalValue","propertiesToTransitionInJs","getStyle","createTransitions$1","getComputedStyle","names","t0","t1","t2","onComplete","animateStyle","setStyle","computedStyle","value$1","processParams","completed","originalStyle","noReset","TABLE","THEAD","TBODY","TR","SELECT","Triple","queryResult","queryAllResult","numNodes","Yielder","doctype","form","dirtyArgs","dirtyValue","createItems","argsList","wasBound","wasRendered","toHtml","reverse$1","shift$1","sort$1","splice$1","unshift$1","insert","toCSS","toCss","FUNCTION","VERSION","transitions","HeaderComponent","SockJS","makeUUID","mergeHeaders","defaultHeaders","headers","headerName","url","self","pingTimerID","pingInterval","vertxbus_ping_interval","sockJSConn","CONNECTING","replyHandlers","onerror","sendPing","setInterval","OPEN","CLOSED","clearInterval","onmessage","json","replyAddress","address","failureCode","failureType","envelope","publish","transportList","_sockjs_onload","process","WebSocketTransport","transUrl","enabled","EventEmitter","debug","urlUtils","addPath","ws","WebsocketDriver","emit","unloadRef","utils","unloadAdd","_cleanup","inherits","env","NODE_ENV","unloadDel","removeAllListeners","transportName","roundTrips","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","run","nextTick","title","browser","argv","version","versions","addListener","removeListener","cwd","chdir","dir","umask","onUnload","afterUnload","isChromePackagedApp","chrome","app","runtime","detachEvent","triggerUnloadCallbacks","unloadTriggered","crypto","_randomStringChars","bytes","randomBytes","ret","numberString","getRandomValues","Uint8Array","URL","getOrigin","protocol","port","isOriginEqual","isSchemeEqual","qs","addQuery","q","extractProtocol","protocolre","slashes","rest","instruction","extracted","relative","relativere","lolcation","required","host","username","password","auth","href","NaN","ins","pathname","ignore","loc","finaldestination","unescape","querystring","decodeURIComponent","querystringify","encodeURIComponent","useColors","documentElement","firebug","exception","table","userAgent","formatArgs","humanize","diff","color","lastC","save","removeItem","load","localstorage","localStorage","colors","formatters","enable","selectColor","prevColor","curr","ms","prevTime","coerce","formatter","logFn","skips","disable","h","short","round","long","plural","ceil","ctor","superCtor","super_","TempCtor","EventTarget","_listeners","g","fired","eventType","arr","dispatchEvent","WebSocket","MozWebSocket","XhrStreamingTransport","XHRLocalObject","XHRCorsObject","AjaxBasedTransport","XhrReceiver","info","nullOrigin","isOpera","needBody","createAjaxSender","AjaxObject","payload","opt","Content-type","ajaxUrl","xo","status","urlSuffix","Receiver","SenderReceiver","senderFunc","pollUrl","BufferedSender","poll","Polling","sendBuffer","sendStop","sendSchedule","sendScheduleWait","tref","receiveUrl","_scheduleReceiver","pollIsClosing","bufferPosition","_chunkHandler","buf","XhrDriver","supportsCORS","AbstractXHRObject","_start","XHR","XMLHttpRequest","xhr","ontimeout","noCredentials","withCredentials","setRequestHeader","onreadystatechange","readyState","responseText","axo","cors","ignored","isKonqueror","hasDomain","domain","XdrStreamingTransport","XDRObject","cookie_needed","sameScheme","eventUtils","xdr","XDomainRequest","_error","onprogress","onload","EventSourceTransport","EventSourceReceiver","EventSourceDriver","es","decodeURI","_close","EventSource","IframeTransport","objectUtils","transport","IframeWrapTransport","baseUrl","iframeInfo","sameOrigin","facadeTransport","windowId","iframeUrl","iframeObj","iframeUtils","createIframe","onmessageCallback","_message","JSON3","postMessage","iframeMessage","cdata","post","iframeEnabled","__WEBPACK_AMD_DEFINE_RESULT__","runInContext","undef","isSupported","serialized","stringifySupported","isExtended","toJSON","Number","getClass","parseSupported","SyntaxError","nativeJSON","isProperty","objectProto","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","functionClass","dateClass","numberClass","stringClass","arrayClass","booleanClass","charIndexBuggy","Months","getDay","year","month","Properties","size","isFunction","isConstructor","hasProperty","objectTypes","Escapes","92","34","8","12","10","13","9","leadingZeroes","toPaddedString","width","unicodePrefix","quote","useCharIndex","symbols","charCode","serialize","whitespace","indentation","date","time","hours","minutes","seconds","milliseconds","results","Index","Source","Unescapes","47","98","116","110","102","114","lex","position","isSigned","hasMembers","walk","isLoader","function","freeExports","freeGlobal","previousJSON","isRestored","noConflict","webpackPolyfill","paths","__webpack_amd_options__","WPrefix","currentWindowId","polluteGlobalNamespace","errorCallback","iframe","unattach","contentWindow","src","display","createHtmlfile","CollectGarbage","write","parentWindow","HtmlFileTransport","HtmlfileReceiver","htmlfileEnabled","constructFunc","XhrPollingTransport","XdrPollingTransport","JsonPTransport","jsonpSender","JsonpReceiver","urlWithId","_callback","_createScript","timeoutId","_abort","scriptErrorTimeout","aborting","script2","onclick","_scriptError","errorTimer","loadedOkay","charset","htmlFor","async","head","createForm","enctype","acceptCharset","area","submit","protocols","extensions","protocols_whitelist","_transportsWhitelist","transports","sessionId","_generateSessionId","_server","server","parsedUrl","secure","sortedProtocols","_origin","_urlInfo","_ir","InfoReceiver","_receiveInfo","userSetCode","Event","CloseEvent","TransportMessageEvent","dbg","wasClean","_transport","rtt","_rto","countRTO","_transUrl","base_url","enabledTransports","filterToEnabled","_transports","main","_connect","Transport","timeoutMs","_transportTimeoutId","_transportTimeout","transportUrl","transportObj","_transportMessage","_transportClose","_open","forceFail","availableTransports","toInteger","abs","ToUint32","Empty","ArrayPrototype","ObjectPrototype","FunctionPrototype","StringPrototype","array_slice","_toString","supportsDescriptors","forceAssign","toObject","that","binder","boundLength","boundArgs","boxedString","splitString","properlyBoxesContext","properlyBoxesNonStrict","properlyBoxesStrict","_","__","thisp","hasFirefox2IndexOfBug","sought","string_split","compliantExecNpcg","separator","limit","separator2","lastIndex","lastLength","flags","ignoreCase","multiline","extended","sticky","lastLastIndex","zeroWidth","wsRegexChars","trimBeginRegexp","trimEndRegexp","hasTrimWhitespaceBug","string_substr","hasNegativeSubstrBug","extraLookup","extraEscapable","unrollLookup","escapable","unrolled","quoted","transportsWhitelist","facade","websocket","logObject","level","levelExists","initEvent","canBubble","cancelable","bubbles","timeStamp","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","urlInfo","doXhr","XDR","XHRCors","XHRLocal","XHRFake","InfoIframe","InfoAjax","_getReceiver","timeoutRef","go","ifr","InfoReceiverIframe","ir","FacadeJS","InfoIframeReceiver","transportMap","at","parentOrigin","bootstrap_iframe","onMessage","_send","frame","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","Hammer","buildEvent","recognizerName","buildEventHandler","getHammerManager","destroy","_hammer","hammerManager","recognizerExists","recognizer","recognizerClass","updateRecognizeWith","recognizers","recognizeWiths","recognizeWith","re","parseHammerValue","Manager","Tap","doubletap","taps","swipe","Swipe","pan","Pan","direction","DIRECTION_HORIZONTAL","press","Press","rotate","Rotate","pinch","Pinch","none","DIRECTION_NONE","DIRECTION_ALL","up","DIRECTION_UP","down","DIRECTION_DOWN","DIRECTION_LEFT","DIRECTION_RIGHT","horizontal","vertical","DIRECTION_VERTICAL","exportName","setTimeoutContext","bindFn","invokeArrayArg","iterator","deprecationMessage","inherit","childP","baseP","assign","boolOrFn","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","types","splitStr","removeEventListeners","hasParent","inStr","inArray","findByKey","uniqueArray","camelProp","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","ownerDocument","defaultView","inputTarget","domHandler","ev","createInputInstance","Type","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","overallVelocity","getVelocity","overallVelocityX","overallVelocityY","scale","getScale","rotation","getRotation","maxPointers","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","velocity","velocityX","velocityY","last","lastInterval","COMPUTE_INTERVAL","clientX","clientY","p1","p2","PROPS_XY","sqrt","atan2","PI","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","touches","changedTouches","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","targetTouches","changedTargetTouches","touch","mouse","primaryTouch","lastTouches","recordTouches","eventData","setLastTouch","lastTouch","lts","removeLastTouch","DEDUP_TIMEOUT","isSyntheticEvent","dx","dy","DEDUP_DISTANCE","TouchAction","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","getTouchActionProps","NATIVE_TOUCH_ACTION","touchMap","cssSupports","CSS","supports","Recognizer","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","preset","oldCssProps","touchAction","toggleCssProps","requireFailure","cssProps","triggerDomEvent","gestureEvent","createEvent","gesture","TEST_ELEMENT","nextKey","MOBILE_REGEX","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","button","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","MSPointerEvent","PointerEvent","removePointer","eventTypeNormalized","isTouch","storeIndex","pointerId","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","sourceCapabilities","firesTouchEvents","PREFIXED_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_MAP","getTouchAction","preventDefaults","prevented","hasNone","isTapPointer","isTapMovement","isTapTouchTime","preventSrc","STATE_RECOGNIZED","STATE_FAILED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","additionalEvent","tryEmit","canEmit","inputDataClone","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","validPointers","validMovement","validTime","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","STOP","FORCED_STOP","stopped","curRecognizer","ractive_events_tap__TapHandler","handleMousedown","__tap_handler__","handleTouchstart","touchdown","handleFocus","handleKeydown","ractive_events_tap","DISTANCE_THRESHOLD","TIME_THRESHOLD","preventMousedownEvents","pointerEnabled","msPointerEnabled","_this","handleMouseup","handleMousemove","finger","handleTouchup","preventMousedownTimeout","handleTouchmove"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,SAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/B,YAMA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GEpDxF,GAAAG,GAAAf,EAAA,GFkDKgB,EAASL,EAAuBI,IEhDrC,WACI,GAAAC,GAAAF,QAASG,SAASC,eAAe,YFyD/B,SAASd,EAAQD,EAASH,GAE/B,YG9DDI,GAAOD,QAAW,WASd,QAASgB,GAAKC,GACV,GAAIC,SACJC,WAAUC,QAAUD,UAAUC,SAAWD,UAAUE,eAAiBF,UAAUG,YAAcH,UAAUI,UACtGC,EAAQC,OAAQ,CAChB,IAAMC,GAAO,GAAIF,IACbG,GAAIV,EACJW,SAAUA,EACVC,OAAO,EACPC,MACIV,SACIA,SAAS,EACTW,MAAO,IACPC,UAAW,GACXC,OAAQ,IAEZC,YAAY,EACZC,UAAU,EACVC,KAAM,GACNC,MAAM,EACNC,SAAS,EACTC,YAAY,GAEhBC,QACIC,IAAK5C,EAAS,KAElB6C,YACIC,OAAQC,KAEZC,OAAQ,WACJC,KAAKC,IACDC,YAAa,SAASC,GAClBH,KAAKI,IAAID,EAAME,SAASC,OAAOC,KAAMJ,EAAME,SAASC,OAAOE,QAE/DC,aAAc,SAASN,GAChBH,KAAKU,IAAI,UACRV,KAAKI,IAAI,SAASJ,KAAKU,IAAI,SAC3BV,KAAKW,OAAO,cACZvC,EAAK4B,KAAKY,YAGlBC,aAAc,SAASV,GACnB,GAAKW,GAAQd,KAAKU,IAAI,UACtBI,GAAMxC,SAAU,EAChBwC,EAAM3B,OAASa,KAAKU,IAAI,QACxBV,KAAKI,IAAI,WAAU,GACnBJ,KAAKe,YAAYD,IAErBE,WAAY,SAASb,GACjB,GAAIW,GAAQd,KAAKU,IAAI,UACrBI,GAAMxC,SAAU,EAChBwC,EAAM3B,OAAS,GACfa,KAAKI,IAAI,WAAU,GACnBJ,KAAKe,YAAYD,IAErBG,YAAa,SAASd,GAClB,GAAKW,GAAQd,KAAKU,IAAI,UACtBI,GAAM7B,MAAQkB,EAAMe,KAAKV,MACzBR,KAAKe,YAAYD,IAErBK,WAAY,SAAShB,GACjBH,KAAKI,IAAI,oBAAoBD,EAAMe,KAAKV,QAE5CI,QAAS,SAAST,GACd/B,EAAK4B,KAAKY,cAItBA,QAAS,WACL,GAAMQ,GAAc,UAAUC,OAAOC,SAASC,SAAS,iBACnDnD,EAAK,GAAIoD,GAASJ,EAiBtB,OAfAhD,GAAGqD,OAAS,WACRzB,KAAKI,IAAI,QAAQ,GACjBhC,EAAGsD,gBAAgB,kBAAmB,SAASC,EAAOC,GAClD5B,KAAKI,KAAKyB,kBAAmBD,EAAIE,KAAKxD,QAClCyD,gBAAiBH,EAAIE,KAAK7C,MAC1B+C,iBAAkBJ,EAAIE,KAAK3C,SAC/Ba,KAAKiC,cACPC,KAAKlC,OACP5B,EAAG+D,KAAK,aAAc7C,KAAMU,KAAKU,IAAI,WACvCwB,KAAKlC,MACP5B,EAAGgE,QAAU,WACTpC,KAAKI,IAAI,QAAQ,GACjBhC,EAAGiE,kBAAkB,mBACrBjE,EAAGiE,kBAAkB,cACvBH,KAAKlC,MACA5B,GAEXE,QAAS,SAASW,GACVZ,UAAUC,SACVD,UAAUC,QAAQW,IAG1B8B,YAAa,SAASa,GAClBxD,EAAG+D,KAAK,iBAAiBP,IAE7BK,WAAY,WACR,GAAInB,GAAQd,KAAKU,IAAI,UACrB,IAAII,EAAMxC,QAAV,CACA0B,KAAK1B,QAAQwC,EAAM7B,MACnB,IAAIqD,GAAQ,KACRC,EAAO,SAASC,GAChB,IAAI1B,EAAMxC,QAEN,WADA0B,MAAK1B,QAAQ,EAGZgE,KAAOA,EAAQE,EACpB,IAAIC,GAAWD,EAAYF,CACvBG,IAAY3B,EAAM7B,MAClBoC,OAAOqB,sBAAsBH,IAE7BD,EAAQ,KACRtC,KAAK1B,QAAQwC,EAAM7B,OACnBoC,OAAOqB,sBAAsBH,KAEnCL,KAAKlC,KACPqB,QAAOqB,sBAAsBH,MAIrC,OAAO3D,GA/HX,GAAIF,GAAU3B,EAAQ,GAClB+B,EAAW/B,EAAQ,GACnB+C,EAAkB/C,EAAQ,GAC1ByE,EAAWzE,EAAQ,EA8HvB,OA7HAA,GAAQ,IACRA,EAAQ,IA4HDmB,MHsEL,SAASf,EAAQD,EAASH,IIzMhC,SAAA4F,IAWA,SAAAA,EAAAC,GACAzF,EAAAD,QAAA0F,KAGC5C,KAAA,WAAoB,YAgJrB,SAAA6C,KACA,MAAAC,IAAAD,yBAGA,QAAAE,GAAAC,GACA,GAAAC,EAEA,IAAAD,GAAA,iBAAAA,GAEA,MAAAE,KAAAJ,IAAAE,EAKAA,EAAAG,SACAH,EAIA,gBAAAA,KAEAC,EAAAH,GAAA7E,eAAA+E,IAGAC,GAAAH,GAAAM,gBACAH,EAAAH,GAAAM,cAAAJ,IAIAC,KAAAE,UACAF,EAKAD,EAAA,IAAAA,EAAA,GAAAG,SACAH,EAAA,GAGA,KA7BA,KA+FA,QAAAK,GAAAnC,GAKA,MAJAA,IAAA,iBAAAA,GAAAoC,YAAApC,EAAAoC,YACApC,EAAAoC,WAAAC,YAAArC,GAGAA,EAGA,QAAAsC,GAAAhD,GACA,aAAAA,KAAAiD,SAAA,GAAAjD,EAAA,GAGA,QAAAkD,GAAAC,GACA,MAAAH,GAAAG,GACAC,QAAA,cACAA,QAAA,eACAA,QAAA,cAIA,QAAAC,GAAAF,GACA,MAAAA,GAAAC,QAAAE,GAAA,SAAAC,GAAiD,MAAAA,GAAAC,OAAA,GAAAC,gBAIjD,QAAAC,GAAAP,GACA,MAAAA,GAAAC,QAAAO,GAAA,SAAAJ,GAAmD,UAAAA,EAAAK,gBA4EnD,QAAAC,GAAA/D,GAEA,IADA,GAAAgE,MAAAC,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAD,EAAAC,GAAAC,UAAAD,EAAA,EAEA,IAAAG,EAUA,OARAJ,GAAAK,QAAA,SAAAC,GACA,IAAAF,IAAAE,GACAC,GAAAvH,KAAAsH,EAAAF,KACApE,EAAAoE,GAAAE,EAAAF,MAKApE,EAGA,QAAAwE,GAAAxE,GAEA,IADA,GAAAgE,MAAAC,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAD,EAAAC,GAAAC,UAAAD,EAAA,EAUA,OARAD,GAAAK,QAAA,SAAAZ,GACA,OAAAgB,KAAAhB,IACAc,GAAAvH,KAAAyG,EAAAgB,QAAAzE,KACAA,EAAAyE,GAAAhB,EAAAgB,MAKAzE,EAOA,QAAA0E,GAAAC,GACA,yBAAAxB,GAAAnG,KAAA2H,GAGA,QAAAC,GAAAC,EAAAC,GACA,cAAAD,GAAA,OAAAC,GAIA,gBAAAD,IAAA,gBAAAC,IAIAD,IAAAC,EAIA,QAAAC,GAAAJ,GACA,OAAAK,MAAAC,WAAAN,KAAAO,SAAAP,GAGA,QAAAQ,GAAAR,GACA,MAAAA,IAAA,oBAAAxB,GAAAnG,KAAA2H,GAGA,QAAAS,MAiEA,QAAAC,GAAAC,EAAAC,GACA,MAAAD,GAAAhC,QAAA,iBAA+C,MAAAiC,GAAAC,UAG/C,QAAAC,GAAAH,GAEA,IADA,GAAAC,MAAAtB,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAsB,EAAAtB,GAAAC,UAAAD,EAAA,EAGA,MADAqB,GAAAD,EAAAC,EAAAC,GACA,GAAAG,OAAAJ,GAGA,QAAAK,KACAvH,GAAAC,OACAuH,GAAAC,MAAA,KAAA3B,WAIA,QAAA4B,GAAAR,GAEA,IADA,GAAAC,MAAAtB,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAsB,EAAAtB,GAAAC,UAAAD,EAAA,EAEAqB,GAAAD,EAAAC,EAAAC,GACAQ,GAAAT,EAAAC,GAGA,QAAAS,GAAAV,GAEA,IADA,GAAAC,MAAAtB,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAsB,EAAAtB,GAAAC,UAAAD,EAAA,EAEAqB,GAAAD,EAAAC,EAAAC,GAEAU,GAAAX,KAIAW,GAAAX,IAAA,EACAS,GAAAT,EAAAC,IAGA,QAAAW,KACA9H,GAAAC,OACAyH,EAAAD,MAAA,KAAA3B,WAIA,QAAAiC,KACA/H,GAAAC,OACA2H,EAAAH,MAAA,KAAA3B,WASA,QAAAkC,GAAAC,EAAAC,EAAArG,GACA,GAAAsG,GAAAC,EAAAH,EAAAC,EAAArG,EACA,OAAAsG,KAAAF,GAAApG,GAAA,KAGA,QAAAuG,GAAAH,EAAAC,EAAArG,GACA,KAAAqG,GAAA,CACA,GAAArG,IAAAqG,GAAAD,GACA,MAAAC,EAGA,IAAAA,EAAAG,SACA,WAGAH,KAAAI,QAIA,QAAAC,GAAAC,EAAAC,EAAAP,EAAAQ,GACA,GAAAF,IAAAC,EAAA,WAEA,IAAAC,EAAA,CACA,GAAAC,GAAAX,EAAA,gBAAAE,EAAAQ,EACA,IAAAC,EAAA,MAAAA,GAAAH,EAAAC,IAAA,IAEApB,GAAAuB,GAAAF,EAAA,iBAGA,MAAAG,IAAAC,OAAAN,EAAAC,IACAI,GAAAE,MAAAP,EAAAC,IACAI,GAAAG,OAAAR,EAAAC,IACA,KAGA,QAAAQ,GAAAR,GACA,kBAAuB,MAAAA,IA6JvB,QAAAS,GAAAH,EAAAjH,GACA,GAAAqH,GAAAJ,EAAAK,QAAAtH,EAEAqH,MAAA,GACAJ,EAAAM,KAAAvH,GAIA,QAAAwH,GAAAP,EAAAjH,GACA,OAAAyH,GAAA,EAAAzK,EAAAiK,EAAAhD,OAAqCwD,EAAAzK,EAAOyK,IAC5C,GAAAR,EAAAQ,IAAAzH,EACA,QAIA,UAGA,QAAA0H,GAAA/C,EAAAC,GACA,GAAA6C,EAEA,KAAAjD,EAAAG,KAAAH,EAAAI,GACA,QAGA,IAAAD,EAAAV,SAAAW,EAAAX,OACA,QAIA,KADAwD,EAAA9C,EAAAV,OACAwD,KACA,GAAA9C,EAAA8C,KAAA7C,EAAA6C,GACA,QAIA,UAGA,QAAAE,GAAAC,GACA,sBAAAA,IACAA,GAGAC,SAAAD,KAIAA,EAGA,QAAAE,GAAAb,GACA,MAAAA,KAAAhD,OAAA,GAGA,QAAA8D,GAAAd,EAAAe,GACA,GAAAf,EAAA,CAIA,GAAAI,GAAAJ,EAAAK,QAAAU,EAEAX,MAAA,GACAJ,EAAAgB,OAAAZ,EAAA,IAIA,QAAAa,GAAAC,GAEA,IADA,GAAAlB,MAAAQ,EAAAU,EAAAlE,OACAwD,KACAR,EAAAQ,GAAAU,EAAAV,EAGA,OAAAR,GA+IA,QAAAmB,GAAAC,GACAC,WAAAD,EAAA,GAGA,QAAAE,GAAAC,EAAAC,GACA,kBAGA,IAFA,GAAAC,GAEAA,EAAAF,EAAAlD,SACAoD,EAAAD,IAKA,QAAAE,GAAAC,EAAAhB,EAAAiB,EAAAC,GAEA,GAAAC,EAGA,IAAAnB,IAAAgB,EACA,SAAAI,WAAA,iEAIA,IAAApB,YAAAqB,IACArB,EAAAmB,KAAAF,EAAAC,OAIA,KAAAlB,GAAA,gBAAAA,IAAA,kBAAAA,GA6CAiB,EAAAjB,OA7CA,CACA,IACAmB,EAAAnB,EAAAmB,KACK,MAAAG,GAEL,WADAJ,GAAAI,GAKA,qBAAAH,GAAA,CACA,GAAAI,GAAAC,EAAAC,CAEAD,GAAA,SAAAE,GACAH,IAGAA,GAAA,EACAR,EAAAC,EAAAU,EAAAT,EAAAC,KAGAO,EAAA,SAAAE,GACAJ,IAGAA,GAAA,EACAL,EAAAS,IAGA,KACAR,EAAAjM,KAAA8K,EAAAwB,EAAAC,GACM,MAAAH,GACN,IAAAC,EAGA,MAFAL,GAAAI,QACAC,GAAA,QAOAN,GAAAjB,IAuEA,QAAA4B,GAAAC,GACAA,EAAAD,SAGA,QAAAE,GAAAC,GACAA,EAAAC,cAGA,QAAAC,GAAAF,IACAA,EAAAG,OAAAH,EAAAI,OAAA9F,QAAA0F,EAAAK,gBAKAL,EAAAM,iBACAN,EAAAM,gBAAA,EAEAN,EAAAnD,SAAAmD,EAAAnD,OAAAyD,eACAN,EAAAnD,OAAA0D,gBAAAP,GAEAA,EAAAC,eAMAD,EAAAQ,OAAAlG,QAAA0F,EAAAS,gBACA,kBAAAT,GAAAtB,UACAsB,EAAAtB,WAGAsB,EAAAnD,SAAAmD,EAAAU,gBACAV,EAAAU,eAAA,EACAV,EAAAnD,OAAA8D,oBAOA,QAAAC,GAAAC,GACA,GAGA9J,GAAA+J,EAHAC,EAAAF,EAAAG,YACAZ,EAAAa,EAAAJ,GAEA/C,EAAAiD,EAAAzG,OAAA4G,EAAA,CACA/I,GAAA,KAAA2F,KAAA,CAGA,IAFA/G,EAAAgK,EAAAjD,GAAA/G,KACAmK,EAAAd,EAAA9F,OACA4G,KAGA,GAFAJ,EAAAV,EAAAc,GAAApB,QAAA/I,KAEA+J,IAAA/J,GAAA+J,EAAAK,SAAApK,MAAAoK,SAAAL,GAAA,QAAA3I,EAIA4I,GAAAjD,GAAA+B,SACAkB,EAAAzC,OAAAR,EAAA,IAIA,QAAAmD,GAAAJ,EAAAO,GACA,GAAAA,EAKI,CAEJ,IADA,GAAAtD,GAAA+C,EAAAQ,SAAA/G,OACAwD,KACAsD,EAAAH,EAAAJ,EAAAQ,SAAAvD,GAAAsD,EAGA,OADAA,KAAAE,OAAAT,EAAAT,QATAgB,IAEA,KADA,GAAAvE,GAAAgE,EACAhE,oBACA,OAAAoE,GAAApE,EAAAuE,GAkGA,QAAAG,GAAAC,GACAA,EAAAD,WAGA,QAAAE,KACA,GAAAC,GAAAC,GAAAC,kBACAD,IAAAC,sBACAF,EAAAlH,QAAA+G,EAIA,IACAM,GADA/D,EAAA6D,GAAAG,UAAAxH,MAGAoH,GAAAC,GAAAG,UACAH,GAAAG,YACA,IAAAC,GAAAJ,GAAAI,QAGA,KAFAJ,GAAAI,YAEAjE,KAAA,CACA+D,EAAAH,EAAA5D,EAGA,IAAArB,GAAAoF,EAAApF,OACAuF,QAAAC,KAAAxF,EAAAyF,UAAAC,SAAA7H,QACA8H,GAAAC,KAAA5F,IAAAyF,UAAAC,SAEA1F,EAAAyF,UAAAC,WACA/D,EAAA2D,EAAAtF,GAEAoF,EAAAS,SAIA,IADAxE,EAAAiE,EAAAzH,OACAwD,KAAA,CACA,GAAAyE,GAAAR,EAAAjE,EACAsE,IAAAC,KAAAE,IAAAL,UAAAC,SACAI,EAAAL,UAAAC,WAGAR,GAAAa,kBAAArC,QAEAuB,EAAAC,GAAAc,kBACAd,GAAAc,qBACAf,EAAAlH,QAAA+G,EAEA,IAAAmB,GAAAf,GAAAe,KAGA,KAFAf,GAAAe,SAEA5E,EAAA,EAAeA,EAAA4E,EAAApI,OAAkBwD,GAAA,EACjC4E,EAAA5E,IAMA,IAAA6D,GAAAG,UAAAxH,QAAAqH,GAAAC,mBAAAtH,QAAAqH,GAAAc,kBAAAnI,QAAAqH,GAAAI,SAAAzH,QAAAqH,GAAAe,MAAApI,OAAA,MAAAmH,KAQA,QAAAkB,GAAA/H,GACA,sBAAAA,GACAA,EAAAnB,QAAAmJ,GAAA,QAGAhI,EAGA,QAAAiI,GAAAC,GACA,MAAAA,KAAArJ,QAAAsJ,GAAA,UAGA,QAAAC,GAAAC,GACA,GACAC,GADApE,IAKA,KAFAmE,EAAAJ,EAAAI,GAEAC,EAAAC,GAAAC,KAAAH,IAAA,CACA,GAAAvF,GAAAwF,EAAAxF,MAAAwF,EAAA,GAAA5I,MACAwE,GAAAlB,KAAAqF,EAAAI,OAAA,EAAA3F,IACAuF,IAAAI,OAAA3F,EAAA,GAKA,MAFAoB,GAAAlB,KAAAqF,GAEAnE,EAGA,QAAAwE,GAAA1I,GACA,sBAAAA,GACAA,EAAAnB,QAAA8J,GAAA,QAGA3I,EAGA,QAAA7C,GAAAyL,EAAAC,GACA,WAAAC,KAAAF,EAAAlK,YAAA,MAAAkK,EAEA,IAAAG,GAAAH,EAAAzL,KAAA0L,EACA,QAAAlJ,KAAAiJ,GAAAG,EAAApJ,GAAAiJ,EAAAjJ,EAEA,OAAAoJ,GAGA,QAAA1N,GAAAwG,EAAAmH,GAIA,IAHA,GAAA3E,GAAA4E,GAAA1L,MAAAsE,GAAA,GAEAqB,EAAA8F,EAAAtJ,OACAwD,KAAA,CACA,GAAAgF,GAAAc,EAAA9F,GAAAnH,EAAAmM,EAAA,GAAAzM,EAAAyM,EAAA,EACA,mBAAAzM,OAAA0B,EAAA1B,EAAAoG,IACA9F,EAAAV,IAAAI,GAKA,MAFAwN,IAAAC,MAEA7E,EAIA,QAAA8E,GAAAtH,EAAAwG,EAAAe,GAGA,MAFA,UAAAA,MAAAvH,EAAAyF,WAEA+B,GAAAP,KAAAT,GACAe,EAAAE,YAAAlB,EAAAC,KAEAe,EAAAG,QAAAnB,EAAAC,KAIA,QAAAmB,GAAA3H,EAAAwG,EAAA5M,GACA,GAAAgO,KAGA,IAAA/I,EAAA2H,GAAA,CACA,GAAAqB,GAAA,SAAAC,GACAtB,EAAAuB,eAAAD,IACAF,EAAAzG,KAAA5B,MAAAqI,EAAAN,EAAAtH,EAAA8H,GAAAE,IAAA,SAAArR,GAAuE,OAAAA,EAAA6P,EAAAsB,OAIvE,QAAAA,KAAAtB,GAAAqB,EAAAC,OAKAF,GAAAzG,KAAA5B,MAAAqI,EAAAN,EAAAtH,EAAAwG,GAAAwB,IAAA,SAAArR,GAA2E,OAAAA,EAAAiD,KAG3E,OAAAgO,GAKA,QAAAK,GAAAjI,EAAAwG,EAAA0B,GACA,mBAAA1B,KAAA/H,EAAAyJ,GACA,SAAA9I,OAAA,gBAGA,IAAAwI,GAAAD,EAAA3H,EAAAwG,EAAA0B,EAEA,OAAA1O,GAAAwG,EAAA4H,EAAAI,IAAA,SAAAG,GACA,GAAAjO,GAAAiO,EAAA,GAAAF,EAAAE,EAAA,GAAAvO,EAAAM,EAAAJ,KACA,KAAA2E,EAAAwJ,KAAAxJ,EAAA7E,GAAA,SAAAwF,OAAAgJ,GACA,QAAAlO,EAAAN,EAAAqO,MAIA,QAAAI,GAAA7B,EAAA0B,GACA,MAAAD,GAAA7O,KAAAoN,EAAA/E,SAAAyG,EAAA,GAAAA,GAQA,QAAAI,GAAAC,EAAAtI,GACAsI,OAEA,IAAAC,EAOA,OANAD,GAAAC,SACAA,EAAA,kBAAAD,GAAAC,OACAD,EAAAC,OACAvI,EAAAuI,OAAAD,EAAAC,UAIAA,UAAAC,GACAC,SAAA,YAAAH,KAAAG,SAAA,IACAC,SAAAJ,EAAAI,UAAA7J,EACAnD,KAAA4M,EAAA5M,MAAAmD,GAIA,QAAA8J,IAAA5I,EAAA9F,EAAAqG,EAAAgI,GACAA,EAAAD,EAAAC,EAAAvI,EACA,IAAAM,GAAApG,EAAAJ,KAGA,IAAAwE,EAAAgC,EAAAC,GAEA,MADAgI,GAAAI,SAAAJ,EAAAhI,IACAsI,EAGA,IAAAC,GAAAzI,EAAAC,EAAAC,EAAAP,EAAAuI,EAAAO,aAGA,OAAAA,GAQA5O,EAAA6O,QAAAzI,EAAAC,EAAAgI,EAAAO,IAPA1B,GAAA1L,QACAxB,EAAAV,IAAA+G,GACA6G,GAAAC,MAEAwB,IAMA,QAAAG,IAAAxC,EAAAjG,EAAAgI,GACA,mBAAA/B,GAAA,CACA,GAAAhB,GAAAD,OAAAC,KAAAgB,EAEA,UAAApH,OAAA,oFAAoGoG,EAAAwC,IAAA,SAAA7J,GAAqC,UAAAA,EAAA,MAAAqI,EAAArI,KAAiD8K,KAAA,8BAAgCzD,EAAAwC,IAAA,SAAA7J,GAA0C,0BAAAA,EAAA,MAAAqI,EAAArI,GAAA,cAA+E8K,KAAA,YAInV,MAAAL,IAAAxP,UAAAqM,UAAAiC,QAAAnB,EAAAC,IAAAjG,EAAAgI,GAKA,QAAAW,MACA,MAAA9P,MAAA+P,WACA/P,KAAAnB,IAGAmB,KAAAnB,IACA0J,EAAAvI,KAAAnB,GAAAmR,sBAAAhQ,MAGAA,KAAAnB,GAAAmB,KAAAgM,SAAAhC,SACAhK,KAAA+P,YAAA,EAEAE,GAAAzD,KAAAxM,MACAA,KAAAnB,IAGA,QAAAqR,IAAAC,GACA,IAAAnQ,KAAAnB,GAAA,SAAAmH,OAAA,6BAAAmK,EAAA,4CAEA,OAAAnQ,MAAAgM,SAAAoE,KAAAD,GAGA,QAAAE,IAAAnP,EAAAoP,GACA,GAAApP,EAAAqP,wBAAA,CACA,GAAAC,GAAAtP,EAAAqP,wBAAAD,EACA,UAAAE,EAAA,KAKA,MAAAC,IAAAvP,EAAAoP,GAGA,QAAAG,IAAAtL,EAAAC,GAUA,IATA,GAKAsL,GALAC,EAAAC,GAAAzL,EAAA0L,WAAA1L,EAAA2L,SAAAC,OACAC,EAAAJ,GAAAxL,EAAAyL,WAAAzL,EAAA0L,SAAAC,OAEAE,EAAA3I,EAAAqI,GACAO,EAAA5I,EAAA0I,GAKAC,OAAAC,GACAP,EAAAQ,MACAH,EAAAG,MAEAT,EAAAO,EAEAA,EAAA3I,EAAAqI,GACAO,EAAA5I,EAAA0I,EAIAC,KAAAJ,WAAAI,EACAC,IAAAL,WAAAK,CAEA,IAAAE,GAAAH,EAAAI,eACAC,EAAAJ,EAAAG,cAGA,IAAAD,IAAAE,EAAA,CACA,GAAAC,GAAAH,EAAAI,MAAA1J,QAAAmJ,GACAQ,EAAAH,EAAAE,MAAA1J,QAAAoJ,EAIA,OAAAK,GAAAE,GAAAd,EAAAlM,OAAAuM,EAAAvM,OAKA,GAAAwH,GAAAyE,EAAAgB,UACA,IAAAzF,EAAA,CACA,GAAA0F,GAAA1F,EAAAnE,QAAAsJ,GACAQ,EAAA3F,EAAAnE,QAAAwJ,EAEA,OAAAK,GAAAC,GAAAjB,EAAAlM,OAAAuM,EAAAvM,OAGA,SAAAuB,OAAA,iKAGA,QAAA6L,IAAAC,GACA,GAAAT,GAAAS,EAAAT,cAEA,OAAAA,KAAAU,MAEAD,EAAAjB,YAAAQ,EAAAS,EAAAjB,UAAAQ,gBACAA,EAAAU,MADA,OAKA,QAAAnB,IAAAkB,GAIA,IAHA,GAAAE,IAAAF,GACAG,EAAAJ,GAAAC,GAEAG,GACAD,EAAAjK,KAAAkK,GACAA,EAAAJ,GAAAI,EAGA,OAAAD,GAgEA,QAAAE,IAAA/B,EAAAhB,GACA,IAAAnP,KAAAnB,GAAA,SAAAmH,OAAA,gCAAAmK,EAAA,iDAEAhB,QACA,IAAAgD,GAAAnS,KAAAoS,aAIAC,EAAAF,EAAAhC,EACA,OAAAkC,GAEAlD,KAAAmD,KAAAD,IAAAE,SAGAF,EAAA,GAAAG,IAAAxS,KAAAmQ,IAAAhB,EAAAmD,MAAA,GAIAD,EAAAC,OACAH,EAAApK,KAAAoI,GACAgC,EAAA,IAAAhC,GAAAkC,GAGArS,KAAAgM,SAAAyG,QAAAtC,EAAAkC,GAEAA,EAAAK,OACAL,EAAApJ,QAGA,QAAA0J,IAAAxC,EAAAhB,GACAA,OACA,IAAAgD,GAAAnS,KAAA4S,sBAIAP,EAAAF,EAAAhC,EACA,OAAAkC,GAEAlD,KAAAmD,KAAAD,IAAAE,SAGAF,EAAA,GAAAG,IAAAxS,KAAAmQ,IAAAhB,EAAAmD,MAAA,GAIAD,EAAAC,OACAH,EAAApK,KAAAoI,GACAgC,EAAA,IAAAhC,GAAAkC,GAGArS,KAAAgM,SAAA6G,kBAAA1C,EAAAkC,GAEAA,EAAAK,OACAL,EAAApJ,QAGA,QAAA6J,IAAA3C,GACA,MAAAnQ,MAAAgM,SAAA+G,cAAA5C,GAGA,QAAA6C,IAAA7C,GACA,MAAAnQ,MAAAiT,UACAjT,KAAAiT,UAAApC,WAAA7Q,KAAAiT,UAAApC,UAAAtQ,OAAA4P,EACAnQ,KAAAiT,UAEAjT,KAAAiT,UAAAC,cAAA/C,GAIA,KAGA,QAAAgD,IAAAhD,GAEA,MAAAnQ,MAAAgH,OACAhH,KAAAgH,OAAA6J,WAAA7Q,KAAAgH,OAAA6J,UAAAtQ,OAAA4P,EACAnQ,KAAAgH,OAEAhH,KAAAgH,OAAAoM,WAAAjD,GAIA,KAGA,QAAAkD,IAAAzM,EAAAzG,GACAyG,EAAAzG,OACAyG,EAAA0M,YAAAvL,KAAAnB,EAAAzG,OAGAyG,EAAAzG,QAGA,QAAAoT,IAAA3M,GACAA,EAAA0M,YAAA7O,OACAmC,EAAAzG,MAAAyG,EAAA0M,YAAAnC,MAEAvK,EAAAzG,MAAA,KAYA,QAAAqT,IAAApG,GACA,GAAAhB,GAAAqH,EAAAC,EAAAzL,EAAAgB,EAAA0K,CAcA,KAZAvH,EAAAe,EAAAC,IACAqG,EAAAG,GAAAxH,EAAA3H,WACAgP,EAAAI,GAAAzH,EAAA3H,SAGAwE,KAEAyK,EAAA,SAAAtF,EAAAnG,GACA,MAAAmG,GAAA,IAAAhC,EAAAnE,IAGAA,EAAAwL,EAAAhP,OACAwD,KACA0L,EAAAF,EAAAxL,GAAA2G,IAAA8E,GAAA7D,KAAA,KAEA5G,EAAA0F,eAAAgF,KACA1K,EAAAlB,KAAA4L,GACA1K,EAAA0K,IAAA,EAIA,OAAA1K,GAOA,QAAA4K,IAAAC,GACA,GAAAC,GAAAC,EAAAP,EAAAC,EAAAzL,EAAAoD,EAAA4I,EAAArF,EAAAsF,EAAA,EAEA,KAAAN,GAAAE,GAAA,CAGA,IAFAL,KAEAS,EAAAzP,OAAAqP,GACAI,GAAA,CASA,KANAH,EAAAI,SAAAD,EAAA,GAEAR,EAAA,SAAAU,GACA,YAAAA,GAGAnM,EAAA,EAAgBA,GAAA8L,EAAU9L,GAAA,GAE1B,IADA+L,EAAA/L,EAAAxE,SAAA,GACAuQ,EAAAvP,OAAAqP,GACAE,EAAA,IAAAA,CAKA,KAFApF,KACAqF,EAAAD,EAAAvP,OACA4G,EAAA,EAAgBA,EAAA4I,EAAO5I,IACvBuD,EAAA7G,KAAA2L,EAAAM,EAAA3I,IAEAoI,GAAAxL,GAAA2G,EAGAgF,GAAAE,GAAAL,EAGA,MAAAG,IAAAE,GAKA,QAAAO,IAAAzN,EAAA0N,EAAAnF,GAGA,GAFA,SAAAA,UAEAmF,EAAA,CAEAnF,EAAAhP,MAOAgP,EAAAhP,MAAAI,KAAA+T,EANAnF,EAAAhP,OACAI,KAAA+T,EAEAC,QAAA,EAMA,IAAAC,GAAAC,GAAAH,EAEA,OAAAI,IAAA9N,EAAA4N,EAAArF,EAAAhP,MAAAgP,EAAAtJ,MAAA,IAGA,QAAA4O,IAAAH,GACA,MAAAK,IAAAhG,eAAA2F,GACAK,GAAAL,GAEAK,GAAAL,GAAAd,GAAAc,GAIA,QAAAI,IAAA9N,EAAA4N,EAAArU,EAAA0F,EAAA+O,GAEA,SAAAA,OAAA,EAEA,IAAAC,GAAA5M,EAAA6M,GAAA,CAIA,KAFAzB,GAAAzM,EAAAzG,GAEA8H,EAAAuM,EAAA/P,OAA+BwD,GAAA,EAAQA,IACvC4M,EAAAjO,EAAAmO,MAAAP,EAAAvM,IAEA4M,IACAC,EAAAE,GAAApO,EAAAiO,EAAA1U,EAAA0F,IAAAiP,EAMA,IAFAvB,GAAA3M,GAEAA,EAAAI,QAAA8N,EAAA,CAEA,GAAAF,GAAAhO,EAAAiK,UAAA,CACA,GAAAoE,GAAArO,EAAAiK,UAAAtQ,KAAA,IAAAiU,IAAA/P,OAAA,EACA+P,GAAAC,GAAAQ,GAEA9U,MAAA0Q,YACA1Q,EAAA0Q,UAAAjK,GAIA8N,GAAA9N,EAAAI,OAAAwN,EAAArU,EAAA0F,GAGA,MAAAiP,GAGA,QAAAE,IAAApO,EAAAiO,EAAA1U,EAAA0F,GACA,GAAAqP,GAAA,KAAAC,GAAA,CAEAhV,OAAAoU,SACA1O,GAAA1F,GAAAsL,OAAA5F,IAKAgP,IAAAtC,OAEA,QAAAtK,GAAA,EAAA1D,EAAAsQ,EAAApQ,OAA6CwD,EAAA1D,EAAS0D,GAAA,EACtD4M,EAAA5M,GAAAmN,KAAAP,EAAA5M,GAAA9B,MAAAS,EAAAf,MAAA,IACAsP,GAAA,EASA,OALAhV,OAAAoU,QAAAY,IAAAD,EAAA/U,EAAAE,YACA6U,EAAAG,gBAAAH,EAAAG,iBACAH,EAAAI,iBAAAJ,EAAAI,oBAGAH,EAGA,QAAAI,IAAAjB,GAEA,IADA,GAAAzO,MAAAtB,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAsB,EAAAtB,GAAAC,UAAAD,EAAA,EAEA,OAAA8P,IAAArU,KAAAsU,GAAuCzO,SAGvC,QAAA2P,IAAAzQ,GACA,SAAAiB,OAAA,8BAAAjB,EAAA,kCAGA,QAAA0Q,IAAAzJ,EAAAiB,GASA,IARA,GAIAyI,GACAC,EACAC,EANAC,EAAA7J,EAAA8J,cAAA3X,KACAiO,EAAAe,EAAAF,GACAlI,EAAAqH,EAAA,GAMAJ,GAAA,CAEA,GAAAA,EAAA+J,YAAA,CACA,GAAAhR,IAAAiH,EAAAhF,OAAAgP,OAEA,MADA5J,GAAA3H,OAAA,GAAA+Q,GAAAzQ,GACAiH,EAAA4B,QAAAqI,YAAAjK,EAAAjH,IAGA,IAAAA,IAAAiH,EAAAhF,OAAAkP,SAEA,MADA9J,GAAA3H,OAAA,GAAA+Q,GAAAzQ,GACAiH,EAAA4B,QAAAqI,YAAAjK,EAAAnE,OAKA,KAAA+N,EAAA5J,EAAA+F,MAAA6D,aAAA5J,EAAA4J,aAAAjH,eAAA5J,GAAA,CACA,GAAAjE,GAAA8U,EAAA7Q,EAEA,QAAAqH,EAAA3H,OAAA,MAAA3D,EACA,sBAAAA,GAAAwN,QACA,MAAAxN,GAAAwN,QAAAlC,EAAAmG,MAAA,IAIA,GAAAvG,EAAA4B,UAEA5B,EAAAmK,SAAAnK,EAAApF,QAAAiK,YAAA6E,GAAA,GAEA1J,EAAA4B,QAAAwI,IAAArR,IACA,MAAA4Q,GACAE,EAAAQ,WAAAtR,EAAAiH,EAAA4B,QAAA0I,QAAAlK,EAAAtG,SAAAf,GAAAuJ,QAAAlC,GAGAJ,EAAA4B,QAAAU,QAAAlC,EAIAJ,GAAAuK,kBAAAvK,EAAApF,QAAAG,UAEAiF,IAAAuK,gBACAZ,GAAA,GAEA3J,IAAAhF,OAIA,IAAA0O,EACA,MAAAG,GAAAvH,QAAAlC,GAOA,QAAAoK,MACAC,GAAA1O,KAAA2O,OAGA,QAAAC,MACA,GAAAC,GAAAH,GAAAtF,KAEA,OADAuF,IAAAD,MAAAhS,OAAA,GACAmS,EAGA,QAAAC,IAAA/V,GACA4V,IACAA,GAAA3O,KAAAjH,GA+CA,QAAAgW,IAAA1O,GAAuCA,EAAAlG,OACvC,QAAA6U,IAAA3O,GAAqCA,EAAA2O,SACrC,QAAAC,IAAA5O,GAAqCA,EAAA4O,eACrC,QAAAC,IAAA7O,GAAqCA,EAAA6O,OACrC,QAAAC,IAAA9O,GAAqCA,EAAA8O,SACrC,QAAAC,IAAA/O,GAAqCA,EAAA+O,mBACrC,QAAAC,IAAAhP,GAAqCA,EAAAgP,SACrC,QAAAC,IAAAjP,GAAqCA,EAAAiP,WACrC,QAAAC,IAAAlP,GAAqCA,EAAAkP,SACrC,QAAAC,IAAAnP,GAAqCA,EAAAmP,WACrC,QAAAC,IAAApP,GAAqCA,EAAAmP,UAAA,GACrC,QAAA9K,IAAArE,GAAqCA,EAAAqE,SACrC,QAAAgL,IAAArP,GAAuC,MAAAA,GAAA3E,WACvC,QAAAiU,IAAAtP,GAAqC,MAAAA,GAAA3E,UAAA,GA2arC,QAAAkU,IAAA7W,GACAA,EAAA6W,oBAAA,GAGA,QAAAC,IAAArM,GAEA,IADA,GAAAtD,GAAAsD,EAAA9G,OACAwD,KACA,GAAAsD,EAAAtD,GAAA6F,MAAA,CACA,GAAAiE,GAAAxG,EAAAtD,GAAA8J,KACA,IAAAA,EAAA,CACA,GAAAvR,GAAA,YAAAuR,EAAAxR,KACAwR,EAAA7Q,KAAA2W,QACA9F,EAAA7Q,KAAAV,KACA,QAAcA,WAMd,QAAAsX,IAAAC,GACA,GAAAA,EAGI,CACJ,GAAAlL,GAAAmL,GAAAD,EACAC,IAAAD,KAEA,KADA,GAAA9P,GAAA4E,EAAApI,OACAwD,KAAA4E,EAAA5E,IAEA,IAAAgQ,GAAAC,GAAAH,EAGA,KAFAG,GAAAH,MACA9P,EAAAgQ,EAAAxT,OACAwD,KAAAgQ,EAAAhQ,GAAAnH,MAAAmX,WAAAhQ,GAAA6J,UAXAgG,IAAA,SACAA,GAAA,QAuBA,QAAAK,IAAArZ,EAAAsZ,EAAAC,GACA,GAAAjL,GAAAtO,EAAAiL,GAAAjL,CAGA,KAAAsO,GAAA,gBAAAA,GAAA,MAAAgL,EAGA,UAAAhL,GAAA,MAAAA,EAAA,KAAAgL,GAAAC,GAAAC,QAAAF,GAAAC,GAAAE,UAAA,MAAAH,EAUA,KARA,GAAAI,GAAApL,EAAAqL,MAAA,KACArM,EAAAe,EAAAqL,IAAA/T,OAAA,IAGA3D,EAAAsX,GAAAC,EACApQ,EAAAmE,EAAA3H,OACA4I,GAAA,EAAAqL,GAAA,EAEA5X,GAAAmH,KACAnH,EAAA4X,eAAA,GAEAtM,EAAAnE,IAAAnH,EAAAiE,MAAAsI,GAAA,GACAvM,IAAAkG,MAIA,QAAAoR,GAAA/K,GAAAqL,EAAAL,EAEAD,IAAA/K,GAAAqL,EAAAL,EACAD,EA8PA,QAAAO,MACA3K,GAAA1L,OAEA,IAEA2F,GACA2Q,EAHAC,EAAAC,IAKA,KAAA7Q,EAAA,EAAeA,EAAA8Q,GAAAtU,OAAoBwD,GAAA,EACnC2Q,EAAAG,GAAA9Q,GAEA2Q,EAAAD,KAAAE,IAEAE,GAAAtQ,OAAAR,IAAA,EAIA+F,IAAAC,MAEA8K,GAAAtU,OACAuU,GAAAL,IAEAM,IAAA,EA6CA,QAAAC,IAAAvb,EAAAwb,GACA,GAAoBpU,GAApBqU,IAEA,KAAAD,EACA,MAAAxb,EAGAwb,IAAA,GAEA,KAAApU,IAAApH,GACAA,EAAAgR,eAAA5J,KACAqU,EAAAD,EAAApU,GAAApH,EAAAoH,GAIA,OAAAqU,GAGA,QAAAC,IAAAC,GACA,GAAAC,EAqBA,OAnBAC,IAAAF,KACAC,EAAAD,IAAA,OAEAE,GAAAF,GAAA,SAAAG,EAAAjZ,GACA,GAAA7C,EAEA,uBAAA8b,IACA9b,KACAA,EAAA4b,EAAAE,GAAAjZ,EACA7C,GAGA,gBAAA8b,GAEAF,EAAAL,GAAAO,EAAAH,GAAAG,EAFA,SAOAD,GAAAF,GAwTA,QAAAI,IAAA5Y,GAGA,OAFA2G,MAEAQ,EAAA,EAAmBA,EAAAnH,EAAA2D,OAAkBwD,IACrCR,EAAAQ,IAAAnH,EAAA6Y,WAAA1R,QAA2CzH,KAG3C,OAAAiH,GA6BA,QAAAmS,IAAA5N,EAAAiB,GACA,GAAAW,GAAA5B,EAAA8J,aAIA,UAAA7I,GAAA,SAAAA,EAAA,MAAAW,EACA,QAAAX,EAAAnF,QAAA,aACA,GAAAuF,GAAAwM,GAAAtM,KAAAN,EACA,IAAAI,KAAA,IACA,GAAAvM,GAAA8Y,GAAA5N,EAAAqB,EAAA,GACA,IAAAvM,EAAA,MAAAA,GAAAgZ,kBAEA,MAAAlM,GAAAkM,kBAEA,OAAA7M,EAAAnF,QAAA,cAEA,KAAA8F,EAAAuI,QAAAvI,EAAAhH,QAAAiK,WACAjD,IAAAhH,QAAAiK,UAAAQ,eAAAyE,aAGA,IAAAiE,GAAAF,GAAAtM,KAAAN,EACA,IAAA8M,KAAA,IACA,GAAAC,GAAAJ,GAAA5N,EAAA+N,EAAA,GACA,IAAAC,EAAA,MAAAA,GAAAF,gBAAA9N,EAAApF,QAAAzI,MAEA,MAAAyP,GAAAkM,gBAAA9N,EAAApF,QAAAzI,MAEA,cAAA8O,GAAA,SAAAA,EAAA,CACA,GAAAgN,GAAAjO,EAAAkO,uBAEA,KAAAD,EAAAlE,YAAA,MACA,OAAAkE,GAAArM,QAAAqI,YAAAgE,EAAA,MAAAhN,EAAA,mBAEA,aAAAA,EACA,MAAAjB,GAAApF,QAAAyF,UAAA8N,iBAEA,gBAAAlN,EACA,MAAAmN,GAIA,UAAAnN,EAAA,SAAAjB,GAAApF,QAAAyF,UAAAiC,QAAAnB,EAAAF,EAAAsF,MAAA,IACA,UAAAtF,EAAA,IAGA,IAFA,GAAAuL,GAAAvL,EAAAwL,MAAA,KAEA,MAAAD,EAAA,WAAAA,EAAA,KACA,GAAA6B,GAAA7B,EAAA1S,OAEA,QAAAuU,IACAzM,IAAA5G,QAQA,MAJAiG,GAAAuL,EAAA3I,KAAA,KAGA,MAAA5C,EAAA,KAAAA,IAAAsF,MAAA,IACA3E,EAAAU,QAAAnB,EAAAF,IAGA,MAAAwI,IAAAzJ,EAAAiB,GAGA,QAAAqN,IAAAlN,EAAAmN,GACA,mBAAAnN,GAAA,MAAApN,MAAAqM,UAAA3L,KAAA,EAAA0M,EAEA,IAGAtM,GAHAsL,EAAAe,EAAAC,GACArI,EAAAqH,EAAA,EAiBA,OAbApM,MAAAqM,UAAA+J,IAAArR,IAGA/E,KAAA6Q,YAAA7Q,KAAA+G,WACAjG,EAAA8Y,GAAA5Z,KAAA6Q,UAAAQ,eAAAtM,GAEAjE,GACAd,KAAAqM,UAAAuC,IAAA7J,EAAAjE,IAKAA,EAAAd,KAAAqM,UAAAiC,QAAAlC,GACAtL,EAAAJ,KAAA,EAAA6Z,GAGA,QAAAC,IAAAxO,GAIA,IAHA,GAAAjH,MAAe8C,KAGfmE,GAAA,CACA,GAAAA,EAAAhF,SAAAgF,EAAAhF,OAAAkP,UAAAlK,EAAAhF,OAAAgP,QAAA,CACA,GAAA/I,GAAAjB,EAAAhF,OAAAkP,UACAjJ,OAAApF,OAAAoF,GAAAjB,EAAAnE,OACAoF,EAAAjB,EAAAhF,OAAAgP,QACA/I,OAAAlI,OAAAkI,GAAAjB,EAAAjH,KAIAiH,EADAA,EAAAuK,kBAAAvK,EAAApF,QAAAG,SACAiF,EAAAuK,gBAEAvK,EAAAhF,OAIA,OAAWjC,MAAA8C,SA4BX,QAAA4S,IAAAhW,EAAAiW,EAAA7U,GACA,GAAA8U,GAAAC,EAAAC,EAAAC,EAAA7S,EAAA8S,IAIA,IAFAJ,EAAAK,GAAAvW,EAAAiW,EAAA7U,IAEA8U,EACA,WASA,KANAG,EAAAH,EAAAlW,OAAA,EAAAkW,EAAA,GAEAC,EAAAK,KAAAC,IAAAzW,EAAAkW,EAAA,IACAE,EAAAD,EAAAD,EAAA,GACAI,EAAAI,WAAAP,EAEA3S,EAAA,EAAeA,EAAA2S,EAAiB3S,GAAA,EAChC8S,EAAAhT,KAAAE,EAGA,MAAUA,EAAA4S,EAAe5S,GAAA,EACzB8S,EAAAhT,MAAA,EAGA,MAAUE,EAAAxD,EAAYwD,GAAA,EACtB8S,EAAAhT,KAAAE,EAAA6S,EAUA,OANA,KAAAA,EACAC,EAAAK,YAAAT,EAAA,GAEAI,EAAAK,YAAA3W,EAGAsW,EAMA,QAAAC,IAAAvW,EAAAiW,EAAA7U,GACA,OAAA6U,GACA,aAOA,IANArS,SAAAxC,EAAA,IAAAA,EAAA,OACAA,EAAA,GAAApB,EAAAwW,KAAAlH,IAAAlO,EAAA,IAAApB,IAGA4D,SAAAxC,EAAA,KAAAA,EAAA,MAEAA,EAAApB,OAAA,GACAoB,EAAAkC,KAAAtD,EAAAoB,EAAA,GAUA,OAPA,gBAAAA,GAAA,KACAA,EAAA,GAAApB,EAAAoB,EAAA,IAIAA,EAAA,GAAAoV,KAAAC,IAAArV,EAAA,GAAApB,EAAAoB,EAAA,IAEAA,CAEA,YACA,cACA,WAEA,WACA,MAAApB,IACAA,EAAA,MAEA,IAEA,YACA,OAAAA,EAAA,GAAAgH,OAAA5F,EAEA,aACA,SAAApB,EAAA,IAEA,eACA,YAAAgH,OAAA5F,IAMA,QAAAwV,IAAAX,GACA,QAAAY,GAAAlO,GAEA,IADA,GAAAvH,MAAAtB,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAsB,EAAAtB,GAAAC,UAAAD,EAAA,EAEA,OAAAzD,GAAAd,KAAAqM,UAAAiC,QAAAnB,EAAAC,IAAAvH,GAGA,QAAA/E,GAAAya,EAAA1V,GACA,GAAA4B,GAAA8T,EAAA7a,KAEA,KAAAsE,EAAAyC,GAAA,CACA,GAAAY,SAAAZ,EAAA,CACAA,IACA,IAAA+T,GAAAC,GAAAf,GAAAvU,MAAAsB,EAAA5B,GACA6V,EAAA1N,GAAA1L,MAAAtC,MAAA,GAAAuJ,KAAA,WAAqE,MAAAiS,IAGrE,OAFAD,GAAAnb,IAAAqH,GACAuG,GAAAC,MACAyN,EAEA,SAAA1V,OAAA,wBAAA0U,EAAA,2BAAAa,EAAAI,cAIA,GAAAZ,GAAAN,GAAAhT,EAAAhD,OAAAiW,EAAA7U,GACAoD,EAAAwS,GAAAf,GAAAvU,MAAAsB,EAAA5B,GAEAuD,EAAA4E,GAAA1L,MAAAtC,MAAA,GAAAuJ,KAAA,WAAiE,MAAAN,IAWjE,OAVAG,GAAAH,SAEA8R,EACAQ,EAAAK,QAAAb,GAEAQ,EAAAnb,IAAA6I,GAGA+E,GAAAC,MAEA7E,EAGA,OAAWkS,OAAAxa,SAKX,QAAA+a,IAAAC,GACA,IAAAA,EAAA,WACA,IAAAA,KAAA,QAAAC,MAAAC,SACA,sBAAAF,GAAA,MAAAA,EAEA,oBAAAA,GACA,MAAAG,IAAAH,KAAAG,GAAAH,GAAA,SAAA7W,GAAkF,MAAAA,GAAA6W,IAGlF,UAAA9V,OAAA,sEAGA,QAAAkW,IAAAtV,EAAA9F,EAAA2G,EAAA0H,GACA,GAAA/F,GAAA4E,GAAA1L,MAAAsE,GAAA,GACApG,EAAAM,EAAAJ,KAEA,KAAAsE,EAAAxE,KAAAwE,EAAAyC,GACA,SAAAzB,OAAA,6CAGA,IAAAmW,GAAAN,GAAA1M,KAAAiN,QAIA,OAHAtb,GAAAub,MAAA5U,EAAA0U,GAEAnO,GAAAC,MACA7E,EAGA,QAAAkT,IAAAlP,EAAA3F,EAAA0H,GACA,MAAA+M,IAAAlc,UAAAqM,UAAAiC,QAAAnB,EAAAC,IAAA3F,EAAA0H,GAKA,QAAAoN,IAAA3V,EAAA9F,GAGAA,EAAAkG,QAAAlG,EAAAkG,OAAAwV,SACA1b,EAAAkG,OAAAyV,OAGA,IAAArT,GAAA4E,GAAA1L,MAAAsE,GAAA,EAKA,IAHA9F,EAAAmW,OACAnW,EAAA4b,eAAA5b,EAAA6a,aAAA7a,EAAAJ,QAEAI,EAAAqV,OAGA,IADA,GAAAnP,GAAAlG,EAAAkG,OAAAjC,EAAAjE,EAAAiE,IACAiC,MAAAmP,QACAnP,EAAA2V,kBAAA3V,EAAA2V,iBAAA5X,GACAA,EAAAiC,EAAAjC,IACAiC,UAWA,OANAlG,GAAA8b,iBAEA5O,GAAAC,MAEA4O,GAAArQ,KAAA5F,EAAA9F,GAEAsI,EAGA,QAAA0T,IAAA1P,GAGA,MAFAA,OAAAD,EAAAC,IAEAmP,GAAAvc,KAAAoN,EAAApN,KAAAqM,UAAAiC,QAAAlB,GAAApN,KAAAqM,WAYA,QAAA0Q,IAAAle,EAAAuO,EAAA5M,GACA,GAAAgO,KAGA,IAAA/I,EAAA2H,GACA,OAAAsB,KAAAtB,GACAA,EAAAuB,eAAAD,IACAF,EAAAzG,MAAAiV,GAAAne,EAAA6P,GAAA5N,MAAAsM,EAAAsB,SAOAF,GAAAzG,MAAAiV,GAAAne,EAAAuO,GAAAtM,MAAAN,GAGA,OAAAgO,GAIA,QAAA9N,IAAA0M,GACA,IAAAA,EAAA,MAAApN,MAAAid,SAAA5L,eAAAyE,cAAApV,KAAA,EAEA,IAAAI,GAAA8Y,GAAA5Z,KAAAid,SAAA5L,eAAAjE,EAEA,OAAAtM,KAAAJ,KAAA,GAAA2H,OAGA,QAAA6U,IAAA5B,EAAA1U,GACA,GAAAqG,GAAA+P,GAAAhd,KAAAsb,GAAAxa,EAAAmM,EAAAnM,MAAA+F,EAAAoG,EAAApG,QACA,OAAA/F,KAAA6a,WAAA/U,GAAAC,GAAAyU,EAGA,QAAA0B,IAAAne,EAAAyc,GACA,GAAA6B,GAAAte,EAAAoe,SAAA5L,cAEA,uBAAAiK,IACYxa,MAAAqc,EAAArH,cAAAjP,SAAAyU,IAGDxa,MAAA8Y,GAAAuD,EAAA7B,GAAAzU,SAAAsW,EAAAvW,SAIX,QAAAwW,IAAAhQ,EAAA5M,GAEA,GADA6H,SAAA7H,MAAA,IACA6E,EAAA7E,GAAA,SAAAwF,OAAA,gBACA,OAAA5F,GAAAJ,KAAA4G,QAAAmW,GAAA/c,KAAAoN,EAAA5M,GAAAoO,IAAA,SAAAG,GACA,GAAAjO,GAAAiO,EAAA,GAAAsO,EAAAtO,EAAA,GAAAvO,EAAAM,EAAAJ,KACA,KAAA2E,EAAAgY,KAAAhY,EAAA7E,GAAA,SAAAwF,OAAA,+BACA,QAAAlF,EAAAN,EAAA6c,MAIA,QAAA1N,IAAAvC,EAAA5M,EAAA2O,GACA,GAAArO,GAAAkc,GAAAhd,KAAAoN,GAAAtM,KACA,OAAA0O,IAAAxP,KAAA4G,QAAA9F,EAAAN,EAAA2O,GAGA,QAAAmO,IAAA1Y,EAAA2Y,GACA,GAAAC,GAAAR,GAAAhd,KAAA4E,GAAA9D,MAAA2c,EAAAT,GAAAhd,KAAAud,GAAAzc,MACAsI,EAAA4E,GAAA1L,MAAAtC,KAAA4G,SAAA,EAGA,OAFA6W,GAAAH,KAAAE,EAAA5Y,GACAoJ,GAAAC,MACA7E,EAGA,QAAAiT,IAAAjP,EAAA3F,EAAA0H,GACA,MAAA+M,IAAAlc,KAAA4G,QAAAoW,GAAAhd,KAAAoN,GAAAtM,MAAA2G,EAAA0H,GAGA,QAAAgC,IAAA/D,GACA,MAAAsQ,IAAAV,GAAAhd,KAAAoN,GAAAtM,UAGA,QAAAiH,IAAAqF,GAEA,IADA,GAAAuQ,MAAApZ,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAoZ,EAAApZ,GAAAC,UAAAD,EAAA,EAEA,OAAAqZ,IAAAZ,GAAAhd,KAAAoN,GAAAtM,MAAA6c,GAGA,QAAAE,IAAAzQ,GACA,MAAA0Q,IAAAd,GAAAhd,KAAAoN,GAAAtM,UAGA,QAAAid,IAAA3Q,EAAA5M,GACA,MAAAJ,GAAAJ,KAAA4G,QAAAmW,GAAA/c,KAAAoN,EAAA5M,IAGA,QAAAsF,IAAAsH,GACA,MAAA4Q,IAAAhB,GAAAhd,KAAAoN,GAAAtM,UAGA,QAAA2H,IAAA2E,EAAAvF,EAAAoW,GAEA,IADA,GAAApP,MAAAtK,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAsK,EAAAtK,GAAAC,UAAAD,EAAA,EAGA,OADAsK,GAAAqP,QAAArW,EAAAoW,GACAE,GAAAnB,GAAAhd,KAAAoN,GAAAtM,MAAA+N,GAGA,QAAAuP,IAAAhR,GACA,MAAAiR,IAAArB,GAAAhd,KAAAoN,GAAAtM,UAGA,QAAAwd,IAAAlR,EAAA5M,GAEA,GADA6H,SAAA7H,MAAA,IACA6E,EAAA7E,GAAA,SAAAwF,OAAA,gBACA,OAAA5F,GAAAJ,KAAA4G,QAAAmW,GAAA/c,KAAAoN,EAAA5M,GAAAoO,IAAA,SAAAG,GACA,GAAAjO,GAAAiO,EAAA,GAAAsO,EAAAtO,EAAA,GAAAvO,EAAAM,EAAAJ,KACA,KAAA2E,EAAAgY,KAAAhY,EAAA7E,GAAA,SAAAwF,OAAA,+BACA,QAAAlF,EAAAN,EAAA6c,MAIA,QAAA1c,IAAAyM,GACA,GAAAH,GAAA+P,GAAAhd,KAAAoN,GAAAtM,EAAAmM,EAAAnM,KACA,OAAAV,GAAAJ,KAAA4G,UAAA9F,KAAAJ,SAGA,QAAA6d,IAAAhB,GACA,GAAAE,GAAAT,GAAAhd,KAAAud,GAAAzc,MACAsI,EAAA4E,GAAA1L,MAAAtC,KAAA4G,SAAA,EAGA,OAFA6W,GAAA1L,OAAA0L,EAAA1L,MAAAyM,OAAAf,EAAA1L,MAAAwM,SACAvQ,GAAAC,MACA7E,EAGA,QAAA8U,IAAA9Q,GAEA,IADA,GAAAyB,MAAAtK,EAAAC,UAAAC,OAAA,EACAF,KAAA,GAAAsK,EAAAtK,GAAAC,UAAAD,EAAA,EAEA,OAAAka,IAAAzB,GAAAhd,KAAAoN,GAAAtM,MAAA+N,GAGA,QAAA6P,IAAAtR,GACA,MAAAmP,IAAAvc,KAAA4G,QAAAoW,GAAAhd,KAAAoN,GAAAtM,OAGA,QAAA6d,IAAAvR,EAAAwR,GACA,GAAA3R,GAAA+P,GAAAhd,KAAAoN,GAAAtM,EAAAmM,EAAAnM,MACAsI,EAAA4E,GAAA1L,MAAAtC,KAAA4G,SAAA,EAGA,OAFA9F,GAAA6W,mBAAAiH,GACA5Q,GAAAC,MACA7E,EAIA,QAAAyV,MACA,GAAA5R,GAAA6R,GAAA9e,MAAAc,EAAAmM,EAAAnM,KACA,SAAAA,EAGA,QAAAie,IAAAnY,GACA,GAAAqG,GAAA6R,GAAA9e,MAAAc,EAAAmM,EAAAnM,MAAA+F,EAAAoG,EAAApG,QACA,IAAA/F,EAAA,MAAAA,GAAA6a,WAAA/U,GAAAC,GAGA,QAAAmY,MACA,GAAA/R,GAAA6R,GAAA9e,MAAAc,EAAAmM,EAAAnM,KACA,IAAAA,EAAA,MAAAA,GAAAJ,KAAA,GAGA,QAAAoe,IAAAG,GACA,GAAApgB,GAAAogB,EAAAhC,QACA,QAAWnc,MAAAjC,EAAAqgB,SAAArgB,EAAAqgB,QAAApe,MAAA+F,SAAAhI,EAAAwS,eAAAzK,SAGX,QAAAuY,IAAA3e,GACA,GAAAyM,GAAA6R,GAAA9e,MAAAc,EAAAmM,EAAAnM,KACA,OAAAV,GAAAJ,KAAA4G,UAAA9F,EAAAN,KAIA,QAAA4M,MAEA,MADA3G,GAAA,wEACAzG,KAAAmJ,UAGA,QAAAiW,MAEA,MADA3Y,GAAA,uFACAzG,KAAAmJ,QAAAnJ,KAAA4G,QAAAzI,MAGA,QAAAyP,MAEA,MADAnH,GAAA,oEACAzG,KAAAU,MAGA,QAAAmH,MAEA,MADApB,GAAA,gFACA+T,GAAAxa,KAAAid,SAAA5L,gBAAAxJ,MAGA,QAAA9C,MAEA,MADA0B,GAAA,4EACA+T,GAAAxa,KAAAid,SAAA5L,gBAAAtM,IAGA,QAAAsa,IAAA1hB,EAAAsM,GAqCA,MApCAqV,IAAA3hB,GACAsf,UAAezc,MAAAyJ,GACfrD,SAAcpG,MAAAyJ,EAAAoH,eAAAzK,SACduC,SAAc3I,MAAA0c,IACdxc,KAAUF,MAAAE,IAEVmO,KAAUrO,MAAA4c,IACVzN,SAAcnP,MAAAmP,IACd2N,MAAW9c,MAAA8c,IACXjB,OAAY7b,MAAA6b,IACZlL,KAAU3Q,MAAA2Q,IACVpJ,MAAWvH,MAAAuH,IACX8V,SAAcrd,MAAAqd,IACdzd,KAAUI,MAAAud,IACVjY,OAAYtF,MAAAsF,IACZsY,MAAW5d,MAAA4d,IACX3V,QAAajI,MAAAiI,IACb6V,UAAe9d,MAAA8d,IACf3d,QAAaH,MAAAG,IACb4d,QAAa/d,MAAA+d,IACbL,SAAc1d,MAAA0d,IACdzR,QAAajM,MAAAke,IACbC,aAAkBne,MAAAme,IAElBE,SAAcre,MAAAqe,IACdE,gBAAqBve,MAAAue,IACrBC,YAAiBxe,MAAAwe,IACjBG,YAAiB3e,MAAA2e,IAEjB/R,SAAc1M,IAAA0M,IACdgS,UAAe1e,IAAA0e,IACfxR,SAAclN,IAAAkN,IACd/F,OAAYnH,IAAAmH,IACZ9C,KAAUrE,IAAAqE,MAGVpH,EAKA,QAAA4hB,IAAAre,GAKA,GAJA,gBAAAA,IAAAmR,KACAnR,EAAAmR,GAAA/U,KAAAU,SAAAkD,KAGAA,MAAA4P,SAAA,QAEA,IAAA0O,GAAAte,EAAA4P,QAEA,OAAAuO,OAAwBG,EAAAzO,OAGxB,QAAA0O,IAAAve,GAKA,MAJA,gBAAAA,KACAA,EAAAlB,KAAAoQ,KAAAlP,IAGAqe,GAAAre,GAKA,QAAAwe,IAAApf,EAAAqf,GACA,IAAA3f,KAAAgM,SAAA4T,SAEA,SAAA5Z,OAAA,wJAMA,IAHA1F,EAAAyC,EAAAzC,GACAqf,EAAA5c,EAAA4c,IAAA,MAEArf,EACA,SAAA0F,OAAA,iDAGA1F,GAAAuf,aAAA7f,KAAAgK,SAAA2V,GACA3f,KAAAnB,GAAAyB,GAEAA,EAAA0P,wBAAA1P,EAAA0P,2BAAAjI,KAAA/H,MACAA,KAAA+P,YAAA,EAEA+P,GAAA9f,MAGA,QAAA8f,IAAAlZ,GACAmZ,GAAAvT,KAAA5F,GAEAA,EAAAiM,kBAAA,KAAAlO,QAAA,SAAAqb,GACAF,GAAAE,EAAAnZ,YAIA,QAAAoZ,IAAAzC,EAAAC,GACA,GAAAA,IAAAD,GAAA,KAAAA,EAAA,KAAA1V,QAAA2V,EAAA,WAAAA,EAAA,KAAA3V,QAAA0V,EAAA,KACA,SAAAxX,OAAA,wCAGA,IACAlF,GADAsI,EAAA4E,GAAA1L,QAIA4d,EAAA/S,EAAAqQ,EAUA,QATAxd,KAAAqM,UAAA+J,IAAA8J,EAAA,KAAAlgB,KAAA6Q,YACA/P,EAAA8Y,GAAA5Z,KAAA6Q,UAAAQ,eAAA6O,EAAA,IACApf,IAAAwN,QAAA4R,EAAA3N,MAAA,KAGAvS,KAAAqM,UAAAiC,QAAAnB,EAAAsQ,IAAAH,KAAAxc,GAAAd,KAAAqM,UAAAiC,QAAA4R,GAAA1C,GAEAxP,GAAAC,MAEA7E,EAiEA,QAAA+W,IAAA/S,EAAAvE,EAAAsG,GACA,GAGAP,GAHAwR,EAAApgB,KAEAqgB,IAGA,IAAA5a,EAAA2H,GACAwB,EAAAxB,EACA+B,EAAAtG,MAEAsD,OAAAC,KAAAwC,GAAAjK,QAAA,SAAAyI,GACA,GAAAvE,GAAA+F,EAAAxB,GAEAkT,EAAAlT,EAAAqL,MAAA,IACA6H,GAAA7b,OAAA,IAAA6b,IAAAC,OAAA,SAAA7R,GAA4E,MAAAA,MAE5E4R,EAAA3b,QAAA,SAAAyI,GACAiT,EAAAtY,KAAAyY,GAAAJ,EAAAhT,EAAAvE,EAAAsG,YAKA,CACA,GAAAmR,EAEA,mBAAAlT,IACA+B,EAAAtG,EACAA,EAAAuE,EACAkT,GAAA,KAEAA,EAAAlT,EAAAqL,MAAA,KAGA6H,EAAA7b,OAAA,IAAA6b,IAAAC,OAAA,SAAA7R,GAA2E,MAAAA,MAE3E4R,EAAA3b,QAAA,SAAAyI,GACAiT,EAAAtY,KAAAyY,GAAAJ,EAAAhT,EAAAvE,EAAAsG,UAQA,MAFAnP,MAAAygB,WAAA1Y,KAAA5B,MAAAnG,KAAAygB,WAAAJ,IAGAtJ,OAAA,WACAsJ,EAAA1b,QAAA,SAAAgH,GACApD,EAAA6X,EAAAK,WAAA9U,GACAA,EAAAoL,aAMA,QAAAyJ,IAAA5Z,EAAAwG,EAAAvE,EAAAsG,GACA,GAAA9C,GAAAzF,EAAAyF,UAEAD,EAAAe,EAAAC,GACAsT,EAAAtU,EAAAtE,QAAA,IAIA,IAHAqH,EAAA/B,YAGAsT,EAAA,CACA,GACA5f,GADAiE,EAAAqH,EAAA,EAiBA,OAbA,KAAArH,GAAAsH,EAAA+J,IAAArR,GAUAjE,EAAAuL,EAAAiC,QAAAlC,GARAxF,EAAAiK,YAAAjK,EAAAG,WACAjG,EAAA8Y,GAAAhT,EAAAiK,UAAAQ,eAAAtM,GACAjE,IACAuL,EAAAuC,IAAA7J,EAAAjE,GACAA,EAAAuL,EAAAiC,QAAAlC,KAOA,GAAAuU,IAAA/Z,EAAA9F,EAAA+H,EAAAsG,GAIA,GAAAyR,GAAA,IAAAF,EACArU,EACAA,EAAAiC,QAAAlC,EAAAmG,MAAA,EAAAmO,GAEA,WAAAG,IAAAja,EAAAga,EAAAxU,EAAA3D,OAAAiY,GAAA7X,EAAAsG,GA+OA,QAAA2R,IAAA1T,EAAAvE,EAAAsG,GACA,mBAAA/B,GACA,SAAApH,OAAA,sEAGA,IAAAlF,GAAAd,KAAAqM,UAAAiC,QAAAnB,EAAAC,IACAzB,EAAA,GAAAoV,IAAA/gB,KAAAc,EAAA+H,EAAAsG,MAMA,OAFAnP,MAAAygB,WAAA1Y,KAAA4D,IAGAoL,OAAA,WACApL,EAAAoL,WAKA,QAAAiK,MACA,SA6EA,QAAAC,IAAA7T,EAAAvE,EAAAsG,GACA,MAAA1J,GAAA2H,IAAA,kBAAAA,IACA+B,EAAA9K,EAAAwE,MAAuCqY,IACvClhB,KAAAmgB,QAAA/S,EAAA+B,KAGAA,EAAA9K,EAAA8K,MAAqC+R,IACrClhB,KAAAmgB,QAAA/S,EAAAvE,EAAAsG,IAGA,QAAAgS,IAAAC,GAAyB,MAAAA,GAAAD,OAEzB,QAAAE,IAAAD,GAAmC,WAAAA,EAEnC,QAAAE,IAAAhN,EAAAzL,GAEA,GAAAuX,GAAApgB,IAEA,IAAAsU,EAUA,CAEA,GAAAE,GAAAF,EAAAmE,MAAA,KAAA7J,IAAAuS,IAAAZ,OAAAc,GAEA7M,GAAA7P,QAAA,SAAA2P,GACA,GAAAO,GAAAuL,EAAArL,MAAAT,EAGA,IAAAO,EAEA,GAAAhM,EAAA,CAGAA,EAAAuM,KAAA,CACA,IAAAvN,GAAAgN,EAAA/M,QAAAe,EACAhB,MAAA,GACAgN,EAAApM,OAAAZ,EAAA,OAMAuY,GAAArL,MAAAT,YA3BA,KAAAA,IAAAtU,MAAA+U,YACA/U,MAAA+U,MAAAT,EAgCA,OAAAtU,MAGA,QAAAuhB,IAAAjN,EAAAzL,GAEA,GAAAuX,GAAApgB,IAEA,oBAAAsU,GAAA,CACA,GACAkN,GADAC,IAGA,KAAAD,IAAAlN,GACAA,EAAA3F,eAAA6S,IACAC,EAAA1Z,KAAA/H,KAAAC,GAAAuhB,EAAAlN,EAAAkN,IAIA,QACAzK,OAAA,WAEA,IADA,GAAA2K,GACAA,EAAAD,EAAAtQ,OAAAuQ,EAAA3K,WAMA,GAAAvC,GAAAF,EAAAmE,MAAA,KAAA7J,IAAAuS,IAAAZ,OAAAc,GAMA,OAJA7M,GAAA7P,QAAA,SAAA2P,IACA8L,EAAArL,MAAAT,KAAA8L,EAAArL,MAAAT,QAAAvM,KAAAc,MAIAkO,OAAA,WAAyB,MAAAqJ,GAAAhL,IAAAd,EAAAzL,KAIzB,QAAA8Y,IAAArN,EAAApL,GACA,GAAAwY,GAAA1hB,KAAAC,GAAAqU,EAAA,WACApL,EAAA/C,MAAAnG,KAAAwE,WACAkd,EAAA3K,UAIA,OAAA2K,GAmBA,QAAAE,IAAAC,GACAC,GAAA/Z,KAAA8Z,GACAE,IAAA,EAGA,QAAAC,MAIAlf,IAAAif,KAEAE,GACAC,GAAAC,WAAAC,QAAAC,GAAA,MAEAH,GAAAI,UAAAD,GAAA,MAGAN,IAAA,GAGA,QAAAM,IAAAE,GAEA,GAAAC,GAAAD,EAAAT,GAAAvB,OAAA,SAAAkC,GAAwF,OAAAF,EAAAza,QAAA2a,EAAArlB,MAAsC0kB,EAE9H,OAAAU,GAAAE,OAAA,SAAAC,EAAAF,GAAuE,SAAAE,EAAA,WAAgCF,EAAA,YAAmBA,EAAA,QAA2BG,IAkBrJ,QAAAC,IAAAjc,EAAAtG,EAAAqf,EAAAmD,GAEA,GAAAC,GAAAnc,EAAAmc,kBACAnc,GAAAoc,UAAApc,EAAAmc,oBAAA,EAEA,IAAA3Z,GAAA4E,GAAA1L,MAAAsE,GAAA,EAGA,IAFAoH,GAAAiV,aAAA,WAAsC,MAAAC,IAAA1W,KAAA5F,KAAqC,GAE3EA,EAAAoF,SAAA4T,SACA,SAAA5Z,OAAA,kGAWA,IARA2Z,EAAA5c,EAAA4c,IAAA/Y,EAAA+Y,OAEA/Y,EAAA/H,GAAAyB,EACAsG,EAAA+Y,SAGA/Y,EAAAuc,OAAAnB,KAEA1hB,EAGA,IAFAA,EAAA0P,wBAAA1P,EAAA0P,2BAAAjI,KAAAnB,GAEA+Y,EAAA,CACA,GAAAyD,GAAAtgB,GAAAD,wBACA+D,GAAAoF,SAAAoL,OAAAgM,GACA9iB,EAAAuf,aAAAuD,EAAAzD,OAEA/Y,GAAAoF,SAAAoL,OAAA9W,EAAAwiB,EAOA,OAHA9U,IAAAC,MACArH,EAAAmc,qBAEA3Z,EAAAG,KAAA,WAAqC,MAAA8Z,IAAA7W,KAAA5F,KAGrC,QAAA0c,IAAAhjB,EAAAqf,GACA,GAAA3f,KAAAujB,SAEA,MADA/c,GAAA,gFACAgd,QAAAra,SAKA,IAFA7I,EAAAyC,EAAAzC,IAAAN,KAAAnB,IAEAmB,KAAAyjB,QAAAnjB,EAAA,CAGA,GAAAojB,GAAApjB,EAAA0P,qBACA0T,MAAA/e,QAAA0S,IAGArX,KAAA2jB,UACArjB,EAAAgiB,UAAA,IAIA,GAAAQ,GAAA9iB,KAAA2jB,QAAAjb,EAAApI,EAAAsjB,YAAA,KACAxa,EAAAyZ,GAAA7iB,KAAAM,EAAAqf,EAAAmD,EAEA,IAAAA,EACA,KAAAA,EAAAre,QAAAnE,EAAAiD,YAAAuf,EAAA3R,MAGA,OAAA/H,GAWA,QAAAya,IAAA1e,EAAAC,GAIA,IAHA,GAAA5H,GAAA2H,EAAAoN,QACAtK,EAAA7C,EAAAX,OAEAwD,MACAzK,EAAAsK,QAAA1C,EAAA6C,KACAzK,EAAAuK,KAAA3C,EAAA6C,GAIA,OAAAzK,GASA,QAAAsmB,IAAA1C,GACA,MAAAA,GAAAD,OAGA,QAAA4C,IAAAC,GACA,MAAAA,GAAA5C,IAGA,QAAA6C,IAAA9T,EAAAnJ,GAIA,IAHA,GACAqG,GADA6W,KAGA7W,EAAA8W,GAAA5W,KAAA4C,IACA+T,EAAAnc,MACAqZ,IAAA/T,EAAA,GACAc,KAAAd,EAAA,GACA+W,UAAA/W,EAAA,IAWA,KALA,GAAAc,GAAA+V,EAAAtV,IAAAmV,IAEAM,KACApc,EAAAic,EAAAzf,OAEAwD,KAAA,CACA,GAAAqc,GAAAnW,EAAAoE,QAGAyR,EAAAE,EAAAjc,EACAqc,GAAArc,GAAA+b,EAAA7V,KAAAnH,EAAAgd,EAAAI,WAAA,EAEA,IAAAG,GAAApW,EAAAoE,OACAgS,GAAAtc,GAAAjB,EAAA,IAAAud,EAAAtc,GAEAoc,EAAAtc,KAAAuc,EAAAzU,KAAA,KAAA0U,EAAA1U,KAAA,MAGA,MAAAwU,GAAAxU,KAAA,MAGA,QAAA2U,IAAAC,EAAArnB,GACA,GAEAinB,GAFAK,EAAA,wBAAyCtnB,EAAA,KAsBzC,OAjBAinB,GADAM,GAAA9W,KAAA4W,GACAA,EAAA7gB,QAAA+gB,GAAAD,GAEAD,EACA7gB,QAAAghB,GAAA,IACAhhB,QAAAihB,GAAA,SAAAxX,EAAAyX,GAEA,GAAAC,GAAAlX,KAAAiX,GAAA,MAAAzX,EAEA,IAAA2X,GAAAF,EAAArM,MAAA,KAAA7J,IAAAkV,IACAO,EAAAW,EACApW,IAAA,SAAAuB,GAAmC,MAAA8T,IAAA9T,EAAAuU,KACnC7U,KAAA,SAEA,OAAAxC,GAAAzJ,QAAAkhB,EAAAT,KAOA,QAAAY,MACA,MAAAhK,MAAAiK,MAAA,SAAAjK,KAAAkK,WAAA1hB,SAAA,IAAA2hB,UAAA,GAGA,QAAAC,MACA,MAAAJ,WAAA,IAAAA,KAAA,IAAAA,KAAA,IAAAA,KAAA,IAAAA,eA4BA,QAAAK,IAAAtmB,GAEAA,KAAAumB,cAAApZ,SACA,kBAAAnN,KAEK,gBAAAA,GACL+G,EAAA,iDAAA/G,EAAA,kBAEAwH,EAAA,sIAmDA,QAAAgf,IAAAC,EAAAC,GACAJ,GAAAI,EAEA,IAAAC,GAAA,kBAAAF,GACAG,EAAA,kBAAAF,EAWA,OANAA,IAAAC,IACAD,MAKAC,GAAAC,EAIA,WACA,GAAA5F,GAAA4F,EAAAC,GAAAH,EAAA1lB,MAAA0lB,EACA1e,EAAA2e,EAAAE,GAAAJ,EAAAzlB,MAAAylB,CAEA,OAAAK,IAAA9F,EAAAhZ,IAPA8e,GAAAJ,EAAAD,GAWA,QAAAI,IAAAlY,EAAAC,GACA,GAAA5O,GAAA2O,EAAArQ,KAAAsQ,EAEA,IAAA5O,EAUA,MARA,gBAAAA,IACA+G,EAAA,uCAGA/G,EAAAumB,cAAApZ,QACA1F,EAAA,uHAGAzH,EAGA,QAAA8mB,IAAAC,EAAAC,GACA,GAAAD,GAAAC,EAAA,CACA,OAAAjhB,KAAAihB,GACAjhB,IAAAghB,KACAA,EAAAhhB,GAAAihB,EAAAjhB,GAIA,OAAAghB,GAGA,MAAAA,IAAAC,EAOA,QAAAC,IAAAnkB,EAAA2C,GACA,SAAAA,MAAA,EAIA,KAFA,GAAAoB,GAAA,GAAAqgB,OAAAzhB,GAEAA,KACAoB,EAAApB,GAAA,IAAAA,CAQA,WAAA0hB,aAAA,oBAAAtgB,EAAAgK,KAAA,iBAAyE/N,EAAA,UAGzE,QAAAskB,IAAAhF,EAAAiF,GACA,GAAAC,GAEAC,EAAA,WAAAnF,EAAAxd,QAAA4iB,GAAA,SAAAnZ,EAAAD,GAEA,MADAkZ,IAAA,EACA,kBAAAlZ,EAAA,OACI,IAEJkZ,KAAAC,EAAA,yBAAuDA,EACvD,IAAA5Y,GAAA,GAAAwY,UAAAI,EACA,OAAAD,GAAA3Y,EAAAzL,KAAAmkB,GAAA1Y,EAKA,QAAA8Y,IAAArF,EAAAnZ,GACA,MAAAye,IAAAtF,GAAAsF,GAAAtF,GACAsF,GAAAtF,GAAAuF,GAAAvF,EAAAnZ,GAGA,QAAA2e,IAAA9nB,GACA,GAAAA,EAAA,CAEA,GAAA+nB,GAAA/nB,EAAA4K,CAEAmd,IAEA1a,OAAAC,KAAAya,GAAAliB,QAAA,SAAAyc,GACAsF,GAAAtF,KACAsF,GAAAtF,GAAAyF,EAAAzF,OA4OA,QAAA0F,IAAAC,GACA,GAAAzkB,GAAA0kB,EAAAC,CAEA,OAAAF,GAAAG,YAAA,MAIA5kB,EAAAykB,EAAAI,IAGAJ,EAAAK,mBAEAJ,EAAAD,EAAAM,aAAAC,KAOAP,EAAAM,aAAAE,KAIAN,EAAAF,EAAAM,aAAAC,MAOAP,EAAAK,kBAEAL,EAAAG,YAAA,MAKAF,EAAAC,IAJAF,EAAAI,IAAA7kB,EACA,QATAykB,EAAAI,IAAA7kB,EACA,MANA,MANAykB,EAAAI,IAAA7kB,EACA,OAXA,KAsCA,QAAAklB,IAAAT,GACA,GAAA9d,EAEA,QAAAA,EAAA8d,EAAAM,aAAAI,MAEAC,EAAAC,GACAC,EAAA3e,GAIA,KAKA,QAAA4e,IAAAzG,GACA,MAAAA,GAAAxd,QAAAkkB,GAAA,QAKA,QAAAC,IAAAC,EAAAC,GACA,MAAAD,GAAAE,OAAAC,GAAAF,EAAApY,UAAAsY,GAAAF,EAAApY,QAAA,GAAAuY,QAAAH,EAAArZ,IAAAiZ,IAAAhY,KAAA,QAaA,QAAAwY,IAAAC,GACA,MAAAA,GAAA1kB,QAAA2kB,GAAA,SAAAlb,EAAAmb,GACA,GAAAC,EAWA,OAPAA,GADA,MAAAD,EAAA,GACAE,GAAAF,GACK,MAAAA,EAAA,GACLrU,SAAAqU,EAAApD,UAAA,OAEAjR,SAAAqU,EAAApD,UAAA,OAGAqD,EAIAE,GAAAC,GAAAH,IAHApb,IAYA,QAAAwb,IAAAzH,GACA,MAAAA,GACAxd,QAAAklB,GAAA,SACAllB,QAAAmlB,GAAA,QACAnlB,QAAAolB,GAAA,QAQA,QAAAJ,IAAAH,GACA,MAAAA,GAKA,KAAAA,EACA,GAIAA,EAAA,IACAA,EAKAA,GAAA,IACAQ,GAAAR,EAAA,KAIAA,EAAA,MACAA,EAIAA,GAAA,MACAS,GAIAT,GAAA,MACAA,EACIU,GAKJV,GAAA,OAAAA,GAAA,OACAA,EAIAA,GAAA,QAAAA,GAAA,OACAA,EAGAS,GAbAA,GAjCAA,GAuDA,QAAAE,IAAArC,GACA,GAAA9d,EAEA,QAAAA,EAAA8d,EAAAM,aAAAgC,MAEA3B,EAAA4B,GACA1B,EAAA3e,GAIA,KAGA,QAAAsgB,IAAAxC,GACA,GAAAyC,GAAAzC,EAAAyC,WAEA,gBAAAA,EAAAhc,OAAA,MACAuZ,EAAAI,KAAA,GAEAO,EAAA+B,GACA7B,EAAA,SAIA,UAAA4B,EAAAhc,OAAA,MACAuZ,EAAAI,KAAA,GAEAO,EAAA+B,GACA7B,EAAA,UAIA,KAiBA,QAAA8B,IAAAC,GACA,gBAAA5C,GAKA,IAJA,GAEA3O,GAFAwR,EAAA,IACAC,GAAA,GAGAA,GACAzR,EAAA2O,EAAAM,aAAAyC,KAAA/C,EAAAM,aAAA0C,KACAhD,EAAAG,YAAAyC,GACAvR,EAEAwR,GADA,MAAAxR,EACA,MACO,QAAAA,EACP,IAEAA,GAGAA,EAAA2O,EAAAM,aAAA2C,IACA5R,EAEAwR,GAAA,aAAAxR,EAAA6R,WAAA,GAAAxmB,SAAA,KAAA8O,OAAA,GAEAsX,GAAA,EAQA,OAHAD,IAAA,IAGA7N,KAAAmO,MAAAN,IAOA,QAAAO,IAAApD,GACA,GAAAzkB,GAAAqB,CAIA,OAFArB,GAAAykB,EAAAI,IAEAJ,EAAAG,YAAA,MACAvjB,EAAAymB,GAAArD,GAEAA,EAAAG,YAAA,MAMAQ,EAAA2C,GACAzC,EAAAjkB,IANAojB,EAAAI,IAAA7kB,EACA,OASAykB,EAAAG,YAAA,MACAvjB,EAAA2mB,GAAAvD,GAEAA,EAAAG,YAAA,MAMAQ,EAAA2C,GACAzC,EAAAjkB,IANAojB,EAAAI,IAAA7kB,EACA,OASA,KASA,QAAAioB,IAAAxD,GACA,GAAAyD,EAEA,QAAAA,EAAAL,GAAApD,IACA0D,GAAA5c,KAAA2c,EAAA5C,GAAA4C,EAAA5C,EAAA,IAAA4C,EAAA5C,EAAAhkB,QAAA,iBAGA4mB,EAAApB,GAAArC,IACAyD,EAAA5C,GAGA4C,EAAAzD,EAAAM,aAAAqD,KACAF,EAGA,KAGA,QAAAG,IAAA5D,GACA,GAAAzkB,GAAAyC,EAAAvE,CAEA8B,GAAAykB,EAAAI,IAGAJ,EAAAK,iBAEA,IAAAwD,GAAA,MAAA7D,EAAA8D,YAAA,MAAA9D,EAAA8D,UAGA,OADA9lB,GAAAwlB,GAAAxD,GACA,OAAAhiB,GACAgiB,EAAAI,IAAA7kB,EACA,OAIAykB,EAAAK,mBAGAwD,GAAA,MAAA7D,EAAA8D,YAAA,MAAA9D,EAAA8D,WAgBA9D,EAAAG,YAAA,MAMAH,EAAAK,kBAGA5mB,EAAAsqB,GAAA/D,GACA,OAAAvmB,GACAumB,EAAAI,IAAA7kB,EACA,OAIAolB,EAAAqD,GACArc,EAAA3J,EACA6iB,EAAApnB,KAjBAumB,EAAAI,IAAA7kB,EACA,OAjBAooB,GAAA7c,KAAA9I,IACAgiB,EAAAplB,MAAA,0CAAAoD,EAAA,eAIA2iB,EAAAqD,GACArc,EAAA3J,EACA6iB,GACAF,EAAAsD,GACAxJ,EAAAzc,MA4BA,QAAAkmB,IAAAlE,GACA,GAAAzkB,GAAAyL,EAAAgB,EAAAmc,CAKA,OAHA5oB,GAAAykB,EAAAI,IAEApY,EAAA4b,GAAA5D,GACA,OAAAhY,EACA,MAGAhB,GAAAgB,GAEAgY,EAAAG,YAAA,MACAgE,EAAAD,GAAAlE,GAEAmE,EAKAnd,EAAAtC,OAAAyf,IAJAnE,EAAAI,IAAA7kB,EACA,OAMAyL,GAGA,QAAAod,IAAApE,GACA,GAAAzkB,GAAA4oB,CAOA,OALA5oB,GAAAykB,EAAAI,IAGAJ,EAAAK,kBAEAL,EAAAG,YAAA,MAKAgE,EAAAD,GAAAlE,GAGAA,EAAAK,kBAEAL,EAAAG,YAAA,MAMAQ,EAAA0D,GACA7tB,EAAA2tB,IANAnE,EAAAI,IAAA7kB,EACA,QAXAykB,EAAAI,IAAA7kB,EACA,MAmBA,QAAA+oB,IAAAtE,GACAA,EAAAK,iBAEA,IAAAkE,GAAAR,GAAA/D,EAEA,WAAAuE,EAAA,WAEA,IAAAC,IAAAD,EAKA,IAFAvE,EAAAK,kBAEAL,EAAAG,YAAA,MACA,GAAA9O,GAAAiT,GAAAtE,EACA,QAAA3O,GAAA2O,EAAAplB,MAAA6pB,IAEAD,EAAAxjB,KAAA5B,MAAAolB,EAAAnT,GAGA,MAAAmT,GAGA,QAAAE,IAAA1E,GACA,GAAAzkB,GAAAopB,CAOA,OALAppB,GAAAykB,EAAAI,IAGAJ,EAAAK,kBAEAL,EAAAG,YAAA,MAKAwE,EAAAL,GAAAtE,GAEAA,EAAAG,YAAA,MAMAQ,EAAAiE,GACApuB,EAAAmuB,IANA3E,EAAAI,IAAA7kB,EACA,QARAykB,EAAAI,IAAA7kB,EACA,MAgBA,QAAAspB,IAAA7E,GACA,MAAAqC,IAAArC,IACAwC,GAAAxC,IACAoD,GAAApD,IACAoE,GAAApE,IACA0E,GAAA1E,IACAS,GAAAT,GAkBA,QAAA8E,IAAA9E,GACA,GAAA+E,GAAA3S,EAAA5Y,EAAAoC,EAAAopB,EAAAC,EAAAC,EAAAC,CAMA,IAJAJ,EAAA/E,EAAAI,IAEA5mB,EAAAwmB,EAAAM,aAAA8E,KAEA,aAAA5rB,GAAA,cAAAA,IACAwmB,EAAAM,aAAA+E,IAAA,CACA,GAAAnf,GAAA4e,GAAA9E,EACA9Z,IAAA8Z,EAAAplB,MAAA,uDAEAolB,EAAAK,kBAEAL,EAAAG,YAAA,MAAAH,EAAAplB,MAAA,+BACApB,GAAA,IAAA0M,EAAA,MAoBA,GAhBAif,GAAA3rB,GAAAwmB,EAAAsF,YAAAtF,EAAAM,aAAAiF,IAEA/rB,IACA4Y,EAAA4N,EAAAM,aAAAkF,KAAA,GACAhsB,GAAA4Y,GAAA4N,EAAAyF,cAAAzF,EAAAM,aAAAoF,KACA1F,EAAAM,aAAAqF,IAEAnsB,GAAA,MAAA4Y,GAGK5Y,GAAA4Y,IACL5Y,EAAA4Y,EACAA,EAAA,KAJAA,EAAA,GACA5Y,EAAA,OAOAA,EACA,WAIA,KAAA4Y,IAAA4N,EAAAyF,cAAAG,GAAA9e,KAAAtN,GAEA,MADAwmB,GAAAI,IAAA2E,EACA,IAIA,KAAA3S,GAAAyT,GAAA/e,KAAAtN,GAIA,MAHAoC,GAAAiqB,GAAArf,KAAAhN,GAAA,GACAwmB,EAAAI,IAAA2E,EAAAnpB,EAAA8B,QAGAijB,EAAAmF,GACAjF,GAAAsE,EAAA,UAAAvpB;CAOA,IAHAqpB,GAAAE,EAAA,MAAA/S,GAAA,IAAA1U,OAAAlE,EAAAkE,OACAsnB,GAAA5S,GAAA,IAAAnM,EAAAzM,GAEAwmB,EAAAG,YAAA,KAMA,GADA+E,EAAAF,EAAAe,YAAA,KACAb,KAAA,SAAA1rB,IAAAkE,OAAA,IACA,GAAAsoB,GAAAhB,EAAAtnB,MACAsnB,KAAAve,OAAA,EAAAye,GACAlF,EAAAI,IAAA2E,GAAAE,GAAAe,EAAAd,QAEAlF,GAAAI,KAAA,CAIA,QACAO,EAAAsD,GACAxJ,GAAA0K,EAAA,UAAAH,EAAAnoB,QAAA,gBAAAA,QAAA,eAIA,QAAAopB,IAAAjG,GACA,IAAAA,EAAAG,YAAA,gBAEAH,GAAAK,iBAEA,IAAAkE,GAAAR,GAAA/D,EAQA,OANAuE,IAAAvE,EAAAplB,MAAA6pB,IAEAzE,EAAAK,kBAEAL,EAAAG,YAAA,MAAAH,EAAAplB,MAAAsrB,KAGAvF,EAAAwF,GACA9kB,EAAAkjB,GAIA,QAAA6B,IAAApG,GACA,MAAA6E,IAAA7E,IACA8E,GAAA9E,IACAiG,GAAAjG,GAGA,QAAAqG,IAAArG,GAOA,GALAA,EAAAsG,kBACAtG,EAAAK,kBAIAL,EAAAG,YAAA,MACAH,EAAAK,iBAEA,IAAA7mB,GAAAwmB,EAAAM,aAAAqD,GACA,IAAAnqB,EACA,OACAmnB,EAAA4F,GACA9L,EAAAjhB,EAIAwmB,GAAAplB,MAAA,4BAIA,GAAAolB,EAAAG,YAAA,MACAH,EAAAK,iBAEA,IAAAkE,GAAAR,GAAA/D,EAOA,OANAuE,IAAAvE,EAAAplB,MAAA6pB,IAEAzE,EAAAK,kBAEAL,EAAAG,YAAA,MAAAH,EAAAplB,MAAA,iBAGA+lB,EAAA4F,GACAllB,EAAAkjB,GAIA,YAGA,QAAAiC,IAAAxG,GACA,GAAAyG,GAAAL,GAAApG,EAEA,KAAAyG,EAAA,WAEA,MAAAA,GAAA,CACA,GAAAC,GAAAL,GAAArG,EACA,IAAA0G,EACAD,GACA9F,EAAAgG,GACAtlB,EAAAolB,EACAzjB,EAAA0jB,OAIA,KAAA1G,EAAAG,YAAA,KAsBA,KArBAH,GAAAK,iBACA,IAAA9kB,GAAAykB,EAAAsF,UACAtF,GAAAsF,YAAA,CACA,IAAAX,GAAAL,GAAAtE,EACAA,GAAAsF,WAAA/pB,EAEAykB,EAAAK,kBAEAL,EAAAG,YAAA,MACAH,EAAAplB,MAAAsrB,IAGAO,GACA9F,EAAAiG,GACAvlB,EAAAolB,GAGA9B,IAAA8B,EAAAI,EAAAlC,IAQA,MAAA8B,GA+HA,QAAAK,IAAA9G,GACA,GAAAzkB,GAAAkrB,EAAAM,EAAAC,CAGA,QADAP,EAAAQ,GAAAjH,KAKAzkB,EAAAykB,EAAAI,IAEAJ,EAAAK,kBAEAL,EAAAG,YAAA,MAKAH,EAAAK,kBAEA0G,EAAAhD,GAAA/D,GACA+G,GACA/G,EAAAplB,MAAA6pB,IAGAzE,EAAAK,kBAEAL,EAAAG,YAAA,MACAH,EAAAplB,MAAA,gBAGAolB,EAAAK,kBAEA2G,EAAAjD,GAAA/D,GACAgH,GACAhH,EAAAplB,MAAA6pB,KAIA9D,EAAAuG,GACAL,GAAAJ,EAAAM,EAAAC,MA1BAhH,EAAAI,IAAA7kB,EACAkrB,IATA,KAsCA,QAAA1C,IAAA/D,GAOA,MAAA8G,IAAA9G,GAGA,QAAAmH,IAAAV,GAaA,QAAAW,GAAA7C,GAEA,OADA8C,MACAnmB,EAAAomB,EAAA,EAA4BpmB,GAAA,EAAQA,IACpCmmB,EAAArmB,KAAA,UAAAE,EAEA,OAAAmmB,GAAA3pB,OAAA,mBAAuC2pB,EAAAve,KAAA,gBAA6Byb,EAAA,SAAsBA,EAG1F,QAAAtP,GAAA9a,GACA,OAAAA,EAAAwmB,GACA,IAAA+B,IACA,IAAAoD,IACA,IAAAvD,IACA,IAAA3B,IACA,MAAAzmB,GAAA0mB,CAEA,KAAAyC,IACA,MAAAtO,MAAAC,UAAAsS,OAAAptB,EAAA0mB,GAEA,KAAA+D,IACA,WAAAzqB,EAAA3D,EAAA2D,EAAA3D,EAAAqR,IAAAoN,GAAAnM,KAAA,YAEA,KAAAub,IACA,WAAelqB,EAAA3D,EAAA2D,EAAA3D,EAAAqR,IAAAoN,GAAAnM,KAAA,YAEf,KAAAkb,IACA,MAAA7pB,GAAAwN,EAAA,IAAAsN,EAAA9a,EAAA0mB,EAEA,KAAA2G,IACA,kBAAArtB,EAAA6C,EAAA,UAAA7C,EAAA6C,GAAAiY,EAAA9a,EAAA0sB,EAEA,KAAAY,IACA,MAAAxS,GAAA9a,EAAA0sB,EAAA,YAAA1sB,EAAA6C,EAAAyJ,OAAA,SAAAtM,EAAA6C,EAAA,IAAA7C,EAAA6C,GAAAiY,EAAA9a,EAAA0sB,EAAA,GAEA,KAAAD,IACA,GAAAzsB,EAAAgrB,OAAA,CACA,GAAA9uB,GAAAixB,GACA,kBAAAjxB,EAAA,MAAA4e,EAAA9a,EAAAkH,GAAA,kBAAAhL,EAAA,gBAAA8D,EAAA0sB,EAAA1sB,EAAA0sB,EAAAhf,IAAA,SAAAzJ,GAA+I,MAAAA,GAAAqc,GAAA,IAAArc,EAAAqc,EAAA1Z,QAAA,OAAAkU,EAAA7W,GAAA,IAAA6W,EAAA7W,GAAA,MAAwF0K,KAAA,eAEvO,MAAAmM,GAAA9a,EAAAkH,GAAA,KAAAlH,EAAA0sB,EAAA1sB,EAAA0sB,EAAAhf,IAAAoN,GAAAnM,KAAA,YAGA,KAAAqd,IACA,UAAAlR,EAAA9a,EAAAkH,GAAA,GAEA,KAAAslB,IACA,MAAA1R,GAAA9a,EAAAkH,GAAA4T,EAAA9a,EAAA6I,EAEA,KAAAujB,IACA,MAAApsB,GAAAsgB,EAAA,IAAAtgB,EAAAsgB,EAAA,IAAAxF,EAAA9a,EAAAkH,GAAA,GAEA,KAAA6lB,IACA,MAAAjS,GAAA9a,EAAA0sB,EAAA,QAAA5R,EAAA9a,EAAA0sB,EAAA,QAAA5R,EAAA9a,EAAA0sB,EAAA,GAEA,KAAA5C,IACA,UAAAyD,EAAA3mB,QAAA5G,EAAAsgB,EAEA,SACA,SAAAxb,OAAA,8BAtEA,GAAAyoB,GAAAC,EAAAL,EAAA,CAOA,OALAM,IAAAnB,EAAAiB,MACAC,EAAA1S,EAAAwR,GAEAiB,IAAA7f,IAAA,SAAA7E,GAAoC,WAAAA,EAAAjC,QAAA,OAAAiC,EAAAyD,OAAA,GAAAzD,KAGpCA,EAAA0kB,EACA1qB,EAAAoqB,EAAAO,IAmEA,QAAAC,IAAAztB,EAAAutB,GACA,GAAAxmB,GAAAsD,CASA,IAPArK,EAAAwmB,IAAAsD,IACAyD,EAAA3mB,QAAA5G,EAAAsgB,MAAA,GACAiN,EAAAvQ,QAAAhd,EAAAsgB,GAIAjW,EAAArK,EAAA0sB,GAAA1sB,EAAA3D,EAEA,GAAAkI,EAAA8F,GACAojB,GAAApjB,EAAAkjB,OAGA,KADAxmB,EAAAsD,EAAA9G,OACAwD,KACAsD,EAAAtD,GAAAuZ,GAAA,IAAAjW,EAAAtD,GAAAuZ,EAAA1Z,QAAA,SACA5G,EAAAgrB,QAAA,GAEAyC,GAAApjB,EAAAtD,GAAAwmB,EAKAvtB,GAAAkH,GACAumB,GAAAztB,EAAAkH,EAAAqmB,GAGAvtB,EAAA6I,GACA4kB,GAAAztB,EAAA6I,EAAA0kB,GAGAvtB,EAAA0mB,GACA+G,GAAAztB,EAAA0mB,EAAA6G,GAqIA,QAAAG,IAAA7H,GACAA,EAAAK,iBAEA,IAAAriB,GAAAwlB,GAAAxD,EAEA,KAAAhiB,EAAA,WAEA,IAAAgK,IAAehK,MAGf,IADAgiB,EAAAK,mBACAL,EAAAG,YAAA,KACA,WAEAH,GAAAK,iBAEA,IAAAyH,GAAA9H,EAAA+H,MAEA,OAAAD,IAEA9f,EAAAvO,MAAAquB,EAAAjH,EACA7Y,GAHA,KAMA,QAAAggB,IAAA3N,EAAAzD,GACA,GAAAoJ,GAAA,GAAAiI,IAAA5N,GAAsCzD,UACtC,OAAAoJ,GAAA9d,OAWA,QAAAgmB,IAAAC,EAAAC,EAAA/nB,GACA,GAAA6B,GACAoE,EACAmd,EACA4E,EACAC,EACAC,EACAC,CAEA,oBAAAL,GAAA,CACA,GAAA/H,GAAAgI,EAAAhI,IAAA+H,EAAAzqB,MACA,IAAA2C,IAAAooB,IAAApoB,IAAAqoB,GAAA,CACA,GAAA1I,GAAA,GAAA2I,IAAA,IAAAR,EAAA,IACA,QAAa/pB,EAAA+oB,GAAAnH,EAAA9d,OAAA,KAQb,GALA7B,IAAAuoB,KAAAtiB,EAAAuiB,GAAAriB,KAAA2hB,MACA1oB,EAAA2oB,EAAAU,kBAAA1I,EAAA,+HACA+H,EAAA,SAAA7hB,EAAA,GAAA6hB,EAAA1hB,OAAAH,EAAA,GAAA5I,SAGA2C,IAAAuoB,KAAAT,EAAApnB,QAAA,MACA,GAAAgoB,GAAA,GAAAJ,IAAA,IAAAR,EAAA,IACA,IAAAY,EAAA7mB,QAAA6mB,EAAA7mB,OAAA,GAKA,MAJA6mB,GAAAtG,YAAA/kB,SACA0qB,EAAAhI,MAAA+H,EAAAzqB,OAAAqrB,EAAAtG,YAAA/kB,OACA0qB,EAAAxtB,MAAA,yCAAAmuB,EAAAtG,YAAA,OAEcphB,EAAA8lB,GAAA4B,EAAA7mB,OAAA,MAGdimB,EAAApnB,QAAA,KAAAonB,EAAApnB,QAAA,QAAAonB,EAAApnB,QAAA,QACAqnB,EAAAhI,MACAgI,EAAAxtB,MAAA,sCAAAutB,EAAA,MAKA,GAAAA,EAAApnB,QAAA,UACA,MAAAonB,GAAA/N,MAGA+N,OAQA,GALAjmB,KAEAomB,KACAC,KAEAJ,EAAA,CACA,KAAAA,EAAAzqB,QAGA,GAFA+lB,EAAA0E,EAAAppB,QAEA,gBAAA0kB,GAAA,CAGA,GAFA4E,EAAA5E,EAAA1iB,QAAA,KAEAsnB,KAAA,EAEO,CAEPA,GAEAC,EAAAtnB,KAAAyiB,EAAAhd,OAAA,EAAA4hB,IAKA5E,EAAA/lB,OAAA2qB,EAAA,IACAE,EAAA,GAAA9E,EAAApF,UAAAgK,EAAA,GAGA,OAdAC,EAAAtnB,KAAAyiB,OAmBA6E,GAAAtnB,KAAAyiB,EAIA8E,KAAA7jB,OAAAyjB,GA2BA,MAxBAG,GAAA5qB,OAEI6qB,EAAA7qB,QAAA,gBAAA4qB,IACJpmB,GAEAuY,EAAA,IAAA6N,EAAA5qB,QAAA,gBAAA4qB,GAAA,GAAAA,EAAA,GAAAA,GAGA,IAAAC,EAAA7qB,QAAA,gBAAA6qB,GAAA,IACAC,EAAAR,GAAA,IAAAO,EAAA,QACArmB,EAAA9D,EAAAoqB,IAAA/uB,OAAA8uB,EAAA,GAAAnO,SAIAlY,EAAA6F,EAAAwgB,GAGArmB,EAAAomB,EAhBApmB,EAAA,GAmBAqmB,EAAA7qB,QAAA2C,GACAZ,EAAA2oB,EAAAU,kBAAAV,EAAAhI,IAAA,0IAGAle,EAkBA,QAAA8mB,IAAAhJ,GACA,GAAAiJ,GAAAzvB,EAAAC,EAAAyH,EAAAgoB,EAAAC,CAKA,IAHAnJ,EAAAK,kBAEA7mB,EAAAwmB,EAAAM,aAAA8I,KACA5vB,EACA,WAKA,KADA0vB,EAAA1vB,EAAAkE,OACAwD,EAAA,EAAeA,EAAA8e,EAAAqJ,KAAA3rB,OAAwBwD,MACvCioB,EAAA3vB,EAAAuH,QAAAif,EAAAqJ,KAAAnoB,GAAAooB,QACAH,EAAAD,MAAAC,EAGA,OAAAD,GAAA1vB,EAAAkE,QACAsiB,EAAAI,KAAA5mB,EAAAkE,OAAAwrB,EACA1vB,IAAAiN,OAAA,EAAAyiB,IACYzO,EAAAjhB,KAGZyvB,GAAWxO,EAAAjhB,GAEXC,EAAA8vB,GAAAvJ,GACA,MAAAvmB,IACAwvB,EAAAO,EAAA/vB,GAGAwvB,GAGA,QAAAM,IAAAvJ,GACA,GAAAzkB,GAAAkuB,EAAAC,EAAAjwB,CAWA,OATA8B,GAAAykB,EAAAI,IAGA,WAAAtZ,KAAAkZ,EAAA8D,aACA9D,EAAAplB,MAAA,wCAGAolB,EAAAK,kBAEAL,EAAAG,YAAA,MAKAH,EAAAK,kBAEAoJ,EAAAzJ,EAAAI,IACAsJ,EAAA1J,EAAA2J,aAEAlwB,EAAAmwB,GAAA5J,EAAA,MACA4J,GAAA5J,EAAA,MACA6J,GAAA7J,GAEA,OAAAvmB,GACAumB,EAAAplB,MAAA,kCAGAolB,EAAA2J,eAAAD,IACA1J,EAAAI,IAAAqJ,EACAzJ,EAAAplB,MAAA,yFAGAnB,EAAAiE,OAIA,IAAAjE,EAAAiE,QAAA,gBAAAjE,GAAA,GACA6nB,GAAA7nB,EAAA,IAGAA,EAPA,KAvBAumB,EAAAI,IAAA7kB,EACA,MAgCA,QAAAuuB,IAAA9J,GACA,GAAAzkB,GAAAwuB,EAAA9I,EAAAC,EAAApgB,CAMA,OAJAvF,GAAAykB,EAAAI,KAEA2J,EAAA/J,EAAAM,aAAA0J,MAMA/I,EAAA8I,EACA7I,EAAAlB,EAAAqJ,KAAAxhB,IAAA,SAAA8Y,GAA8C,MAAAA,GAAA2I,QAE9CxoB,EAAAkgB,GAAAC,EAAAC,OAAA,IACA6I,IAAAtjB,OAAA,EAAA3F,GACAkf,EAAAI,IAAA7kB,EAAAwuB,EAAArsB,QAGAqsB,GAXA,KAcA,QAAAF,IAAA7J,GACA,GAAAmI,GAAA1E,CAOA,KALAzD,EAAAiK,aAAA,EAEA9B,KAEA1E,EAAAyG,GAAAlK,IAAA8J,GAAA9J,GACAyD,GACA0E,EAAAnnB,KAAAyiB,GACAA,EAAAyG,GAAAlK,IAAA8J,GAAA9J,EAGA,OAAAmI,GAAAzqB,QAIAsiB,EAAAiK,aAAA,EACA9B,GAJA,KAOA,QAAAyB,IAAA5J,EAAAmK,GACA,GAAA5uB,GAAA4sB,EAAA1E,CAIA,IAFAloB,EAAAykB,EAAAI,KAEAJ,EAAAG,YAAAgK,GACA,WAQA,KALAnK,EAAAiK,YAAAE,EAEAhC,KAEA1E,EAAAyG,GAAAlK,IAAAoK,GAAApK,EAAAmK,GACA,OAAA1G,GACA0E,EAAAnnB,KAAAyiB,GACAA,EAAAyG,GAAAlK,IAAAoK,GAAApK,EAAAmK,EAGA,OAAAnK,GAAAG,YAAAgK,IAKAnK,EAAAiK,aAAA,EAEA9B,IANAnI,EAAAI,IAAA7kB,EACA,MAQA,QAAA6uB,IAAApK,EAAAmK,GACA,GAAAlJ,GAAAjB,EAAAyC,YAEAvB,EAAAlB,EAAAqJ,KAAAxhB,IAAA,SAAA8Y,GAAkD,MAAAA,GAAA2I,MAClDpI,GAAAlgB,KAAAmpB,EAEA,IAAArpB,GAAAkgB,GAAAC,EAAAC,EAMA,OAJApgB,MAAA,GACAkf,EAAAplB,MAAA,oDAGAkG,GAIAkf,EAAAI,KAAAtf,EACAmgB,EAAAxa,OAAA,EAAA3F,IAJA,KAOA,QAAAupB,IAAArK,GACA,GAAA1Z,GACAgkB,EACAC,CAIA,IAFAD,EAAAtB,GAAAhJ,IAEAsK,EAAA,WAGA,IAAAC,EAAAC,GAAAF,EAAA7P,GACA6P,EAAA3J,EAAA4J,EAAA5J,EACA4J,EAAA1J,IAAAyJ,EAAAzJ,EAAA0J,EAAA1J,SACAyJ,GAAA7P,EAEA8P,EAAA5J,IAAA+H,IAAA6B,EAAA5J,IAAA8H,KAAA6B,EAAAd,EAAAtB,GAAAoC,EAAAd,EAAAxJ,IAEAuK,EAAA5J,IAAA+H,GACAhpB,EAAA,WAAA6qB,EAAA1J,EAAA,qBAAA0J,EAAA1J,EAAA,qPACM0J,EAAA5J,IAAA8H,IACN/oB,EAAA,wNAKA,IAAA4G,EAAAmkB,GAAAjkB,KAAA8jB,EAAA7P,SACA6P,GAAA7P,EACA6P,EAAA3J,EAAA8H,GACA6B,EAAAd,EAAAtB,GAAAoC,EAAAd,EAAAxJ,EAAAyI,IACA,gBAAA6B,GAAAd,EAAAc,EAAAd,EAAA/O,EAAAnU,EAAA,GACAgkB,EAAAd,EAAAljB,EAAA,OAIA,IAAAA,EAAAokB,GAAAlkB,KAAA8jB,EAAA7P,SACA6P,GAAA7P,EACA6P,EAAA3J,EAAA+H,GACA4B,EAAAd,EAAAtB,GAAAoC,EAAAd,EAAAxJ,EAAA0I,IACA,gBAAA4B,GAAAd,EAAAc,EAAAd,EAAA/O,EAAAnU,EAAA,GACAgkB,EAAAd,EAAAljB,EAAA,GACAgkB,EAAAzJ,EAAA,WAAAva,EAAA,eAAAA,EAAA,iBAIA,IAAAA,EAAAqkB,GAAAnkB,KAAA8jB,EAAA7P,GACA6P,EAAA7P,EAAAnU,EAAA,GACAgkB,EAAA3J,EAAAiI,GACA0B,EAAAd,EAAAtB,GAAAoC,EAAAd,EAAAxJ,EAAA4I,IAEAgC,GAAA9jB,KAAAwjB,EAAAd,EAAA/O,GAAA6P,EAAAd,KACAxJ,EAAAI,MAAAkK,EAAAd,EAAA/O,GAAA6P,EAAAd,GAAA9rB,OACAsiB,EAAAplB,MAAA,qIAIA,CACA,GAAAolB,EAAA6K,yBAAAC,GAAAhkB,KAAAwjB,EAAA7P,GACA,OAAcsQ,SAAA,EAEdT,GAAAd,EAAAc,EAAAd,IAAA,KAAAc,EAAAd,EAAA,MACAc,EAAA3J,EAAAqK,GAIA,MAAAV,GAKA,QAAAJ,IAAAlK,GACA,GAAAiL,GAAA/pB,CAIA,IAAA8e,EAAA9f,YAAA8f,EAAAkL,WAAA,EACA,WAGA,KAAAhqB,EAAA,EAAeA,EAAA8e,EAAAqJ,KAAA3rB,OAAwBwD,GAAA,EACvC,GAAA+pB,EAAAE,GAAAnL,IAAAqJ,KAAAnoB,IACA,MAAA+pB,EAIA,OAAAjL,GAAAoL,QAAApL,EAAAiK,cACAgB,EAAAZ,GAAArK,KAEAA,EAAAK,kBACA4K,GAJA,OASA,QAAAE,IAAAnL,EAAAqL,GACA,GAAA9vB,GAAA0vB,EAAAK,EAAApqB,CAIA,IAFA3F,EAAAykB,EAAAI,IAEAJ,EAAAG,YAAA,KAAAkL,EAAA/B,OACA,OAAA/tB,GAAA,OAAAykB,EAAA3F,IAAA9e,EAAA,GACA,MAAA8vB,GAAA/B,SAEI,KAAAtJ,EAAAG,YAAAkL,EAAA/B,MACJ,WAIA,IAAA2B,EAAAlL,GAAAC,GAEA,MAAAA,GAAAG,YAAAkL,EAAAE,QAKAF,EAAA/B,KAAA2B,EAAA,GACAI,EAAAE,MAAAN,EAAA,GACAjL,EAAAwL,mBAEAC,IARA,IAcA,IAHAzL,EAAAK,kBAGAL,EAAAG,YAAA,MACAH,EAAAI,KAAA,CACA,IAAAsL,GAAA1L,EAAAI,GACA,IAAAK,GAAAT,GASAA,EAAAI,IAAAsL,MATA,CAEA,GADA1L,EAAAI,IAAAsL,EAAAL,EAAAE,MAAA,OACAvL,EAAAiK,YAEA,MADAjK,GAAAI,IAAA7kB,EACA,IAEAykB,GAAAplB,MAAA,kDAOA,IAAAsG,EAAA,EAAeA,EAAAmqB,EAAAM,QAAAjuB,OAAwBwD,GAAA,EAGvC,GAFAoqB,EAAAD,EAAAM,QAAAzqB,GAEA+pB,EAAAK,EAAAtL,EAAAqL,GASA,MARAA,GAAAO,WACAX,EAAAjuB,GAAA,GAGAgjB,EAAA6L,uBACAZ,EAAAv0B,EAAAspB,EAAA8L,WAAAvwB,IAGA0vB,CAKA,OADAjL,GAAAI,IAAA7kB,EACA,KAGA,QAAAwwB,IAAAtF,EAAAwE,GACA,GAAAe,EAEA,IAAAvF,EAAA,CACA,KAAAA,EAAA9F,IAAAwF,IAAAM,EAAAplB,GACAolB,IAAAplB,CAaA,OAVAolB,GAAA9F,IAAAsD,GACAgH,EAAAjoB,EAAAyjB,EAAAhM,GAEAuR,EAAAC,GAAAxF,IACAwE,EAAAiB,GAAAF,EAEAf,EAAA5pB,EAAA8lB,GAAAV,GAIAwE,GAKA,QAAAgB,IAAAxF,GAGA,IAFA,GAAAC,GAAAyF,KAEA1F,EAAA9F,IAAAgG,IAAAF,EAAAzjB,EAAA2d,IAAA4F,IACAG,EAAAD,EAAAzjB,EAEA0jB,EAAArlB,EACAqlB,EAAArlB,EAAAsf,IAAAsD,GACAkI,EAAAhV,QAAAuP,EAAArlB,GAEA8qB,EAAAhV,QAAAgQ,GAAAT,EAAArlB,IAGA8qB,EAAAhV,QAAAuP,EAAAjM,GAGAgM,IAAAplB,CAGA,OAAAolB,GAAA9F,IAAAsD,GACA,MAIAjhB,EAAAyjB,EAAAhM,EACAjkB,EAAA21B,GAIA,QAAAC,IAAApM,EAAAqL,GACA,GAAAgB,GAAA5F,EAAA1C,GAAA/D,EAEA,OAAAyG,IAIAzG,EAAAG,YAAAkL,EAAAE,QACAvL,EAAAplB,MAAA,+BAAAywB,EAAA,WAGAgB,GAAa1L,EAAA2L,IACbP,GAAAtF,EAAA4F,GAEAA,GAVA,KAaA,QAAAE,IAAAvM,EAAAqL,GACA,GAAA5E,GAAA4F,CAEA,OAAArM,GAAAG,YAAA,MAIAH,EAAAK,mBAEAoG,EAAA1C,GAAA/D,KAMAA,EAAAG,YAAAkL,EAAAE,QACAvL,EAAAplB,MAAA,+BAAAywB,EAAA,WAGAgB,GAAa1L,EAAA2L,IACbP,GAAAtF,EAAA4F,GAEAA,GAVA,MARA,KAwBA,QAAAG,IAAAxM,GACA,GAAAyM,GAAA5d,KAAAtT,EAAAykB,EAAAI,GAMA,IAJAJ,EAAAK,kBAEAoM,EAAAC,GAAA1M,GAEA,CAMA,IALAyM,EAAAprB,EAAA0qB,GAAAU,EAAAprB,MACAwN,EAAA7N,KAAAyrB,GAEAzM,EAAAK,kBAEAL,EAAAG,YAAA,MACAsM,EAAAC,GAAA1M,GAEAyM,GACAzM,EAAAplB,MAAA,2BAGA6xB,EAAAprB,EAAA0qB,GAAAU,EAAAprB,MACAwN,EAAA7N,KAAAyrB,GAEAzM,EAAAK,iBAGA,OAAAxR,GAIA,MADAmR,GAAAI,IAAA7kB,EACA,KAGA,QAAAmxB,IAAA1M,GACA,GAAAuE,GAAAkI,EAAAlxB,EAAAykB,EAAAI,GAMA,OAJAJ,GAAAK,mBAEAkE,EAAAR,GAAA/D,QAOAA,EAAAK,kBAEAL,EAAAM,aAAAqM,KAKA3M,EAAAK,kBAEAoM,EAAAzM,EAAAM,aAAAsM,IAEAH,GACAzM,EAAAplB,MAAA,iCAGW6f,EAAAgS,EAAAprB,EAAAkjB,KAZXvE,EAAAI,IAAA7kB,EACA,QARAykB,EAAAI,IAAA7kB,EACA,MAqBA,QAAAsxB,IAAA7M,EAAAqL,GACA,IAAArL,EAAAG,YAAA,gBAEAH,GAAAK,kBAMAL,EAAAyF,aAAAzF,EAAAsG,kBAAA,CACA,IAAAG,GAAA1C,GAAA/D,EAGA,IAFAA,EAAAyF,aAAAzF,EAAAsG,kBAAA,GAEAG,EAAA,WAEA,IAAAqG,IAAkBnM,EAAAoM,GAClBhB,IAAAtF,EAAAqG,GAEA9M,EAAAK,iBAIA,IAAAxR,GAAA2d,GAAAxM,EACA,IAAAnR,EACAie,GACAnM,EAAAqM,GACAC,EAAApe,EACA2a,GAAAsD,QAMA,CACA,GAAAjmB,GAAAkd,GAAA/D,EACAnZ,KACAimB,GACAnM,EAAAuM,GACAzS,EAAA0S,GACA3D,GAAAsD,IAGAf,GAAAllB,EAAAimB,IAUA,MANA9M,GAAAK,kBAEAL,EAAAG,YAAAkL,EAAAE,QACAvL,EAAAplB,MAAA,+BAAAywB,EAAA,WAGAyB,EAGA,QAAAM,IAAApN,EAAAqL,GACA,GAAAvqB,EAEA,OAAAkf,GAAAG,YAAA,MAIArf,EAAAkf,EAAAyC,YAAA1hB,QAAAsqB,EAAAE,OAEAzqB,KAAA,GACAkf,EAAAI,KAAAtf,EAAAuqB,EAAAE,MAAA7tB,QACYijB,EAAA0M,KAFZ,QALA,KAWA,QAAAC,IAAAtN,EAAAuN,GACA,GAAAhyB,GAAAkrB,EAAAvlB,CAKA,IAHA3F,EAAAykB,EAAAI,IACAqG,EAAA1C,GAAA/D,IAEAyG,EAAA,CAEA,GAAAvgB,GAAA8Z,EAAAM,aAAA,SACA,OAAApa,IAEAya,EAAAsD,GACAxJ,EAAAvU,GAIA,KAGA,IAAAhF,EAAA,EAAeA,EAAAqsB,EAAA7vB,OAA8BwD,GAAA,EAC7C,GAAA8e,EAAAyC,YAAAhc,OAAA,EAAA8mB,EAAArsB,GAAAxD,UAAA6vB,EAAArsB,GACA,MAAAulB,EAKA,OADAzG,GAAAI,IAAA7kB,EACAupB,GAAA9E,GAGA,QAAAwN,IAAAxN,EAAAqL,GACA,GAAA9vB,GAAAkrB,EAAA9d,EAAA8kB,CAEAlyB,GAAAykB,EAAAI,GAGA,KACAqG,EAAA6G,GAAAtN,GAAAqL,EAAAE,QACI,MAAA5oB,GACJ8qB,EAAA9qB,EAGA,IAAA8jB,EAAA,CACA,SAAAzG,EAAA3F,IAAApd,OAAA1B,GAGA,MADAykB,GAAAI,IAAA7kB,EACA,IAGA,IAAAkyB,EACA,KAAAA,GAIA,IAAAzN,EAAAG,YAAAkL,EAAAE,SACAvL,EAAAplB,MAAA,+BAAAywB,EAAA,4BAEA5E,GAAA,CAEA,SAAAzG,EAAA8D,WACA,WAGA9D,GAAAplB,MAAA,0CAOA,MAHA+N,IAAmBgY,EAAA+M,IACnB3B,GAAAtF,EAAA9d,GAEAA,EAKA,QAAAglB,IAAA3N,EAAAqL,GACA,IAAArL,EAAAM,aAAAsN,IAAA,WAEA,IAAAp0B,GAAAwmB,EAAAM,aAAA,8BAEAN,GAAAK,kBAEAL,EAAAG,YAAAkL,EAAAE,QACAvL,EAAAplB,MAAA,8BAGA,IAAAizB,IAAkBlN,EAAAmN,GAGlB,OAFAt0B,KAAAq0B,EAAApT,EAAAjhB,GAEAq0B,EAGA,QAAAE,IAAA/N,EAAAqL,GACA,GAAA9vB,GAAAknB,EAAA3hB,EAAAof,CAIA,OAFA3kB,GAAAykB,EAAAI,IAEAJ,EAAAG,YAAAkL,EAAA/B,OAIAtJ,EAAAK,kBAEAL,EAAAG,YAAA,MAKAH,EAAAK,kBAEAoC,EAAAzC,EAAAyC,YACA3hB,EAAA2hB,EAAA1hB,QAAAsqB,EAAAE,OAEAzqB,KAAA,GACAof,GACAS,EAAAqN,GACAhrB,EAAAyf,EAAAhc,OAAA,EAAA3F,GAAA4Q,MAAA,SAGAsO,EAAAI,KAAAtf,EAEAkf,EAAAG,YAAAkL,EAAAE,QACAvL,EAAAplB,MAAA,+BAAAywB,EAAA,WAGAnL,IAGAF,EAAAI,IAAA7kB,EACA,QAzBAykB,EAAAI,IAAA7kB,EACA,OAPA,KAoCA,QAAA0yB,IAAAjO,EAAAqL,GACA,GAAA9vB,GAAAykB,EAAAI,GAEA,OAAAJ,GAAAG,YAAAkL,EAAA/B,MAIAtJ,EAAAM,aAAA4N,KAKAlO,EAAAG,YAAAkL,EAAAE,QACAvL,EAAAplB,MAAA,+BAAAywB,EAAA,YAIA1K,EAAAwN,MATAnO,EAAAI,IAAA7kB,EACA,MALA,KAmBA,QAAA6yB,IAAApO,EAAAqL,GACA,GAAA9vB,GAAAykB,EAAAI,GAEA,KAAAJ,EAAAG,YAAAkL,EAAA/B,MACA,WAGA,KAAAtJ,EAAAM,aAAA+N,IAEA,MADArO,GAAAI,IAAA7kB,EACA,IAGA,IAAAkrB,GAAA1C,GAAA/D,EAMA,OAJAA,GAAAG,YAAAkL,EAAAE,QACAvL,EAAAplB,MAAA,+BAAAywB,EAAA,YAIA1K,EAAA2N,GACAjtB,EAAAolB,GAcA,QAAA8H,IAAAvO,EAAAqL,GACA,GAAA9vB,GAAAkrB,EAAA+H,EAAAvV,EAAAxU,EAAAgqB,EAAAC,EAAAC,EAAAC,EAAAC,EAAA3tB,EAAA4tB,EAAAC,GAAA,CAIA,IAFAxzB,EAAAykB,EAAAI,IAEAJ,EAAAG,YAAA,KACAqO,GAAe7N,EAAAuM,GAAA1D,KAAA/O,EAAAuU,QACX,KAAAhP,EAAAG,YAAA,KAaJ,WAZAqO,IAAe7N,EAAAuM,GAAA1D,MAEfxJ,EAAAG,YAAA,aACAH,EAAAI,IAAA7kB,EAAAykB,EAAAiP,mBAAA,GAAAvxB,OACAsiB,EAAAplB,MAAA,wGAGA8zB,EAAA1O,EAAAM,aAAA4O,OACAJ,EAAAJ,EACAF,EAAA/T,EAAA0U,GAAAT,IAQA,GAFA1O,EAAAK,kBAEA,SAAAqO,EAAA,CACA,GAAA7f,GAAA2d,GAAAxM,EACAnR,KACAkgB,GAAA,EACAP,EAAAvB,EAAApe,EACA2f,EAAA7N,EAAAqM,QAEI,aAAA0B,EAAA,CACJ,GAAAjC,GAAAC,GAAA1M,EACAyM,KACA+B,EAAAvB,IAAoBxS,EAAAgS,EAAAhS,EAAApZ,GAAiB2B,EAAA,OACrCyjB,EAAAgG,EAAAprB,GAIA,IAAA0tB,IACAtI,MAAA1C,GAAA/D,IAEAyG,GACAzG,EAAAplB,MAAA,uBAIAsG,EAAA8e,EAAAM,aAAA8O,KAAA,CACA,GAAAC,IAEAA,EAAArP,EAAAM,aAAAgP,KACAd,EAAAttB,IAAA,IAAAmuB,EAEAb,EAAAttB,IAKA8e,EAAAK,kBAEAL,EAAAG,YAAAkL,EAAAE,QACAvL,EAAAplB,MAAA,+BAAAywB,EAAA,WAGArL,EAAA2J,cAAA,EACAllB,EAAA+pB,EAAAhF,EAEAoF,IAEA,IAAAxO,EACA,GAEA,IADAA,EAAAJ,EAAAI,IACAnH,EAAA8U,GAAA/N,EAAAqL,GACAyD,GAAA7V,EAAAjW,IAAA8rB,IACA9O,EAAAI,MACAJ,EAAAplB,MAAA,YAAAywB,EAAA,SAAAyD,EAAAzD,EAAA,QAGArL,EAAA2J,cAAA,EACAkF,GAAA,MAGA,KAAAE,IAAA9V,EAAAmV,GAAApO,EAAAqL,IAAA,CACAmD,EAAA/T,IAAAuU,IACAhP,EAAAplB,MAAA,uCAGA6zB,GACAzO,EAAAplB,MAAA,wCAGA+zB,IACAA,KAGA,IAAA1D,IACAtK,EAAAuM,GACAzS,EAAA8U,GACA/F,EAAA/kB,KAEAsnB,IAAA9S,EAAA5X,EAAA4pB,GAEA0D,EAAA3tB,KAAAiqB,OAGA,KAAA8D,IAAA9V,EAAAgV,GAAAjO,EAAAqL,IACAmD,EAAA/T,IAAAuU,IACAhP,EAAAplB,MAAA,uCAGA6zB,GACAzO,EAAAplB,MAAA,iEAGA6zB,GAAA,EAGAE,IACAA,MAGAA,EAAA3tB,MACA2f,EAAAuM,GACAzS,EAAAuU,GACAxF,EAAA/kB,WAIA,CAGA,GAFAwU,EAAA+G,EAAA+H,KAAAyH,KAEAvW,EACA,KAGAxU,GAAAzD,KAAAiY,UAEI4V,EAkBJ,OAhBAF,KACAH,EAAAthB,EAAAyhB,GAGAI,GACAhD,GAAAtF,EAAA+H,GAOAA,EAAAhF,EAAA9rB,cACA8wB,GAAAhF,EAGAgF,EAKA,QAAAiB,IAAAzP,GACA,GAAAzkB,GAAAm0B,EAAAjN,EAAAkN,EAAAC,CAIA,OAFAr0B,GAAAykB,EAAAI,IAEAJ,EAAA6P,eAAA7P,EAAAG,YAAA2P,IACA,MAGArN,EAAAzC,EAAAyC,YACAkN,EAAAlN,EAAA1hB,QAAAgvB,IAEAJ,KAAA,GACA3P,EAAAplB,MAAA,4DAGA80B,EAAAjN,EAAAhc,OAAA,EAAAkpB,GACA3P,EAAAI,KAAAuP,EAAA,EAEAC,GACAjP,EAAA0M,GACA52B,EAAAi5B,GAGA1P,EAAA6L,uBACA+D,EAAAl5B,EAAAspB,EAAA8L,WAAAvwB,IAGAq0B,GAKA,QAAAI,IAAAvlB,GACA,GAAAvJ,GAAA+uB,EAAAC,EAAAC,EAAAC,CAEA,KAAAlvB,EAAA,EAAaA,EAAAuJ,EAAA/M,OAAgBwD,GAAA,EAC7B+uB,EAAAxlB,EAAAvJ,GACAgvB,EAAAzlB,EAAAvJ,EAAA,GACAivB,EAAA1lB,EAAAvJ,EAAA,GAGAmvB,GAAAJ,IAAAK,GAAAJ,IAAAG,GAAAF,IAGAI,GAAAzpB,KAAAqpB,IAAAK,GAAA1pB,KAAAmpB,KAGAxlB,EAAAvJ,EAAA,GAAAivB,EAAAtzB,QAAA0zB,GAAA,MAGA9lB,EAAAvJ,GAAA+uB,EAAApzB,QAAA2zB,GAAA,KAMAC,GAAAR,IAAAI,GAAAH,IACAK,GAAAzpB,KAAAopB,IAAAG,GAAAJ,EAAAzG,EAAA,KAAAgH,GAAA1pB,KAAAmpB,EAAAzG,EAAA,MACA/e,EAAAvJ,EAAA,GAAAgvB,EAAArzB,QAAA0zB,GAAA,MACAN,EAAAzG,EAAA,GAAAyG,EAAAzG,EAAA,GAAA3sB,QAAA2zB,GAAA,KAMAH,GAAAJ,IAAAQ,GAAAP,KACAE,EAAA7uB,EAAA2uB,EAAA1G,GAEA6G,GAAAD,IAAAG,GAAAzpB,KAAAspB,IAAAI,GAAA1pB,KAAAmpB,KACAC,EAAA1G,EAAA0G,EAAA1G,EAAA9rB,OAAA,GAAA0yB,EAAAvzB,QAAA0zB,GAAA,MACA9lB,EAAAvJ,GAAA+uB,EAAApzB,QAAA2zB,GAAA,KAKA,OAAA/lB,GAGA,QAAA4lB,IAAAtlB,GACA,sBAAAA,GAGA,QAAAulB,IAAAvlB,GACA,MAAAA,GAAA4V,IAAA0M,IAAAtiB,EAAA4V,IAAA+P,GAGA,QAAAD,IAAA1lB,GACA,OAAAA,EAAA4V,IAAAuM,IAAAniB,EAAA4V,IAAAgQ,KAAA5lB,EAAAye,EAGA,QAAAoH,IAAAnmB,EAAAomB,EAAAC,GACA,GAAA/lB,EAEA8lB,KACA9lB,EAAAN,EAAA,GACA,gBAAAM,KACAA,IAAAlO,QAAAg0B,EAAA,IAEA9lB,EAGAN,EAAA,GAAAM,EAFAN,EAAA1L,UAOA+xB,IACA/lB,EAAAxJ,EAAAkJ,GACA,gBAAAM,KACAA,IAAAlO,QAAAi0B,EAAA,IAEA/lB,EAGAN,IAAA/M,OAAA,GAAAqN,EAFAN,EAAAL,QAeA,QAAA2mB,IAAAtmB,EAAAumB,EAAAC,EAAAC,EAAAC,GACA,mBAAA1mB,GAAA,CAEA,GAAAvJ,GACA6J,EACAqmB,EACAC,EACAC,EACAC,EACAC,EACAxzB,CAMA,KAHAgyB,GAAAvlB,GAEAvJ,EAAAuJ,EAAA/M,OACAwD,KACA6J,EAAAN,EAAAvJ,GAGA6J,EAAAggB,QACAtgB,EAAA/I,OAAAR,EAAA,GAIA8vB,GAAAjmB,EAAA4V,IAAA0M,IACA5iB,EAAA/I,OAAAR,EAAA,EAQA,KAHA0vB,GAAAnmB,EAAAymB,EAAAO,GAAA,KAAAN,EAAAO,GAAA,MAEAxwB,EAAAuJ,EAAA/M,OACAwD,KAAA,CAIA,GAHA6J,EAAAN,EAAAvJ,GAGA6J,EAAAye,EAAA,CACA,GAAAmI,GAAA5mB,EAAA4V,IAAAiR,IAAAC,GAAA/qB,KAAAiE,EAAApI,EACA2uB,GAAAL,GAAAU,GAEAV,GAAAU,GACAf,GAAA7lB,EAAAye,EAAAsI,GAAAC,IAGAT,IACAF,EAAA3mB,EAAAvJ,EAAA,GACAmwB,EAAA5mB,EAAAvJ,EAAA,KAIAkwB,GAAA,gBAAAA,IAAAM,GAAA5qB,KAAAsqB,MACAG,GAAA,KAIAF,GAAA,gBAAAA,IAAAI,GAAA3qB,KAAAuqB,MACAG,GAAA,IAIAT,GAAAhmB,EAAAye,EAAAwH,EAAAM,EAAAC,EAAAC,GAGAvzB,EAAA8M,EAAAye,EAAA/O,IACAsW,GAAAhmB,EAAAye,EAAA/O,EAAAuW,EAAAC,EAAAM,EAAAJ,GAIAlzB,EAAA8M,EAAAye,EAAAzhB,IACAgpB,GAAAhmB,EAAAye,EAAAzhB,EAAAipB,EAAAC,EAAAM,EAAAJ,GAeA,GAVApmB,EAAAmC,IACA6jB,GAAAhmB,EAAAmC,EAAA8jB,EAAAC,EAAAM,EAAAC,GAEAzmB,EAAAmC,EAAAtP,QAAA,SAAAZ,GAAqC,MAAAA,GAAAkQ,EAAA,IACrCnC,EAAAmC,EAAAiK,QAAAjW,EAAA,KACAuJ,EAAA/I,OAAAtC,MAAAqL,EAAAM,EAAAmC,SACAnC,GAAAmC,GAIAnC,EAAA3M,EACA,IAAAJ,IAAA+M,GAAA3M,EACA2M,EAAA3M,EAAAwJ,eAAA5J,IAAA,gBAAA+M,GAAA3M,EAAAJ,IACA+yB,GAAAhmB,EAAA3M,EAAAJ,GAAAgzB,EAAAC,EAAAM,EAAAC,EAKAzmB,GAAAvU,IACAu6B,GAAAhmB,EAAAvU,EAAAw6B,EAAAC,EAAAM,EAAAC,GACAzmB,EAAAvU,EAAAkH,OAAA,SAAAqN,GAAAvU,GAMA,IADA0K,EAAAuJ,EAAA/M,OACAwD,KACA,gBAAAuJ,GAAAvJ,KACA,gBAAAuJ,GAAAvJ,EAAA,KACAuJ,EAAAvJ,GAAAuJ,EAAAvJ,GAAAuJ,EAAAvJ,EAAA,GACAuJ,EAAA/I,OAAAR,EAAA,MAGA+vB,IACAxmB,EAAAvJ,GAAAuJ,EAAAvJ,GAAArE,QAAAm1B,GAAA,MAGA,KAAAvnB,EAAAvJ,IACAuJ,EAAA/I,OAAAR,EAAA,KAQA,QAAA+wB,IAAAjS,GACA,GAAAzkB,GAAA8vB,CAKA,OAHA9vB,GAAAykB,EAAAI,IAGAJ,EAAAG,YAAA,OAIAkL,EAAArL,EAAAM,aAAA4R,KACAlS,EAAAkL,QAAAG,IAAArL,EAAAkL,QACAlL,EAAAI,IAAA7kB,EACA,OAIAolB,EAAAwR,GACAxvB,EAAA0oB,IAKArL,EAAAI,KAAA,MACAJ,GAAAplB,MAAA,wBAjBA,KA0CA,QAAAw3B,IAAApS,GACA,GAAAzkB,GACA2H,EACAonB,EACA+H,EACA5tB,EACA6tB,EACAC,EACAtZ,EACA4V,EACAzO,EACAqC,EACA+P,CAIA,IAFAj3B,EAAAykB,EAAAI,IAEAJ,EAAAkL,QAAAlL,EAAAiK,aAAAjK,EAAA6P,aACA,WAGA,KAAA7P,EAAAG,YAAA,KACA,WAIA,UAAAH,EAAA8D,WACA,WAQA,IALA5gB,KACA8c,EAAA6L,uBACA3oB,EAAAxM,EAAAspB,EAAA8L,WAAAvwB,IAGAykB,EAAAG,YAAA,KAOA,MANAjd,GAAAyd,EAAA8R,GACAzS,EAAAM,aAAA,cACAN,EAAAplB,MAAA,gCAGAsI,EAAA9E,EAAA4hB,EAAAM,aAAA,WACApd,CAOA,IAJAA,EAAAyd,EAAAiR,GAGA1uB,EAAAP,EAAAqd,EAAAM,aAAAoS,KACAxvB,EAAAP,EACA,WAaA,KATAgwB,GAAA7rB,KAAAkZ,EAAA8D,aACA9D,EAAAplB,MAAA,oBAGAolB,EAAAK,kBAEAL,EAAAoL,OAAA,EAGAd,EAAAJ,GAAAlK,IACAsK,KAAA,IACApnB,EAAA1M,IAAA0M,EAAA1M,MACA0M,EAAA1M,EAAAwK,KAAAspB,IAGAtK,EAAAK,iBAcA,IAXAL,EAAAoL,OAAA,EAGApL,EAAAK,kBAGAL,EAAAG,YAAA,OACAkS,GAAA,IAIArS,EAAAG,YAAA,KACA,WAGA,IAAAyS,GAAA1vB,EAAAP,EAAAtF,cACA4zB,EAAAjR,EAAAiR,kBAEA,KAAAoB,IAAAQ,GAAA/rB,KAAA5D,EAAAP,GAAA,CACAqd,EAAA8S,aAAA9xB,KAAA4xB,GAIA,WAAAA,GAAA,UAAAA,GAAA,aAAAA,IACA5S,EAAAkL,OAAA0H,GAGAnuB,KACA6tB,EAAAS,GAAA,KAEA,GAUA,IATA3S,EAAAJ,EAAAI,IACAqC,EAAAzC,EAAAyC,YAEAA,GACAzC,EAAAplB,MAAA,gBAAAolB,EAAA8S,aAAAp1B,OAAA,qBAAAsiB,EAAA8S,aAAAhc,UAAAjP,IAAA,SAAAxG,GAAqJ,WAAAA,EAAA,MAA2ByH,KAAA,SAKhLkqB,GAAAJ,EAAAnQ,GAKA,GAAA+P,EAAAP,GAAAjS,GAAA,CACA6O,GAAA,CAEA,IAAAoE,GAAAT,EAAA7vB,EAAAtF,aAGA,IAAA41B,IAAAL,IAEA5S,EAAAI,QAGAJ,EAAA8S,aAAA/xB,QAAAkyB,IAAA,CACA,GAAAhrB,GAAA,wBAIA4qB,IAAA/rB,KAAAmsB,KACAhrB,GAAA,MAAAgrB,EAAA,qDAGAjT,EAAAplB,MAAAqN,SAMAgR,EAAA8U,GAAA/N,GAA6CsJ,KAAAtJ,EAAAiP,mBAAA,GAAA1D,MAAAvL,EAAAiP,mBAAA,OAC7CJ,GAAA,EACA7O,EAAAI,QAIAnH,EAAA+G,EAAA+H,KAAAmL,MACAZ,EAAArZ,EAAAwB,KACAuF,EAAAI,MACAJ,EAAAplB,MAAA,iCAGAm2B,GAAA9X,EAAAuQ,EAAAxJ,EAAAgR,cAAAC,SAEAqB,EAAArZ,EAAAwB,GAAAxB,EAAAuQ,EACA+I,GAAA,IAIAtZ,EAAA+G,EAAA+H,KAAAyH,KACA/qB,EAAAzD,KAAAiY,GAEA4V,GAAA,MApDAA,IAAA,SAwDKA,EAELpqB,GAAA/G,SACAwF,EAAAsmB,EAAA/kB,GAGA8tB,IACArvB,EAAAxM,EAAA47B,GAGAtS,EAAA8S,aAAA1oB,MAKA,MAFA4V,GAAAkL,OAAA,KAEAlL,EAAAmT,kBAAAnT,EAAAmT,iBAAApyB,QAAA6xB,MAAA,EACA7H,GAGA7nB,EAGA,QAAA8vB,IAAAx5B,EAAAipB,GACA,GAAAnc,GAAA8sB,CAKA,OAHA9sB,GAAA,2BAAAE,KAAAic,GACA2Q,EAAAC,GAAA75B,IAEA8M,IAAA8sB,KAIAA,EAAAryB,QAAAuF,EAAA,GAAAjJ,eAGA,QAAAi2B,IAAAtT,GACA,GAAAlf,GAAA2hB,EAAA2Q,EAAAG,CAiCA,OA/BA9Q,GAAAzC,EAAAyC,YAEAzC,EAAA6P,cACAuD,EAAApT,EAAAqJ,KAAAxhB,IAAA,SAAA8Y,GAAkD,MAAAA,GAAA2I,OAClD8J,IAAA1uB,OAAAsb,EAAAqJ,KAAAxhB,IAAA,SAAA8Y,GAAqE,WAAAA,EAAA2I,QAErExoB,EAAAkgB,GAAAyB,EAAA2Q,KAEAG,EAAAvT,EAAAkL,OAAA,KAAAlL,EAAAkL,OAAA,IAEAlL,EAAAkL,SAAAlL,EAAA9f,YAAA8f,EAAAkL,QACApqB,EAAA2hB,EAAA1hB,QAAAwyB,IAEAH,EAAApT,EAAAqJ,KAAAxhB,IAAA,SAAA8Y,GAAmD,MAAAA,GAAA2I,OACnD8J,IAAA1uB,OAAAsb,EAAAqJ,KAAAxhB,IAAA,SAAA8Y,GAAsE,WAAAA,EAAA2I,QAGtEtJ,EAAAiK,eAAA,EAEAmJ,EAAApyB,KAAA,yBACMgf,EAAAiK,YAENmJ,EAAApyB,KAAAgf,EAAAiK,aAEAmJ,EAAApyB,KAAAuyB,GAGAzyB,EAAAkgB,GAAAyB,EAAA2Q,KAIAtyB,GAIAA,KAAA,IACAA,EAAA2hB,EAAA/kB,QAGAsiB,EAAAI,KAAAtf,EAEAkf,EAAAkL,QAAA,aAAAlL,EAAAkL,QAAAlL,EAAA6P,aACApN,EAAAhc,OAAA,EAAA3F,GAEAwgB,GAAAmB,EAAAhc,OAAA,EAAA3F,KAZA,KAoBA,QAAA0yB,IAAAxT,GACA,GAAAzkB,GAAAykB,EAAAI,IACAkJ,EAAAtJ,EAAAiP,mBAAA,GACA1D,EAAAvL,EAAAiP,mBAAA,EAEA,KAAAjP,EAAAM,aAAAmT,MAAAzT,EAAAG,YAAAmJ,GAEA,MADAtJ,GAAAI,IAAA7kB,EACA,IAGA,IAAA/B,GAAAwmB,EAAAM,aAAAoT,GAKA,IAHAh0B,EAAA,sEAAgFlG,EAAA,yDAA0EA,EAAA,sBAA+BA,EAAA,YAGzLwmB,EAAAG,YAAAoL,KAAAvL,EAAAM,aAAAqT,IAEA,MADA3T,GAAAI,IAAA7kB,EACA,IAGA,IACAszB,GADAa,KAGAkE,EAAA,GAAAvS,QAAA,YAAAP,GAAAwI,GAAA,cAAA9vB,EAAA,OAAAsnB,GAAAyK,GAAA,UAEA,GACA,IAAAvL,EAAAM,aAAAsT,GACA/E,GAAA,MAGA,CACA,GAAA5V,GAAA+G,EAAA+H,KAAAyH,GACAvW,IACA+G,EAAAplB,MAAA,mCAAA0uB,EAAA,IAAA9vB,EAAA+xB,EAAA,UAGAmE,EAAA1uB,KAAAiY,UAEI4V,EAEJ,QACAlO,EAAAkT,GACArK,EAAAkG,EACAjV,EAAAjhB,GAMA,QAAAs6B,IAAA9T,GACA,GAAAzkB,GAAA/B,EAAAk2B,EAAAzW,EAAA4V,CAEAtzB,GAAAykB,EAAAI,GAEA,IAAA2T,GAAA/T,EAAAiP,kBAEA,KAAAjP,EAAAG,YAAA4T,EAAA,IACA,WAGA,KAAA/T,EAAAM,aAAA0T,IAEA,MADAhU,GAAAI,IAAA7kB,EACA,IAGA/B,GAAAwmB,EAAAM,aAAA,iCAEA9mB,GACAwmB,EAAAplB,MAAA,+BAGAolB,EAAAK,kBACAL,EAAAG,YAAA4T,EAAA,KACA/T,EAAAplB,MAAA,+BAAAm5B,EAAA,QAGArE,IAEA,IAEAzW,EAAA8U,GAAA/N,GAAuCsJ,KAAAtJ,EAAAiP,mBAAA,GAAA1D,MAAAvL,EAAAiP,mBAAA,OACvC,aAAAhW,EAAAjW,GACAgd,EAAAplB,MAAA,YAAAm5B,EAAA,cAAAA,EAAA,IAGAlF,GAAA,IAIA5V,EAAA+G,EAAA+H,KAAAyH,IAEAvW,GACA+G,EAAAplB,MAAA,YAAAm5B,EAAA,cAAAA,EAAA,IAGArE,EAAA1uB,KAAAiY,WAEI4V,EAEJ,QACAlO,EAAAkT,GACApZ,EAAAjhB,EACAgwB,EAAAkG,GAIA,QAAAuE,IAAAjU,GAOA,IANA,GAAA/a,MACAqtB,EAAAS,GAAA,MACAR,GAAA,EAEAtB,EAAAjR,EAAAiR,mBAEAjR,EAAAI,IAAAJ,EAAA3F,IAAA3c,QAAA,CACA,GAAAqN,GAAA+hB,EAAA1M,EAAAJ,EAAAI,KAEA0M,EAAA9M,EAAA+H,KAAAmL,MACAZ,EAAAxF,EAAArS,KACAuF,EAAAI,MACAJ,EAAAplB,MAAA,kCAGAm2B,GAAAjE,EAAAtD,EAAAxJ,EAAAgR,cAAAC,SAEAqB,EAAAxF,EAAArS,GAAAqS,EAAAtD,EACA+I,GAAA,IACKxnB,EAAAiV,EAAA+H,KAAAyH,KACLvqB,EAAAjE,KAAA+J,GAEAiV,EAAAplB,MAAA,+BAIA,GAAAsH,IACA2e,EAAAqT,GACAvT,EAAA1b,EAOA,OAJAstB,KACArwB,EAAAxL,EAAA47B,GAGApwB,EAGA,QAAAiyB,IAAAv9B,EAAA2tB,GAEAnf,OAAAC,KAAAzO,GAAAgH,QAAA,SAAAI,GACA,GAAAo2B,GAAAp2B,EAAApH,GAAA,MAAAy9B,IAAAz9B,EAAA2tB,EAEA,IAAAre,GAAAtP,EAAAoH,EACAs2B,IAAApuB,IAAAiuB,GAAAjuB,EAAAqe,KAIA,QAAA6P,IAAAp2B,EAAApH,GACA,YAAAoH,GAAAC,EAAArH,EAAAoM,GAGA,QAAAqxB,IAAAz9B,EAAA2tB,GACA,GAAAvnB,GAAApG,EAAAoG,EAAAgG,EAAApM,EAAAoM,CACAuhB,GAAAvnB,KAAAunB,EAAAvnB,GAAAkiB,GAAAliB,EAAAgG,EAAAtF,SAGA,QAAA42B,IAAApuB,GACA,MAAAjI,GAAAiI,IAAAxH,EAAAwH,GAYA,QAAAid,IAAAprB,EAAAqQ,GACA,UAAAmsB,IAAAx8B,EAAAqQ,OAAqDlG,OAmHrD,QAAAsyB,IAAAC,EAAA75B,EAAA85B,GACAD,GACAz1B,EAAA,wCAAApE,EAAA,KAAA85B,GAIA,QAAA9U,IAAA7kB,EAAA2C,GAEA,MADA82B,IAAAtV,GAAA,0BAAAyV,IACAzV,GAAAnkB,EAAA2C,GAGA,QAAAk3B,IAAAva,EAAAiF,GAEA,MADAkV,IAAAnV,GAAA,4BAAiEwV,IACjExV,GAAAhF,EAAAiF,GAmHA,QAAAwV,IAAAj1B,GACA,GAAAk1B,GAAAl1B,EAAAm1B,QAAAj9B,QAGA,IAAAg9B,KAAAnuB,GAAA,CAIA,GAAA1E,GAAA+yB,GAAAp1B,EAAAk1B,EAAAnuB,GAIA,OAAA1E,KAAA6yB,EAAA7yB,QACA6yB,EAAA7yB,SACAA,GAFA,QAMA,QAAA+yB,IAAAp1B,EAAA+G,GACA,MAAAA,GAAArQ,KAAAsJ,GACAq1B,OAAAlV,GAAAkV,OACAC,SAAAnV,GAAAmV,SACAhS,MAAA,SAAAprB,EAAAqQ,GAGA,MAFA,UAAAA,MAAA4X,GAAAoV,gBAAAv1B,IAEAmgB,GAAAmD,MAAAprB,EAAAqQ,MAKA,QAAAitB,IAAAt9B,EAAA8H,GAWA,MAVA,gBAAA9H,GAEAA,EAAAu9B,GAAAv9B,EAAA8H,IAIA01B,GAAAx9B,GACA8nB,GAAA9nB,IAGAA,EAGA,QAAAu9B,IAAAv9B,EAAA8H,GAMA,MAJA,MAAA9H,EAAA,KACAA,EAAAioB,GAAAkV,OAAAn9B,IAGAioB,GAAAwV,SAAAz9B,EAAA8H,GAGA,QAAA01B,IAAAx9B,GAGA,GAAAuJ,QAAAvJ,EACA,SAAAkH,OAAA,0BAAAlH,EAAA,IAIA,oBAAAA,GAAA8oB,EACA,SAAA5hB,OAAA,8JAIA,IAAAlH,EAAA8oB,IAAAqT,GACA,SAAAj1B,OAAA,yCAAAi1B,GAAA,SAAAn8B,EAAA,iHAIA,QAAA09B,IAAAC,EAAAC,EAAAC,GACA,GAAAD,EAKA,OAAA33B,KAAA23B,IACAC,GAAAF,EAAA9tB,eAAA5J,KACA03B,EAAA13B,GAAA23B,EAAA33B,IAoEA,QAAA63B,IAAA51B,EAAAzG,EAAAi7B,GAGA,QAAAhf,KACA,GAAAqgB,GAAAC,GAAAtgB,EAAAugB,QAAAx8B,GACAy8B,EAAA,UAAAh9B,MACAi9B,EAAAj9B,KAAAk9B,MAEAl9B,MAAAk9B,OAAAL,CAEA,IAAA5zB,GAAAuyB,EAAAr1B,MAAAnG,KAAAwE,UAQA,OANAw4B,GACAh9B,KAAAk9B,OAAAD,QAEAj9B,MAAAk9B,OAGAj0B,EAjBA,eAAA4E,KAAA2tB,IAoBAhf,EAAAugB,QAAA/1B,EACAwV,EAAA2gB,QAAA3B,EAEAhf,GAvBAgf,EA0BA,QAAAsB,IAAA91B,EAAAzG,GACA,GAAAA,IAAAyG,GAAA,CACA,GAAAxG,GAAAwG,EAAAzG,EAEA,yBAAAC,GACAA,EACA,WAAkB,MAAAA,IAGlB,MAAAkF,GAGA,QAAA03B,IAAAC,EAAAC,EAAAC,GACA,iBAAAF,EAAA,6CAAAC,EAAA,KACAC,EAAA,wDAAAD,EAAA,QAGA,QAAAE,IAAAruB,EAAAsuB,EAAAH,GACA,GAAAG,IAAAtuB,GAAA,CACA,GAAAmuB,IAAAnuB,GAIA,SAAAnJ,OAAAo3B,GAAAK,EAAAH,GAAA,GAHA92B,GAAA42B,GAAAK,EAAAH,IACAnuB,EAAAmuB,GAAAnuB,EAAAsuB,IAOA,QAAAC,IAAAvuB,GACAquB,GAAAruB,EAAA,4BACAquB,GAAAruB,EAAA,mBACAquB,GAAAruB,EAAA,yBACAquB,GAAAruB,EAAA,6BAKAnK,EAAAmK,EAAAwuB,WACAH,GAAAruB,EAAA,oBA0CA,QAAAyuB,IAAApC,EAAAqC,EAAAv9B,EAAA6O,GACAuuB,GAAAvuB,EAEA,QAAApK,KAAAoK,GACA,GAAA2uB,GAAAnvB,eAAA5J,GAAA,CACA,GAAAvE,GAAA2O,EAAApK,EAOA,QAAAA,GAAA,kBAAAvE,GACAgG,EAAA,GAAAzB,EAAA,2EACA,SAAAy2B,EAAAl7B,EAAA,MAGAA,EAAAyE,GAAAvE,EAMA,GAAA2O,EAAAsU,QAAAtU,EAAAwU,QACA,SAAA3d,OAAA,iDAGA+3B,IAAAp5B,QAAA,SAAAq5B,GACAA,EAAAxC,GAAAqC,EAAAv9B,EAAA6O,KAGA8uB,GAAAzC,GAAAqC,EAAAv9B,EAAA6O,GACA+uB,GAAA1C,GAAAqC,EAAAv9B,EAAA6O,GACAgvB,GAAA3C,GAAAqC,EAAAv9B,EAAA6O,GAEAivB,GAAAP,EAAAQ,UAAA/9B,EAAA6O,GAGA,QAAAivB,IAAAp3B,EAAA1G,EAAA6O,GACA,OAAApK,KAAAoK,GACA,IAAAmvB,GAAAv5B,IAAAoK,EAAAR,eAAA5J,GAAA,CACA,GAAAyD,GAAA2G,EAAApK,EAGA,mBAAAyD,KACAA,EAAAo0B,GAAA51B,EAAAjC,EAAAyD,IAGAlI,EAAAyE,GAAAyD,GAKA,QAAA+1B,IAAA92B,GACA,GAAA9J,KAEA,OADA8J,GAAA9C,QAAA,SAAAyD,GAAkC,MAAAzK,GAAAyK,IAAA,IAClCzK,EAUA,QAAA6gC,IAAAx/B,GAGA,GAFAA,QAEA,gBAAAA,GACA,SAAAgH,OAAA,+EAIAhH,GAAAy/B,GAAA/rB,KAAA1S,KAAAulB,YAAAvlB,MAA0DhB,QAE1D,IAAAoK,GAAA4E,GAAA1L,MAAAtC,MAAA,GAGAwc,EAAAxc,KAAAqM,UAAAmQ,OACAA,MAAAkiB,MACAliB,EAAAkiB,MAAA1/B,MAAA,GAEAgB,KAAAqM,UAAAjM,IAAApB,GAGAgB,KAAAqM,UAAAjM,IAAApB,EAQA,KAJA,GACA2/B,GADAryB,EAAAsyB,GAAAF,MAAA1+B,MAGAiI,EAAAqE,EAAA7H,OACAwD,KACA,GAAA42B,GAAA/2B,QAAAwE,EAAArE,KAAA,GACA02B,GAAA,CACA,OAeA,MAXAA,KACAG,GAAAtyB,KAAAxM,MACAA,KAAAgM,SAAA+yB,cAAA/+B,KAAAlB,UACAkgC,GAAAxyB,KAAAxM,MACAi/B,GAAAzyB,KAAAxM,OAGAgO,GAAAC,MAEAixB,GAAA1yB,KAAAxM,KAAAhB,GAEAoK,EAGA,QAAA+1B,IAAAv6B,EAAArE,EAAAyvB,EAAAzS,GACA3Y,EAAAD,QAAA,SAAAmN,GAEA,GAAAA,EAAA1K,OAAA0sB,KAAAhiB,EAAAstB,UAAA7+B,GAAAuR,EAAAvR,UAGA,MAFAuR,GAAAkf,YAAAhB,MACAzS,GAAAxV,KAAA+J,EAKA,IAAAA,EAAA9F,SACAmzB,GAAArtB,EAAA9F,SAAA0F,YAAAI,EAAA9F,SAAAwF,MAAAjR,EAAAyvB,EAAAzS,OAIA,IAAAvY,EAAA8M,EAAAN,OACA2tB,GAAArtB,EAAAN,MAAAjR,EAAAyvB,EAAAzS,OAIA,IAAAzL,EAAA1K,OAAAi4B,IAAAvtB,EAAAjL,SAAA,CAEA,GAAAiL,EAAAjL,SAAAwyB,SAAA94B,GAAA,MACA4+B,IAAArtB,EAAAjL,SAAAmF,SAAAwF,MAAAjR,EAAAyvB,EAAAzS,GAIAzL,EAAA1K,OAAAuxB,IACA3zB,EAAA8M,EAAAwtB,aACAH,GAAArtB,EAAAwtB,WAAA/+B,GAAA,EAAAgd,KAMA,QAAAgiB,IAAA1L,GACAA,EAAA0L,qBAGA,QAAAC,IAAAj/B,EAAAszB,GACA,GAAA4L,KACAN,IAAAn/B,KAAAgM,SAAAwF,MAAAjR,GAAA,EAAAk/B,EAEA,IAAAr2B,GAAA4E,GAAA1L,MAAAtC,MAAA,EAOA,OALAA,MAAAq5B,SAAA94B,GAAAszB,EACA4L,EAAA96B,QAAA46B,IAEAvxB,GAAAC,MAEA7E,EA4FA,QAAAs2B,IAAA3uB,EAAA9D,EAAApF,GACA,GAAA83B,GAAA5uB,EAAA/E,SAAA7C,QAAA8D,EAAA,SAAAnM,GACAyH,EAAAwI,EAAA6uB,UAAAD,GACA5uB,EAAA8uB,OAAAh4B,GAAA/G,EACAiQ,EAAA+D,UAGA/D,GAAA6uB,UAAA73B,KAAA43B,GAsbA,QAAAG,IAAA9zB,EAAAlN,GACA,MAAAA,GAAAiL,EACA6P,GAAA5N,EAAAlN,EAAAiL,GAGAjL,EAAAsJ,EACA,GAAA23B,IAAA/zB,EAAAlN,EAAAsJ,GAGAtJ,EAAAm0B,GACA,GAAA+M,IAAAh0B,EAAAlN,EAAAm0B,IADA,OAKA,QAAAgN,IAAA1K,GACA,GAAAA,EAAAz2B,SAAAk1B,EAAA,CACAuB,EAAA3f,UAGA,QADA6Y,GAAA8G,EAAAz2B,SAAAk1B,EACA/rB,EAAA,EAAoBA,EAAAwmB,EAAAhqB,OAAiBwD,IACrCstB,EAAA3f,QAAA6Y,EAAAxmB,GAAAuZ,GAAAse,GAAAvK,EAAAlkB,eAAAod,EAAAxmB,GAAAG,IAgGA,QAAA83B,IAAA59B,EAAA69B,EAAA5/B,GAGA,IAFA,SAAA4/B,OAAA,GAEA79B,MAAA8E,OAAAuxB,IAAAp4B,GAAA+B,EAAA/B,aAAA4/B,GAAA79B,EAAA8E,OAAAi4B,KAEA/8B,IAAAyP,MAAAzP,EAAAyP,MAEAzP,EAAAuO,UAAAvO,EAAA89B,mBAAA99B,EAAAuO,UAAAQ,eAEA/O,EAAA0E,OAAA1E,EAAA0E,OAEA1E,EAAA+O,eAAA/O,EAAA+O,eAEAhJ,MAGA,OAAA/F,GAGA,QAAA+9B,IAAAC,GACA,MAAAA,GAAA18B,QAAA,wBAAAyJ,EAAAyX,GACA,MAAAA,GAAA7gB,gBAUA,QAAAs8B,IAAA9b,GACA,GAAA9G,KAEA,uBAAA8G,MAEAA,EAAA7gB,QAAA48B,GAAA,SAAAnzB,GAAsD,YAAAsQ,EAAA5V,KAAAsF,GAAA,KACtDzJ,QAAA68B,GAAA,IACAhoB,MAAA,KACA8H,OAAA,SAAAmgB,GAAsC,QAAAA,EAAAvf,SACtCvS,IAAA,SAAA8xB,GAAmC,MAAAA,GAAA98B,QAAApD,GAAA,SAAA6M,EAAAmU,GAAoD,MAAA7D,GAAA6D,OACvFkB,OAAA,SAAAie,EAAAD,GACA,GAAAz4B,GAAAy4B,EAAA54B,QAAA,KACAvH,EAAA8/B,GAAAK,EAAAlzB,OAAA,EAAAvF,GAAAkZ,OAEA,OADAwf,GAAAC,GAAArgC,OAAAmgC,EAAAlzB,OAAAvF,EAAA,GAAAkZ,OACAwf,OAIA,QAAAE,IAAAzf,GAKA,IAJA,GAAA7V,GAAA6V,EAAA3I,MAAAqoB,IAGA74B,EAAAsD,EAAA9G,OACAwD,KACAsD,EAAAtD,IAAAsD,EAAA9C,OAAAR,EAAA,EAGA,OAAAsD,GAKA,QAAAw1B,IAAA1P,GACA,GAAApnB,GAAAonB,EAAApnB,QAAA1J,EAAA8wB,EAAA9wB,IAEA,WAAAA,EAAA,MAAAygC,GAEA,cAAAzgC,EAAA,CAIA,GAHA8wB,EAAA3hB,eAAA2hB,EAAA3hB,aAAA5B,OAAA,GAGA,WAAA7D,EAAA1J,MAAA,UAAAA,EACA,MAAA0J,GAAAg3B,aAAA,YAAAC,GAAAC,EAGA,iBAAAl3B,EAAA1J,KAAA,MAAA6gC,GAGA,UAAAn3B,EAAAg3B,aAAA,yBAAAI,GAGA,cAAAp3B,EAAA1J,KAAA,CACA,GAAA6G,GAAA6C,EAAAg3B,aAAA,OAGA,aAAA75B,EAAA,MAAA1B,EAGA,cAAA0B,GAAA6C,EAAAiV,SAAA,SAAAjV,EAAAiV,QAAAmS,UAAA9wB,KAAA,MAAA+gC,GAEA,KAAAC,GAAAz5B,QAAAV,GAAA,MAAAg6B,IAGA,MAAAI,IAGA,GAAAtgC,GAAA+I,EAAA/I,IAGA,IAAAmwB,EAAAoQ,UAAA,SAAAlhC,EAAA,CACA,aAAAW,EAAAkG,KAAA,MAAAs6B,GACA,iBAAAxgC,EAAAkG,KAAA,MAAAu6B,IAGA,aAAAphC,EAAA,MAAAqhC,GAEA,QAAArhC,EAAAuH,QAAA,gBAAA+5B,GAGA,cAAAthC,KAAAW,EAAA4gC,cAAA5gC,EAAA4gC,eAAAxZ,IAAA,MAAAyZ,GAEA,QAAAxhC,EAAAuH,QAAA,gBAAAk6B,GAEA,IAAA3Q,EAAA4Q,UAAA,CACA,GAAAC,GAAAj4B,EAAAg3B,aAAA,OAEA,QADA5P,EAAA3hB,cAAA,YAAAnP,GAAA,aAAA2hC,GAAA,UAAAA,IAAA7Q,EAAA3hB,aAAA5B,OAAA,GACAq0B,GAGA,MAAA9Q,GAAA+Q,WAAA/Q,EAAA+Q,YAAA/Q,EAAAnwB,KAAA4gC,aAAAO,GAEAC,GAGA,QAAAtB,IAAAtC,GACA,GAAAzxB,GAAAjN,KAAAkB,EAAA+L,EAAA/L,KACAV,EAAAR,KAAAuiC,UAIA,OADAviC,MAAA4G,QAAA47B,MAAAthC,EAAA9D,MAAA8D,SAAAlB,MAAA4G,QAAA47B,MAAAthC,EAAA9D,IACAshC,EAAAx9B,EAAAuhC,gBAAA,OAEAziC,KAAA4G,QAAA47B,MAAAhiC,GAAAU,OAEAA,EAAA9D,GAAAoD,IAGA,QAAA0gC,IAAAxC,GACA,GAAAl+B,GAAAR,KAAAuiC,UAEAv9B,GAAAxE,WAEA,IAAA2O,GAAAnP,KAAAkB,KAAAiO,QACAlH,EAAAkH,EAAA1K,MAEA,IAAAi6B,EACA,KAAAz2B,KAAAkH,EAAAlH,GAAAy6B,UAAA,MAEA,MAAAz6B,KAAA,CACA,GAAA6T,GAAA3M,EAAAlH,GACA06B,EAAA7mB,EAAAhL,SACAgL,EAAAhL,SAAAtQ,MACAsb,EAAAtb,KAEAsb,GAAA4mB,SAAA16B,EAAAxH,EAAAmiC,IAKA,QAAAxB,IAAAzC,GACA,GAAAl+B,GAAAR,KAAAuiC,UAEA,KAAAviC,KAAA4iC,OAAA,CACA5iC,KAAAkB,KAAA4P,SAAAtQ,OAEA,IAAA2O,GAAAnP,KAAAkB,KAAAiO,QACAlH,EAAAkH,EAAA1K,OACAo+B,GAAA,CAEA,IAAAnE,EACA,KAAAz2B,KAAAkH,EAAAlH,GAAAy6B,UAAA,MAEA,MAAAz6B,KAAA,CACA,GAAA6T,GAAA3M,EAAAlH,GACA06B,EAAA7mB,EAAAhL,SACAgL,EAAAhL,SAAAtQ,MACAsb,EAAAtb,KAGA,IAFAsb,EAAAgnB,UAAAhnB,EAAA4mB,WAAAG,GAAA,GAEAF,GAAAniC,EAEA,YADAsb,EAAA4mB,UAAA,GAMAG,IAAA7iC,KAAAkB,KAAA6hC,eAAA,IAKA,QAAA1B,IAAA3C,GACA,GAAAl+B,GAAAR,KAAAuiC,UAEAviC,MAAA4iC,SACAlE,EAAA1+B,KAAAkB,KAAAohB,UAAA,GACAtiB,KAAAkB,KAAAohB,UAAAja,SAAA7H,EAAA,GAAAA,GAIA,QAAA8gC,IAAA5C,GACA,GAAAx9B,GAAAlB,KAAAkB,KACA8hC,EAAA9hC,EAAA2W,QAEArX,EAAAR,KAAAuiC,UAEA,OAAA7D,GAAAx9B,EAAA2W,SAAA,GAGA3W,EAAAV,MAAAR,KAAAkB,KAAA4P,SAAAtQ,QACAU,EAAA2W,QAAArX,IAAAR,KAAAiK,QAAAg3B,aAAA,aAMA+B,IAAA9hC,EAAA2W,SAAA7X,KAAAiK,QAAAiV,SAAAlf,KAAAiK,QAAAiV,QAAAU,UACA5f,KAAAiK,QAAAiV,QAAA+jB,MAAAniC,MAAAV,IAAAJ,KAAAiK,QAAAiV,QAAA+jB,MAAAV,cAIA,QAAAf,IAAA9C,GACA,IAAA1+B,KAAA4iC,OAAA,CACA,GAAAlE,EAGA,MAFA1+B,MAAAkB,KAAAuhC,gBAAA,cACAziC,KAAAkB,KAAAV,MAAAR,KAAAkB,KAAA4P,SAAAtQ,MAAA,KAIA,IAAAA,GAAAR,KAAAuiC,UAEAviC,MAAAkB,KAAAV,MAAAR,KAAAkB,KAAA4P,SAAAtQ,QACAR,KAAAkB,KAAAgiC,aAAA,QAAA1iC,IAIA,QAAA4gC,IAAA1C,GACA,IAAA1+B,KAAA4iC,OAAA,CACA,GAAAlE,EAGA,MAFA1+B,MAAAkB,KAAA4P,SAAAtQ,MAAA,OACAR,MAAAkB,KAAAuhC,gBAAA,QAIA,IAAAjiC,GAAAR,KAAAuiC,UAEAviC,MAAAkB,KAAA4P,SAAAtQ,QAEAR,KAAAkB,KAAAV,MAAAgD,EAAAhD,GACAR,KAAAkB,KAAAgiC,aAAA,QAAA1/B,EAAAhD,KAIA,QAAAkhC,IAAAhD,GACAA,EAAA1+B,KAAAkB,KAAA2W,SAAA,EACA7X,KAAAkB,KAAA2W,QAAA7X,KAAAuiC,YAAAviC,KAAAkB,KAAA4P,SAAAtQ,MAGA,QAAAmhC,IAAAjD,GACA,GAAAzxB,GAAAjN,KAAAiK,EAAAgD,EAAAhD,QAAA/I,EAAA+L,EAAA/L,KACAge,EAAAjV,EAAAiV,QAEA1e,EAAAR,KAAAuiC,WACAY,EAAAl5B,EAAAg3B,aAAA,QAMA,IAAAj8B,EAAAxE,GAEI,CAEJ,IADA,GAAAyH,GAAAzH,EAAAiE,OACAwD,KACA,GAAAk7B,GAAA3iC,EAAAyH,GAEA,YADAiX,EAAAkkB,UAAAliC,EAAA2W,SAAA,EAIAqH,GAAAkkB,UAAAliC,EAAA2W,SAAA,MATAqH,GAAAkkB,UAAAliC,EAAA2W,QAAArX,GAAA2iC,EAaA,QAAAvB,IAAAlD,GAOA,IANA,GAAA2E,GAAA3E,KAAyB6B,GAAAvgC,KAAAuiC,YAAA,IACzB9f,EAAAziB,KAAAkB,KAAAuhB,MACArW,EAAAD,OAAAC,KAAAi3B,GACAC,EAAAtjC,KAAAqY,aAEApQ,EAAA,EACAA,EAAAmE,EAAA3H,QACA2H,EAAAnE,IAAAwa,OAAArW,EAAAnE,IAAAo7B,EAAAj3B,EAAAnE,KACAA,GAKA,KADAA,EAAAq7B,EAAA7+B,OACAwD,OACAmE,EAAAtE,QAAAw7B,EAAAr7B,KAAAq7B,EAAAr7B,IAAAwa,OAAA6gB,EAAAr7B,IAAA,GAGAjI,MAAAqY,SAAAjM,EAGA,QAAAy1B,IAAAnD,GACA1+B,KAAAujC,YACAvjC,KAAAujC,UAAA1/B,EAAA7D,KAAAO,KAAAiN,OAAA,KAGAxN,KAAAkB,KAAAuhB,MAAAziB,KAAAujC,WAAA7E,EAAA,GAAA1+B,KAAAuiC,WAGA,QAAAR,IAAArD,GAMA,IALA,GAAAl+B,GAAAk+B,KAAAmC,GAAAr9B,EAAAxD,KAAAuiC,aACAvS,EAAA6Q,GAAA7gC,KAAAkB,KAAAsiC,WACAF,EAAAtjC,KAAAqY,UAAA2X,EAAAzd,MAAA,GAEAtK,EAAA,EACAA,EAAAzH,EAAAiE,SACAurB,EAAAloB,QAAAtH,EAAAyH,KAAA+nB,EAAAjoB,KAAAvH,EAAAyH,IACAA,GAKA,KADAA,EAAAq7B,EAAA7+B,OACAwD,KACA,KAAAzH,EAAAsH,QAAAw7B,EAAAr7B,IAAA,CACA,GAAAioB,GAAAF,EAAAloB,QAAAw7B,EAAAr7B,KACAioB,GAAAF,EAAAvnB,OAAAynB,EAAA,GAIA,GAAAsT,GAAAxT,EAAAngB,KAAA,IAEA2zB,KAAAxjC,KAAAkB,KAAAsiC,YACAxjC,KAAAkB,KAAAsiC,aAGAxjC,KAAAqY,SAAA7X,EAGA,QAAAwhC,IAAAtD,GACA,GAAAn+B,GAAAP,KAAAO,KAAAiN,OAAA,GACAwiB,EAAA6Q,GAAA7gC,KAAAkB,KAAAsiC,WACAhjC,GAAAk+B,GAAA1+B,KAAAuiC,UAEAviC,MAAAyjC,cAAAzjC,KAAAyjC,YAAAljC,GAEAC,KAAAwvB,EAAAloB,QAAAvH,GAAAyvB,EAAAjoB,KAAAxH,IACAC,IAAAwvB,EAAAloB,QAAAvH,IAAAyvB,EAAAvnB,OAAAunB,EAAAloB,QAAAvH,GAAA,GAEAP,KAAAkB,KAAAsiC,UAAAxT,EAAAngB,KAAA,KAGA,QAAAsyB,IAAAzD,GAGA,IAAA1+B,KAAA4iC,OAAA,CACA,GAAAlE,EAGA,MAFA1+B,MAAA0jC,cAAA1jC,KAAAkB,KAAAlB,KAAA2jC,eAAA,OACA3jC,MAAAkB,KAAAuhC,gBAAAziC,KAAA2jC,aAIA3jC,MAAA0jC,YACA1jC,KAAAkB,KAAAlB,KAAA2jC,cAAA3jC,KAAAuiC,WAEAviC,KAAAuiC,WACAviC,KAAAkB,KAAAgiC,aAAAljC,KAAA2jC,aAAA,IAEA3jC,KAAAkB,KAAAuhC,gBAAAziC,KAAA2jC,eAMA,QAAArB,IAAA5D,GACAA,EAAA1+B,KAAAkB,KAAAuhC,gBAAAziC,KAAAO,MACAP,KAAAkB,KAAAgiC,aAAAljC,KAAAO,KAAAiD,EAAAxD,KAAA4jC,cAGA,QAAAvB,IAAA3D,GACAA,EAAA1+B,KAAAkB,KAAA2iC,kBAAA7jC,KAAAoiC,UAAApiC,KAAAO,KAAAgS,MAAAvS,KAAAO,KAAAuH,QAAA,SACA9H,KAAAkB,KAAA4iC,eAAA9jC,KAAAoiC,UAAApiC,KAAAO,KAAAgS,MAAAvS,KAAAO,KAAAuH,QAAA,QAAAtE,EAAAxD,KAAA4jC,cAyBA,QAAAG,IAAA7iC,EAAAiY,GAGA,IAFA,GAAA6qB,GAAA,SAAA7qB,EAEAjY,GAAA,CACA,GAAAA,EAAA+iC,cAAA/iC,EAAA+iC,aAAAD,GAAA,MAAA9iC,GAAA+/B,aAAA+C,EACA9iC,KAAAoC,WAGA,MAAA4gC,IAAA/qB,GAmPA,QAAAgrB,IAAAC,EAAA5jC,EAAAiM,GACA,IAAAjM,EACA4jC,EAAA5jC,OAAA,EACI,SAAAA,EACJ4jC,EAAA5jC,OAAA,EACI,UAAAA,GAAA,MAAAA,EACJ4jC,EAAA5jC,OAAA,EAEA4jC,EAAA5jC,OAGA,IAAAw2B,GAAAoN,EAAAn6B,QAAAm6B,OAMA,OALAA,GAAAn6B,QAAAm6B,UAAA5jC,MACAiM,IAAA23B,EAAAn6B,QAAAq1B,WAAApgB,SAAA8X,IAAAoN,EAAA5jC,OACA4jC,EAAAn6B,QAAAo6B,wBAGAD,EAAA5jC,MAMA,QAAA8jC,MAA2B,MAAAhF,IAC3B,QAAAiF,IAAA52B,GACA2xB,IAAA,EACA3xB,IACA2xB,IAAA,EAmGA,QAAAkF,IAAApjB,EAAAqjB,GACA,GAAAC,GAAAD,EAAA,WACA,OAAArjB,IACAujB,GAAAriB,UAAA,IAAAoiB,EAAA,IAAAtjB,EAAA,MAAAsjB,EAAA,MACAh8B,EAAAi8B,GAAA/gB,WAAA,GAAA0b,eAIA,QAAAsF,IAAA5c,EAAA6c,GAGA,IAFA,GAAA58B,GAAA+f,EAAAvjB,OAEAwD,KACA,GAAA+f,EAAA/f,GAAA1H,OAAAskC,EAAAtkC,KACA,QAIA,UAGA,QAAAukC,IAAAtoB,EAAA/U,EAAAiT,EAAAK,GACA,GAAAgqB,GAAAvoB,EAAAuoB,OAEAhqB,IACAgqB,EAAAnpB,QAAAb,GAuMA,QAAAiqB,IAAAC,EAAAr+B,EAAAwG,EAAAoP,GACA,GAAAyoB,EAAA7kC,KAAA6kC,EAAA7kC,IAAA8kC,QAEA,MADAD,GAAA7kC,IAAA8kC,QAAAC,WAAAp9B,MAAoDnB,UAAAwG,YACpD63B,CAGA,IAAAG,GAEAD,IAAsBv+B,UAAAwG,YAEtBi4B,GACA3kC,IAAA,WACA,eAAAukC,KAAAzkC,MAAAykC,EAAAvkC,IAAApD,KAAA0C,OAEAI,IAAA,SAAAI,GACA4kC,IAEA,SAAAH,GACAA,EAAAzkC,QAEAykC,EAAA7kC,IAAA9C,KAAA0C,KAAAQ,GAGAgc,EAAAomB,SACAwC,GAAA,EACAD,EAAAxgC,QAAA,SAAAsI,GACA,GAAArG,GAAAqG,EAAArG,QACAwG,EAAAH,EAAAG,OAEAxG,GAAAxG,IAAAgN,EAAA5M,KAEA4kC,GAAA,KAEAE,YAAA,EAKA,OAFAD,GAAAjlC,IAAA8kC,SAA6BC,aAAAF,sBAE7BI,EAGA,QAAAE,IAAAF,EAAAz+B,EAAAwG,GACA,IAAAi4B,EAAAjlC,MAAAilC,EAAAjlC,IAAA8kC,QAAA,QAIA,KAFA,GAAAC,GAAAE,EAAAjlC,IAAA8kC,QACAj9B,EAAAk9B,EAAA1gC,OACAwD,KAAA,CACA,GAAAu9B,GAAAL,EAAAl9B,EACA,IAAAu9B,EAAA5+B,aAAA4+B,EAAAp4B,YAEA,MADA+3B,GAAA18B,OAAAR,EAAA,IACA,GAoGA,QAAAw9B,IAAAC,GACA,GAAAC,GAAAD,EACA9hC,QAAA,kBAAAgiC,GAA2C,MAAAA,GAAAntB,MAAA,MAAA5I,KAAA,QAC3C4I,MAAA,MAEAotB,EAAAF,EAAAlhC,OAAA,IACAkhC,EAAApzB,MAAA,GAAAmQ,OAAA,SAAA4gB,EAAAwC,GACA,MAAA7qB,MAAAC,IAAAooB,EAAA,OAAA/1B,KAAAu4B,GAAA,GAAArhC,SACKshC,IAEL,OAAAJ,GAAA/2B,IAAA,SAAAk3B,EAAA79B,GACA,cAAAA,EAAA69B,EAAA1gB,UAAAygB,GAAAC,KACIj2B,KAAA,MAIJ,QAAAm2B,IAAAvvB,GACA,IAAAA,EAAA,QAQA,QANAkvB,GAAAlvB,EAAAgC,MAAA,MACAlY,EAAA0lC,GAAA1lC,KAAA,YAEA2lC,KAEA3hC,EAAAohC,EAAAlhC,OACAwD,EAAA,EAAmBA,EAAA1D,EAAS0D,GAAA,GAC5B,GAAA69B,GAAAH,EAAA19B,EAEA,KAAA69B,EAAAh+B,QAAAvH,GACA,MAAA2lC,GAAAr2B,KAAA,KAEAq2B,GAAAn+B,KAAA+9B,IA6WA,QAAAK,IAAAv/B,EAAA7B,EAAAqhC,GACA,GAAAC,GACAC,EAGAC,EACAC,EACAC,CA+BA,OA7BA,kBAAAL,KACAC,EAAAnkC,EAAAkkC,EAAAx/B,GACA2/B,EAAAH,EAAA3iC,WACA+iC,GAAA,GAGA,gBAAAJ,KACAC,EAAA1K,GAAAyK,EAAAx/B,GACA2/B,EAAAH,GAGA,gBAAAA,KACA,gBAAAA,GAAA1lC,KACA2lC,EAAA1K,GAAAyK,EAAA1lC,IAAAkG,GACA2/B,EAAAH,EAAA1lC,KACK,kBAAA0lC,GAAA1lC,KACL2lC,EAAAnkC,EAAAkkC,EAAA1lC,IAAAkG,GACA2/B,EAAAH,EAAA1lC,IAAA+C,WACA+iC,GAAA,GAEAzgC,EAAA,8CAAAhB,GAGA,kBAAAqhC,GAAAhmC,MACAkmC,EAAApkC,EAAAkkC,EAAAhmC,IAAAwG,GACA6/B,EAAAL,EAAAhmC,IAAAqD,cAKA4iC,SACAC,SACAC,eACAE,eACAD,kBAmBA,QAAAE,IAAA9/B,EAAAuI,GACAzQ,GAAAC,OAAAgoC,KAEAC,GAAAhgC,GAGAigC,GAAAjgC,EAAA,QAAqClG,IAAAomC,KAGrCC,GAAAv6B,KAAA5F,EAAAuI,GAGA63B,GAAAriC,QAAA,SAAApE,GACAqG,EAAArG,GAAA8D,EAAAy1B,GAAAlzB,EAAA2e,YAAAhlB,IAAA,MAAA4O,EAAA5O,KAIA,IAAA8L,GAAA,GAAA46B,KACAxqB,MAAAyqB,GAAAtgC,IAAA6V,MAAAtN,GACAnQ,KAAAy/B,GAAA/rB,KAAA9L,EAAA2e,YAAA3e,EAAAuI,GACAvI,WAGAA,GAAAyF,WAGA,IAAA86B,GAAA9iC,EAAAy1B,GAAAlzB,EAAA2e,YAAA8Y,UAAA8I,UAAAh4B,EAAAg4B,SAEA,QAAApiC,KAAAoiC,GAAA,CACA,GAAAf,GAAAD,GAAAv/B,EAAA7B,EAAAoiC,EAAApiC,GACAsH,GAAA+6B,QAAAriC,EAAAqhC,IAIA,QAAAiB,IAAAC,GAKA,IAJA,GAAAC,MACA1hC,EAAA0hC,EAAA97B,OAAAtF,MAAAohC,EAAAD,GAEAr/B,EAAApC,EAAApB,OACAwD,MACAs/B,EAAAz/B,QAAAjC,EAAAoC,KACAs/B,EAAArpB,QAAArY,EAAAoC,GAIA,OAAAs/B,GAGA,QAAAL,IAAAtgC,EAAA4gC,EAAAr4B,GAiCA,QAAAs4B,GAAAC,GASA,MARA,gBAAAA,KACAA,EAAAhhC,EAAA,WAAAE,EAAA8gC,GAEAA,GACA3hC,EAAAuB,GAAAogC,EAAA,aAIAA,EAzCAF,IAAA54B,IAAA64B,EACA,IAAAhrB,GAAAtU,EAAAgH,EAAAsN,OAAA7N,IAAA64B,GAEAE,KACAC,GAAAJ,EAAA/qB,EACA7V,GAAAI,SAAAJ,EAAAG,UACA6gC,EAAA7/B,KAAAnB,EAAAI,OAAAqF,UAAAsxB,UAEAiK,EAAA7/B,KAAA4/B,EAEA,IAAA5oC,GAAA,SAAAoQ,KAAApQ,MAAA6H,EAAA7H,MACA8oC,EAAA,gBAAA14B,KAAA04B,aAAAjhC,EAAAihC,YAEA,IAAA9oC,EAAA,CACA,IAAA+oC,GACA,SAAA9hC,OAAA,qEAGA6hC,IACAF,EAAA5/B,KAAAggC,IAGAJ,EAAA5/B,KAAAigC,IAOA,MAJAH,IACAF,EAAA5/B,KAAAkgC,IAGAZ,GAAAO,GAgBA,QAAAhB,IAAAhgC,GAGAA,EAAAshC,MAAA,KAAAC,KAGAvhC,EAAAmO,MAAA+kB,GAAA,MAIAlzB,EAAAm1B,WAGAn1B,EAAA47B,SAGA57B,EAAAzG,MAAA,KACAyG,EAAA0M,eAGA1M,EAAAwL,gBACAxL,EAAAgM,yBAGAhM,EAAA6Z,cAEA7Z,EAAAiK,YACAjK,EAAAzI,KAAAyI,EACAA,EAAAI,OAAAJ,EAAAqM,UAAA,MAKA,QAAA6zB,MACA,SAAA9gC,OAAA,8FAGA,QAAAoiC,IAAAl9B,EAAAtE,GACA,MAAAsE,GAAAtE,EAAAshC,SAAAh9B,EAAAtE,EAAAshC,WAGA,QAAA17B,IAAA67B,EAAAzhC,GACA,GAAA0hC,GAAAF,GAAAC,EAAAn9B,MAAAtE,EAMA,KAJAyhC,EAAAE,KAAA/7B,KAAA5F,GAIA0hC,EAAA7jC,QACA+H,GAAA67B,EAAAC,EAAAxiC,eAGAuiC,GAAAn9B,MAAAtE,EAAAshC,OAgCA,QAAAM,IAAA5hC,EAAA6hC,EAAAt5B,GACAhD,OAAAC,KAAAxF,EAAAyF,UAAAq8B,cAAA/jC,QAAA,SAAAI,GACA,GAAA4jC,GAAA/hC,EAAAyF,UAAAq8B,aAAA3jC,EAEA6B,GAAAyF,UAAA7L,MAAAmO,eAAA5J,IACA4jC,EAAAvoC,IAAAwG,EAAAyF,UAAA7L,MAAAuE,MAKA65B,GAAAlsB,KAAA9L,EAAA2e,YAAA3e,EAAA6hC,GAEAG,GAAAp8B,KAAA5F,GACAiiC,GAAAC,MAAAliC,EAEA,IAAAoF,EAGA,IAAApF,EAAA9H,SAAA,CACA,GAAAyjB,IAEApT,EAAAoT,QAAA3b,EAAAuc,SACAZ,EAAApT,EAAAoT,OAAApT,EAAAoT,OAAAhQ,WAEA3L,EAAAuc,OACAZ,EAAAxa,KAAAnB,EAAAuc,QAIAvc,EAAAoF,WAAA,GAAA+8B,KACAh3B,MAAAnL,EACA9H,SAAA8H,EAAA9H,SACAyjB,WACKrgB,KAAA0E,EAAAyF,WAKL,GAFAw8B,GAAA56B,IAAArH,GAEAoF,EAAA,CAEA,GAAAnN,GAAAkE,EAAA6D,EAAA/H,GACA,IAAAA,EAAA,CACA,GAAAuK,GAAAxC,EAAAwQ,OAAAvY,EAAA+H,EAAA6c,OAEA/kB,IAAAsqC,gBACA5/B,EAAA,eAAAorB,GAKA,KAJA/tB,GAAA,kOACAD,EAAA,sCAA2DI;GAC3DX,EAAAuuB,GAEAA,MAqVA,QAAAyU,IAAAp4B,GAEA,GAAAhK,GAAAgK,EAAAjK,OAEA,GAIA,KAHA,GAAAuL,GAAAtL,EAAA+L,sBAEA3K,EAAAkK,EAAA1N,OACAwD,KAAA,CACA,GAAA1H,GAAA4R,EAAAlK,GACAoK,EAAAF,EAAA,IAAA5R,EAEA8R,GAAAxE,KAAAgD,KACAwB,EAAAxD,IAAAgC,EAAAhK,UAEAgK,EAAAsB,YAAApK,KAAAsK,UAGIxL,IAAAG,QAGJ,QAAAkiC,IAAAr4B,GAGA,IAFA,GAAAhK,GAAAgK,EAAAjK,QAEAC,GAAA,CACA,GAAAwL,GAAAxL,EAAA+L,sBAAA,IAAA/B,EAAA,KACAwB,MAAAouB,OAAA5vB,GAEAhK,IAAAG,QAIA,QAAAmiC,IAAA92B,GACAA,EAAA82B,YAyeA,QAAAC,IAAAn/B,GAEA,GAAA/I,GAAA+I,EAAA/I,KACA2F,EAAAoD,EAAArD,OAEA,GAIA,KAHA,GAAAuL,GAAAtL,EAAAuL,aAEAnK,EAAAkK,EAAA1N,OACAwD,KAAA,CACA,GAAAkI,GAAAgC,EAAAlK,GACAoK,EAAAF,EAAA,IAAAhC,EAEAkC,GAAAxE,KAAA3M,KACAmR,EAAAxD,IAAA3N,GAEA+I,EAAAkI,YAAApK,KAAAsK,UAGIxL,IAAAG,QAGJ,QAAAqiC,IAAAC,EAAA1iC,GACAH,EAAA,OAAA6iC,EAAA,8IAA4L1iC,YAkH5L,QAAA2iC,MACAvpC,KAAA8Q,SAAAoO,QAAAlI,eAyCA,QAAAwyB,IAAAvG,EAAAniC,EAAAyhC,GACA,GAAAkH,GAAA,GAAAxG,EAAA,eACA,OAAAniC,GAAA2oC,KAAA3oC,EAAA2oC,GAAA,GAAAC,IAAAD,EAAA3oC,EAAAyhC,IAyCA,QAAAA,MACA,GAAAoH,GAAA3pC,KAAA4pC,SAAArpB,OAAA,SAAAnb,GAAkD,MAAAA,GAAAlE,MAAAkE,EAAAlE,KAAA2W,UAAmCjJ,IAAA,SAAAxJ,GAAsB,MAAAA,GAAA6E,QAAAg3B,aAAA,WAC3GsG,IAEA,OADAoC,GAAAhlC,QAAA,SAAAijB,GAA+B5f,EAAAu/B,EAAA3f,IAAA2f,EAAAx/B,KAAA6f,KAC/B2f,EA+KA,QAAAsC,MACAN,GAAAjsC,KAAA0C,KAEA,IAAAQ,GAAAR,KAAA8Q,SAAAoO,QAAApe,MAAAJ,KACAV,MAAAQ,MAAA6H,QAAA7H,EAAA,GAAAA,EAGA,QAAAspC,IAAAC,GACA,GAAAC,EAEA,mBACA,GAAA5pB,GAAApgB,IAEAgqC,IAAAC,aAAAD,GAEAA,EAAAlhC,WAAA,WACA,GAAAoW,GAAAkB,EAAAtP,SAAAoO,OACAA,GAAAU,UAAA2pB,GAAAjsC,KAAA8iB,GACA4pB,EAAA,MACKD,IA+FL,QAAAG,IAAAC,GACA,MAAAA,GAAAC,gBACA1hC,EAAAyhC,EAAAC,iBACAD,EAAAh7B,QACAzG,EAAAyhC,EAAAh7B,SAAAoR,OAAA,SAAAzE,GAA8D,MAAAA,GAAA4mB,cAiI9D,QAAA2H,IAAAZ,GACA,MAAAa,IAAAb,KAAAa,GAAAb,OAsDA,QAAAc,MACA,GAAA1yB,GAAA7X,KAAA4pC,SAAArpB,OAAA,SAAAnb,GAAuD,MAAAA,GAAAlE,KAAA2W,SACvD,IAAAA,EAAApT,OAAA,EACA,MAAAoT,GAAA,GAAA5N,QAAAg3B,aAAA,SAwMA,QAAAuJ,IAAAnZ,GACA,MAAAA,IACAA,EAAAvyB,SAAAyxB,GACA,IAAAc,EAAAvyB,SAAAyxB,EAAA9rB,QACA4sB,EAAAvyB,SAAAyxB,EAAA,GAAA7I,IAAA+M,KACApD,EAAAvyB,SAAAyxB,EAAA,GAAAxsB,EAGA,QAAA0mC,IAAAxgC,GACA,GAAAq1B,GAAAr1B,EAAAygC,eAIA,IAAAzgC,EAAAg3B,aAAA,oBAAAuJ,GAAAlL,EAAAqL,iBAEA,MAAAH,IAAAlL,EAAA9+B,OAAAoqC,GAAA,IAIA,cAAA3gC,EAAA1J,KAAA,CACA,GAAA6G,GAAA6C,EAAAg3B,aAAA,OAEA,cAAA75B,GAAA,aAAAA,EAAA,CACA,GAAAyjC,GAAAL,GAAAlL,EAAA/+B,MACAuqC,EAAAN,GAAAlL,EAAAznB,QAGA,IAAAgzB,GAAAC,EAAA,CACA,aAAA1jC,EAIA,MAAA2jC,GAHAvkC,GAAA,qGAA0HI,QAAAqD,EAAA9L,OAO1H,GAAA0sC,EACA,gBAAAzjC,EAAA4jC,GAAAC,EAGA,IAAAH,EACA,gBAAA1jC,EAAA8jC,GAAAH,GAIA,eAAA3jC,GAAAojC,GAAAlL,EAAA9+B,OACA2qC,GAGAX,GAAAlL,EAAA9+B,OACA,WAAA4G,GAAA,UAAAA,EAAAgkC,GAAAC,GAGA,KAIA,iBAAAphC,EAAA1J,MAAAiqC,GAAAlL,EAAA9+B,OACAyJ,EAAAg3B,aAAA,YAAAqK,GAAAC,GAIA,aAAAthC,EAAA1J,MAAAiqC,GAAAlL,EAAA9+B,OACA6qC,GADA,OAKA,QAAAG,IAAAn5B,GACAA,EAAA82B,YAwXA,QAAAsC,IAAAxhC,GACA,GAAAq1B,GAAAr1B,EAAAygC,gBAEAgB,EAAApM,EAAAl4B,KACA+7B,EAAA7D,EAAA9+B,MACAmrC,EAAArM,EAAA/+B,IAEA,IAAAmrC,GAAA,UAAAA,EAAAlrC,OAAA2iC,GAAAwI,EAAAj8B,aAIA,MAAAyzB,GAAAZ,aAAAoJ,EAAAj8B,aAAA5O,MAAAJ,OAAA,OAKA,QAAAkrC,IAAAva,GACA,GAAAjQ,GAAAiQ,EAAA5tB,UACA,OAAA2d,GAAA,IAAAA,EAAA,GAGA,QAAAyqB,IAAA5hC,GAEA,IADA,GAAAhC,GAAAgC,EAAAkI,YAAA1N,OACAwD,KAAA,CACA,GAAAoK,GAAApI,EAAAkI,YAAAlK,EACAoK,GAAAouB,OAAAx2B,EAAA/I,OAIA,QAAA4qC,IAAA7hC,GAEA,GAAA8hC,GAAA9hC,EAAAg3B,aAAA,QACA,IAAA8K,EAAA,MAAAA,EAGA,YAAA9hC,EAAA1J,KAAA,MAAAyrC,GAEA,IAAAhlC,GAAAiD,EAAAjD,MAEA,OAAAA,GAEA,kBAAAA,EAAAzG,KAAA+nB,GAGAthB,EAAA9F,KAAA4gC,aAGA73B,EAAArD,QAAA/H,GAAAijC,aAyBA,QAAAmK,MACA,GAAAhiC,GAAAjK,KAAA8Q,SAAAC,KAEA/C,IAAA1L,QACA2H,EAAAiiC,aAAAvnC,QAAAwnC,IACAn+B,GAAAC,MAGA,QAAAk+B,IAAAjtB,GACAA,EAAApe,MAAAV,IAAA8e,EAAA2c,YAiPA,QAAAuQ,IAAAt6B,GACA,GAAAhT,GAAAgT,EAAAhT,SAAAyxB,EACAlkB,EAAAyF,EAAA7H,QAAApD,SAAAwF,UACAggC,EAAAhgC,EAAA7L,KAEA,KAAA1B,EAAA2F,QAAA3F,EAAA,GAAA4oB,IAAA+M,IACA3iB,EAAAhR,MAAAg/B,GAAAhuB,EAAAT,eAAAvS,EAAA,IAEAgT,EAAAhR,QACA2F,EAAA,OAAAqL,EAAA,YAAmDhT,EAAA,+HAAkJ8H,QAAAkL,EAAA7H,QAAApD,WACrMiL,EAAAT,eAAAzK,QAAAlG,IAAAoR,EAAAvR,MACAuR,EAAAhR,MAAAgR,EAAAT,eAAAyE,cAAAQ,QAAAxE,EAAAvR,OAGAuR,EAAAwL,KAAAjR,EAAAgK,WAAAvE,EAAAvR,KAAAuR,EAAAhR,MAAAhC,EAAA,GAAAiL,GAEA1B,SAAAyJ,EAAAhR,MAAAJ,OAAAoR,EAAAvR,OAAA8rC,IACAv6B,EAAAhR,MAAAV,IAAAisC,EAAAv6B,EAAAvR,SAKAuR,EAAAw6B,cAAA,GAAAvD,KACAh3B,MAAAD,EACAhT,aACKoD,OAEL4P,EAAAhR,MAAAuL,EAAAiK,QAAAxE,EAAAvR,MACAuR,EAAAhR,MAAAV,IAAA0R,EAAAw6B,cAAAC,WAGAz6B,EAAAw6B,cAAAx3B,OAAA,WACAi0B,GAAA1K,UAAAvpB,OAAAxX,KAAAwU,EAAAw6B,eAEAt+B,GAAAiV,aAAA,WACAnR,EAAAw6B,cAAA7/B,SACAqF,EAAAhR,MAAAV,IAAA0R,EAAAw6B,cAAAC,eAoGA,QAAAC,IAAA5lC,EAAArG,EAAA8Q,GAEA,GAAAwiB,GAAA4Y,GAAA7lC,EAAArG,EAAA8Q,MACA,IAAAwiB,EAAA,MAAAA,EAIA,IADAA,EAAA9M,GAAAkV,OAAA17B,GAAmCmsC,SAAA,IACnC,CAEA,GAAAnd,GAAAxI,GAAAwV,SAAA1I,EAAAjtB,EAMA,OAHA2oB,GAAA9xB,GAAAqH,EAAA8B,EAAAyyB,SAAA9J,EAAA9xB,GAGAmJ,EAAAyyB,SAAA94B,GAAAgvB,EAAA7H,GAIA,QAAA+kB,IAAA7lC,EAAArG,EAAA8Q,GAEA,GAAAwiB,GAAA8Y,GAAApsC,EAAA8Q,EAAAU,MACA,IAAA8hB,EAAA,MAAAA,EAGA,IAAAhtB,GAAAC,EAAA,WAAAF,EAAArG,EAEA,IAAAsG,EAAA,CAEAgtB,EAAAhtB,EAAAwyB,SAAA94B,EAGA,IAAAoN,EAOA,IANA,kBAAAkmB,KACAlmB,EAAAkmB,EAAA3xB,KAAA2E,GACA8G,EAAAi/B,QAAA/lC,EAAAwyB,SAAA1qB,eAAApO,GACAszB,EAAAlmB,EAAArQ,KAAAsJ,EAAAmgB,MAGA8M,GAAA,KAAAA,EAEA,WADArtB,GAAAqmC,GAAAtsC,EAAA,qBAAwEqG,WAMxE,KAAAmgB,GAAAmV,SAAArI,GAAA,CAEA,GAAAtE,GAAAxI,GAAAwV,SAAA1I,EAAAhtB,EAIA0oB,GAAA9xB,GACA+I,EAAA,2DAAoCjG,GAAiDqG,WAKrF,IAAAtG,GAAAqN,EAAA9G,EAAAimC,GAAAjmC,EAAAtG,EAGAD,GAAA+4B,SAAA94B,GAAAszB,EAAAtE,EAAA7H,EAMA,MAFA/Z,KAAAkmB,EAAAkZ,IAAAp/B,GAEAkmB,EAAAjM,EAAAiM,EAAAnM,EAAAmM,GAGA,QAAAiZ,IAAAlmC,EAAA7B,GACA,MAAA6B,GAAAyyB,SAAA1qB,eAAA5J,GACA6B,EACAomC,GAAApmC,EAAA2e,YAAAxgB,GAGA,QAAAioC,IAAAznB,EAAAxgB,GACA,GAAAwgB,EACA,MAAAA,GAAA8T,SAAA1qB,eAAA5J,GACAwgB,EACAynB,GAAAznB,EAAA0nB,QAAAloC,GAGA,QAAA4nC,IAAApsC,EAAAyG,GACA,GAAAA,EAAA,CACA,GAAAA,EAAAlI,UAAAkI,EAAAlI,SAAArB,GAAAuJ,EAAAlI,SAAArB,EAAA8C,GACA,MAAAyG,GAAAlI,SAAArB,EAAA8C,EACK,IAAAyG,EAAAqK,gBAAArK,EAAAqK,eAAAU,MACL,MAAA46B,IAAApsC,EAAAyG,EAAAqK,eAAAU,QAsKA,QAAAm7B,IAAA3sC,EAAAszB,EAAAjtB,GACA,GAAA2oB,EAEA,KACAA,EAAAxI,GAAAmD,MAAA2J,EAAA9M,GAAAoV,gBAAAv1B,IACI,MAAA8C,GACJlD,EAAA,4CAAAjG,EAAA,MAAAmJ,EAAA,SAGA,MAAA6lB,KAAqB7H,MAicrB,QAAAylB,IAAA3sC,GACA,OAAAA,GACAwE,EAAAxE,IAAA,IAAAA,EAAAiE,QACAgB,EAAAjF,IAAA,IAAA2L,OAAAC,KAAA5L,GAAAiE,OAGA,QAAA2oC,IAAA5sC,EAAA6sC,GACA,MAAAA,IAAAroC,EAAAxE,GAAA8sC,GACA7nC,EAAAjF,IAAA,kBAAAA,GAAA+sC,GACAllC,SAAA7H,EAAA,KACA81B,GAkMA,QAAAkX,IAAAC,EAAA9K,GAEA,IADA,GAAA16B,GAAAwlC,EAAAhpC,OACAwD,KACA,GAAAwlC,EAAAxlC,IAAA06B,EAAA,SAsSA,QAAA+K,MACAC,IAAA7qC,GAAA8qC,IAGA,QAAAC,MACAF,IAAA,EAGA,QAAAG,MACAH,IAAA,EAKA,QAAAI,IAAArpC,GACA,MAAAA,GAAAd,QAAAoqC,GAAA,IAKA,QAAAC,IAAA7sB,GACA,MAAAA,IAEA8sB,GAAArgC,KAAAuT,OAAA,IAAAA,GAEAA,EAAAxd,QAAA,kBAAAyJ,GAAqD,UAAAA,EAAAjJ,iBAJrD,GAqOA,QAAA+pC,IAAAjtC,EAAAuhB,GACAA,EACAvhB,EAAAgiC,aAAA,QAAAzgB,IAIAvhB,EAAA+/B,aAAA,SACA//B,EAAAuhC,gBAAA,UAkWA,QAAA2L,IAAA9lB,EAAApnB,EAAAkiB,GACA,GAAAof,KAGA,UAAAla,GAAA,KAAAA,EAAA,MAAAka,EAEA,IAAAvvB,GACAuJ,EACA6xB,CAEAC,MAAA9xB,EAAA+xB,GAAArtC,EAAAwjC,WACAzxB,EAAAhJ,GAAA,OACAgJ,EAAAqP,UAAA9F,EAAA,GAAA8L,EAAA9L,EAAA,GACAvJ,IAAA7P,cAAA,MAEA,WAAA6P,EAAAyxB,UACA2J,EAAAp7B,EAAA9D,QAAA8D,EAAA8vB,iBAIA7hC,EAAA4gC,eAAAkK,IACA/4B,EAAAhJ,GAAA,OACAgJ,EAAAqP,UAAA,kBAAAgG,EAAA,SACArV,IAAA7P,cAAA,OAGA,aAAAlC,EAAAwjC,SACAzxB,EAAAu7B,GAAA,OAEA,mBAAAv7B,GAAAw7B,YACAx7B,EAAAw7B,YAAAnmB,EAEArV,EAAAqP,UAAAgG,IAKArV,EAAAhJ,GAAA/I,EAAAwjC,SACAzxB,EAAAqP,UAAAgG,EAEA,WAAArV,EAAAyxB,UACA2J,EAAAp7B,EAAA9D,QAAA8D,EAAA8vB,gBAKA,KADA,GAAA/iB,GACAA,EAAA/M,EAAAy7B,YACAlM,EAAAz6B,KAAAiY,GACAoD,EAAAurB,YAAA3uB,EAQA,IAAA/X,EACA,eAAA/G,EAAAwjC,QAEA,IADAz8B,EAAAu6B,EAAA/9B,OACAwD,KACAu6B,EAAAv6B,KAAAomC,IACA7L,EAAAv6B,GAAAy6B,UAAA,EAKA,OAAAF,GAGA,QAAAv4B,IAAAy6B,GACA,MAAAkK,IAAAlK,KAAAkK,GAAAlK,GAAA8J,GAAA9J,IA0NA,QAAAmK,IAAAjoC,EAAArG,GACA,GACAuuC,GADAjoC,EAAAC,EAAA,aAAAF,EAAArG,EAGA,IAAAsG,IACAioC,EAAAjoC,EAAAjH,WAAAW,IAGAuuC,EAAA7B,SAAA,CAEA,GAAAt/B,GAAAmhC,EAAA5sC,KAAA2E,EAIA,IAHA8G,EAAAi/B,QAAA/lC,EAAAjH,WAAA+O,eAAApO,GACAuuC,EAAAnhC,KAEAmhC,EAEA,WADAtoC,GAAAqmC,GAAAtsC,EAAA,yBAA8EqG,WAI9E,iBAAAkoC,KAEAA,EAAAD,GAAAjoC,EAAAkoC,IAGAA,EAAA/B,IAAAp/B,EACA9G,EAAAjH,WAAAW,GAAAuuC,EAIA,MAAAA,GA2BA,QAAAC,IAAA5/B,GACA,mBAAAA,GAAArQ,SACA,UAAAkwC,IAAA7/B,EAGA,IAAAA,EAAArQ,SAAA4oB,IAAAiR,GAAA,CAEA,GAAAsW,GAAAJ,GAAA1/B,EAAAkC,eAAAzK,QAAAuI,EAAArQ,SAAA4K,EACA,IAAAulC,EACA,UAAAH,IAAA3/B,EAAA8/B,EAGA,IAAAvK,GAAAv1B,EAAArQ,SAAA4K,EAAAtF,cAEA8qC,EAAAC,GAAAzK,IAAA0K,EACA,WAAAF,GAAA//B,GAGA,GAAAkgC,EAGA,IAAAlgC,EAAArQ,SAAA4oB,IAAAqK,GAAA,CACA,GAAAlzB,GAAAsQ,EAAA4C,QACAlT,KAAAuI,OAAAi4B,IAAAxgC,EAAAuI,OAAAuxB,MACA95B,EAAAqhC,GAAA/wB,EAAAkC,iBAEAlC,EAAAlF,QAAApL,EAEAwwC,EAAAxwC,EAAAuI,OAAAi4B,GAAAiQ,GAAAC,OAEAF,GAAAG,GAAArgC,EAAArQ,SAAA4oB,EAGA,KAAA2nB,EAAA,SAAArpC,OAAA,0BAAAmJ,EAAArQ,SAAA,EAEA,WAAAuwC,GAAAlgC,GAIA,QAAAsgC,IAAAj+B,EAAAmM,EAAA+xB,EAAAC,GAGA,MAFA,UAAAA,MAAA,GAEAn+B,EAAA5C,IAAA,SAAAkD,GACA,GAAAA,EAAA1K,OAAAwoC,GACA,MAAA99B,GAAAhT,QAGA,IAAAgT,EAAA9F,SACA,MAAA8F,GAAA9F,SAAA0F,WACAI,EAAA9F,SAAA0F,WAAA9C,IAAA,SAAA5C,GACA,MAAAyjC,IAAAzjC,EAAAwF,MAAAmM,EAAA+xB,EAAAC,KACO9/B,KAAA,IAEP4/B,GAAA39B,EAAA9F,SAAAwF,MAAAmM,EAAA+xB,EAAAC,EAIA,IAAAE,GAAA,GAAAH,EAAA,IAAAC,IACA7uC,EAAAgR,EAAAhR,OAAAgR,EAAAg+B,QAQA,OANAnyB,GAAAkyB,GAAA/uC,EACAA,EAAA0b,QACA1b,EAAAivC,aACAjvC,EAAAJ,MACA2H,OAEA,KAAcwnC,EAAA,MACVhgC,KAAA,IAGJ,QAAAmgC,IAAAl+B,GACAA,EAAAyF,UAAA,GAuWA,QAAA04B,IAAAnxC,GACAo/B,GAAAxrB,KAAA,KAAA1S,MAA2ClB,YAE3C,IAAAikB,GAAA/iB,KAAA+iB,kBACA/iB,MAAA+iB,oBAAA,CAMA,IAAAlS,GAAA7Q,KAAA6Q,SACAA,OAAAq/B,eAAA,GACAlwC,KAAAuX,WACA1G,MAAAq/B,eAAA,GAGAlwC,KAAAgM,SAAAsL,SAAAC,UAAA,GAEAvX,KAAAgM,SAAA,GAAA+8B,KACAjqC,SAAAkB,KAAAlB,SACAX,KAAA6B,KACA+R,MAAA/R,MAGA,IAAAojB,GAAAvgB,GACA7C,MAAAgM,SAAA9J,KAAAlC,KAAAqM,WAAA+K,OAAAgM,GAIAvS,EACA7Q,KAAAgM,SAAAmkC,iBAAAtwB,aAAAuD,EAAAvS,EAAAu/B,gBAEApwC,KAAAnB,GAAAghB,aAAAuD,EAAApjB,KAAA2f,QAGA3f,KAAA+iB,qBAKA,QAAAstB,IAAAjjC,EAAA5M,GACA,GAAAoG,GAAA5G,IAEA,OAAAI,GAAAwG,EAAA2H,EAAA3H,EAAAwG,EAAA5M,IASA,QAAA8vC,IAAAljC,EAAA0B,GACA,MAAAD,GAAA7O,KAAAoN,EAAA/E,SAAAyG,GAAA,GAAAA,GAQA,QAAAyhC,MACA,GAAAvwC,KAAAujB,SAEA,MADA/c,GAAA,kFACAgqC,GAAArnC,SAGAnJ,MAAAujB,UAAA,EACAvjB,KAAAgM,SAAAsL,SACAtX,KAAAqM,UAAAgL,WAEArX,KAAAygB,WAAA9b,QAAAoS,IAEA/W,KAAAgM,SAAA4T,UAAA5f,KAAAnB,GAAAmR,uBACAzH,EAAAvI,KAAAnB,GAAAmR,sBAAAhQ,MAGAA,KAAAkwC,eAAA,CACA,IAAA9mC,GAAApJ,KAAAgM,SAAA4T,SAAA5f,KAAAuX,WAAAi5B,GAAArnC,SAIA,OAFAsnC,IAAAjkC,KAAAxM,MAEAoJ,EAGA,QAAAsnC,IAAAtjC,GACA,mBAAAA,GACA,SAAA5D,WAAAmnC,GAGA,OAAAvwC,GAAAJ,KAAAkO,EAAAlO,KAAAoN,GAAAwB,IAAA,SAAArR,GAAkE,OAAAA,KAAAmD,UAGlE,QAAAkwC,MACA,GAAAruB,IAAAviB,KAAAmjB,OAAA1X,OAAAzL,KAAA6S,oBAAAjE,IAAA,SAAApR,GAAqF,MAAAA,GAAA2lB,SACrF0tB,EAAA1kC,OAAAC,KAAAmW,EAAAG,OAAA,SAAAouB,EAAA1zC,GAAuE,MAAA0zC,GAAA1zC,IAAA,EAAA0zC,OACvE,OAAAzuB,IAAAwuB,GAGA,QAAAE,MACA,MAAA/wC,MAAAgM,SAAAvI,UAAA,GAGA,QAAAutC,MACA,MAAAhxC,MAAAgM,SAAAvI,UAAA,GAGA,QAAAwtC,IAAA1wC,EAAAW,EAAAgwC,GAEAhwC,YAAAiwC,cAGA1rC,EAAAvE,KAEAgwC,EAAAhwC,GAWAA,KAAAlB,KAAAG,MAAAe,KAEAA,KAAA4P,UACA/K,EAAA,uCAAAxF,GAGA2wC,OACA,IAAAn/B,GAAA7Q,EAAA4P,SAAAC,MACAqgC,EAAA,GAAAC,KAAoCt/B,QAAAV,eAAAU,EAAAV,eAAA9Q,OAAA2wC,UACpCE,GAAAlvC,MAEA,IAAAkH,GAAA4E,GAAA1L,MAAAtC,MAAA,EAKA,OAJAgO,IAAAsjC,mBAAAF,GACApjC,GAAAC,MAEA7E,EAAAG,KAAA,WAA8B,MAAA6nC,GAAA95B,WAC9BlO,EAGA,QAAAmoC,IAAA9zB,GACA,GAAArU,GAAA4E,GAAA1L,OAGA,OAFAtC,MAAAqM,UAAAiC,QAAAnB,EAAAsQ,IAAmD+zB,UAAA,IAAkBjzB,SACrEvQ,GAAAC,MACA7E,EAKA,QAAAqoC,MACA,IAAAzxC,KAAAgM,SAAA4T,SAEA,MADApZ,GAAA,6EACAgqC,GAAArnC,SAGA,IAAAC,GAAA4E,GAAA1L,MAAAtC,MAAA,GAIAkwC,GAAAlwC,KAAA6Q,WAAA7Q,KAAA6Q,UAAAq/B,eAAAlwC,KAAAkwC,aAQA,OAPAlwC,MAAAgM,SAAAuL,SAAA24B,GAEA3nC,EAAAvI,KAAAnB,GAAAmR,sBAAAhQ,MAEA0xC,GAAAllC,KAAAxM,MAEAgO,GAAAC,MACA7E,EAKA,QAAAuoC,IAAAvkC,EAAAwR,GACA,GAAAxV,GAAA4E,GAAA1L,MAAAtC,MAAA,EAUA,OARAoN,GAGApN,KAAAqM,UAAAiC,QAAAnB,EAAAC,IAAAuK,mBAAAiH,KAAA,GAFA5e,KAAAqM,UAAAsL,oBAAA,GAKA3J,GAAAC,MAEA7E,EAsDA,QAAAwoC,IAAApW,EAAAqB,EAAAgV,GAEA,MAAAA,IAAAC,GAAAtW,EAAAqB,GAEA,WAEA,GAAA5zB,GAAA+zB,EAAA,UAAAh9B,MAAAk9B,EAAAl9B,KAAAk9B,MAUA,OARAl9B,MAAAk9B,OAAAL,EAEA5zB,EAAAuyB,EAAAr1B,MAAAnG,KAAAwE,WAEAw4B,IACAh9B,KAAAk9B,UAGAj0B,GAKAuyB,EAIA,QAAAsW,IAAAtW,EAAAqB,GACA,wBAAAA,IAAA,SAAAhvB,KAAA2tB,GAGA,QAAAuW,IAAAC,GAGA,IAFA,GAAA7iC,MAEA6iC,GACAC,GAAAD,EAAA7iC,GACA+iC,GAAAF,EAAA7iC,GAGA6iC,EADAA,EAAA/E,UAAAvuC,IACAszC,EAAA/E,OAMA,OAAA99B,GAGA,QAAA8iC,IAAAD,EAAA7iC,GACA4uB,GAAAp5B,QAAA,SAAAoF,GACAooC,GACApoC,EAAAqoC,YAAAJ,EAAA3T,UAAA2T,EACA7iC,EAAApF,EAAAxJ,QAIA,QAAA4xC,IAAA7xC,EAAA6O,EAAA5O,GACA,GAAAy9B,GAAA5xB,EAAAD,OAAAC,KAAA9L,EAAAC,GAEA6L,GAAA3H,UAEAu5B,EAAA7uB,EAAA5O,MACAy9B,EAAA7uB,EAAA5O,OAGA6L,EACAmU,OAAA,SAAAxb,GAA+B,QAAAA,IAAAi5B,MAC/Br5B,QAAA,SAAAI,GAAgC,MAAAi5B,GAAAj5B,GAAAzE,EAAAC,GAAAwE,MAGhC,QAAAmtC,IAAAF,EAAA7iC,GACAhD,OAAAC,KAAA4lC,EAAA3T,WAAA15B,QAAA,SAAAI,GACA,gBAAAA,EAAA,CAEA,GAAAvE,GAAAwxC,EAAA3T,UAAAt5B,EAEA,IAAAA,IAAAoK,IAKA,qBAAAA,GAAApK,IACA,kBAAAvE,IACA2O,EAAApK,GAAAo4B,QAAA,CAEA,GAAAl0B,GAAA6oC,EAAAtxC,EAAA28B,OAEA2U,KAAwBtxC,IAAA28B,SAGxBl0B,EAAA2oC,GAAAziC,EAAApK,GAAAo4B,QAAA38B,GAEAsxC,IAAwB7oC,EAAAk0B,QAAAl0B,GAExBkG,EAAApK,GAAAkE,OAjBAkG,GAAApK,GAAAvE,EAAA28B,QAAA38B,EAAA28B,QAAA38B,KAsBA,QAAA6xC,MAEA,IADA,GAAAljC,MAAA5K,EAAAC,UAAAC,OACAF,KAAA4K,EAAA5K,GAAAC,UAAAD,EAEA,OAAA4K,GAAA1K,OAGA0K,EAAAuT,OAAA4vB,GAAAtyC,MAFAsyC,GAAAtyC,MAMA,QAAAsyC,IAAAzU,EAAA1uB,GACA,SAAAA,SAEA,IAAA6iC,GAAAO,CA6CA,OArCApjC,GAAAkvB,oBAAA3/B,MACAyQ,EAAA4iC,GAAA5iC,IAGA6iC,EAAA,SAAA7iC,GACA,MAAAnP,gBAAAgyC,IAEAtL,GAAA1mC,KAAAmP,WACAq5B,IAAAxoC,KAAAmP,WAHA,GAAA6iC,GAAA7iC,IAMAojC,EAAAzY,GAAA+D,EAAAQ,WACAkU,EAAAhtB,YAAAysB,EAGA1yB,GAAA0yB,GAEAQ,UAAehyC,MAAA+xC,GAGfF,QAAa7xC,MAAA6xC,GAAAI,UAAA,EAAAC,cAAA,GAGbzF,SAAczsC,MAAAq9B,KAIde,GAAAyT,OAAAxU,EAAA0U,EAAApjC,GAEAsvB,GAAA4T,OAAAxU,EAAA0U,EAAApjC,GAEAA,EAAAg4B,WACAoL,EAAApL,SAAA9iC,EAAAy1B,GAAA+D,EAAAQ,UAAA8I,UAAAh4B,EAAAg4B,WAGA6K,EAAA3T,UAAAkU,EAEAP,EAGA,QAAAW,MAEA,IADA,GAAAvmC,MAAA7H,EAAAC,UAAAC,OACAF,KAAA6H,EAAA7H,GAAAC,UAAAD,EAEA,OAAA6H,GAAAwC,IAAA9B,GAAA+C,KAAA,KAGA,QAAA+iC,IAAAxlC,GACA,MAAAD,GAAAC,GAAAwB,IAAAnB,GAsBA,QAAA/O,IAAAyQ,GACA,MAAAnP,gBAAAtB,KAEAgoC,GAAA1mC,KAAAmP,WACAq5B,IAAAxoC,KAAAmP,WAHA,GAAAzQ,IAAAyQ,GAhkhBA,GAqFA24B,IArFA0K,IAEA3zC,GAAA,OACA4kB,QAAA,EAGA3kB,SAAA,KAGAg8B,YAAA,KAAgC,MAChC+X,kBAAA,MAAiC,OACjCC,kBAAA,WACAC,wBAAA,aACAC,KAAA,EACA/rC,aAAA,EACA+wB,oBAAA,EACAib,UAAA,EACAlb,eAAA,EACAmb,aAAA,EAGAl0C,QACAmoC,YACApoC,OAAA,EACA8oC,cAAA,EACAprB,SACA1V,UAAA,EACAosC,QAAA,EACAC,MAAA,EAGApwB,SAAA,EACAD,oBAAA,EACAxT,SAAA,OAGAkV,IAAA,KACA4uB,gBAAA,GA2BAjkC,IACAC,OAAA,SAAA8X,GAA6B,MAAAA,IAC7BmsB,OAAA,SAAAnsB,GAA6B,MAAAlM,MAAAs4B,IAAApsB,EAAA,IAC7BqsB,QAAA,SAAArsB,GAA8B,MAAAlM,MAAAs4B,IAAApsB,EAAA,QAC9BssB,UAAA,SAAAtsB,GACA,OAAAA,GAAA,MAA+B,GAAAlM,KAAAs4B,IAAApsB,EAAA,GAC/B,IAAAlM,KAAAs4B,IAAApsB,EAAA,UAIAusB,GAAA,KAIAxwC,GAAA,mBAAA7B,eAAA,KACAyB,GAAAI,GAAAlF,SAAA,KAEA21C,KAAA7wC,GAEA8wC,IADA,mBAAAv1C,YAAA,QAAAwP,KAAAxP,UAAAw1C,SACA,mBAAAC,UAAA,kBAAAA,SAAA1tC,MAAA,kBAAA0tC,SAAA1tC,KAAAD,MAGA,KACAgG,OAAA06B,kBAA2B,QAAWrmC,MAAA,IACtCsnC,IAAA,EACG,MAAAp+B,GACHo+B,IAAA,EAGA,GAeA0G,IACAuF,GACAC,GACAC,GACAC,GACA96B,GACAnR,GACAoD,GACA8oC,GAvBAC,KAAAtxC,IACAA,GAAAuxC,eAAAC,WAAA,2DAGAC,IAAA,yBAEAjsB,GAAA,+BACAksB,GAAA,qCACAxI,GAAA,6BACAyI,GAAA,+BACAC,GAAA,uCACA3I,GAAA,+BAEA7H,IAAoB5b,QAAAksB,UAAAJ,IAAApI,GAAAyI,SAAAC,OAAA3I,SA8EpB,IAvDAyC,GAXA4F,GAWA,SAAAhtC,EAAAutC,EAAAtC,GACA,MAAAsC,QAAArsB,GAMA+pB,EACAvvC,GAAA8xC,gBAAAD,EAAAvtC,EAAAirC,GACAvvC,GAAA8xC,gBAAAD,EAAAvtC,GAPAirC,EACAvvC,GAAA0rC,cAAApnC,EAAAirC,GACAvvC,GAAA0rC,cAAApnC,IAdA,SAAAA,EAAAutC,EAAAtC,GACA,GAAAsC,OAAArsB,GACA,sQAGA,OAAA+pB,GACAvvC,GAAA0rC,cAAApnC,EAAAirC,GACAvvC,GAAA0rC,cAAApnC,IA0DAusC,GAEG,CAYH,IAXAK,GAAAxF,GAAA,OACAyF,IAAA,6BAEAE,GAAA,SAAAz5B,GACA,gBAAAxZ,EAAAiP,GACA,MAAAjP,GAAAwZ,GAAAvK,KAIAlI,GAAAgsC,GAAAxvC,OAEAwD,OAAA8rC,IAGA,GAFAG,GAAAD,GAAAhsC,IAEA+rC,GAAAE,IACAH,GAAAI,GAAAD,QAGA,KADA7oC,GAAAkpC,GAAA9vC,OACA4G,MAGA,GAFA+N,GAAAm7B,GAAAtsC,IAAAisC,GAAA1mC,OAAA,KAAAvJ,cAAAiwC,GAAA9uB,UAAA,GAEA4uB,GAAA56B,IAAA,CACA26B,GAAAI,GAAA/6B,GACA,OAOA26B,KACAA,GAAA,SAAA7yC,EAAAiP,GACA,GAAAqyB,GAAAl/B,EAAA2E,CAiBA,KAfA3E,EAAApC,EAAAoC,WAEAA,IAEA0wC,GAAA1xB,UAAA,GAEAhf,EAAA0wC,GACA9yC,IAAA2zC,YAEAb,GAAArF,YAAAztC,IAGAshC,EAAAl/B,EAAAwxC,iBAAA3kC,GAEAlI,EAAAu6B,EAAA/9B,OACAwD,KACA,GAAAu6B,EAAAv6B,KAAA/G,EACA,QAIA,gBAzDA6yC,IAAA,IAiFA,IAUAja,IACA+M,GACAvnB,GAZAxb,GAAA,QAKAK,GAAA,QAQA,KACAgI,OAAA06B,kBAA2B,QAAWnmC,IAAA,aAAmBN,IAAA,eAEzD0C,IACAqJ,OAAA06B,eAAA2H,GAAA,eAA4DhuC,MAAA,IAG5DqmC,GAAA16B,OAAA06B,eACG,MAAArS,GAGHqS,GAAA,SAAAlpC,EAAA+G,EAAAqwC,GACAA,EAAAr0C,IAAA/C,EAAA+G,GAAAqwC,EAAAr0C,MACA/C,EAAA+G,GAAAqwC,EAAAv0C,OAIA,IACA,IACA2L,OAAAmT,qBAAiCzR,MAAQrN,MAAA,KACrC,MAAAg0B,GAEJ,KAAAA,GAGA1xB,IACAqJ,OAAAmT,iBAAAkvB,GAAA,QAAsD3gC,MAAQrN,MAAA,KAG9D8e,GAAAnT,OAAAmT,iBACG,MAAAkV,GACHlV,GAAA,SAAA3hB,EAAA0lC,GACA,GAAA3+B,EAEA,KAAAA,IAAA2+B,GACAA,EAAA10B,eAAAjK,IACAmiC,GAAAlpC,EAAA+G,EAAA2+B,EAAA3+B,KAMA,IACAyH,OAAA2tB,OAAA,MAEAA,GAAA3tB,OAAA2tB,OACG,MAAAtF,GAEHsF,GAAA,WACA,GAAAkb,GAAA,YAEA,iBAAAzC,EAAAlP,GACA,GAAA1lC,EAEA,eAAA40C,MAIAyC,EAAA3W,UAAAkU,EACA50C,EAAA,GAAAq3C,GAEA3R,GACAl3B,OAAAmT,iBAAA3hB,EAAA0lC,GAGA1lC,OAqCA,GAgCAuI,IACAG,GACAsgC,GAlCA9hC,GAAAsH,OAAAkyB,UAAA1vB,eAEAlL,GAAA0I,OAAAkyB,UAAA56B,SA6BA8C,KAIA,IAAAqtC,GAAA,CACA,GAAAqB,KACA,kDACA,iDACA,+CACA,+CACA,8EAEAC,GAAA,uoBAEAvO,IAAA,WACA,GAAAjoC,GAAAy2C,mBAAA,EAEA,YADAxO,GAAAjhC,EAGA,IAAAE,GAAA,mBAAAlH,OAAAy2C,gBAAAD,GACAE,IAAAtB,QAAAuB,cACAD,IAAAtB,QAAAuB,eAAAlvC,MAAA2tC,QAAAmB,IACAnB,QAAA5tC,IAAAN,GACAwvC,GACAtB,QAAAwB,SAAAL,IAGAtO,GAAAjhC,GAGAW,GAAA,SAAAT,EAAAC,GAIA,GAHA8gC,KAGA,gBAAA9gC,KAAApB,OAAA,IACA,GAAA0K,GAAAtJ,EAAAsL,MACAvK,EAAAuI,IAAAvI,QAAA,IAEA,IAAAA,EAAA,CAGA,GAAArG,EACAqG,GAAAiK,YAAAtQ,EAAAqG,EAAAiK,UAAAtQ,QACAqF,EAAA,IAAArF,EAAA,KAAAqF,EAGA,IAAA1E,IACAA,EAAAiO,EAAAjO,MAAA0F,EAAAoF,UAAApF,EAAAoF,SAAA4T,UAAAhZ,EAAAwJ,KAAA,OACAvK,EAAAkC,KAAA7G,IAKA4yC,QAAA1tC,KAAAD,MAAA2tC,SAAA,mBAAAluC,EAAA,4BAA2F,2BAA2B6F,OAAA5F,KAGtHK,GAAA,WACA4tC,QAAA5tC,IAAAC,MAAA2tC,QAAAtvC,gBAGA6B,IAAAH,GAAAygC,GAAAjhC,CAwDA,IAAAirC,IAAA,gBACA9D,GAAA,+DACAvlC,GAAA,SAAA/G,EAAA6G,GAA+C,kBAAA7G,EAAA,KAAA6G,EAAA,2FAAAA,EAAA,KAyC/CG,IACAC,OAAA,SAAAN,EAAAC,GACA,GAAAouC,EAEA,OAAAlwC,GAAA6B,IAAA7B,EAAA8B,IAIAD,KACAC,KAEAouC,EAAApuC,EAAAD,EAEAquC,EAIA,SAAA7tB,GACA,MAAAxgB,GAAAwgB,EAAA6tB,GAJA,WAAyB,MAAAruC,KATzB,MAiBAO,MAAA,SAAAP,EAAAC,GACA,GAAAquC,GAAAjuC,EAAAhD,EAAA0D,CAEA,KAAAjD,EAAAkC,KAAAlC,EAAAmC,GACA,WAOA,KAJAquC,KACAjuC,KAEAU,EAAA1D,EAAA0W,KAAAC,IAAAhU,EAAAzC,OAAA0C,EAAA1C,QACAwD,KACAV,EAAAU,GAAAhB,EAAAC,EAAAe,GAAAd,EAAAc,GAIA,KAAAA,EAAA1D,EAAgB0D,EAAAf,EAAAzC,OAAewD,GAAA,EAC/ButC,EAAAvtC,GAAAf,EAAAe,EAGA,KAAAA,EAAA1D,EAAgB0D,EAAAd,EAAA1C,OAAawD,GAAA,EAC7ButC,EAAAvtC,GAAAd,EAAAc,EAGA,iBAAAyf,GAGA,IAFA,GAAAzf,GAAA1D,EAEA0D,KACAutC,EAAAvtC,GAAAV,EAAAU,GAAAyf,EAGA,OAAA8tB,KAIA9tC,OAAA,SAAAR,EAAAC,GACA,GAAAsuC,GAAAlxC,EAAAgD,EAAAiuC,EAAA9wC,CAEA,KAAAe,EAAAyB,KAAAzB,EAAA0B,GACA,WAGAsuC,MACAD,KACAjuC,IAEA,KAAA7C,IAAAwC,GACArC,GAAAvH,KAAA4J,EAAAxC,KACAG,GAAAvH,KAAA6J,EAAAzC,IACA+wC,EAAA1tC,KAAArD,GACA6C,EAAA7C,GAAAuC,EAAAC,EAAAxC,GAAAyC,EAAAzC,KAAAiD,EAAAR,EAAAzC,KAIA8wC,EAAA9wC,GAAAwC,EAAAxC,GAKA,KAAAA,IAAAyC,GACAtC,GAAAvH,KAAA6J,EAAAzC,KAAAG,GAAAvH,KAAA4J,EAAAxC,KACA8wC,EAAA9wC,GAAAyC,EAAAzC,GAMA,OAFAH,GAAAkxC,EAAAhxC,OAEA,SAAAijB,GAGA,IAFA,GAAAhjB,GAAAuD,EAAA1D,EAEA0D,KACAvD,EAAA+wC,EAAAxtC,GAEAutC,EAAA9wC,GAAA6C,EAAA7C,GAAAgjB,EAGA,OAAA8tB,MAMAE,IACAhP,WACArJ,WAAA,aACAsY,YAAA,eAEAv+B,QACAimB,WAAA,OACAz3B,QAAA,6WAQA2J,UACA8tB,WAAA,WACAsY,YAAA,eAIAC,GAAA,SAAAz1C,GACAH,KAAAG,QACAH,KAAAw7B,OAAA,KAAAr7B,EACAH,KAAA09B,UAAAgY,GAAAv1C,GAGAy1C,IAAAvX,UAAA/gC,KAAA,SAAAk+B,EAAA50B,EAAAivC,GACA,GAAAjvC,EAAA40B,GAEA,MADAqa,GAAAjvC,EAAA40B,GAAAqa,GAAAjvC,EAAA40B,MACA,GAIAoa,GAAAvX,UAAA7xB,KAAA,SAAA5F,EAAAivC,GACA71C,KAAA1C,KAAA0C,KAAAw7B,OAAA50B,EAAAivC,IAGAjvC,EAAA5G,KAAAw7B,SAAAx7B,KAAA09B,WAAA19B,KAAA1C,KAAA0C,KAAA09B,UAAAL,WAAAz2B,EAAAivC,KACA71C,KAAA09B,UAAA93B,QACAY,EAAAxG,KAAA09B,UAAA93B,SAEAY,EAAA,4KAAAxG,KAAA09B,UAAAL,WAAAr9B,KAAA09B,UAAAiY,cAKAE,EAAAjvC,EAAA4F,KAAAxM,KAAAG,MAAA01C,GAAAjvC,EAAA4F,KAAAxM,KAAAG,OA+EA,IAAAsJ,IACAqsC,MACAC,MACAC,KACA,mBAAAxyB,SAEA/Z,GAAA+Z,SAEA/Z,GAAA,SAAAZ,GACA,GAIAI,GACAgtC,EACAC,EACA7sC,EACAC,EAEAF,EAVA+sC,KACAC,KACAC,EAAAP,EAUAI,GAAA,SAAAI,GACA,gBAAA91C,GACA61C,IAAAP,KAIA7sC,EAAAzI,EACA61C,EAAAC,EAEAL,EAAAltC,EAAAstC,IAAAN,GAAAI,EAAAC,EAAAntC,GAGAL,EAAAqtC,MAIA5sC,EAAA6sC,EAAAH,IACAzsC,EAAA4sC,EAAAF,GAEA,KACAntC,EAAAQ,EAAAC,GACK,MAAAkrB,GACLlrB,EAAAkrB,GAgDA,MA7CAprB,IAEAG,KAAA,SAAAgtC,EAAAC,GACA,GAAAC,GAAA,GAAAhtC,IAAA,SAAAJ,EAAAC,GAEA,GAAAotC,GAAA,SAAAxtC,EAAAF,EAAA2tC,GAGA,kBAAAztC,GACAF,EAAAjB,KAAA,SAAA6uC,GACA,GAAAxuC,EAEA,KACAA,EAAAc,EAAA0tC,GACAztC,EAAAstC,EAAAruC,EAAAiB,EAAAC,GACW,MAAAkrB,GACXlrB,EAAAkrB,MAMAxrB,EAAAjB,KAAA4uC,GAKAD,GAAAH,EAAAJ,EAAA9sC,GACAqtC,EAAAF,EAAAJ,EAAA9sC,GAEA+sC,IAAAP,IAEAltC,EAAAqtC,IAKA,OAAAQ,KAIArtC,EAAA,eAAAotC,GACA,MAAAx2C,MAAAuJ,KAAA,KAAAitC,IAGAptC,GAGAK,GAAAkgC,IAAA,SAAAkN,GACA,UAAAptC,IAAA,SAAAJ,EAAAC,GACA,GAAAwtC,GAAA7uC,EAAA8uC,EAAA9tC,IAEA,KAAA4tC,EAAApyC,OAEA,WADA4E,GAAAJ,EAmBA,KAfA8tC,EAAA,SAAA3tC,EAAAnB,GACAmB,GAAA,kBAAAA,GAAAG,KACAH,EAAAG,KAAA,SAAA/I,GACAyI,EAAAhB,GAAAzH,IACAs2C,GAAAztC,EAAAJ,IACQK,IAIRL,EAAAhB,GAAAmB,IACA0tC,GAAAztC,EAAAJ,KAIA6tC,EAAA7uC,EAAA4uC,EAAApyC,OACAwD,KACA8uC,EAAAF,EAAA5uC,SAKAwB,GAAAN,QAAA,SAAA3I,GACA,UAAAiJ,IAAA,SAAAJ,GACAA,EAAA7I,MAIAiJ,GAAAH,OAAA,SAAA0tC,GACA,UAAAvtC,IAAA,SAAAJ,EAAAC,GACAA,EAAA0tC,MAKA,IAAAxG,IAAA/mC,GAiFAwtC,GAAA,SAAApuC,EAAA7B,GACAhH,KAAA6I,WACA7I,KAAAgH,SAEAhH,KAAA2K,UACA3K,KAAAuK,UAEAvK,KAAAwL,YACAxL,KAAA4K,cAAA5K,KAAAwK,cAAA,EAEAxK,KAAAmL,eACAnL,KAAAyK,gBAAA,EAEAzD,GACAA,EAAAkwC,SAAAl3C,MAIAi3C,IAAA5Y,UAAAxvB,IAAA,SAAAuiC,GACA,GAAA7lC,GAAA6lC,EAAA+F,QAAAn3C,KAAA2K,OAAA3K,KAAAuK,MACAgB,GAAAxD,KAAAqpC,IAGA6F,GAAA5Y,UAAA6Y,SAAA,SAAAl3B,GACAhgB,KAAAwL,SAAAzD,KAAAiY,GAEAhgB,KAAA4K,eAAA,EACA5K,KAAAwK,eAAA,GAGAysC,GAAA5Y,UAAA3zB,gBAAA,WACA1K,KAAAwK,eAAA,EACAH,EAAArK,OAGAi3C,GAAA5Y,UAAAvzB,eAAA,WACA9K,KAAA4K,eAAA,EACAP,EAAArK,OAGAi3C,GAAA5Y,UAAAj0B,YAAA,WACApK,KAAAmL,YAAAxG,QAAAqF,GACAhK,KAAAwL,SAAA7G,QAAAuF,IAGA+sC,GAAA5Y,UAAA/zB,MAAA,WACAS,EAAA/K,OAGAi3C,GAAA5Y,UAAAoC,OAAA,SAAA2Q,GACA,GAAA7lC,GAAA6lC,EAAA+F,QAAAn3C,KAAA2K,OAAA3K,KAAAuK,MACAhC,GAAAgD,EAAA6lC,GACA/mC,EAAArK,OAGAi3C,GAAA5Y,UAAA/7B,MAAA,WACAtC,KAAAwL,SAAA7G,QAAA,SAAAnH,GAA0C,MAAAA,GAAA8E,UAC1CtC,KAAA2K,OAAAc,OAAAzL,KAAAuK,QAAA5F,QAAA,SAAA+iB,GAA8D,MAAAA,GAAAplB,UAC9DtC,KAAAsK,OAAA,EACAD,EAAArK,MA+EA,IAEA8L,IAFAS,GAAA,GAAAqpC,IAAA,UAIA5nC,IACA1L,MAAA,SAAAuE,EAAAuwC,GACA,GAAAhuC,GAAAiuC,CAiBA,OAfAD,KACAhuC,EAAA,GAAAonC,IAAA,SAAAjgB,GAA8C,MAAA8mB,GAAA9mB,KAG9CzkB,IACAwrC,cAAAxrC,GACAa,kBAAA,GAAAsqC,IAAAI,EAAAvrC,OAAAa,mBACAV,aACAY,SACAd,sBACAa,qBACAV,YACArF,YAGAuC,GAGA6E,IAAA,WACArC,IAEAE,GAAAwrC,eAAAxrC,GAAAa,kBAAArK,QAEAwJ,MAAAwrC,eAGAC,YAAA,SAAAvrC,GACApE,EAAAkE,GAAAG,UAAAD,IAIAwrC,kBAAA,SAAAxrC,GACA,GAAAF,GAAA,CAGA,IADA,GAAA1G,GAAA0G,GACA1G,EAAAkyC,eACAlyC,IAAAkyC,aAGA1vC,GAAAxC,EAAA6G,UAAAD,KAGAyrC,YAAA,SAAA5wC,GACAiF,IAAAlE,EAAAkE,GAAAI,SAAArF,IAGA6wC,YAAA,SAAA/rC,EAAAgsC,GACA/vC,EAAA+vC,EAAA7rC,GAAAc,kBAAAd,GAAAC,mBAAAJ,IAGA2lC,mBAAA,SAAAF,GACAA,EAAAwG,SAAA9rC,GAAAa,kBACAb,GAAAa,kBAAAkC,IAAAuiC,IAIAyG,gBAAA,SAAA5yC,GACA6G,GAAAa,kBAAAxB,YAAApD,KAAA9C,IAGAge,aAAA,SAAA60B,EAAAC,GACA,GAAAC,EAEA,IAAAlsC,GAEK,CAEL,IADAksC,EAAAlsC,GACAisC,GAAAC,EAAAV,eAIAU,IAAAV,aAGAU,GAAAnrC,MAAA9E,KAAA+vC,OAVAA,OA0EA5qC,GAAA,oCACAI,GAAA,qBACAP,GAAA,SACAW,GAAA,sBA+DAU,GAAA,KAiCAY,GAAA,oCAoBAS,GAAA+gC,GAAArnC,SACA09B,IAAAp3B,GAAA,QAAwCjP,MAAAkF,GAExC,IAAA2J,IAAAD,GAAAC,OAuDAY,GAAA,GAAA2lC,IAAA,UA4GApjC,GAAA,SAAA5L,EAAAuJ,EAAAmC,EAAA2lC,GACAj4C,KAAA4G,UACA5G,KAAAmQ,WACAnQ,KAAAsS,OACAtS,KAAAi4C,mBAEAj4C,KAAAiJ,UAEAjJ,KAAAk4C,OAAA,EAGA1lC,IAAA6rB,UAAAxvB,IAAA,SAAAiD,GACA9R,KAAAiJ,OAAAlB,KAAA+J,GACA9R,KAAAmpC,aAGA32B,GAAA6rB,UAAAtnB,OAAA,WACA,GAAA5E,GAAAnS,KAAAlC,MAAAkC,KAAAi4C,iBAAA,sCACA9nC,EAAAnQ,KAAAmQ,SAEAtI,EAAAsK,EAAArK,QAAAqI,EAEAtI,MAAA,IACAsK,EAAA1J,OAAAZ,EAAA,GACAsK,EAAAhC,GAAA,OAIAqC,GAAA6rB,UAAA3rB,KAAA,WACA1S,KAAAk4C,OAAA,GAGA1lC,GAAA6rB,UAAA8K,UAAA,WACA,GAAA/oB,GAAApgB,IAEAA,MAAAk4C,QACAl4C,KAAAk4C,OAAA,EAIAlqC,GAAAiV,aAAA,WAAuC,MAAA7C,GAAA3T,aAIvC+F,GAAA6rB,UAAAoC,OAAA,SAAA0X,GACA,GAAAtwC,GAAA7H,KAAAiJ,OAAAnB,QAAA9H,KAAAi4C,iBAAAE,EAAAtxC,SAAAsxC,EACAtwC,MAAA,GAAA7H,KAAAiJ,OAAAR,OAAAZ,EAAA,IAGA2K,GAAA6rB,UAAA5xB,OAAA,WACAzM,KAAAiJ,OAAAmV,KAAApe,KAAAi4C,iBAAAxnC,GAAAJ,IACArQ,KAAAk4C,OAAA,GAGA1lC,GAAA6rB,UAAAxwB,KAAA,SAAAiE,GACA,MAAA9R,MAAAi4C,kBACAj4C,KAAAmQ,UAAA2B,EAAAvR,OAAAP,KAAAmQ,SACA2B,EAAAiiC,GAAAjiC,EAAA9R,KAAAmQ,UAAA,KAwGA,IA6OAuG,IA7OA9C,MA2EAe,MAiKA8B,MAmBA2hC,GAAA,SAAArzC,EAAAiC,GACAhH,KAAAQ,MAAAuE,EACA/E,KAAAq4C,WAAAr4C,KAAAsY,OAAA,EACAtY,KAAAs4C,QACAt4C,KAAAu4C,SACAv4C,KAAAgH,SAGAoxC,IAAA/Z,UAAA39B,IAAA,SAAA83C,GAEA,MADAA,IAAA3hC,GAAA7W,MACAyN,EAAAzN,KAAAQ,QAGA43C,GAAA/Z,UAAA1iB,WAAA,WACA,MAAAlO,GAAAzN,KAAAQ,QAGA43C,GAAA/Z,UAAAoa,UAAA,SAAArgC,EAAAC,GAIA,IAHA,GAAA+H,GAAApgB,KAEAiI,EAAAjI,KAAAs4C,KAAA7zC,OACAwD,KAAAmY,EAAAk4B,KAAArwC,GAAAwwC,UAAArgC,EAAAC,GAAA,EAGA,KADApQ,EAAAjI,KAAAu4C,MAAA9zC,OACAwD,KAAAmY,EAAAm4B,MAAAtwC,GAAAwwC,UAAArgC,EAAAC,GAAA,IAGA+/B,GAAA/Z,UAAApmB,SAAA,SAAAutB,GACAxlC,KAAAs4C,KAAAvwC,KAAAy9B,IAGA4S,GAAA/Z,UAAAqa,aAAA,SAAAp7B,GACA1V,EAAA5H,KAAAu4C,MAAAj7B,IAGA86B,GAAA/Z,UAAAsa,WAAA,SAAAnT,GACAj9B,EAAAvI,KAAAs4C,KAAA9S,IAGA4S,GAAA/Z,UAAAua,eAAA,SAAAt7B,GACA/U,EAAAvI,KAAAu4C,MAAAj7B,GAkBA,IAAAu7B,IAAA,SAAA7xC,EAAAJ,GACA5G,KAAAgH,SACAhH,KAAA4G,UACA5G,KAAAQ,MAAAoG,EAAAI,EAAA2U,WAAA/U,GAAAI,EAAA2U,aACA3b,KAAAs4C,QACAt4C,KAAAwL,YACAxL,KAAAq4C,WAAAr4C,KAAAuY,WAAA,EAGAsgC,IAAAxa,UAAA39B,IAAA,SAAA83C,GAEA,MADAA,IAAA3hC,GAAA7W,MACAA,KAAAQ,OAGAq4C,GAAAxa,UAAAya,SAAA,SAAAlyC,GACA,KAAAA,EAAAshC,QAAAloC,MAAAwL,UAAA,CACA,GAAA1K,GAAA,GAAA+3C,IAAA74C,KAAAgH,OAAAJ,EACA5G,MAAAwL,SAAA5E,EAAAshC,OAAApnC,EACAA,EAAAiR,MAAA/R,KAEA,MAAAA,MAAAwL,SAAA5E,EAAAshC,QAGA2Q,GAAAxa,UAAA1iB,WAAA,WACA,MAAA3b,MAAAQ,OAGAq4C,GAAAxa,UAAArnB,aAAA,WAKA,IAJA,GAAAoJ,GAAApgB,KAEAoM,EAAAD,OAAAC,KAAApM,KAAAwL,UACAvD,EAAAmE,EAAA3H,OACAwD,KACAmY,EAAA5U,SAAAY,EAAAnE,IAAA+O,cAGAhX,MAAAs4C,KAAA3zC,QAAAqS,KAGA6hC,GAAAxa,UAAA0a,eAAA,SAAA3gC,GAKA,IAJA,GAAAgI,GAAApgB,KAEAoM,EAAAD,OAAAC,KAAApM,KAAAwL,UACAvD,EAAAmE,EAAA3H,OACAwD,KAAA,CACA,GAAA+X,GAAAI,EAAA5U,SAAAY,EAAAnE,GACA+X,GAAAxf,MAAA4X,EAAAuD,WAAAqE,EAAApZ,SACAoZ,EAAAhJ,iBAIA6hC,GAAAxa,UAAAoa,UAAA,SAAArgC,EAAAC,GAOA,IANA,GAAA+H,GAAApgB,KAEAc,EAAAsX,IAAA0B,gBAAA9Z,KAAA4G,SAAAyB,OAEA+D,EAAAD,OAAAC,KAAApM,KAAAwL,UACAvD,EAAAmE,EAAA3H,OACAwD,KACAmY,EAAA5U,SAAAY,EAAAnE,IAAAwwC,UAAArgC,EAAAC,GAAA,EAIA,KADApQ,EAAAjI,KAAAs4C,KAAA7zC,OACAwD,KACAmY,EAAAk4B,KAAArwC,GAAAwwC,UAAA33C,EAAAsf,GAAA,IAIAy4B,GAAAxa,UAAApmB,SAAA,SAAA+gC,GACAh5C,KAAAs4C,KAAAvwC,KAAAixC,IAGAH,GAAAxa,UAAA96B,YAAA,SAAAzC,GACAA,EAAA8F,eAAA5G,MAAAwL,SAAA1K,EAAA8F,QAAAshC,QAGA2Q,GAAAxa,UAAAhnB,SAAA,WACA,GAAA+I,GAAApgB,IAEAA,MAAA+R,OAAA/R,KAAA+R,MAAAxO,YAAAvD,KAIA,KAFA,GAAAoM,GAAAD,OAAAC,KAAApM,KAAAwL,UACAvD,EAAAmE,EAAA3H,OACAwD,KACAmY,EAAA5U,SAAAY,EAAAnE,IAAAoP,YAIAwhC,GAAAxa,UAAAsa,WAAA,SAAAK,GACAzwC,EAAAvI,KAAAs4C,KAAAU,GACAh5C,KAAAs4C,KAAA7zC,QAAAzE,KAAAqX,WAGA,IAAA4hC,IAAA9sC,OAAAkyB,UAAA1vB,eAEAqJ,IAAsBkhC,SAAAjiC,SACtBiB,IAAuBghC,SAAAjiC,SAEvBkiC,GAAA,SAAAnyC,GACAhH,KAAAs4C,QAEAt4C,KAAAwL,YACAxL,KAAA2Z,cACA3Z,KAAAu4C,SAEAv4C,KAAAo5C,aAEAp5C,KAAAq5C,cACAr5C,KAAAs5C,mBAEAt5C,KAAA4pC,YACA5pC,KAAAu5C,oBAEAvyC,IACAhH,KAAAgH,SACAhH,KAAA7B,KAAA6I,EAAA7I,MAIAg7C,IAAA9a,UAAAmb,cAAA,SAAAz0C,EAAA46B,GACA3/B,KAAAs5C,gBAAAv0C,KACA/E,KAAAq5C,WAAAtxC,KAAAhD,GACA/E,KAAAs5C,gBAAAv0C,OAGA/E,KAAAs5C,gBAAAv0C,GAAAgD,KAAA43B,IAGAwZ,GAAA9a,UAAAob,eAAA,SAAA3B,EAAA//B,GAAgF,SAAAA,MAAA,SAEhFC,GAAAD,GAAAhQ,KAAA+vC,IACAqB,GAAA9a,UAAAqb,mBAAA,SAAA5nC,EAAAiG,GAAwF,SAAAA,MAAA,SAExFG,GAAAH,GAAAhQ,MAA8BjH,MAAAd,KAAA8R,UAE9BqnC,GAAA9a,UAAA1hB,iBAAA,SAAAg9B,GAKA,IAJA,GAAAv5B,GAAApgB,KAEAiI,EAAAjI,KAAAq5C,WAAA50C,OAEAwD,KAAA,CACA,GAAAlD,GAAAqb,EAAAi5B,WAAApxC,EAEA,KAAA0xC,GAAA50C,IAAA40C,EAAA,CAMA,IAJA,GAAA/Z,GAAAxf,EAAAk5B,gBAAAv0C,GACA60C,EAAAx5B,EAAAhK,IAAArR,GAEAsG,EAAAu0B,EAAAn7B,OACA4G,KACAuuC,GAAAha,EAAAv0B,GAAAwuC,oBACAja,EAAAv0B,GAAAyuC,UAAAla,EAAAn3B,OAAA4C,EAAA,EAGAu0B,GAAAn7B,SACA2b,EAAAi5B,WAAA5wC,OAAAR,EAAA,GACAmY,EAAAk5B,gBAAAv0C,GAAA,SAKAo0C,GAAA9a,UAAAhwB,YAAA,SAAAjC,GACA,GAGA2nC,GACA9rC,EAJA1D,EAAA6H,EAAA3H,OAEAs1C,GAAA/5C,MAIAyO,EAAA,WACA,GAAA1J,GAAAqH,EAAAnE,EAEA,OAAAlD,GACAgvC,KACAgG,EAAAp1C,QAAA,SAAA7D,GACAizC,EAAAhsC,KAAA5B,MAAA4tC,EAAAjzC,EAAAk5C,iBAAAl5C,EAAAJ,WAGAqzC,EAAAgG,EAAAnrC,IAAA,SAAA9N,GAAwD,MAAAA,GAAAwV,QAAAvR,KAGxDg1C,EAAAhG,EAGA,KAAA9rC,EAAA,EAAgBA,EAAA1D,EAAS0D,GAAA,EAAAwG,GAEzB,OAAAslC,IAGAoF,GAAA9a,UAAApoB,YAAA,SAAAlR,EAAAk1C,GACA,MAAA5xC,UAAAtD,GAAAk1C,GAEAl1C,IAAA/E,MAAAo5C,YAAAp5C,KAAAo5C,UAAAr0C,GAAA,GAAAqzC,IAAAtrC,EAAA/H,GAAA/E,OAEAA,KAAAo5C,UAAAr0C,IAJA/E,KAAAgH,OAAAiP,YAAAlR,GAAA,IAOAo0C,GAAA9a,UAAA1iB,WAAA,SAAA/U,GACA,MAAAA,KAAA5G,KAAA4G,SAAA5G,KAAAwe,MAAAxe,KAAAwe,MAAAle,OAAAqb,WAAA/U,IAEA5G,KAAAoN,UACApN,KAAAoN,QAAApN,KAAAgH,OAAAmP,OAAAnW,KAAA+E,IAAA,GAAA/E,KAAAgH,OAAA2U,WAAA/U,GAAA,IAAAkG,EAAA9M,KAAA+E,MAGA/E,KAAAoN,UAGA+rC,GAAA9a,UAAA2b,iBAAA,SAAAx5C,GACA,GAEAgL,GAFA4U,EAAApgB,IAGA,IAAAgF,EAAAxE,GACAgL,KACA,UAAAxL,YAAAyE,SAAAjE,EAAAiE,QACA+G,EAAAzD,KAAA/H,KAAAsW,QAAA,WAEA9V,EAAAmE,QAAA,SAAApH,EAAA0K,GACAuD,EAAAzD,KAAAqY,EAAA9J,QAAArO,UAIA,IAAAxC,EAAAjF,IAAA,kBAAAA,GACAgL,EAAAW,OAAAC,KAAA5L,GAAAoO,IAAA,SAAA7J,GAA2D,MAAAqb,GAAA9J,QAAAvR,SAG3D,UAAAvE,EACA,QAGA,OAAAgL,IAGA2tC,GAAA9a,UAAA6b,WAAA,SAAA1B,GACA,GAAAp4B,GAAApgB,KAEAQ,EAAAR,KAAAU,IAAA83C,GAA0C2B,SAAA,GAC1C,IAAA10C,EAAAjF,GAAA,CAKA,IAJA,GAAAyI,GAAAjE,EAAAxE,SAEA4L,EAAAD,OAAAC,KAAA5L,GACAyH,EAAAmE,EAAA3H,OACAwD,KAAA,CACA,GAAA+X,GAAAI,EAAAzG,WAAAvN,EAAAnE,GACA+X,GACAA,EAAAxB,MAAAvV,EAAAmD,EAAAnE,IAAA+X,EAAAxB,MAAA07B,aACAjxC,EAAAmD,EAAAnE,IAAA+X,EAAAk6B,aAFAjxC,EAAAmD,EAAAnE,IAAAzH,EAAA4L,EAAAnE,IAMA,IADAA,EAAAjI,KAAAwL,SAAA/G,OACAwD,KAAA,CACA,GAAAmyC,GAAAh6B,EAAA5U,SAAAvD,EACAmyC,GAAAr1C,MAAAkE,KAAAmxC,EAAA57B,QACAvV,EAAAmxC,EAAAr1C,KAAAq1C,EAAA57B,MAAA07B,cAIA,MAAAjxC,GACI,MAAAzI,IAGJ24C,GAAA9a,UAAAjoB,IAAA,SAAArR,GACA,GAAA/E,KAAAwe,MAAA,MAAAxe,MAAAwe,MAAApI,IAAArR,EAEA,IAAAvE,GAAAR,KAAAU,KACA,KAAAF,EAAA,QAGA,IADAuE,EAAA0I,EAAA1I,GACAk0C,GAAA37C,KAAAkD,EAAAuE,GAAA,QAIA,KADA,GAAAwgB,GAAA/kB,EAAA+kB,YACAA,IAAAY,UAAAZ,IAAAW,OAAAX,IAAApZ,QAAA,CACA,GAAA8sC,GAAA37C,KAAAioB,EAAA8Y,UAAAt5B,GAAA,QACAwgB,iBAGA,UAGA4zB,GAAA9a,UAAA/vB,QAAA,SAAAlC,EAAAmO,GAEA,OADAzZ,GAAAd,KACAiI,EAAA,EAAmBA,EAAAmE,EAAA3H,OAAiBwD,GAAA,GACpC,GAAAsS,KAAAi3B,YAAA,GAAAvpC,EAAA,IAAAmE,EAAA3H,QAAA3D,EAAA6Y,WAAAvN,EAAAnE,KAAAnH,EAAA6Y,WAAAvN,EAAAnE,IAAAuW,MAAA,MAAA1d,GAAA6Y,WAAAvN,EAAAnE,GACAnH,KAAAwV,QAAAlK,EAAAnE,GAAAsS,GAGA,MAAAzZ,IAGAq4C,GAAA9a,UAAAzhB,eAAA,WAEA,IADA,GAAA5V,GAAAhH,KAAAgH,OAAAsU,GAAAtb,KAAA+E,KACAiC,GACAA,EAAAuyC,iBAAA90C,QAAAuC,EAAAuyC,iBAAA50C,QAAA,SAAAipB,GAA2F,MAAAA,GAAAysB,OAAA/+B,EAAA/I,WAC3F+I,EAAA4C,QAAAlX,EAAAjC,KACAiC,EAAAuxC,MAAA5zC,QAAAwS,IACAnQ,EAAAsxC,KAAA3zC,QAAAqS,IACAhQ,YAIAmyC,GAAA9a,UAAAoa,UAAA,SAAArgC,EAAAC,EAAAiiC,GAKA,IAHA,GAAAl6B,GAAApgB,KAEAiI,EAAAjI,KAAAs4C,KAAA7zC,OACAwD,KACAmY,EAAAk4B,KAAArwC,GAAAwwC,WAAAr4B,EAAAk4B,KAAArwC,GAAAwwC,UAAArgC,EAAAC,EAAAiiC,EAIA,KADAryC,EAAAjI,KAAAu4C,MAAA9zC,OACAwD,KAAA,CACA,GAAAqV,GAAA8C,EAAAm4B,MAAAtwC,EAEAqV,GAAAvL,MAAAyM,OAAAlB,EAAAi9B,UAAAniC,GAAA,EAAAkiC,GAIA,IADAryC,EAAAjI,KAAAwL,SAAA/G,OACAwD,KAAA,CACA,GAAA+X,GAAAI,EAAA5U,SAAAvD,EACA+X,GAAAy4B,UAAArgC,IAAA9B,QAAA0J,EAAAjb,KAAAsD,OAAA2X,EAAAs6B,GAIA,IADAryC,EAAAjI,KAAAq5C,WAAA50C,OACAwD,KAGA,IAFA,GAAAoxC,GAAAj5B,EAAAk5B,gBAAAl5B,EAAAi5B,WAAApxC,IACAzK,EAAA67C,EAAA50C,OACAjH,KACA67C,EAAA77C,GAAAi7C,UAAArgC,EAAAC,EAOA,KAHArY,KAAAw6C,cAAAx6C,KAAAw6C,aAAA/B,UAAArgC,EAAAC,GAAA,GAEApQ,EAAAjI,KAAA4pC,SAAAnlC,OACAwD,KACAmY,EAAAwpB,SAAA3hC,GAAAwwC,UAAArgC,EAAAC,EAAAiiC,IAIAnB,GAAA9a,UAAApmB,SAAA,SAAA+gC,GACAh5C,KAAAs4C,KAAAvwC,KAAAixC,IAGAG,GAAA9a,UAAA3hB,eAAA,SAAA3X,EAAAvE,GACAR,KAAAmW,QAGAnW,KAAAsM,QAAAvH,GAAAvE,EACAwN,GAAAypC,YAAAz3C,KAAA7B,KAAAyI,UAHA5G,KAAA7B,KAAAue,eAAA3X,EAAAvE,IAOA24C,GAAA9a,UAAAqa,aAAA,SAAAp7B,GACA1V,EAAA5H,KAAAu4C,MAAAj7B,IAGA67B,GAAA9a,UAAAoc,wBAAA,SAAA9uC,GACA3L,KAAAu5C,iBAAAxxC,KAAA4D,GACA3L,KAAAiY,SAAAtM,IAGAwtC,GAAA9a,UAAAqc,sBAAA,SAAAx7B,GACAlf,KAAA4pC,SAAA7hC,KAAAmX,IAGAi6B,GAAA9a,UAAAsc,iBAAA,SAAA51C,EAAA46B,GACA,GAAAC,GAAA5/B,KAAAs5C,gBAAAv0C,EAEA66B,IACAr3B,EAAAq3B,EAAAD,IAIAwZ,GAAA9a,UAAAuc,SAAA,WAIA,IAHA,GAAAx6B,GAAApgB,KAEAiI,EAAAjI,KAAAwL,SAAA/G,OACAwD,KACAmY,EAAA5U,SAAAvD,GAAA2yC,UAEA56C,MAAAwc,UACAxc,KAAAwc,QAAAnF,WACArX,KAAAwc,QAAA,KACAxc,KAAA66C,QAAA,IAIA1B,GAAA9a,UAAAsa,WAAA,SAAAnT,GACAj9B,EAAAvI,KAAAs4C,KAAA9S,IAGA2T,GAAA9a,UAAAua,eAAA,SAAAt7B,GACA/U,EAAAvI,KAAAu4C,MAAAj7B,IAGA67B,GAAA9a,UAAAyc,0BAAA,SAAAnvC,GACApD,EAAAvI,KAAAu5C,iBAAA5tC,GACA3L,KAAA24C,WAAAhtC,IAGAwtC,GAAA9a,UAAA0c,wBAAA,SAAA77B,GACA3W,EAAAvI,KAAA4pC,SAAA1qB,IAGAi6B,GAAA9a,UAAA1mB,mBAAA,SAAAiH,GAIA,IAHA,GAAAwB,GAAApgB,KAEAiI,EAAAjI,KAAA4pC,SAAAnlC,OACAwD,KAAA,CACA,GAAAzH,GAAA4f,EAAAwpB,SAAA3hC,GAAAs6B,UACA/hC,KAAA4f,EAAA5f,OAAA4f,EAAAhgB,IAAAI,GAIA,IAAAR,KAAA4pC,SAAAnlC,OAAA,CACA,GAAAu2C,GAAApjC,GAAA5X,KAAAs4C,KACA0C,MAAAx6C,QAAAR,KAAAQ,OAAAR,KAAAI,IAAA46C,EAAAx6C,OAGAoe,IACA5e,KAAAwL,SAAA7G,QAAAgT,IACA3X,KAAAu4C,MAAA5zC,QAAAgT,IACA3X,KAAAwe,OAAAxe,KAAAwe,MAAA7G,mBAAAiH,KAwCAw5B,GAAA/Z,UAAAob,eAAAN,GAAA9a,UAAAob,eACArB,GAAA/Z,UAAAqb,mBAAAP,GAAA9a,UAAAqb,mBACAb,GAAAxa,UAAAob,eAAAN,GAAA9a,UAAAob,eACAZ,GAAAxa,UAAAqb,mBAAAP,GAAA9a,UAAAqb,kBAqCA,IAAAuB,IAAA,SAAA9B,GACA,QAAA8B,GAAAj0C,EAAA+K,EAAAzR,EAAAyE,GACAo0C,EAAA77C,KAAA0C,KAAAgH,GAEAhH,KAAA+R,QACA/R,KAAAM,SACAN,KAAA+E,IAAAsD,SAAAtD,EAAAgN,EAAAhN,MACAgN,EAAAmpC,SAAAl7C,KAAAkgB,WAAA,GAAAnO,EAAA,eAAA/R,KAAA,KAEAM,EAAAo4C,aAAA14C,MAEAA,KAAAq4C,WAAArxC,EAAAqxC,WAEAr4C,KAAAk7C,QAAA,EAiKA,MA9JAD,GAAA5c,UAAAlyB,OAAA2tB,OAAAqf,KAAA9a,WACA4c,EAAA5c,UAAA9Y,YAAA01B,EAEAA,EAAA5c,UAAA1uB,QAAA,SAAAzI,EAAAC,EAAAgI,EAAAO,GACA1P,KAAAM,OAAAqP,QAAAzI,EAAAC,EAAAgI,EAAAO,IAGAurC,EAAA5c,UAAA8c,WAAA,SAAA36C,GACAR,KAAAM,OAAA66C,WAAA36C,IAGAy6C,EAAA5c,UAAA39B,IAAA,SAAA83C,EAAAj+B,GASA,MARAi+B,KACA3hC,GAAA7W,MAGAua,QACAA,EAAAw3B,QAAA,GAGA/xC,KAAAM,OAAAI,KAAA,EAAA6Z,IAGA0gC,EAAA5c,UAAA1iB,WAAA,SAAA/U,GACA,MAAAA,QAAA5G,KAAA7B,KAAAyI,QAAA5G,KAAAM,OAAAqb,WAAA/U,GAEAuyC,EAAA9a,UAAA1iB,WAAAre,KAAA0C,KAAA4G,IAGAq0C,EAAA5c,UAAAvkB,gBAAA,SAAAlT,GAEA,MADA5G,MAAAw6C,eAAAx6C,KAAAw6C,aAAA,GAAA3B,IAAA74C,OACA4G,OAAA5G,KAAA7B,KAAAyI,QAAA5G,KAAAw6C,aAAA1B,SAAAlyC,GACA5G,KAAAw6C,cAGAS,EAAA5c,UAAArnB,aAAA,WACAhX,KAAAs4C,KAAA3zC,QAAAqS,IACAhX,KAAAu4C,MAAA5zC,QAAAqS,IACAhX,KAAA4c,kBAGAq+B,EAAA5c,UAAA/nB,QAAA,SAAAvR,GAEA,GAAAsD,SAAAtD,GAAA,KAAAA,EAAA,MAAA/E,KAEA,KAAAA,KAAA2Z,WAAAhL,eAAA5J,GAAA,CACA,GAAAib,GAAA,GAAAi7B,GAAAj7C,eAAAM,OAAAgW,QAAAvR,KACA/E,MAAAwL,SAAAzD,KAAAiY,GACAhgB,KAAA2Z,WAAA5U,GAAAib,EAGA,MAAAhgB,MAAA2Z,WAAA5U,IAGAk2C,EAAA5c,UAAApnB,KAAA,WACAjX,KAAAM,OAAA2W,QAGAgkC,EAAA5c,UAAAnnB,OAAA,WACAlX,KAAAu4C,MAAA5zC,QAAAuS,IAEAlX,KAAAs4C,KAAA3zC,QAAAqS,IACAhX,KAAA2c,oBAGAs+B,EAAA5c,UAAAlnB,iBAAA,WACAnX,KAAAu4C,MAAA5zC,QAAAwS,IACAnX,KAAAs4C,KAAA3zC,QAAAqS,KAGAikC,EAAA5c,UAAA+c,SAAA,WACAp7C,KAAAM,OAAAo4C,aAAA14C,MACAA,KAAAwL,SAAA7G,QAAA,SAAAnH,GAA2C,MAAAA,GAAA49C,cAG3CH,EAAA5c,UAAAkc,UAAA,SAAAj6C,EAAAnC,EAAAm8C,GACA,GAAAl6B,GAAApgB,IAEA7B,IAAA6B,KAAAkgB,aAAA5f,EAAA6X,GAAAnY,KAAAkgB,WAAA5f,EAAAN,KAAAM,SACAA,GAAAN,KAAAM,aAEAN,KAAAM,OAAAs4C,eAAA54C,MACAA,KAAAw6C,cAAAx6C,KAAAw6C,aAAAzB,eAAAz4C,GAEAN,KAAAM,SACAN,KAAAwL,SAAA7G,QAAA,SAAAnH,GACAA,EAAA+8C,UAAAj6C,EAAAgW,QAAA9Y,EAAAuH,MAAA,EAAAu1C,KAGAn8C,GAAA6B,KAAAy5C,eAAA,WACAr5B,EAAAg7B,WACAd,GAAAl6B,EAAAxD,qBAIAq+B,EAAA5c,UAAAj+B,IAAA,SAAAI,GACAR,KAAAM,OAAAF,IAAAI,IAGAy6C,EAAA5c,UAAAziB,QAAA,SAAAb,GAEA,GAAAqF,GAAApgB,IAEA,KAAAA,KAAA0Y,UAGA,GAAA1Y,KAAAM,OAAAoY,UAEK,CACL1Y,KAAA0Y,WAAA,CAGA,KADA,GAAAzQ,GAAA8S,EAAAtW,OACAwD,KAAA,CACA,GAAAioB,GAAAnV,EAAA9S,EAEAA,KAAAioB,IAKAjoB,IAAAmY,GAAAzG,YAAAyG,EAAAzG,WAAA1R,GAAAwwC,WAAAvoB,EAAA9P,EAAA9J,QAAA4Z,GAAA7nB,OAAA+X,EAAAzG,WAAA1R,IAAA,KAEAioB,GAAA9P,EAAAg5B,UAAAnxC,GACAmY,EAAAg5B,UAAAnxC,GAAAwwC,UAAApwC,OAAA+X,EAAAg5B,UAAAnxC,IAAA,IACOioB,GAAA9P,EAAAg5B,UAAAnxC,KACPmY,EAAAg5B,UAAAlpB,IAAA9P,EAAAzG,WAAAuW,GAAAja,YAAAia,GACA9P,EAAAg5B,UAAAnxC,GAAAwwC,UAAAr4B,EAAAg5B,UAAAlpB,GAAA9P,EAAAg5B,UAAAnxC,IAAA,KAIA,GAAAozC,GAAAr7C,KAAA4E,SAAAH,SAAAzE,KAAA4E,SAAApE,MAAAiE,MAKA,KAHAzE,KAAAu4C,MAAA5zC,QAAA,SAAAsP,GAAyC,MAAAA,GAAA2H,QAAAb,KAEzC9S,EAAAjI,KAAAs4C,KAAA7zC,OACAwD,KACAmY,EAAAk4B,KAAArwC,GAAA2T,SAAAwE,EAAAk4B,KAAArwC,GAAA2T,QAAAb,EAGA/a,MAAAkX,SAEAmkC,GAAAr7C,KAAA4c,iBAEA5c,KAAA0Y,WAAA,MApCA1Y,MAAAM,OAAAsb,QAAAb,IAyCAkgC,EAAA5c,UAAAz5B,OAAA,WACA,MAAA5E,MAAAM,OAAAsE,OAAA5E,KAAAM,OAAAsE,SACA5E,KAAAM,QAGA26C,EAAA5c,UAAAhnB,SAAA,WACArX,KAAAwe,OAAAxe,KAAAwe,MAAAnH,WACArX,KAAAwL,SAAA7G,QAAA0S,KAGA4jC,GACG9B,GAEHA,IAAA9a,UAAA/gB,KAAA,SAAAxc,EAAAsM,GACA,GAAAkuC,GAAAt7C,KAAAwe,OAAA,GAAAy8B,IAAAj7C,KAAAgH,OAAAhH,KAAAc,EAAAd,KAAA+E,IACAu2C,GAAAp7B,WAAA9S,EACApN,KAAAwe,OAAAxe,KAAAwe,MAAA+7B,UAAAz5C,GAAA,MACAd,KAAAy4C,UAAA6C,EAAAt7C,MAAA,GACA8X,IAEA,IAAAuhC,IAAAr5C,KAAAwe,KAIA,OAHAxe,MAAAwe,MAAA88B,EACAjC,GAAAr5C,KAAAgH,OAAA2V,mBACA2+B,EAAApkC,SACAokC,GAGAnC,GAAA9a,UAAA9f,OAAA,WACA,GAAAve,KAAAwe,MAAA,CACA,GAAA+8B,GAAAv7C,KAAAwe,KACAxe,MAAAwe,MAAAnW,OACAkzC,EAAA9C,UAAAz4C,UAAAwe,OACA1G,KACAyjC,EAAAlkC,YAIA,IAAA3U,GAGAQ,MAIA,SAAAqxC,EAAAiH,EAAAt4C,GAEA,GAAAkF,GAAAU,CAEA,KAAA5F,EAAAR,sBAAA,CAIA,IAAA0F,EAAA,EAAgBA,EAAAmsC,EAAA9vC,SAAAvB,EAAAR,wBAAkD0F,EAClElF,EAAAR,sBAAAQ,EAAAqxC,EAAAnsC,GAAA,wBAGAlF,GAAAR,wBACAoG,EAAA5F,EAAA4F,WAEA5F,EAAAR,sBAAA,SAAAmG;AACA,GAAA4yC,GAAAC,EAAAt+C,CAOA,OALAq+C,GAAAE,KAAA9iC,MACA6iC,EAAAzgC,KAAAlH,IAAA,MAAA0nC,EAAAD,IACAp+C,EAAA0L,EAAA,WAAmCD,EAAA4yC,EAAAC,IAAmCA,GAEtEF,EAAAC,EAAAC,EACAt+C,MAIIm3C,GAAA,EAAArxC,IAEJR,GAAAQ,GAAAR,uBAhCAA,GAAA,IAmCA,IAAAsW,IAAAtW,GAEAoW,GAAA5V,OAAA04C,aAAA,kBAAA14C,IAAA04C,YAAA/iC,IACA,WAAgB,MAAA3V,IAAA04C,YAAA/iC,OAChB,WAAgB,MAAA8iC,MAAA9iC,OAIhBE,MACAE,IAAA,EA4BA4iC,GAAA,SAAA1sC,GACAnP,KAAAsP,SAAAH,EAAAG,SACAtP,KAAAuC,KAAA4M,EAAA5M,KACAvC,KAAAuP,SAAAJ,EAAAI,SACAvP,KAAAoP,OAAAD,EAAAC,OAEApP,KAAAsC,MAAAwW,KACA9Y,KAAAiO,IAAAjO,KAAAsC,MAAAtC,KAAAsP,SAEAtP,KAAAiZ,SAAA,EAEAF,GAAAhR,KAAA/H,MACAiZ,IAAAD,GAAAL,IAGAkjC,IAAAxd,UAAA1lB,KAAA,SAAAE,GACA,IAAA7Y,KAAAiZ,QAAA,QAEA,IAAAJ,EAAA7Y,KAAAiO,IAIA,MAHAjO,MAAAuC,MAAAvC,KAAAuC,KAAA,GACAvC,KAAAuP,UAAAvP,KAAAuP,SAAA,IAEA,CAGA,IAAAusC,GAAAjjC,EAAA7Y,KAAAsC,MACAy5C,EAAA/7C,KAAAoP,OAAA0sC,EAAA97C,KAAAsP,SAIA,OAFAtP,MAAAuC,MAAAvC,KAAAuC,KAAAw5C,IAEA,GAGAF,GAAAxd,UAAA2d,KAAA,WACAh8C,KAAAi8C,OAAAj8C,KAAAi8C,QACAj8C,KAAAiZ,SAAA,EAGA,IAAAO,OA8CA0iC,GAAA,SAAA/C,GACA,QAAA+C,GAAAl1C,EAAAjC,GACAo0C,EAAA77C,KAAA0C,KAAAgH,GAEAhH,KAAA4Y,OAAA,KAEA5R,IACAhH,KAAA+E,IAAA0I,EAAA1I,GACA/E,KAAAq4C,WAAArxC,EAAAqxC,WAEArxC,EAAAxG,QACAR,KAAAQ,MAAAwG,EAAAxG,MAAAR,KAAA+E,KACAC,EAAAhF,KAAAQ,SAAAR,KAAAyE,OAAAzE,KAAAQ,MAAAiE,QACAzE,KAAAyc,UAqSA,MAhSAy/B,GAAA7d,UAAAlyB,OAAA2tB,OAAAqf,KAAA9a,WACA6d,EAAA7d,UAAA9Y,YAAA22B,EAEAA,EAAA7d,UAAA5hB,MAAA,WACA,GAAA2D,GAAApgB,KAEA29B,EAAA39B,KAAA7B,KAAAw/B,SACAp5B,EAAAo5B,EAAAl5B,MAKA,IAHAzE,KAAA66C,QAAA,EAGA,IAAAt2C,EAAA,CAEA,GAAA/D,GAAAR,KAAAwc,QAAA,mBAAAxc,WAAAm8C,gBAAAn8C,KAAA+vC,aAAA/vC,KAAAQ,MAGAoG,EAAA5G,KAAA7B,KAAAyI,QACAwG,EAAApN,KAAA2b,YAGA,IAAA3b,KAAAwc,QAAA,CACA,GAAA4/B,GAAAp8C,KAAA+vC,eAAAvvC,KAAAR,KAAAwc,QAAAkiB,OAAA1+B,KAAAwc,QAAAkiB,MAAAl+B,MAAA,EAEA,KAAA47C,EAaA,aAHAp8C,MAAAm8C,gBACAn8C,KAAA+vC,aAAAvvC,OACAR,KAAAQ,MAAAR,KAAAwc,QAAA9b,MAPA,IAJAV,KAAAwc,QAAAnF,WACArX,KAAAwc,QAAA,KAGAnU,SAAArI,KAAAQ,MAAA,CACA,GAAAilB,GAAAzlB,KAAAgH,OAAAxG,OAAAR,KAAAgH,OAAAq1C,aAAAr8C,KAAA+E,IACA0gB,GAAAzlB,KAAA+E,OAAAvE,IAAAilB,EAAAzlB,KAAA+E,KAAAvE,IAUA,GAAAyH,EAEA,KAAAA,EAAA,EAAgBA,EAAA1D,EAAS0D,GAAA,GACzB,GAAAy/B,GAAA/J,EAAA11B,EACA,IAAAy/B,EAAAnnB,OAAA/f,EAAA4M,EAAAxG,GAAA,CACAwZ,EAAA5D,QAAAkrB,EAAA9K,KAAAh2B,EAAApG,EAAA4M,EAAAiM,GAAAjM,IACAgT,EAAA2vB,aAAAvvC,EACA4f,EAAA5D,QAAAuoB,QAAA3kB,EAEAA,EAAA5f,MAAA4f,EAAA5D,QAAA9b,KAEA,WAKAw7C,EAAA7d,UAAA1uB,QAAA,SAAAzI,EAAAC,EAAAgI,EAAAO,GACA,GAAA0Q,GAAApgB,IAEAA,MAAA4Y,QAAA5Y,KAAA4Y,OAAAojC,MAEA,IAAA3E,GACAjuC,EAAA,GAAAonC,IAAA,SAAAnnC,GAAsD,MAAAguC,GAAAhuC,GAoBtD,OAlBArJ,MAAA4Y,OAAA,GAAAijC,KACAvsC,SAAAH,EAAAG,SACAF,OAAAD,EAAAC,OACA7M,KAAA,SAAAmlB,GACA,GAAAlnB,GAAAkP,EAAAgY,EACAtH,GAAA+6B,WAAA36C,GACA2O,EAAA5M,MAAA4M,EAAA5M,KAAAmlB,EAAAlnB,IAEA+O,SAAA,WACA6Q,EAAA+6B,WAAAh0C,GACAgI,EAAAI,UAAAJ,EAAAI,SAAApI,GAEAiZ,EAAAxH,OAAA,KACAy+B,OAIAjuC,EAAA4yC,KAAAh8C,KAAA4Y,OAAAojC,KACA5yC,GAGA8yC,EAAA7d,UAAA8c,WAAA,SAAA36C,GACA,IAAA0E,EAAA1E,EAAAR,KAAAQ,OAAA,CAKA,GAFAR,KAAA0c,eAAA1c,KAAA2b,aAAAnb,GAEAR,KAAAgH,OAAAwV,SAAAxc,KAAAgH,OAAAwV,QAAApc,IACAJ,KAAAgH,OAAAwV,QAAApc,IAAAJ,KAAA+E,IAAAvE,GACAR,KAAAgH,OAAAxG,MAAAR,KAAAgH,OAAAwV,QAAA9b,MAEAV,KAAAQ,MAAAR,KAAAgH,OAAAxG,MAAAR,KAAA+E,KACA/E,KAAAwc,UAAAxc,KAAAm8C,gBAAAn8C,KAAAQ,OACAR,KAAAyc,YACK,IAAAzc,KAAAwc,QACLxc,KAAAm8C,gBAAA37C,EACAR,KAAAyc,YACK,CACL,GAAAgJ,GAAAzlB,KAAAgH,OAAAxG,OAAAR,KAAAgH,OAAAq1C,aAAAr8C,KAAA+E,IACA0gB,GAAAzlB,KAAA+E,KAAAvE,EAEAR,KAAAQ,QACAR,KAAAyc,QAGAzc,KAAAgH,OAAA2V,mBACA3c,KAAA2c,mBAGA3X,EAAAxE,KAAAR,KAAAyE,OAAAjE,EAAAiE,QAGAzE,KAAAu4C,MAAA5zC,QAAAqS,IACAhX,KAAAwL,SAAA7G,QAAAsS,IACAjX,KAAAs4C,KAAA3zC,QAAAqS,IAEAhX,KAAA4c,iBAEA,WAAA5c,KAAA+E,KAAAC,EAAAhF,KAAAgH,OAAAxG,SAAAR,KAAAgH,OAAAvC,OAAAzE,KAAAgH,OAAAxG,MAAAiE,UAGAy3C,EAAA7d,UAAAge,aAAA,SAAAt3C,GACA,GAAAu3C,GAAAj3C,EAAAN,QAGA,OAFA/E,MAAAI,IAAAk8C,GAEAA,GAGAJ,EAAA7d,UAAA39B,IAAA,SAAA83C,EAAAj+B,GACA,MAAAva,MAAAwe,MAAAxe,KAAAwe,MAAA9d,IAAA83C,EAAAj+B,IACAi+B,GAAA3hC,GAAA7W,MAEAua,KAAA4/B,QAAAn6C,KAAAk6C,YAAA,IACA1B,GAAAj+B,KAAAw3B,SAAA/xC,KAAAwc,QAAAxc,KAAA+vC,aAAA/vC,KAAAQ,QAGA07C,EAAA7d,UAAAvkB,gBAAA,SAAAlT,GAEA,MADA5G,MAAAw6C,eAAAx6C,KAAAw6C,aAAA,GAAA3B,IAAA74C,OACAA,KAAAw6C,cAGA0B,EAAA7d,UAAA/nB,QAAA,SAAAvR,EAAAwV,GACA,GAAAva,KAAAwe,MACA,OAAAjE,MAAAi3B,WAAA,GAAAnpC,SAAAtD,GAAA,KAAAA,EACA/E,KAAAwe,MAAAlI,QAAAvR,GADA/E,IAIA,IAAAqI,SAAAtD,GAAA,KAAAA,EAAA,MAAA/E,KAGA,KAAAA,KAAA2Z,WAAAhL,eAAA5J,GAAA,CACA,GAAAib,GAAA,GAAAk8B,GAAAl8C,KAAA+E,EACA/E,MAAAwL,SAAAzD,KAAAiY,GACAhgB,KAAA2Z,WAAA5U,GAAAib,EAGA,MAAAhgB,MAAA2Z,WAAA5U,GAAAyZ,MAAAxe,KAAA2Z,WAAA5U,GAAAyZ,MACAxe,KAAA2Z,WAAA5U,IAGAm3C,EAAA7d,UAAApnB,KAAA,WACA,GAAAjX,KAAAwe,MAAA,MAAAxe,MAAAwe,MAAAvH,MAEA,IAAAzW,GAAAR,KAAAu8C,UAEA,KAAAr3C,EAAA1E,EAAAR,KAAAQ,OAAA,CACA,GAAAg8C,GAAAx8C,KAAAQ,KACAR,MAAAQ,SAGAg8C,IAAAh8C,GAAAR,KAAA66C,UACA76C,KAAAwc,UAAAxc,KAAAm8C,gBAAA37C,GACAR,KAAAyc,SAIAzX,EAAAxE,KAAAR,KAAAyE,OAAAjE,EAAAiE,QAEAzE,KAAAwL,SAAA7G,QAAAsS,IACAjX,KAAAu4C,MAAA5zC,QAAAuS,IAEAlX,KAAAs4C,KAAA3zC,QAAAqS,IACAhX,KAAA2c,qBAIAu/B,EAAA7d,UAAAhiB,MAAA,SAAA5U,EAAA0U,GACA,GAAAsgC,GAAAz8C,KAAAQ,MAAAk8C,EAAAj1C,CACAg1C,KAAAC,IAAAD,EAAA/iC,GAAA1Z,OACAmc,IACAsgC,IAAA7tC,IAAAuN,GACAugC,IAAA9tC,IAAAuN,GAGA,IAAAwgC,GAAAF,EAAAh4C,OAEAm4C,KACAC,EAAA,EAEA9hC,EAAA0hC,EAAA7tC,IAAA,SAAAkD,GACA,GAAAjK,GACAvF,EAAAu6C,CAEA,IAGA,GAFAh1C,EAAA60C,EAAA50C,QAAAgK,EAAAxP,GAEAuF,KAAA,EACA,QAGAvF,GAAAuF,EAAA,QACM+0C,EAAA/0C,MAAA,GAAAvF,EAAAq6C,EASN,OALA90C,KAAAg1C,IACAA,GAAA,GAGAD,EAAA/0C,IAAA,EACAA,GAGA7H,MAAAgH,OAAAxG,MAAAR,KAAA+E,KAAA0C,EACAzH,KAAA4b,QAAAb,IAGAmhC,EAAA7d,UAAAke,SAAA,WACA,MAAAv8C,MAAAgH,OAAAxG,MAAAR,KAAAgH,OAAAxG,MAAAR,KAAA+E,KAAAsD,QAGA6zC,EAAA7d,UAAAj+B,IAAA,SAAAI,GACAR,KAAA4Y,QAAA5Y,KAAA4Y,OAAAojC,OACAh8C,KAAAm7C,WAAA36C,IAGA07C,EAAA7d,UAAAziB,QAAA,SAAAb,GACA,GAAAqF,GAAApgB,IAEAA,MAAA0Y,WAAA,CAEA,KADA,GAAAzQ,GAAA8S,EAAAtW,OACAwD,KAAA,CACA,GAAAioB,GAAAnV,EAAA9S,EAEAA,KAAAioB,IAKAjoB,IAAAmY,GAAAzG,YAAAyG,EAAAzG,WAAA1R,GAAAwwC,WAAAvoB,EAAA9P,EAAA9J,QAAA4Z,GAAA7nB,OAAA+X,EAAAzG,WAAA1R,IAAA,KAEAioB,GAAA9P,EAAAg5B,UAAAnxC,GACAmY,EAAAg5B,UAAAnxC,GAAAwwC,UAAApwC,OAAA+X,EAAAg5B,UAAAnxC,IAAA,IACMioB,GAAA9P,EAAAg5B,UAAAnxC,KACNmY,EAAAg5B,UAAAlpB,IAAA9P,EAAAzG,WAAAuW,GAAAja,YAAAia,GACA9P,EAAAg5B,UAAAnxC,GAAAwwC,UAAAr4B,EAAAg5B,UAAAlpB,GAAA9P,EAAAg5B,UAAAnxC,IAAA,KAIA,GAAAozC,GAAAr7C,KAAAyE,SAAAzE,KAAAQ,MAAAiE,MAMA,KAJAzE,KAAAu4C,MAAA5zC,QAAA,SAAAsP,GAAwC,MAAAA,GAAA2H,QAAAb,KACxCjD,GAAA,SAEA7P,EAAAjI,KAAAs4C,KAAA7zC,OACAwD,KACAmY,EAAAk4B,KAAArwC,GAAA2T,SAAAwE,EAAAk4B,KAAArwC,GAAA2T,QAAAb,EAGA/a,MAAAiX,OACAa,GAAA,QAEAujC,GAAAr7C,KAAA4c,iBACA5c,KAAA0Y,WAAA,GAGAwjC,EAAA7d,UAAAhnB,SAAA,WACArX,KAAAwe,OAAAxe,KAAAwe,MAAAnH,WACArX,KAAAwL,SAAA7G,QAAA0S,IACArX,KAAAwc,SAAAxc,KAAAwc,QAAAnF,WACArX,KAAAw6C,cAAAx6C,KAAAw6C,aAAAnjC,YAGA6kC,GACG/C,IAYH2D,GAAA,SAAAZ,GACA,QAAAY,KACAZ,EAAA5+C,KAAA0C,KAAA,gBACAA,KAAAQ,MAAA,mBAAAmC,KAAAtB,OACArB,KAAAmW,QAAA,EACAnW,KAAA7B,KAAA6B,KACAA,KAAA29B,YAaA,MAVAmf,GAAAze,UAAAlyB,OAAA2tB,OAAAoiB,KAAA7d,WACAye,EAAAze,UAAA9Y,YAAAu3B,EAEAA,EAAAze,UAAA1iB,WAAA,WACA,iBAIAmhC,EAAAze,UAAA3hB,eAAA,aAEAogC,GACGZ,IAEH9hC,GAAA,GAAA0iC,IAEAjjC,GAAA,uBA2NA4B,GAAAyK,MAAAmY,UA8CApiB,MAiCAY,GAAA,GAAA+4B,IAAA,UAwCAh4B,GAAAvC,GAAA,QAAAva,MACA4c,GAAArC,GAAA,OAAAva,MACAkd,GAAA3C,GAAA,SAAAva,MACA2d,GAAApD,GAAA,WAAAva,MACAud,GAAAhD,GAAA,QAAAva,MACAqd,GAAA9C,GAAA,UAAAva,MACAgd,GAAAzC,GAAA,WAAAva,MAoPAuR,GAAAvP,OAAAM,cAsBA2c,GAAA,GAAA61B,IAAA,UAsDAmH,GAAA,SAAA/wC,EAAA+f,EAAAljB,GACA,GAAAuX,GAAApgB,IAeA,KAbAA,KAAAgM,WACAhM,KAAA+rB,UAAA/e,EAAA+e,GACA/rB,KAAA6I,WAEA7I,KAAAoM,KAAAe,EAAA4e,GACA/rB,KAAA85C,UAAA,EAEA95C,KAAAg9C,YAMAhxC,GACAA,EAAA4B,UACA5B,EAAA4B,QAAA4rC,cAAAp5B,EAAAhU,KAAA,GAAAgU,GACAA,EAAA48B,SAAAj1C,KAAAiE,EAAA4B,UAGA5B,IAAAuK,iBAAAvK,EAAAhF,OAIA+1C,IAAA1e,UAAAwb,kBAAA,WACA,IAAA75C,KAAA85C,SAAA,CAEA,GAAAh5C,GAAA2U,GAAAzV,KAAAgM,SAAAhM,KAAA+rB,UAEAjrB,KACAd,KAAA85C,UAAA,EACA95C,KAAA6I,SAAA/H,MAIAi8C,GAAA1e,UAAA4e,gBAAA,WACA,IAAAj9C,KAAA85C,SAAA,CAEA,GAAAh5C,GAAAd,KAAAgM,SAAA8J,cAAAxH,QAAAtO,KAAAoM,KACApM,MAAA6I,SAAA/H,GACAd,KAAA85C,UAAA,IAGAiD,GAAA1e,UAAAoa,UAAA,SAAArgC,EAAAC,GACA,GAAA+H,GAAApgB,IAEAqY,MAAAsiC,iBAAA36C,KAAAoM,KAAA,GAAApM,MACAoY,GAAApK,GAAAiV,aAAA,WAAkD,MAAA7K,GAAAohC,cAAAp5B,EAAAhU,KAAA,GAAAgU,MAGlD28B,GAAA1e,UAAA/mB,OAAA,WACA,GAAA8I,GAAApgB,IAEAA,MAAAgM,UAAAzD,EAAAvI,KAAAgM,SAAAqtC,WAAAr5C,MAEAA,KAAA85C,UAEA95C,KAAAg9C,SAAAr4C,QAAA,SAAAnH,GAA0C,MAAAA,GAAAm9C,iBAAAv6B,EAAAhU,KAAA,GAAAgU,KA8F1C,IAAAO,IAAA,SAAA/Z,EAAA9F,EAAA+H,EAAAsG,GACA,GAAAiR,GAAApgB,IAEAA,MAAA4N,QAAAuB,EAAAvB,SAAAhH,EACA5G,KAAA6I,WACA7I,KAAA4G,UAEA9F,EAAAd,KAAA85C,SAAAh5C,IAEAd,KAAAoN,QAAA+B,EAAA/B,QACApN,KAAA2/B,SAAA,GAAAod,IAAAn2C,EAAAoF,SAAAmD,EAAA/B,QAAA,SAAAtM,GACAsf,EAAA05B,SAAAh5C,MAIAqO,EAAAuD,QAAA,GACA1S,KAAAk4C,OAAA,EACAl4C,KAAA0L,YAEA1L,KAAAk9C,SAAAl9C,KAAAm9C,SAGAn9C,KAAA23C,MAAAxoC,EAAAwoC,MACA33C,KAAAo9C,KAAAjuC,EAAAiuC,KACAp9C,KAAAq9C,OAAAluC,EAAAkuC,OAEAr9C,KAAAk4C,OAAA,EAGAv3B,IAAA0d,UAAAtnB,OAAA,WACA/W,KAAAs9C,WAAA,EACAt9C,KAAAc,MACAd,KAAAc,MAAA63C,WAAA34C,MAEAA,KAAA2/B,SAAAroB,UAIAqJ,GAAA0d,UAAA3yB,SAAA,WACA1L,KAAAs9C,YACAt9C,KAAA6I,SAAAvL,KAAA0C,KAAA4N,QAAA5N,KAAAm9C,SAAAn9C,KAAAk9C,SAAAl9C,KAAAoN,SACApN,KAAAk9C,SAAAl9C,KAAAc,MAAAd,KAAAc,MAAAJ,MAAAV,KAAAm9C,SACAn9C,KAAAk4C,OAAA,IAIAv3B,GAAA0d,UAAArnB,aAAA,WACA,GAAAoJ,GAAApgB,IAEA,KAAAA,KAAAk4C,MAAA,CACA,GAAAiF,GAAAn9C,KAAAc,MAAAJ,KACA,IAAAwE,EAAAi4C,EAAAn9C,KAAAk9C,UAAA,MAIA,IAFAl9C,KAAAm9C,WAEAn9C,KAAAq9C,QAAAr9C,KAAAm9C,WAAAn9C,KAAAk9C,SAAA,MAEAlvC,IAAA0pC,YAAA13C,UAAA23C,OACA33C,KAAAk4C,OAAA,EAEAl4C,KAAAo9C,MAAApvC,GAAAiV,aAAA,WAAwD,MAAA7C,GAAArJ,aAIxD4J,GAAA0d,UAAAoa,UAAA,SAAArgC,EAAAC,GACA,GAAA+H,GAAApgB,IAIA,OAFAoY,GAAAD,GAAAnY,KAAAoN,QAAAgL,EAAAC,GAEAD,IAAApY,KAAAc,QAEAd,KAAAc,OAAAd,KAAAc,MAAA63C,WAAA34C,WACAoY,KAAAqhC,eAAA,WAAiD,MAAAr5B,GAAA05B,SAAA1hC,QAGjDuI,GAAA0d,UAAAyb,SAAA,SAAAh5C,GACAd,KAAAc,QACAd,KAAAoN,QAAAtM,EAAA6a,WAAA3b,KAAA4G,SAEA5G,KAAAk9C,SAAA70C,OACArI,KAAAm9C,SAAAr8C,EAAAJ,MAEAI,EAAAmX,SAAAjY,MAGA,IAAA6gB,IAAA,SAAAja,EAAAga,EAAAxU,EAAAvD,EAAAsG,GACA,GAAAiR,GAAApgB,IAEAA,MAAA4N,QAAAuB,EAAAvB,SAAAhH,EACA5G,KAAA4G,UACA5G,KAAA4gB,YACA5gB,KAAAoM,OACApM,KAAA6I,UAEA,IAAA2d,GAAApa,EAAAyD,KAAA,OAAAjM,QAAA,cACA25C,EAAA38B,EAAAjF,WAAA/U,EACA5G,MAAAwmB,QAAA,GAAA4B,QAAA,KAAAm1B,IAAA,UAAA/2B,EAAA,KAEAxmB,KAAAw9C,aACAx9C,KAAAy9C,aAEAz9C,KAAA23C,MAAAxoC,EAAAwoC,MACA33C,KAAAo9C,KAAAjuC,EAAAiuC,KACAp9C,KAAAq9C,OAAAluC,EAAAkuC,OAEAr9C,KAAAk4C,OAAA,EACAl4C,KAAA09C,WACA19C,KAAA6zB,SAAA,CAEA,IAAAgM,GAAAjf,EAAAvS,YAAArO,KAAAoM,KAEAyzB,GAAAl7B,QAAA,SAAA7D,GACAsf,EAAAq9B,UAAA38C,EAAA6a,WAAAyE,EAAAxZ,UAAA9F,EAAAJ,QAGAyO,EAAAuD,QAAA,EACA1S,KAAA0L,WAEA1L,KAAAw9C,UAAAx9C,KAAAy9C,UAGA78B,EAAA65B,wBAAAz6C,MAGA6gB,IAAAwd,UAAAtnB,OAAA,WACA/W,KAAA4gB,UAAAk6B,0BAAA96C,OAGA6gB,GAAAwd,UAAA3yB,SAAA,WACA,GAAA0U,GAAApgB,IAsBA,IApBAmM,OAAAC,KAAApM,KAAAy9C,WAAA94C,QAAA,SAAAyI,GACA,IAAAgT,EAAAu9B,SAAAv9B,EAAAu9B,QAAAvwC,GAAA,CAEA,GAAA+vC,GAAA/8B,EAAAq9B,UAAArwC,GACA8vC,EAAA98B,EAAAo9B,UAAApwC,EAEA,MAAAgT,EAAAi9B,QAAAF,IAAAD,GACAh4C,EAAAi4C,EAAAD,IAAA,CAEA,GAAAr3C,IAAAs3C,EAAAD,EAAA9vC,EACA,IAAAA,EAAA,CACA,GAAAwwC,GAAAx9B,EAAAoG,QAAAjZ,KAAAH,EACAwwC,KACA/3C,IAAA4F,OAAAmyC,EAAArrC,MAAA,KAIA6N,EAAAvX,SAAA1C,MAAAia,EAAAxS,QAAA/H,OAGA7F,KAAA6zB,QACA,OAAAnlB,KAAA1O,MAAAy9C,UACAz9C,KAAAw9C,UAAA9uC,GAAA1O,KAAAy9C,UAAA/uC,OAGA1O,MAAAw9C,UAAAx9C,KAAAy9C,SAGAz9C,MAAA29C,QAAA,KACA39C,KAAAk4C,OAAA,GAGAr3B,GAAAwd,UAAAgc,OAAA,SAAAt1C,GACA/E,KAAA09C,QAAA31C,KAAAhD,IAGA8b,GAAAwd,UAAAziB,QAAA,SAAAb,GACA,GAAAqF,GAAApgB,IAEA,IAAAgF,EAAAhF,KAAA4gB,UAAApgB,OAAA,CAEA,GAAA2N,GAAAnO,KAAA4gB,UAAAjF,WAAA3b,KAAA4G,SACAmN,EAAA/T,KAAA4gB,UAAApgB,MAAAiE,OACAo5C,EAAA79C,KAAAoM,KAAA3H,OAAA,MAAAzE,KAAAoM,KAAAmG,MAAA,GAAA1C,KAAA,OAEA7P,MAAA29C,UACA,QAAA11C,GAAA,EAAmBA,EAAA8S,EAAAtW,OAAuBwD,IAC1C8S,EAAA9S,MAAA,GAAA8S,EAAA9S,SACAmY,EAAAu9B,QAAA,GAAAxvC,EAAA,IAAAlG,EAAA41C,IAAA,EAGA,QAAAC,GAAA/iC,EAAAK,YAA0C0iC,EAAA/pC,EAAW+pC,IACrD19B,EAAAu9B,QAAA,GAAAxvC,EAAA,IAAA2vC,EAAAD,IAAA,IAIAh9B,GAAAwd,UAAArnB,aAAA,WACA,GAAAoJ,GAAApgB,IAEA,KAAAA,KAAAk4C,OAAAl4C,KAAA09C,QAAAj5C,OAAA,CAWA,GAVAzE,KAAAk4C,QAAAl4C,KAAAy9C,cAUAz9C,KAAA09C,QAAAj5C,OAMK,CACL,GAAA4pB,GAAA,EACA0vB,EAAA/9C,KAAA4gB,UAAAzK,OACAnW,KAAA09C,QAAA9uC,IAAA,SAAAxC,GAA2C,MAAAA,GAAAwC,IAAA9B,GAAA+C,KAAA,OAC3C7P,KAAA09C,QAAA9uC,IAAA,SAAAxC,GAA2C,MAAAgU,GAAAQ,UAAAjF,WAAAyE,EAAAxZ,SAAA,IAAAwF,EAAAwC,IAAA9B,GAAA+C,KAAA,MAY3C,IAVA7P,KAAA4gB,UAAAvS,YAAArO,KAAAoM,MAAAzH,QAAA,SAAA7D,GACA,GAAAsM,GAAAtM,EAAA6a,WAAAyE,EAAAxZ,QAEAm3C,GAAAx9B,OAAA,SAAA7R,GAAsC,WAAAtB,EAAAtF,QAAA4G,IAAA,IAAAA,EAAA5G,QAAAsF,KAAmE3I,SACzG4pB,IACAjO,EAAAq9B,UAAArwC,GAAAtM,EAAAJ,UAKA2tB,EAAA,MAEAruB,MAAA6zB,SAAA,MAvBA7zB,MAAA4gB,UAAAvS,YAAArO,KAAAoM,MAAAzH,QAAA,SAAA7D,GACA,GAAAsM,GAAAtM,EAAA6a,WAAAyE,EAAAxZ,QACAwZ,GAAAq9B,UAAArwC,GAAAtM,EAAAJ,QAEAV,KAAA6zB,SAAA,CAsBA7lB,IAAA0pC,YAAA13C,UAAA23C,OACA33C,KAAAk4C,OAAA,EACAl4C,KAAA09C,QAAAj5C,OAAA,EAEAzE,KAAAo9C,MAAAp9C,KAAA+W,UA2BA,IAAAgK,IAAA,SAAAnT,EAAA9M,EAAA+H,EAAAsG,GACAnP,KAAA4N,UACA5N,KAAAc,QACAd,KAAAoN,QAAAtM,EAAA6a,aACA3b,KAAA6I,WAEA7I,KAAA82C,QAAA,KAEAh2C,EAAAmX,SAAAjY,MAEAmP,EAAAuD,QAAA,GACA1S,KAAAg+C,UACAh+C,KAAA4b,YACA5b,KAAAgX,gBAEAhX,KAAAg+C,OAAAh+C,KAAAuS,QAIAwO,IAAAsd,UAAArnB,aAAA,WACAhX,KAAA82C,SAEA92C,KAAA6I,SAAA7I,KAAA82C,SACA92C,KAAA82C,QAAA,OAKA92C,KAAA4b,QAAA5b,KAAAg+C,OAAApvC,IAAAoS,KACAhhB,KAAAgX,iBAIA+J,GAAAsd,UAAAziB,QAAA,SAAAb,GACA,GAMAzY,GANA8d,EAAApgB,KAEAm9C,EAAAn9C,KAAAuS,QAEA0rC,KACAC,KAGAC,IAEApjC,GAAApW,QAAA,SAAAy5C,EAAAC,GACAF,EAAAC,IAAA,EAEAA,IAAAC,GAAAh2C,SAAA/F,IACAA,EAAA+7C,GAGAD,KAAA,GACAF,EAAAn2C,KAAAqY,EAAA49B,OAAAK,MAIAh2C,SAAA/F,MAAAyY,EAAAtW,OAGA,QADAF,GAAA44C,EAAA14C,OACAwD,EAAA,EAAmBA,EAAA1D,EAAS0D,GAAA,EAC5Bk2C,EAAAl2C,IAAAg2C,EAAAl2C,KAAAo1C,EAAAl1C,GAGAjI,MAAA82C,SAAmBmH,WAAAC,UAAA57C,SACnBtC,KAAAg+C,OAAAb,GAGAp8B,GAAAsd,UAAA9rB,MAAA,WACA,GAAA/R,GAAAR,KAAAc,MAAAJ,KACA,OAAAsE,GAAAxE,KAAA+R,WAGA,IAAA2O,KAAqBxO,MAAA,EAAA0qC,MAAA,GAyGrBkB,GAAAjjC,GAAA,OAAAC,KAEAijC,GAAAljC,GAAA,QAAAC,KAEAsH,GAAA,oCAGAd,MAGAC,IAAA,EAGAG,GAAA,KACAD,GAAA,MA+BAnf,IAAAof,OAAA5e,aAEA4e,GAAApf,GAAA0rC,cAAA,SACAtsB,GAAA9a,KAAA,WAEAtE,GAAA07C,qBAAA,WAAA7P,YAAAzsB,IAEAD,KAAAC,GAAAC,WAGA,IAkXAs8B,IACAC,GAnXAx7B,GAAA,GAAA0yB,IAAA,UACAvyB,GAAA,GAAAuyB,IAAA,YAsEA3X,IACAoU,OAAA,SAAAxU,EAAA0U,EAAApjC,GACAojC,EAAA91B,MAAAoH,GAAA0uB,EAAA91B,MAAAtU,EAAAgH,EAAAsN,SAGA/J,KAAA,cAgBAmS,GAAA,+BACAD,GAAA,oBACAT,GAAA,kGACAY,GAAA,cACAJ,GAAA,yCA+EAwZ,IACA59B,KAAA,MAGA8xC,OAAA,SAAAxU,EAAA0U,EAAApjC,GACA,GAAAA,EAAAsV,IAAA,CAEA,GAAArnB,GAAAioB,KACA1C,EAAAxT,EAAAkkC,eAAAlkC,EAAAsV,IAAAD,GAAArV,EAAAsV,IAAArnB,EAEAm1C,GAAApvB,MAAA/lB,EAEAwkB,IAAaxkB,KAAAulB,aAKbjQ,KAAA,SAAAmrB,EAAAv9B,EAAA6O,GACAA,EAAAsV,KAEAje,EAAA,gUAkBAi4B,IACAl+B,KAAA,OAEA8xC,OAAA,SAAAxU,EAAA0U,EAAApjC,GACA,GAAApK,GACAvE,CAGA,IAAA2O,EAAAnQ,MAAAyG,EAAA0J,EAAAnQ,MACA,IAAA+F,IAAAoK,GAAAnQ,KACAwB,EAAA2O,EAAAnQ,KAAA+F,GAEAvE,GAAA,gBAAAA,KACAiF,EAAAjF,IAAAwE,EAAAxE,KACAgG,EAAA,mUAMA+rC,GAAAvzC,KAAAwmB,GAAA+sB,EAAAvzC,KAAAmQ,EAAAnQ,OAGA0T,KAAA,SAAAmrB,EAAAj3B,EAAAuI,GACA,GAAAlG,GAAAuc,GAAAqY,EAAAQ,UAAAr/B,KAAAmQ,EAAAnQ,KAMA,IAJA,kBAAAiK,SAAA3L,KAAAsJ,IAIAqC,KAAAsc,cAAApZ,OACA,OAAAzH,KAAAuE,GACA,kBAAAA,GAAAvE,KAAAuE,EAAAvE,GAAAxC,EAAA+G,EAAAvE,GAAAkC,GAIA,OAAAqC,QAGAy1B,MAAA,SAAA93B,GACA,GAAAqC,GAAAjJ,KAAA0S,KAAA9L,EAAA2e,YAAA3e,IAAAyF,UAEA,OADAzF,GAAAyF,UAAAlO,KAAAiC,IAAA6I,IACA,IA6DAgyB,GAAA,EAEAzU,GAAA,kBAgCAE,GAAAoT,GAAA,MAsBA6kB,GAAA,MACAD,IAAA,SAAA94C,GACA5F,KAAAO,KAAA,aACAP,KAAA4F,SACA,KACA,SAAAI,OAAAJ,GACI,MAAA8D,GACJ1J,KAAAyW,MAAA/M,EAAA+M,QAIAioC,GAAArgB,UAAAr4B,MAAAq4B,UAEAogB,GAAA,SAAAr9B,EAAAjS,GACA,GAEAqC,GAAAM,EAFAsO,EAAApgB,KAEA4+C,EAAA,CAmBA,KAjBA5+C,KAAAohB,MACAphB,KAAAmP,cACAnP,KAAAmnB,IAAA,EAEAnnB,KAAA2lC,MAAA3lC,KAAAohB,IAAA3I,MAAA,MACAzY,KAAA6+C,SAAA7+C,KAAA2lC,MAAA/2B,IAAA,SAAAk3B,GACA,GAAAgZ,GAAAF,EAAA9Y,EAAArhC,OAAA,CAGA,OADAm6C,GAAAE,EACAA,GACI,GAGJ9+C,KAAA0S,MAAA1S,KAAA0S,KAAA0O,EAAAjS,GAEAqC,KAEA4O,EAAA+G,IAAA/G,EAAAgB,IAAA3c,SAAAqN,EAAAsO,EAAA0O,SACAtd,EAAAzJ,KAAA+J,EAGA9R,MAAA++C,SAAA/+C,KAAAwpB,YACAxpB,KAAAiJ,OAAAjJ,KAAAg/C,YAAAh/C,KAAAg/C,YAAAxtC,EAAArC,GAAAqC,GAGAitC,GAAApgB,WACAvP,KAAA,SAAAmwB,GACA,GAEA93B,GAAAlf,EAAA1D,EAAAuN,EAFAsO,EAAApgB,IASA,KALAi/C,MAAAj/C,KAAAi/C,YAEA93B,EAAAnnB,KAAAmnB,IAEA5iB,EAAA06C,EAAAx6C,OACAwD,EAAA,EAAgBA,EAAA1D,EAAS0D,GAAA,EAGzB,GAFAmY,EAAA+G,MAEArV,EAAAmtC,EAAAh3C,GAAAmY,GACA,MAAAtO,EAIA,cAGA+d,kBAAA,SAAA1I,EAAAvhB,GACA,GAAAqH,GAAAjN,KAAA6yB,WAAA1L,GAAA+3B,EAAAjyC,EAAA,GAAAkyC,EAAAlyC,EAAA,EACA,IAAAjN,KAAAmP,QAAA+jC,gBAAA,EACA,OAAAgM,EAAAC,EAAA,GAAAv5C,EAAA,YAAAs5C,EAAA,cAAAC,EAGA,IAAArZ,GAAA9lC,KAAA2lC,MAAAuZ,EAAA,GAEAE,EAAA,GACAC,EAAA,EACA,IAAAr/C,KAAAmP,QAAA+jC,aAAA,CACA,GAAA5wC,GAAA48C,EAAA,EAAAl/C,KAAAmP,QAAA+jC,aAAA,IAAAgM,EAAA,EAAAl/C,KAAAmP,QAAA+jC,YACAkM,GAAAp/C,KAAA2lC,MAAApzB,MAAAjQ,EAAA48C,EAAA,EAAA58C,GAAAuN,KAAA,MAAAjM,QAAA,YACAy7C,EAAAr/C,KAAA2lC,MAAApzB,MAAA2sC,IAAAl/C,KAAAmP,QAAA+jC,cAAArjC,KAAA,MAAAjM,QAAA,YACAw7C,IACAA,GAAA,MAEAC,IACAA,EAAA,KAAAA,GAIA,GAAAC,GAAA,EACAC,EAAAH,EAAAtZ,EAAAliC,QAAA,eAAAyJ,EAAAmyC,GAKA,MAJAA,GAAAL,IACAG,GAAA,GAGA,OACK,QAAAp5B,OAAAi5B,EAAAG,GAAAzvC,KAAA,aAAAwvC,CAEL,QAAAH,EAAAC,EAAA,GAAAv5C,EAAA,YAAAs5C,EAAA,cAAAC,EAAA,MAAAI,IAGA1sB,WAAA,SAAA2sB,GAKA,IAJA,GAEAL,GAFA/+B,EAAApgB,KAEAk/C,EAAA,EAAAN,EAAA,EAEAY,GAAAp/B,EAAAy+B,SAAAK,IACAN,EAAAx+B,EAAAy+B,SAAAK,GACAA,GAAA,CAIA,OADAC,GAAAK,EAAAZ,GACAM,EAAA,EAAAC,EAAA,EAAAK,IAGA79C,MAAA,SAAAiE,GACA,GAAAqH,GAAAjN,KAAA6vB,kBAAA7vB,KAAAmnB,IAAAvhB,GAAAs5C,EAAAjyC,EAAA,GAAAkyC,EAAAlyC,EAAA,GAAArL,EAAAqL,EAAA,GAEAtL,EAAA,GAAA+8C,IAAA98C,EAMA,MAJAD,GAAAmkC,KAAAoZ,EACAv9C,EAAA89C,UAAAN,EACAx9C,EAAA+9C,aAAA95C,EAEAjE,GAGAulB,YAAA,SAAAvjB,GACA,GAAA3D,KAAAohB,IAAA5T,OAAAxN,KAAAmnB,IAAAxjB,EAAAc,UAAAd,EAEA,MADA3D,MAAAmnB,KAAAxjB,EAAAc,OACAd,GAIA0jB,aAAA,SAAAb,GACA,GAAAnZ,EAEA,IAAAA,EAAAmZ,EAAAjZ,KAAAvN,KAAAwpB,aAEA,MADAxpB,MAAAmnB,KAAA9Z,EAAA,GAAA5I,OACA4I,EAAA,IAAAA,EAAA,IAIA+Z,gBAAA,WACApnB,KAAAqnB,aAAAs3B,KAGAn1B,UAAA,WACA,MAAAxpB,MAAAohB,IAAAgE,UAAAplB,KAAAmnB,MAGA0D,SAAA,WACA,MAAA7qB,MAAAohB,IAAApd,OAAAhE,KAAAmnB,OAIAs3B,GAAApM,OAAA,SAAAE,GACA,GAAAP,GAAAjtC,EAAA84B,EAAA79B,IAEAgyC,GAAA,SAAA5wB,EAAAjS,GACAsvC,GAAAnhD,KAAA0C,KAAAohB,EAAAjS,IAGA6iC,EAAA3T,UAAAvE,GAAA+D,EAAAQ,UAEA,KAAAt5B,IAAAwtC,GACA1tC,GAAAvH,KAAAi1C,EAAAxtC,KACAitC,EAAA3T,UAAAt5B,GAAAwtC,EAAAxtC,GAKA,OADAitC,GAAAK,OAAAoM,GAAApM,OACAL,EAGA,IAwQAloB,IACAC,GACAC,GA1QA21B,GAAAlB,GAEA7O,GAAA,EACAnb,GAAA,EACApB,GAAA,EACAY,GAAA,EACAyD,GAAA,EACA3C,GAAA,EACA4D,GAAA,EACA7E,GAAA,EACAM,GAAA,EACAqD,GAAA,GACA1F,GAAA,GACAmH,GAAA,GACAmG,GAAA,GACAxK,GAAA,GACA+F,GAAA,GACApB,GAAA,GACAzF,GAAA,GAEAzK,GAAA,GACAe,GAAA,GACAsB,GAAA,GACAP,GAAA,GACA3B,GAAA,GACA9B,GAAA,GAEAkF,GAAA,GACA9B,GAAA,GAGAC,GAAA,GACAsC,GAAA,GACAI,GAAA,GACAa,GAAA,GACArB,GAAA,GACAe,GAAA,GACAO,GAAA,GAEAb,GAAA,GAEA2I,GAAA,GACAP,GAAA,GACAuX,GAAA,GACApZ,GAAA,GACAqZ,GAAA,GAEArY,GAAA,GACAG,GAAA,GAEA1F,GAAA,GACAH,GAAA,GACAC,GAAA,GACAmwB,GAAA,GAEAt4B,GAAA,WACAC,GAAA,OAyCAE,GAAA,0HAeAK,GAAA,yBAMAK,MAOA03B,GAAA,4YACAjmB,GAAA,qGAEAlR,IAAsBo3B,KAAA,GAAAh3B,IAAA,GAAAi3B,KAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAC,KAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,IAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,OAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,QAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,QAAA,IAAAC,GAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,IAAA,IAAAC,QAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAA7S,MAAA,IAAA8S,QAAA,IAAAC,KAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,KAAA,IAAAC,MAAA,IAAAC,OAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,GAAA,IAAAC,QAAA,IAAAC,GAAA,IAAAC,IAAA,IAAAC,OAAA,IAAAC,MAAA,IAAAC,IAAA,IAAAC,QAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,MAAA,IAAAC,SAAA,IAAAC,MAAA,IAAAC,IAAA,IAAAC,KAAA,KAAAC,KAAA,KAAAC,OAAA,KAAAC,KAAA,KAAAC,IAAA,KAAAC,IAAA,KAAAC,IAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,OAAA,KAAAC,OAAA,KAAAC,KAAA,KAAAC,OAAA,KAAAC,OAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,OAAA,KAAAC,OAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,KAAA,KAAAC,MAAA,KAAAC,OAAA,KAAAC,KAAA,KAAAC,MAAA,KAAAC,QAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,MAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,OAAA,KAAAnyC,KAAA,KAAAoyC,MAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,KAAA,KAAAC,MAAA,KAAAC,GAAA,KAAAC,KAAA,KAAAC,IAAA,KAAAC,MAAA,KAAAC,OAAA,KAAAC,MAAA,KAAAzoD,KAAA,KAAA0oD,MAAA,KAAAC,IAAA,KAAAC,IAAA,KAAAC,GAAA,KAAAC,IAAA,KAAAC,IAAA,KAAAC,IAAA,KAAAC,OAAA,KAAAC,IAAA,KAAAC,KAAA,KAAAC,MAAA,KAAAC,GAAA,KAAAC,MAAA,KAAAC,GAAA,KAAAC,GAAA,KAAAC,IAAA,KAAAC,IAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,MAAA,KAAAC,OAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,MAAA,KAAAC,MAAA,KAAAC,OAAA,KAAAC,OAAA,KAAAC,KAAA,KAAAC,KAAA,KAAAC,IAAA,KAAAC,OAAA,KAAAC,MAAA,KAAAC,OAAA,KAAAC,MAAA,MACtBrmC,IAAA,kJACAV,GAAA,GAAAH,QAAA,0BAAAjc,OAAAC,KAAAsc,IAAA7Y,KAAA,YAA4G,KAC5GsZ,GAAA,kBAAAmF,QAAAihC,cACA5mC,GAAAQ,GAAAmF,OAAAihC,cAAAjhC,OAAAkhC,aAuBAzmC,GAAA,KACAC,GAAA,KACAF,GAAA,KACAI,GAAA,MAiEAsC,GAAA,mCACAyB,GAAA,yBAGA5D,GAAA,6FA0CAS,IAAA,sCAGAC,GAAA,8EAGAC,GAAA,wCAsCA,IA0OA4C,IACAD,GA3OArC,GAAAZ,GAAA,KACAU,GAAAV,GAAA,KAsCAgB,GAAA,4BAEAD,GAAA,6BAgMA8B,GAAA,yCAIAK,IAAA,0LAGAD,GAAA,8JAEA,IAoMA8iC,IACAC,GArMAhjC,GAAA,4EACAD,GAAA,+BACAN,GAAA,+CACAC,GAAA,SACAE,GAAA,WAkMAojC,IAAA,SAAAC,EAAAC,GACA,gBAAA7oC,GACA,GAAAyG,EAEA,QAAAA,EAAAoiC,EAAA7oC,IACAyG,EAGAzG,EAAAG,YAAAyoC,IAIA5oC,EAAAK,kBAEAoG,EAAA1C,GAAA/D,GACAyG,GACAzG,EAAAplB,MAAA6pB,KAIAznB,EAAA4rD,EACA/hC,EAAAJ,EACA9F,EAAA6G,KAbA,OAmBA,WACA,GAAAtmB,GAAA1D,EAAAsrD,EAAAC,EAAAF,CAKA,KAHAE,EAAA,iBAAAr3C,MAAA,KAEAm3C,EAAAriC,GACAtlB,EAAA,EAAA1D,EAAAurD,EAAArrD,OAA6CwD,EAAA1D,EAAS0D,GAAA,EACtD4nD,EAAAH,GAAAI,EAAA7nD,GAAA2nD,GACAA,EAAAC,CAMAJ,IAAAG,IAGA,IAEAG,IACAC,GAHAC,GAAAR,EAIAO,IAAA,SAAAL,EAAAC,GACA,gBAAA7oC,GACA,GAAAzkB,GAAA4tD,EAAAC,CAGA,IADAD,EAAAN,EAAA7oC,IACAmpC,EACA,WAMA,SAKA,GAJA5tD,EAAAykB,EAAAI,IAEAJ,EAAAK,mBAEAL,EAAAG,YAAAyoC,GAEA,MADA5oC,GAAAI,IAAA7kB,EACA4tD,CAIA,WAAAP,GAAA,gBAAA9hD,KAAAkZ,EAAAyC,YAAAxlB,OAAA,IAEA,MADA+iB,GAAAI,IAAA7kB,EACA4tD,CAOA,IAJAnpC,EAAAK,kBAGA+oC,EAAAP,EAAA7oC,IACAopC,EAEA,MADAppC,GAAAI,IAAA7kB,EACA4tD,CAGAA,IACAxoC,EAAA8G,GACAzqB,EAAA4rD,EACA/hC,GAAAsiC,EAAAC,OAUA,WACA,GAAAloD,GAAA1D,EAAAsrD,EAAAO,EAAAR,CAUA,KAJAQ,EAAA,wEAAA33C,MAAA,KAGAm3C,EAAAK,GACAhoD,EAAA,EAAA1D,EAAA6rD,EAAA3rD,OAA4CwD,EAAA1D,EAAS0D,GAAA,EACrD4nD,EAAAG,GAAAI,EAAAnoD,GAAA2nD,GACAA,EAAAC,CAIAE,IAAAH,IAGA,IAwUAlgC,IAxUA1B,GAAA+hC,GAgLAM,IACAC,MAAA,EACAC,OAAA,EACAC,KAAA,KACAnoD,kBAGAooD,GAAA,GAAAroC,QAAA,OAAAjc,OAAAC,KAAAikD,IAAAxgD,KAAA,UACA6gD,GAAA,8FACAC,GAAA,kBACAC,GAAA,kBACAC,GAAA,QAEA7hC,GAAA2wB,GAAAtN,QACA3/B,KAAA,SAAA0O,EAAAjS,GACAnP,KAAA2d,OAAAxO,EAAAwO,OACA3d,KAAAonB,mBAGA43B,YAAA,SAAA/1C,GACA,WAAAA,EAAAxE,QAAAosD,GAAAhjD,KAAA7N,KAAA++C,WAIYv+C,MAAAyI,EAAA,GAAA2e,GAHZ,MAMAq3B,YACA,SAAAl4B,GACA,IAAAA,EAAApJ,OAAA,WAEA,IAAAmzC,GAAA/pC,EAAAM,aAAAupC,GAEA,OAAAE,IAAA/pC,EAAApJ,OAAAhP,eAAAmiD,IACclpC,EAAAb,EAAApJ,OAAAmzC,IADd,QAKA,SAAA/pC,GACA,GAAAgqC,GAAAhqC,EAAAM,aAAAopC,GACA,IAAAM,EAAA,OAA4BnpC,EAAAyoC,GAAAU,KAG5B,SAAAhqC,GACA,GAAAvf,GAAAuf,EAAAM,aAAAqpC,GACA,IAAAlpD,EAAA,OAA2BogB,GAAApgB,IAG3B,SAAAuf,GACA,GAAAiqC,GAAA7mC,GAAApD,GACApJ,EAAAoJ,EAAApJ,MAEA,OAAAqzC,IAAArzC,GAEAiK,EAAAopC,EAAAppC,EAAAhkB,QAAA+sD,GAAA,SAAAtjD,EAAAyX,GAA+E,MAAAA,KAAAnH,KAAAmH,QAI/EksC,GAGA,SAAAjqC,GACA,IAAAA,EAAAG,YAAA,KAAiC,WAEjC,IAAAje,KAIA,IAFA8d,EAAAK,kBAEAL,EAAAG,YAAA,KACA,OAAcU,EAAA3e,EAId,KADA,GAAA8F,GACAA,EAAA6f,GAAA7H,IAAA,CAKA,GAJA9d,EAAA8F,EAAAhK,KAAAgK,EAAAvO,MAEAumB,EAAAK,kBAEAL,EAAAG,YAAA,KACA,OAAeU,EAAA3e,EAGf,KAAA8d,EAAAG,YAAA,KACA,YAIA,aAGA,SAAAH,GACA,IAAAA,EAAAG,YAAA,gBAEA,IAAAje,KAIA,IAFA8d,EAAAK,kBAEAL,EAAAG,YAAA,KACA,OAAcU,EAAA3e,EAId,KADA,GAAA4lB,GACAA,EAAA9H,EAAA+H,QAAA,CAKA,GAJA7lB,EAAAlB,KAAA8mB,EAAAjH,GAEAb,EAAAK,kBAEAL,EAAAG,YAAA,KACA,OAAeU,EAAA3e,EAGf,KAAA8d,EAAAG,YAAA,KACA,WAGAH,GAAAK,kBAGA,gBAiCAwI,GAAA,uCAEAF,IAAAiwB,GAAAtN,QACA4M,YAAAn0B,IACAuB,YAAA,GAmHA,IAurCA+N,IAvrCAjK,GAAA,gBACA0B,GAAA,MACAH,GAAA,gDACAC,GAAA,yFACAH,GAAA,iCACAC,GAAA,4DACAF,IACA0/B,eAAyBvpC,EAAA+H,GAAA7H,EAAA,MACzBspC,OAAiBxpC,EAAA+H,GAAA7H,EAAA,MACjBupC,OAAiBzpC,EAAA+H,GAAA7H,EAAA,MACjBwrB,MAAgB1rB,EAAAk4B,GAAAh4B,EAAA,KAChBurB,QAAkBzrB,EAAAk4B,GAAAh4B,EAAA,KAClBwpC,WAAqB1pC,EAAA8H,KAErBuB,GAAA,gBA+OAyB,IAA8B9K,EAAA+P,GAAA3F,SAAA,GA2L9B6B,GAAA,0EACAD,GAAA,OA+MAiB,GAAA,YA2DAM,GAAA,cAuBAG,GAAA,gBA0BAc,IACAm7B,KAAA/jB,GACAgkB,GAAAh7B,GACAi7B,KAAAhkB,GACAikB,OAAAz7B,IAGAI,GAAA,qCACAE,GAAA,qCACAJ,GAAA,GAAA7N,QAAA,KAAAjc,OAAAC,KAAA8pB,IAAArmB,KAAA,aAgKAgnB,GAAA,OACAC,GAAA,MAgCAS,GAAA,qBACAD,GAAA,qBAyFAyB,GAAA,gBACAH,GAAA,mCACAJ,GAAA,gBACAC,GAAA,gBACAI,GAAA,kBACAC,GAAA,kBA0HAG,GAAA,uCA6BAQ,GAAA,gCACAC,GAAA,aACA5H,IAAiBA,SAAA,EAGjBsI,KACAq3B,IAAA,MACAC,IAAA,WACAC,IAAA,WACAl0D,EAAA,0IAAAgb,MAAA,KACAm5C,IAAA,WACAC,IAAA,WACAC,UAAA,YACAh2C,QAAA,qBACAi2C,OAAA,iBACAC,OAAA,iBACAC,OAAA,SACAC,IAAA,cACAC,IAAA,gBACAC,IAAA,gBAiQA,IAmLA92B,IAnLAd,GAAA,WACAC,GAAA,uCACAC,GAAA,SAiDAK,GAAA,qBA4HAs3B,IAAAz+B,GAAAN,GAAAgC,GAAAZ,GAAAH,GAAAJ,IACAm+B,IAAAn/B,IACAo/B,IAAAj/B,GAAAgC,GAAAf,GAQArK,IAAAsoC,gBAAA,SAAArrB,GACA,MAAAA,OAEAh7B,QAAAC,KAAA+6B,GAAAxiC,QAAA,SAAAI,GACA,GAAAvE,GAAA2mC,EAAApiC,EACA,iBAAAvE,KACA2mC,EAAApiC,GAAAqhB,GAAA5lB,SAMA,IAAA+1B,KAAAtF,GAAAuF,GAAA2C,GAAAkB,IACAJ,IAAAM,GAAAM,GAEAS,IAAAqkB,GAAAtN,QACA3/B,KAAA,SAAA0O,EAAAjS,GACA,GAAA0jC,GAAA1jC,EAAA0jC,mBAAA,MAA6D,OAC7DC,EAAA3jC,EAAA2jC,mBAAA,WACAC,EAAA5jC,EAAA4jC,yBAAA,YAEA/yC,MAAAg2B,mBAAA7mB,EAAA2rB,aAAA,KAAyD,MAEzD96B,KAAAowB,OACMuC,UAAA,EAAA8/B,UAAA,EAAApiC,KAAArwB,KAAAg2B,mBAAA,GAAA1D,MAAAtyB,KAAAg2B,mBAAA,GAAAtD,QAAA2/B,KACA1/B,UAAA,EAAA8/B,UAAA,EAAApiC,KAAAwiB,EAAA,GAAAvgB,MAAAugB,EAAA,GAAAngB,QAAA4/B,KACA3/B,UAAA,EAAA8/B,UAAA,EAAApiC,KAAAyiB,EAAA,GAAAxgB,MAAAwgB,EAAA,GAAApgB,QAAA6/B,KACA5/B,UAAA,EAAA8/B,UAAA,EAAApiC,KAAA0iB,EAAA,GAAAzgB,MAAAygB,EAAA,GAAArgB,QAAA4/B,KAGNtyD,KAAAkzC,aAAA/jC,EAAA+jC,cAAA,EAEAlzC,KAAAuyB,mBAEAvyB,KAAA0wB,aAAA,EACA1wB,KAAA65B,gBAEA75B,KAAAiH,aACAyrD,QAAAvjD,EAAAlI,aAAAkI,EAAAlI,YAAAyrD,UAAA,EACAjwC,OAAAtT,EAAAlI,aAAAkI,EAAAlI,YAAAwb,SAAA,EACAkwC,UAAA,GAGAxjD,EAAA8jC,YAAA,IACA9jC,EAAA8jC,UAEA2f,SAAA,yHAAAn6C,MAAA,KACAo6C,iBAAA,IAIA7yD,KAAA+3B,cAAA5oB,EAAA4oB,iBAAA,EACA/3B,KAAAg4B,mBAAA7oB,EAAA6oB,mBACAh4B,KAAAk6B,iBAAA/qB,EAAA8jC,UAAA9jC,EAAA8jC,SAAA2f,SACA5yD,KAAA4xB,wBAAAziB,EAAA8jC,UAAA9jC,EAAA8jC,SAAA4f,gBACA7yD,KAAA4yB,qBAAAzjB,EAAAyjB,qBACA5yB,KAAA42B,aAAAznB,EAAAynB,aACA52B,KAAAgzC,IAAA7jC,EAAA6jC,KAGAgM,YAAA,SAAA/1C,GAEA,IAAAA,EAAAxE,OACA,OAAaijB,KAAAE,EAAAqT,GASb,IANAj7B,KAAA0wB,aAAA,GACA1wB,KAAA2B,MAAA,2BAGAm2B,GAAA7uB,EAAA,GAAAye,EAAA1nB,KAAA+3B,cAAA/3B,KAAAg4B,oBAAAh4B,KAAAg4B,oBAAAh4B,KAAAg4B,oBAEAh4B,KAAAgzC,OAAA,GACA,GAAA1nB,KACA4P,IAAAjyB,EAAA,GAAAye,EAAA4D,GACAnf,OAAAC,KAAAkf,GAAA7mB,SAAAwE,EAAA,GAAAS,EAAA4hB,GAGA,MAAAriB,GAAA,IAGAg2C,YACAjkB,IAGAzI,iBAAA,WAGAvyB,KAAAowB,KAAAhS,KAAA,SAAAjZ,EAAAC,GACA,MAAAA,GAAAirB,KAAA5rB,OAAAU,EAAAkrB,KAAA5rB,WAKA,IAAAquD,KACA,aACA,mBACA,mBACA,yBACA,MACA,cACA,qBACA,WACA,gBACA,gBAGAp3B,GAAA,6EAEAE,GAAA,6LAmBA7U,IAEAkV,OAAA,SAAA7+B,EAAA+R,GACA,IAAArM,GAAA,CACA,GAAAqM,KAAAu9B,QAAwC,MACxC,UAAA1mC,OAAA,6BAAA5I,EAAA,4CAGAA,QAAAwG,QAAA,SAEA,IAAA9E,EAEA,MAAAA,EAAAgE,GAAA7E,eAAAb,IAAA,CACA,GAAA+R,KAAAu9B,QAAwC,MACxC,UAAA1mC,OAAA,4CAAA5I,GAGA,cAAA0B,EAAA4lC,QAAAzgC,cAAA,CACA,GAAAkL,KAAAu9B,QAAwC,MACxC,UAAA1mC,OAAA,6BAAA5I,EAAA,gCAGA,qBAAA0B,KAAA2vC,YAAA3vC,EAAAwjB,WAIA4Z,SAAA,SAAAp9B,GACA,wBAAAA,KAGAq9B,gBAAA,SAAAv1B,GAIA,MAFAA,GAAA4rC,WAA6B5rC,IAAA4rC,UAE7BsgB,GAAApwC,OAAA,SAAArF,EAAAtY,GAEA,MADAsY,GAAAtY,GAAA6B,EAAA7B,GACAsY,QAIA6M,MAAA,SAAAprB,EAAAqQ,GACAosB,GAAArR,GAAA,WAAAwR,GACA,IAAAnM,GAAArF,GAAAprB,EAAAqQ,EAEA,OADAyX,IAAA2I,GACAA,GAGAgN,SAAA,SAAAz9B,EAAA8H,GACA,MAAA5G,MAAAkqB,MAAAprB,EAAAkB,KAAAm8B,gBAAAv1B,MAIAs3B,IACA39B,KAAA,WAEA8xC,OAAA,SAAAxU,EAAA0U,EAAApjC,GAEA,eAAAA,GAAA,CACA,GAAArQ,GAAAqQ,EAAArQ,QAEA,mBAAAA,GACAyzC,EAAAzzC,WAEAyzC,EAAAzzC,SAAAs9B,GAAAt9B,EAAAyzC,KAKA7/B,KAAA,SAAAmrB,EAAAj3B,EAAAuI,GAIA,GAAArQ,GAAA,YAAAqQ,KAAArQ,SAAA++B,EAAAQ,UAAAv/B,QAGA,IAFAA,MAA4B8oB,EAAAqT,GAAAvT,MAE5B,kBAAA5oB,GAAA,CACA,GAAA6O,GAAA7O,CACAA,GAAAk9B,GAAAp1B,EAAA+G,GAEA/G,EAAAm1B,QAAAj9B,UACA6O,KACA1E,OAAAnK,GAIAA,EAAAs9B,GAAAt9B,EAAA8H,GAMAA,EAAA9H,WAAA4oB,EAEA5oB,EAAArB,GACA++B,GAAA51B,EAAAyyB,SAAAv6B,EAAArB,IAIAihC,MAAA,SAAA93B,GACA,GAAAqC,GAAA4yB,GAAAj1B,EAEA,IAAAqC,EAAA,CACA,GAAAsmB,GAAA6M,GAAAnzB,EAAArC,EAKA,OAHAA,GAAA9H,SAAAywB,EAAA7H,EACA8U,GAAA51B,EAAAyyB,SAAA9J,EAAA9xB,GAAA,IAEA,KAyFAs1D,IACA,WACA,aACA,WACA,aACA,SACA,SACA,gBACA,WACA,eAGAC,GAAA,SAAAzyD,EAAA6xC,GACApyC,KAAAO,OACAP,KAAAoyC,cAGA4gB,IAAA30B,UAAAgU,OAAA,SAAAxU,EAAA0U,EAAApjC,GACAnP,KAAA49B,UACA59B,KAAAoyC,YAAAvU,EAAA2U,SAAA3U,EACA79B,KAAAoyC,YAAAG,IAAAhtB,YACApW,IAGA6jD,GAAA30B,UAAA3rB,KAAA,aAIAsgD,GAAA30B,UAAAT,UAAA,SAAAC,EAAAv9B,EAAA6O,GACA,GAAA5O,GAAAP,KAAAO,KACAub,EAAA3M,EAAA5O,GAEAy9B,EAAAlE,GAAA+D,EAAAt9B,GAEA,QAAAwE,KAAA+W,GACAkiB,EAAAj5B,GAAA+W,EAAA/W,EAGAzE,GAAAC,GAAAy9B,GAGAg1B,GAAA30B,UAAAK,MAAA,SAAA93B,GACA,GAAAo3B,GAAAp3B,EAAA5G,KAAAO,MACAm9C,GAAA,CAeA,OAbAvxC,QAAAC,KAAA4xB,GAAAr5B,QAAA,SAAAI,GACA,GAAA+M,GAAAksB,EAAAj5B,EAEA+M,GAAAi7B,MACAj7B,EAAAi7B,IAAAH,QACA5O,EAAAj5B,GAAA+M,EAAAi7B,UAEA/O,GAAAj5B,GAEA24C,GAAA,KAIAA,EAGA,IAAA3f,IAAAg1B,GAAAnkD,IAAA,SAAArO,GAAyD,UAAAyyD,IAAAzyD,EAAA,aAAAA,KAuEzD0yD,IACAx2C,MAAAwhB,GACAxZ,IAAA0Z,GACAn/B,KAAAy/B,GACA3/B,SAAAo/B,IAGAg1B,GAAA/mD,OAAAC,KAAAomC,IAEA1U,GAAAS,GAAA20B,GAAA3yC,OAAA,SAAAxb,GAAqE,OAAAkuD,GAAAluD,MAGrEu5B,GAAAC,GAAA20B,GAAAznD,OAAAsyB,GAAAnvB,IAAA,SAAA7E,GAAmF,MAAAA,GAAAxJ,SAEnF4yD,MAAA1nD,OACAynD,GAAA3yC,OAAA,SAAAxb,GAAyC,OAAAg5B,GAAAh5B,KAAAkuD,GAAAluD,KACzCg5B,GAEAk1B,GAAAn0D,SACAm0D,GAAAxuC,KAGAma,IACAyT,OAAA,SAAAxU,EAAA0U,EAAApjC,GAAgD,MAAAyuB,IAAA,SAAAC,EAAA0U,EAAApjC,IAEhDuD,KAAA,SAAAmrB,EAAAj3B,EAAAuI,GAAgD,MAAAyuB,IAAA,OAAAC,EAAAj3B,EAAAuI,IAEhDuvB,MAAA,SAAA93B,GACA,MAAAusD,IAAA5yC,OAAA,SAAA/iB,GACA,MAAAA,GAAAkhC,OAAAlhC,EAAAkhC,MAAA93B,KACKgI,IAAA,SAAApR,GAAuB,MAAAA,GAAA+C,QAK5B4yD,UA8DAt0B,IAAA,0DAEAI,GAAA,GAAA2W,IAAA,YACA1W,GAAA,GAAA0W,IAAA,SACA5W,GAAA,GAAA4W,IAAA,UACA9W,GAAA,GAAA8W,IAAA,YAwGAvG,GAAA,SAAAlgC,GACAnP,KAAAqR,eAAAlC,EAAAkC,eACArR,KAAA4G,QAAAuI,EAAAkC,eAAAzK,QAEA5G,KAAAlB,SAAAqQ,EAAArQ,SACAkB,KAAA6H,MAAAsH,EAAAtH,MACA7H,KAAAoH,KAAA+H,EAAArQ,SAAA4oB,EAEA1nB,KAAAk4C,OAAA,EAGA7I,IAAAhR,UAAAvpB,OAAA,WACA9U,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAAqR,eAAAyD,WAIAu6B,GAAAhR,UAAA+0B,UAAA,WACApzD,KAAAgM,UAAAhM,KAAAgM,SAAAonD,aAGA/jB,GAAAhR,UAAAjuB,KAAA,WACA,aAGAi/B,GAAAhR,UAAA5rB,QAAA,aAIA48B,GAAAhR,UAAAtrB,cAAA,WACA,aAGAs8B,GAAAhR,UAAAxrB,kBAAA,aAIAw8B,GAAAhR,UAAA+R,aAAA,WACA,MAAApwC,MAAAqR,eAAA++B,aAAApwC,OAGAqvC,GAAAhR,UAAAuc,SAAA,WACA56C,KAAAgM,UAAAhM,KAAAgM,SAAA4uC,YAGAvL,GAAAhR,UAAAkO,QAAA,WACA,MAAAvsC,MAAAyD,WAGA,IAAA4vD,IAAA,SAAAnX,GACA,QAAAmX,KACAnX,EAAA/1C,MAAAnG,KAAAwE,WAkCA,MA/BA6uD,GAAAh1B,UAAAlyB,OAAA2tB,OAAAoiB,KAAA7d,WACAg1B,EAAAh1B,UAAA9Y,YAAA8tC,EAEAA,EAAAh1B,UAAA39B,IAAA,SAAA83C,GACAA,GAAA3hC,GAAA7W,KAEA,IAAAylB,GAAAzlB,KAAAgH,OAAAtG,KACA,OAAA+kB,KAAAzlB,KAAA+E,KAAAsD,QAGAgrD,EAAAh1B,UAAArnB,aAAA,WACAhX,KAAAk4C,OAAA,EAEAl4C,KAAAu4C,MAAA5zC,QAAAuS,IACAlX,KAAAs4C,KAAA3zC,QAAAqS,IACAhX,KAAAwL,SAAA7G,QAAAqS,IACAhX,KAAA2c,oBAGA02C,EAAAh1B,UAAA/nB,QAAA,SAAAvR,GACA,GAAAsD,SAAAtD,GAAA,KAAAA,EAAA,MAAA/E,KAEA,KAAAA,KAAA2Z,WAAAhL,eAAA5J,GAAA,CACA,GAAAib,GAAA,GAAAqzC,GAAArzD,KAAA+E,EACA/E,MAAAwL,SAAAzD,KAAAiY,GACAhgB,KAAA2Z,WAAA5U,GAAAib,EAGA,MAAAhgB,MAAA2Z,WAAA5U,IAGAsuD,GACGnX,IAYHnc,GAAA,SAAAmc,GACA,QAAAnc,GAAA/zB,EAAAlN,GACA,GAAAshB,GAAApgB,IAEAk8C,GAAA5+C,KAAA0C,KAAAgM,EAAApF,QAAAyF,UAAA,MAEArM,KAAAgM,WACAhM,KAAAlB,WAEAkB,KAAAq4C,YAAA,EACAr4C,KAAAk4C,OAAA,EAEAl4C,KAAA2N,GAAA8Y,GAAA3nB,EAAAiF,EAAAjF,EAAAiL,EAAAtF,QAEAzE,KAAA4/B,aACA5/B,KAAA6/B,OAAA7/B,KAAAlB,SAAAiL,EAAA6E,IAAA,SAAA3B,EAAApF,GACA,GAAA/G,GAAA8Y,GAAAwG,EAAApU,SAAAiB,EAMA,OAJAnM,IACA4+B,GAAAtf,EAAAnT,EAAApF,GAGA/G,IAEAd,KAAA4W,gBAEA5W,KAAA4b,QAAAvT,OAEArI,KAAA8U,SA8IA,MA3IAirB,GAAA1B,UAAAlyB,OAAA2tB,OAAAoiB,KAAA7d,WACA0B,EAAA1B,UAAA9Y,YAAAwa,EAEAA,EAAA1B,UAAAvpB,OAAA,SAAAw+C,GAEA,SAAAA,OAAA,GAEAtzD,KAAAuzD,kBAAAvzD,MAAA7B,KAAAotB,YAAAvrB,KAAAoN,SACApN,KAAAoN,QAAA/E,OAEAirD,IACAtzD,KAAAk4C,OAAA,EACAl4C,KAAAgX,iBAIA+oB,EAAA1B,UAAA39B,IAAA,SAAA83C,GAUA,MATAA,IAAA3hC,GAAA7W,MAEAA,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAAQ,MAAAR,KAAAuiC,WACAviC,KAAAwc,UAAAxc,KAAAm8C,gBAAAn8C,KAAAQ,OACAR,KAAAyc,SAGA+7B,GAAAx4C,KAAAwc,QAAAxc,KAAA+vC,aAAA/vC,KAAAQ,OAGAu/B,EAAA1B,UAAA1iB,WAAA,WACA,GAAAyE,GAAApgB,IAEA,OAAAA,MAAAlB,UACAkB,KAAAoN,UACApN,KAAAoN,QAAA,IAAApN,KAAAlB,SAAAiF,EAAAH,QAAA,mBAAAyJ,EAAApF,GACA,GAAAA,GAAAmY,EAAAyf,OAAAp7B,OAAA,MAAA4I,EAEA,IAAAvM,GAAAsf,EAAAyf,OAAA53B,EACA,OAAAnH,KAAA6a,aAAA,eAGA3b,KAAA7B,KAAAotB,YAAAvrB,KAAAoN,SAAApN,KACAA,KAAAuzD,YAAA,GAGAvzD,KAAAoN,SAbA,cAgBA2yB,EAAA1B,UAAAkE,SAAA,WACA,GAAAniB,GAAApgB,IAEAwW,KACA,IAAAvN,EAEA,KACA,GAAAioC,GAAAlxC,KAAA6/B,OAAAjxB,IAAA,SAAArR,GAAmD,MAAAA,KAAAmD,KAAA,GAAA2H,QACnDY,GAAAjJ,KAAA2N,GAAAxH,MAAAnG,KAAAgM,SAAApF,QAAAsqC,GACK,MAAA1c,GACLhuB,EAAA,qBAAAxG,KAAA2b,aAAA,MAAA6Y,EAAA5uB,SAAA4uB,IAGA,GAAA5d,GAAAD,IAYA,OAVA3W,MAAA4W,aAAA2J,OAAA,SAAAzR,GAA8C,QAAA8H,EAAA9O,QAAAgH,KAAsCnK,QAAA,SAAAmK,GACpFA,EAAA6pC,WAAAv4B,GACA7X,EAAA6X,EAAAxJ,aAAA9H,KAGA8H,EAAA2J,OAAA,SAAAzR,GAAyC,QAAAsR,EAAAxJ,aAAA9O,QAAAgH,KAA6CnK,QAAA,SAAAmK,GACtFA,EAAAmJ,SAAAmI,GACAA,EAAAxJ,aAAA7O,KAAA+G,KAGA7F,GAGA82B,EAAA1B,UAAArnB,aAAA,WACAhX,KAAAk4C,OAAA,EAEAl4C,KAAAu4C,MAAA5zC,QAAAuS,IACAlX,KAAAs4C,KAAA3zC,QAAAqS,IACAhX,KAAAwL,SAAA7G,QAAAqS,IAEAhX,KAAA2c,oBAGAojB,EAAA1B,UAAA/nB,QAAA,SAAAvR,GACA,GAAAsD,SAAAtD,GAAA,KAAAA,EAAA,MAAA/E,KAEA,KAAAA,KAAA2Z,WAAAhL,eAAA5J,GAAA,CACA,GAAAib,GAAA,GAAAqzC,IAAArzD,KAAA+E,EACA/E,MAAAwL,SAAAzD,KAAAiY,GACAhgB,KAAA2Z,WAAA5U,GAAAib,EAGA,MAAAhgB,MAAA2Z,WAAA5U,IAGAg7B,EAAA1B,UAAApnB,KAAA,WACAjX,KAAAgX,gBAGA+oB,EAAA1B,UAAAoa,UAAA,SAAArgC,EAAAC,EAAAiiC,GACA,GAAApqB,GAAAlwB,KAAA6/B,OAAA/3B,QAAAuQ,IAEA6X,IACA9X,EAAAD,GAAAnY,KAAAlB,SAAAiL,EAAAmmB,GAAA9X,EAAAC,GACAD,IAAAC,IACAA,EAAAsgC,WAAA34C,MACAA,KAAA6/B,OAAAp3B,OAAAynB,EAAA,EAAA9X,GAEAA,KAAAshC,mBAAA15C,KAAA,UAGAA,KAAA8U,QAAAwlC,IAGAva,EAAA1B,UAAAke,SAAA,WACA,MAAAv8C,MAAAU,OAGAq/B,EAAA1B,UAAAhnB,SAAA,WACA,GAAA+I,GAAApgB,IAEAA,MAAAsX,SACAtX,KAAAgM,SAAA3D,OACArI,KAAA4W,cAAA5W,KAAA4W,aAAAjS,QAAA,SAAAmK;AAAwE,MAAAA,GAAA6pC,WAAAv4B,KACxE87B,EAAA7d,UAAAhnB,SAAA/Z,KAAA0C,OAGA+/B,EAAA1B,UAAAsa,WAAA,SAAAK,GACAkD,EAAA7d,UAAAsa,WAAAr7C,KAAA0C,KAAAg5C,GACAh5C,KAAAs4C,KAAA7zC,QAAAzE,KAAAqX,YAGA0oB,EAAA1B,UAAA/mB,OAAA,WACAtX,KAAA4/B,UAAAj7B,QAAA2S,KAGAyoB,GACGmc,IAEHsX,GAAA,SAAAtX,GACA,QAAAsX,GAAAxsD,EAAAjC,GACAm3C,EAAA5+C,KAAA0C,KAAAgH,EAAAjC,GAwCA,MArCAyuD,GAAAn1B,UAAAlyB,OAAA2tB,OAAAoiB,KAAA7d,WACAm1B,EAAAn1B,UAAA9Y,YAAAiuC,EAEAA,EAAAn1B,UAAA8c,WAAA,SAAA36C,GACA,IAAA0E,EAAA1E,EAAAR,KAAAQ,OAGA,IADA,GAAAwG,GAAAhH,KAAAgH,OAAAoF,GAAApM,KAAA+E,KACAiC,GAAA,CACA,GAAAA,EAAAmH,KAAA,CACA,GAAA7N,GAAA0G,EAAAlG,MAAAwN,QAAAlC,EACA9L,GAAA66C,WAAA36C,EACA,OAGA4L,EAAA8R,QAAAlX,EAAAjC,KAEAiC,aAIAwsD,EAAAn1B,UAAA/nB,QAAA,SAAAvR,GACA,GAAAsD,SAAAtD,GAAA,KAAAA,EAAA,MAAA/E,KAEA,KAAAA,KAAA2Z,WAAAhL,eAAA5J,GAAA,CACA,GAAAib,GAAA,GAAAwzC,GAAAxzD,KAAA+E,EACA/E,MAAAwL,SAAAzD,KAAAiY,GACAhgB,KAAA2Z,WAAA5U,GAAAib,EAGA,MAAAhgB,MAAA2Z,WAAA5U,IAGAyuD,EAAAn1B,UAAAke,SAAA,WACA,GAAAv1C,GAAAhH,KAAAgH,OAAAtG,KACA,OAAAsG,IAAAhH,KAAA+E,MAAAiC,KAAAhH,KAAA+E,KAAAsD,QAGAmrD,GACGtX,IAEHlc,GAAA,SAAAkc,GACA,QAAAlc,GAAAh0B,EAAAlN,GACA,GAAAshB,GAAApgB,IAEAk8C,GAAA5+C,KAAA0C,KAAA,WACAA,KAAAk4C,OAAA,EACAl4C,KAAA7B,KAAA6N,EAAApF,QAAAyF,UACArM,KAAAlB,WAEAkB,KAAA4/B,aAEA5/B,KAAAmO,KAAA2xB,GAAA9zB,EAAAlN,EACA,IAAA20D,EAEAzzD,MAAAmO,OACAslD,EAAAznD,EAAA7C,QAAArK,EAAAiL,EAAA,SAAAjJ,GACAsf,EAAAjS,KAAArN,EACAsf,EAAAtL,SAEAvM,EAAA6X,EAAAwf,UAAA6zB,KAGAzzD,KAAA4/B,UAAA73B,KAAA0rD,GAGA,IAAAC,GAAA1zD,KAAA0zD,cACA18C,aAAA,WAAgC,MAAAoJ,GAAApJ,gBAChCyhC,UAAA,SAAArgC,EAAAC,GACA,GAAAA,IAAA+H,EAAAjS,KACAiK,EAAAD,GAAArZ,EAAAsZ,EAAAC,GACAD,IAAAgI,EAAAjS,OACAiS,EAAAjS,KAAAwqC,WAAA+a,GACAtzC,EAAAjS,KAAAiK,OAGO,CACP,GAAA8X,GAAA9P,EAAA8S,QAAAprB,QAAAuQ,IACA6X,IAEA9X,EAAAD,GAAArZ,EAAAvB,EAAA2yB,GAAA1O,EAAApJ,EAAAC,GACAD,IAAAgI,EAAA8S,QAAAhD,IACA9P,EAAA8S,QAAAzqB,OAAAynB,EAAA,EAAA9X,IAMAA,IAAAC,KAAAsgC,WAAA+a,GACAt7C,KAAAqhC,eAAA,WAAoD,MAAArhC,GAAAH,SAAAy7C,KAEpDtzC,EAAAtL,UAIA9U,MAAAkzB,QAAAp0B,EAAAvB,EAAAqR,IAAA,SAAA9P,EAAAmJ,GACA,mBAAAnJ,GACA,OAAc4B,IAAA,WAAmB,MAAA5B,IAGjC,IAAAgC,GACA6+B,CAEA,OAAA7gC,GAAA4oB,IAAAsD,IACAlqB,EAAA8Y,GAAA5N,EAAAlN,EAAA0iB,GAEA1gB,EACAA,EAAAmX,SAAAy7C,IAEA/zB,EAAA3zB,EAAA7C,QAAArK,EAAA0iB,EAAA,SAAA1gB,GACAsf,EAAA8S,QAAAjrB,GAAAnH,EAEAA,EAAAmX,SAAAy7C,GACAtzC,EAAApJ,eAEAzO,EAAA6X,EAAAwf,UAAAD,KAGAvf,EAAAwf,UAAA73B,KAAA43B,IAGA7+B,IAGAA,EAAA,GAAAi/B,IAAA/zB,EAAAlN,GACAgC,EAAAmX,SAAAy7C,GACA5yD,KAGAd,KAAA2zD,cAAA,EACA3zD,KAAA8U,SA6HA,MA1HAkrB,GAAA3B,UAAAlyB,OAAA2tB,OAAAoiB,KAAA7d,WACA2B,EAAA3B,UAAA9Y,YAAAya,EAEAA,EAAA3B,UAAAvpB,OAAA,WACA9U,KAAAmO,OACAnO,KAAAk4C,OAAAl4C,KAAAgX,iBAGAgpB,EAAA3B,UAAA4e,gBAAA,WACAj9C,KAAA4/B,UAAAj7B,QAAA,SAAAg7B,GAAmD,MAAAA,GAAAsd,oBACnDj9C,KAAAk4C,OAAA,EACAl4C,KAAA8U,UAGAkrB,EAAA3B,UAAA39B,IAAA,SAAA83C,GACA,GAAAp4B,GAAApgB,IAEA,IAAAA,KAAAk4C,MAAA,CACAl4C,KAAA8U,QAGA,KADA,GAAA7M,GAAAjI,KAAAkzB,QAAAzuB,OAAAq1C,GAAA,EACAA,GAAA7xC,KACAmY,EAAA8S,QAAAjrB,KAAA6xC,GAAA,EAGA,IAAA95C,KAAAmO,MAAA2rC,EAAA,CACA,GAAA1tC,GAAApM,KAAAkzB,QAAAtkB,IAAA,SAAArR,GAAmD,MAAAuP,GAAAwhB,OAAA/wB,EAAAmD,UACnDI,EAAAd,KAAAmO,KAAAG,QAAAlC,EAEAtL,KAAAd,KAAAc,QACAd,KAAAc,QACAd,KAAAc,MAAA63C,WAAA34C,MACAA,KAAAc,MAAAi6C,wBAAA/6C,OAGAA,KAAAc,QACAd,KAAAgH,OAAAlG,EAAAkG,OACAhH,KAAAc,MAAAmX,SAAAjY,MACAA,KAAAc,MAAA45C,sBAAA16C,MAEAA,KAAAw6C,cAAAx6C,KAAAw6C,aAAAxjC,gBAOA,MAHAhX,MAAAQ,MAAAR,KAAAc,MAAAd,KAAAc,MAAAJ,IAAA83C,GAAAnwC,OACArI,KAAAk4C,OAAA,EACAl4C,KAAAiX,OACAjX,KAAAQ,MAEA,MAAAR,MAAAc,MAAAd,KAAAc,MAAAJ,IAAA83C,GAAAnwC,QAKA23B,EAAA3B,UAAAkE,SAAA,WACA,GAAAniB,GAAApgB,IAEAA,MAAAQ,MAAAR,KAAAc,MAAAd,KAAAc,MAAAJ,MAAA2H,MAGA,KADA,GAAAJ,GAAAjI,KAAA4pC,SAAAnlC,OACAwD,KAAA,CACA,GAAAzH,GAAA4f,EAAAwpB,SAAA3hC,GAAAs6B,UACA,IAAA/hC,IAAA4f,EAAA5f,MAAA,MAAAA,GAIA,GAAAw6C,GAAApjC,GAAA5X,KAAAs4C,KACA,OAAA0C,KAAAx6C,MAEAR,KAAAQ,OAGAw/B,EAAA3B,UAAA1iB,WAAA,WACA,MAAA3b,MAAAc,MAAAd,KAAAc,MAAA6a,aAAA,cAGAqkB,EAAA3B,UAAArnB,aAAA,WACAhX,KAAAk4C,OAAA,EACAl4C,KAAAiX,QAGA+oB,EAAA3B,UAAA/nB,QAAA,SAAAvR,GACA,GAAAsD,SAAAtD,GAAA,KAAAA,EAAA,MAAA/E,KAEA,KAAAA,KAAA2Z,WAAAhL,eAAA5J,GAAA,CACA,GAAAib,GAAA,GAAAwzC,IAAAxzD,KAAA+E,EACA/E,MAAAwL,SAAAzD,KAAAiY,GACAhgB,KAAA2Z,WAAA5U,GAAAib,EAGA,MAAAhgB,MAAA2Z,WAAA5U,IAGAi7B,EAAA3B,UAAApnB,KAAA,WACAjX,KAAAk4C,OACAl4C,KAAAs4C,KAAA3zC,QAAAqS,IAGAhX,KAAAu4C,MAAA5zC,QAAAuS,IACAlX,KAAAwL,SAAA7G,QAAAsS,IACAjX,KAAA2c,oBAGAqjB,EAAA3B,UAAAke,SAAA,WACA,MAAAv8C,MAAAQ,OAGAw/B,EAAA3B,UAAAoa,UAAA,aAEAzY,EAAA3B,UAAAj+B,IAAA,SAAAI,GACA,IAAAR,KAAAc,MAAA,SAAAkF,OAAA,2DACAhG,MAAAc,MAAAV,IAAAI,IAGAw/B,EAAA3B,UAAA/mB,OAAA,WACAtX,KAAA4/B,UAAAj7B,QAAA2S,IACAtX,KAAAc,QACAd,KAAAc,MAAA63C,WAAA34C,MACAA,KAAAc,MAAAi6C,wBAAA/6C,QAIAggC,GACGkc,IA2BH0X,GAAA,SAAAvkB,GACA,QAAAukB,GAAAzkD,GACAkgC,EAAA/xC,KAAA0C,KAAAmP,GAEAnP,KAAAgM,SAAA,KAoFA,MAjFA4nD,GAAAv1B,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACAu1B,EAAAv1B,UAAA9Y,YAAAquC,EAEAA,EAAAv1B,UAAAn8B,KAAA,WACA+9B,GAAAjgC,MAEAA,KAAAgM,SAAA,GAAA+8B,KACAh3B,MAAA/R,KACAlB,SAAAkB,KAAAlB,SAAAyxB,IACKruB,QAGL0xD,EAAAv1B,UAAAr0B,OAAA,WACA,MAAAhK,MAAAgM,SAAAhM,KAAAgM,SAAAhC,SAAAnH,KAGA+wD,EAAAv1B,UAAAjuB,KAAA,SAAAD,GACA,GAAAnQ,KAAAgM,SACA,MAAAhM,MAAAgM,SAAAoE,KAAAD,IAIAyjD,EAAAv1B,UAAA5rB,QAAA,SAAAtC,EAAAkC,GACArS,KAAAgM,UACAhM,KAAAgM,SAAAyG,QAAAtC,EAAAkC,IAIAuhD,EAAAv1B,UAAAtrB,cAAA,SAAAxS,GACA,GAAAP,KAAAgM,SACA,MAAAhM,MAAAgM,SAAA+G,cAAAxS,IAIAqzD,EAAAv1B,UAAAxrB,kBAAA,SAAAtS,EAAA8R,GACArS,KAAAgM,UACAhM,KAAAgM,SAAA6G,kBAAAtS,EAAA8R,IAIAuhD,EAAAv1B,UAAAw1B,UAAA,SAAAC,GACA,MAAA9zD,MAAAgM,UAAAhM,KAAAgM,SAAA6nD,UAAAC,IAGAF,EAAAv1B,UAAAoa,UAAA,WACA,GAAAr4B,GAAApgB,IAEAA,MAAA4iC,SACA5iC,KAAA4iC,QAAA,EACA50B,GAAAiV,aAAA,WACA7C,EAAAwiB,QAAA,EACA3C,GAAA7f,OAIAwzC,EAAAv1B,UAAAjnB,OAAA,SAAA9W,GACAN,KAAA4f,UAAA,EACA5f,KAAAgM,UAAAhM,KAAAgM,SAAAoL,OAAA9W,IAGAszD,EAAAv1B,UAAA56B,SAAA,SAAA+8B,GACA,MAAAxgC,MAAAgM,SAAAhM,KAAAgM,SAAAvI,SAAA+8B,GAAA,IAGAozB,EAAAv1B,UAAA/mB,OAAA,WACAtX,KAAA4V,WACA5V,KAAAgM,UAAAhM,KAAAgM,SAAAsL,UAGAs8C,EAAAv1B,UAAA9mB,SAAA,SAAA24B,GACAlwC,KAAA4f,UAAA5f,KAAAgM,UAAAhM,KAAAgM,SAAAuL,SAAA24B,GACAlwC,KAAA4f,UAAA,GAGAg0C,EAAAv1B,UAAA5xB,OAAA,WACAzM,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAAgM,SAAAS,WAIAmnD,GACGvkB,IA2BHvO,GAAA,MACAF,IAAoBmzB,MAAA,YACpBtzB,GAAA,wBACAD,GAAA,uGACAhgC,GAAA,WAgCA+gC,IAAAl5B,OAAA,6EAsUA2rD,IACAC,iBAAA,gBACAC,UAAA,YACAC,QAAA,UACAC,MAAA,YACAC,SAAA,WACAC,QAAA,UACA3pB,gBAAA,kBACA4pB,SAAA,WACAC,QAAA,UACAC,IAAA,UACAC,aAAA,YACAC,MAAA,QACAC,UAAA,YACAC,WAAA,aACAC,QAAA,UACAC,SAAA,WACAC,QAAA,UACAC,SAAA,WACAC,OAAA,UAcA3lB,GAAA,SAAAF,GACA,QAAAE,GAAApgC,GACAkgC,EAAA/xC,KAAA0C,KAAAmP,GAEAnP,KAAAO,KAAA4O,EAAArQ,SAAA0iB,EACAxhB,KAAAoiC,UAAA,KAEApiC,KAAA+R,MAAA5C,EAAA4C,OAAA5C,EAAAkC,eAAAU,OAAA5C,EAAAlF,SAAAi2B,GAAA/wB,EAAAkC,gBACArR,KAAAiK,QAAAkF,EAAAlF,UAAAjK,KAAA+R,MAAA24B,gBAAA1qC,KAAA+R,MAAAmuB,GAAA/wB,EAAAkC,iBACArR,KAAAqR,eAAAlC,EAAAkC,eACArR,KAAA4G,QAAA5G,KAAAqR,eAAAzK,QAEA5G,KAAA4f,UAAA,EACA5f,KAAAm1D,eAAA,KACAn1D,KAAAgM,SAAA,KAEAhM,KAAAiK,QAAAygC,gBAAA1qC,KAAAO,MAAAP,KAEAgF,EAAAmK,EAAArQ,SAAAyxB,GAMAvwB,KAAAgM,SAAA,GAAA+8B,KACAh3B,MAAA/R,KACAlB,SAAAqQ,EAAArQ,SAAAyxB,KAPAvwB,KAAAQ,MAAA2O,EAAArQ,SAAAyxB,EACA,IAAAvwB,KAAAQ,QACAR,KAAAQ,MAAA,KASAR,KAAA0P,aAAA1P,KAAAgM,UACA,IAAAhM,KAAAgM,SAAAwF,MAAA/M,QACAzE,KAAAgM,SAAAwF,MAAA,GAAApK,OAAAqtB,IACAz0B,KAAAgM,SAAAwF,MAAA,GAEAxR,KAAA0P,eAAA1P,KAAA0P,aAAAqC,MAAA/R,MAmIA,MAhIAuvC,GAAAlR,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACAkR,EAAAlR,UAAA9Y,YAAAgqB,EAEAA,EAAAlR,UAAAn8B,KAAA,WACAlC,KAAAgM,UACAhM,KAAAgM,SAAA9J,QAIAqtC,EAAAlR,UAAAvpB,OAAA,WACA9U,KAAAk4C,QACAl4C,KAAAqR,eAAAyD,SACA9U,KAAAiK,QAAA6K,SACA9U,KAAAk4C,OAAA,IAIA3I,EAAAlR,UAAA+0B,UAAA,WACApzD,KAAAm1D,gBAAA,IAGA5lB,EAAAlR,UAAAuF,UAAA,WACA,MAAA5jC,MAAAgM,SACAhM,KAAAgM,SAAAvI,WACA,MAAAzD,KAAAQ,MAAA,GAAAR,KAAAQ,MAAA,IAKA+uC,EAAAlR,UAAAkE,SAAA,WACA,MAAAviC,MAAAgM,SAAAhM,KAAAgM,SAAAugC,YAAAsT,GAAAhyC,KAAA7N,KAAAO,OAAAP,KAAAQ,OAGA+uC,EAAAlR,UAAAjnB,OAAA,WACA,GAAAlW,GAAAlB,KAAAiK,QAAA/I,IAsBA,IArBAlB,KAAAkB,OAGAA,EAAA4gC,cAAA5gC,EAAA4gC,eAAAoC,GAAA5b,OACAtoB,KAAA2jC,aAAAqwB,GAAAh0D,KAAAO,OAAAP,KAAAO,KAEA8H,SAAAnH,EAAAlB,KAAA2jC,gBACA3jC,KAAA0jC,aAAA,IAKAmc,GAAAhyC,KAAA7N,KAAAO,OAAAP,KAAAyhC,YACAzhC,KAAAiiC,WAAA,GAGA,UAAAjiC,KAAA2jC,eACAziC,EAAA4P,SAAAtQ,MAAAR,KAAAQ,QAIAU,EAAA4gC,aAAA,CACA,GAAAj6B,GAAA7H,KAAAO,KAAAuH,QAAA,IACAD,MAAA,EACA7H,KAAAoiC,UAAA2B,GAAA7iC,EAAAlB,KAAAO,KAAAgS,MAAA,EAAA1K,IAEA7H,KAAAoiC,UAAAlhC,EAAA4gC,aAIA9hC,KAAA4f,UAAA,EACA5f,KAAAm1D,eAAAp0B,GAAA/gC,MACAA,KAAAm1D,kBAGA5lB,EAAAlR,UAAA56B,SAAA,WACA,GAAAjD,GAAAR,KAAAuiC,UAGA,cAAAviC,KAAAO,MAAA8H,SAAArI,KAAAiK,QAAAg3B,aAAA,+BAAAjhC,KAAAiK,QAAA1J,MAAA,aAAAP,KAAAiK,QAAA1J,KAAA,CAKA,YAAAP,KAAAO,MAAA,UAAAP,KAAAiK,QAAA1J,MAAAP,KAAA0P,cAAA,UAAA1P,KAAAiK,QAAAg3B,aAAA,QACA,iBAAuBjhC,KAAA0P,aAAA5O,MAAA6a,aAAA,KAIvB,IAAA3b,KAAA+R,QAAA/R,KAAAiK,SAAA,UAAAjK,KAAAO,MAAA,UAAAP,KAAAO,OAAAP,KAAAujC,YAAAvjC,KAAAyjC,YAAA,CAIA,KAAAzjC,KAAA4f,UAAA5f,KAAA+R,QAAA/R,KAAAiK,SAAAjK,KAAAO,KAAAuH,QAAA,WAAA9H,KAAAO,KAAAuH,QAAA,WAOA,YANA9H,KAAAO,KAAAuH,QAAA,UAGA9H,KAAAyjC,YAAAzjC,KAAAO,KAAAiN,OAAA,GAFAxN,KAAAujC,UAAA1/B,EAAA7D,KAAAO,KAAAiN,OAAA,IAQA,IAAAqyC,GAAAhyC,KAAA7N,KAAAO,MAAA,MAAAC,GAAAR,KAAAO,KAAA,EACA,UAAAC,EAAA,QAEA,IAAA4gB,GAAA1d,EAAA1D,KAAA4jC,YACA,OAAAxiB,GACA,GAAAphB,KAAA,UAAAohB,EAAA,IACAphB,KAAAO,QAGAgvC,EAAAlR,UAAA/mB,OAAA,WACAtX,KAAAgM,UAAAhM,KAAAgM,SAAAsL,UAGAi4B,EAAAlR,UAAA9mB,SAAA,WACAvX,KAAAm1D,gBAAA,GAEAn1D,KAAA4f,UAAA,GAGA2vB,EAAAlR,UAAA5xB,OAAA,WACAzM,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAAgM,UAAAhM,KAAAgM,SAAAS,SACAzM,KAAA4f,UAAA5f,KAAAm1D,iBACAn1D,KAAAyhC,WAAAzhC,KAAA4iC,QACA5iC,KAAA0P,aAAA0lD,cAAAC,SAAA,EAAAr1D,KAAA0P,aAAA5O,MAAAJ,SAKA6uC,GACGF,IAEHimB,GAAA,SAAAjmB,GACA,QAAAimB,GAAAnmD,GACAkgC,EAAA/xC,KAAA0C,KAAAmP,GAEAnP,KAAA+R,MAAA5C,EAAA4C,OAAA5C,EAAAkC,eAAAU,OAAAmuB,GAAA/wB,EAAAkC,gBACArR,KAAAiK,QAAAjK,KAAA+R,MAAA24B,gBAAA1qC,KAAA+R,MAAAmuB,GAAA/wB,EAAAkC,gBACArR,KAAAokC,KAAA,MAAAj1B,EAAArQ,SAAA8oB,EAAA,gBAEA5nB,KAAAiK,QAAA7C,OAAAuxB,KACA3zB,EAAAmK,EAAArQ,SAAAyxB,KACAvwB,KAAAgM,SAAA,GAAA+8B,KACAh3B,MAAA/R,KACAlB,SAAAqQ,EAAArQ,SAAAyxB,KAIAvwB,KAAA0P,aAAA1P,KAAAgM,UACA,IAAAhM,KAAAgM,SAAAwF,MAAA/M,QACAzE,KAAAgM,SAAAwF,MAAA,GAAApK,OAAAqtB,IACAz0B,KAAAgM,SAAAwF,MAAA,IAiDA,MA7CA8jD,GAAAj3B,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACAi3B,EAAAj3B,UAAA9Y,YAAA+vC,EAEAA,EAAAj3B,UAAAn8B,KAAA,WACAlC,KAAAgM,UAAAhM,KAAAgM,SAAA9J,OACAiiC,GAAAnkC,UAAAuiC,YAAA,IAGA+yB,EAAAj3B,UAAAvpB,OAAA,WACA9U,KAAAk4C,QACAl4C,KAAAiK,QAAA6K,SACA9U,KAAAk4C,OAAA,IAIAod,EAAAj3B,UAAAkE,SAAA,WACA,MAAAviC,MAAAgM,SAAAhM,KAAAgM,SAAAugC,UACA,SAAAvsC,WAAAQ,QACA,KAAAR,MAAAlB,WAAAkB,KAAAlB,SAAAyxB,GAIA+kC,EAAAj3B,UAAAjnB,OAAA,WACA+sB,GAAAnkC,UAAAuiC,YAAA,IAGA+yB,EAAAj3B,UAAA56B,SAAA,WAA0D,UAE1D6xD,EAAAj3B,UAAA/mB,OAAA,WACAtX,KAAAgM,UAAAhM,KAAAgM,SAAAsL,eAEAtX,MAAAiK,QAAAjK,KAAAokC,OAGAkxB,EAAAj3B,UAAA9mB,SAAA,WACAvX,KAAAiK,QAAA2V,UAAA5f,KAAAiK,QAAAo6B,yBAGAixB,EAAAj3B,UAAA5xB,OAAA,WACAzM,KAAAk4C,QACAl4C,KAAAgM,UAAAhM,KAAAgM,SAAAS,SACA03B,GAAAnkC,UAAAuiC,YAAA,KAIA+yB,GACGjmB,IAsBH1K,GAAA7hC,GAAA0rC,GAAA,YAEAlP,IAAA,EAQAi2B,GAAA,SAAAlmB,GACA,QAAAkmB,GAAApmD,GACAkgC,EAAA/xC,KAAA0C,KAAAmP,GAEAnP,KAAAs/B,cAEAt/B,KAAA+R,MAAA5C,EAAA4C,MAEA/R,KAAAgM,SAAA,GAAA+8B,KACAniC,QAAA5G,KAAA4G,QACAmL,MAAA/R,KACAlB,SAAAkB,KAAAlB,WAGAkB,KAAAgM,SAAAokC,aAAA1qC,EAEA1F,KAAAk4C,OAAA,EA6EA,MA1EAqd,GAAAl3B,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACAk3B,EAAAl3B,UAAA9Y,YAAAgwC,EAEAA,EAAAl3B,UAAAn8B,KAAA,WACAlC,KAAAgM,SAAA9J,QAGAqzD,EAAAl3B,UAAAvpB,OAAA,WACA9U,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAA+R,MAAA+C,WAIAygD,EAAAl3B,UAAAjnB,OAAA,WACApX,KAAAkB,KAAAlB,KAAA+R,MAAA7Q,KACAlB,KAAAkB,OACAlB,KAAAykC,MAAAzkC,KAAAkB,KAAA4gC,eAAAkK,IAGA1M,IAAA,EACAt/B,KAAA4f,UAAA5f,KAAAgM,SAAAoL,SACAkoB,IAAA,EAEAt/B,KAAA4f,UAAA,EACA5f,KAAAk4C,OAAA,EACAl4C,KAAAyM,UAGA8oD,EAAAl3B,UAAA56B,SAAA,WACA,MAAAzD,MAAAgM,SAAAvI,YAGA8xD,EAAAl3B,UAAA/mB,OAAA,WACAtX,KAAAgM,SAAAsL,UAGAi+C,EAAAl3B,UAAA9mB,SAAA,WACAvX,KAAA4f,UAAA,EACA5f,KAAAgM,SAAAuL,YAGAg+C,EAAAl3B,UAAA5xB,OAAA,WACA,GAEA2U,GACAo0C,EAHAp1C,EAAApgB,IAKAA,MAAAk4C,QACAl4C,KAAAk4C,OAAA,EAEA5Y,IAAA,EACAt/B,KAAAgM,SAAAS,SACA6yB,IAAA,EAEAt/B,KAAA4f,UAAA5f,KAAAkB,OACAkgB,EAAAphB,KAAAgM,SAAAvI,WACA+xD,EAAAhxB,GAAApjB,EAAAphB,KAAAykC,OAIAzkC,KAAAs/B,WAAA/e,OAAA,SAAApb,GAA8C,MAAAy/B,IAAA4wB,EAAArwD,KAA4BR,QAAA,SAAAQ,GAC1Eib,EAAAlf,KAAAuhC,gBAAAt9B,EAAA5E,QAGAi1D,EAAA7wD,QAAA,SAAAQ,GACAib,EAAAlf,KAAAgiC,aAAA/9B,EAAA5E,KAAA4E,EAAA3E,SAGAR,KAAAs/B,WAAAk2B,KAKAD,GACGlmB,IAkCHomB,IAAA,0DACAC,KAEAD,IAAA9wD,QAAA,SAAA+V,GACA,GAAA8gB,GAAA,WAGA,IAFA,GAAApb,GAAApgB,KACA6F,KAAAtB,EAAAC,UAAAC,OACAF,KAAAsB,EAAAtB,GAAAC,UAAAD,EAEA,IAAAwW,GAAAN,GAAAza,KAAAyE,OAAAiW,EAAA7U,EAGA7F,MAAA8Q,SAAA6kD,SAAAhxD,QAAA,SAAAoF,GAAoDA,EAAAhL,QAAAgL,EAAAhL,MAAA6jC,QAAA,IAGpD,IAAA35B,GAAAid,MAAAmY,UAAA3jB,GAAAvU,MAAAnG,KAAAwE,UAGAwJ,IAAA1L,QAEAtC,KAAA8Q,SAAAs0B,SAAA,CAEA,KADA,GAAAn9B,GAAAjI,KAAA8Q,SAAA6kD,SAAAlxD,OACAwD,KACA68B,GAAA1kB,EAAAtP,SAAA6kD,SAAA1tD,GAAAmY,EAAA1F,EAAAK,EAUA,OAPA/M,IAAAC,MAEAjO,KAAA8Q,SAAAs0B,SAAA,EAGAplC,KAAA8Q,SAAA6kD,SAAAhxD,QAAA,SAAAoF,GAAoDA,EAAAhL,QAAAgL,EAAAhL,MAAA6jC,QAAA,KAEpD35B,EAGA49B,IAAA6uB,GAAAh7C,GACAla,MAAAg7B,EACAkX,cAAA,KAIA,IAAAkjB,IACAC,QAIUC,WAEVF,GAAA,SAAAnuD,GAA2C,MAAAA,GAAAquD,UAAAJ,IAC3CG,GAAA,SAAApuD,GAA6C,MAAAA,GAAAquD,UAAA5vC,MAAAmY,aAK7Cu3B,GAAA,SAAAnuD,GAEA,IADA,GAAAQ,GAAAwtD,GAAAhxD,OACAwD,KAAA,CACA,GAAAyS,GAAA+6C,GAAAxtD,EACA4+B,IAAAp/B,EAAAiT,GACAla,MAAAk1D,GAAAh7C,GACAg4B,cAAA,MAKAmjB,GAAA,SAAApuD,GAEA,IADA,GAAAQ,GAAAwtD,GAAAhxD,OACAwD,WACAR,GAAAguD,GAAAxtD,MAKA2tD,GAAAG,QAAAF,EACA,IAAAG,IAAAJ,GAEAK,GAAA,mDAEAhuB,IACA1nB,OAAA,SAAA7Y,GAGA,MAAA1C,GAAA0C,QAAAoJ,WAAApJ,EAAAoJ,SAAAs0B,UAEAxI,KAAA,SAAAh2B,EAAAa,EAAA2F,GACA,UAAA8oD,IAAAtvD,EAAAa,EAAA2F,KAIA8oD,GAAA,SAAAtvD,EAAAa,GACAzH,KAAA7B,KAAAyI,EACA5G,KAAAQ,MAAAiH,EACAzH,KAAA+kC,QAAA,KAGAt9B,EAAAqJ,WAEA+1B,GAAAp/B,EAAA,YACAjH,OACAm1D,YACAQ,aACA/wB,SAAA,GAEAsN,cAAA,IAGAsjB,GAAAvuD,IAIAA,EAAAqJ,SAAAqlD,UAAAvvD,EAAAshC,SACAzgC,EAAAqJ,SAAAqlD,UAAAvvD,EAAAshC,OAAA,EACAzgC,EAAAqJ,SAAAqlD,UAAApuD,KAAAnB,IAGAa,EAAAqJ,SAAAqlD,UAAAvvD,EAAAshC,QAAA,EACAzgC,EAAAqJ,SAAA6kD,SAAA5tD,KAAA/H,MAGAk2D,IAAA73B,UAAA39B,IAAA,WACA,MAAAV,MAAAQ,OAGA01D,GAAA73B,UAAAK,MAAA,SAAAl+B,GACA,MAAAR,MAAAQ,WAGA01D,GAAA73B,UAAAhnB,SAAA,WACA,GAAA5P,GAAA+X,EAAAm2C,EAAAQ,EAAAtuD,CAUA,IARAJ,EAAAzH,KAAAQ,MACAgf,EAAA/X,EAAAqJ,SACA6kD,EAAAn2C,EAAAm2C,SACAQ,EAAA32C,EAAA22C,UAKA32C,EAAA4lB,QACA,QAIA,IADAv9B,EAAA8tD,EAAA7tD,QAAA9H,MACA6H,KAAA,EACA,SAAA7B,OAAAiwD,GAOA,IAJAN,EAAAltD,OAAAZ,EAAA,GAIA8tD,EAAAlxD,QAQA,GADA0xD,EAAAn2D,KAAA7B,KAAA+pC,QAAA,GACAiuB,EAAAn2D,KAAA7B,KAAA+pC,OAAA,CAGA,GAFArgC,EAAAsuD,EAAAruD,QAAA9H,KAAA7B,MAEA0J,KAAA,EACA,SAAA7B,OAAAiwD,GAGAE,GAAA1tD,OAAAZ,EAAA,eAdAJ,GAAAqJ,SACAklD,GAAAD,QAAA/1D,KAAAQ,OAkBA,IAAA41D,GAEA,KACAjqD,OAAA06B,kBAA2B,QAAWnmC,IAAA,aAAmBN,IAAA,eAEzDg2D,IACA71C,OAAA,SAAA/f,GACA,MAAAA,IAAA,gBAAAA,IAEAo8B,KAAA,SAAAh2B,EAAApG,EAAA4M,GACA,UAAAipD,IAAAzvD,EAAApG,EAAA4M,KAGG,MAAAonB,GACH4hC,IAAA,EAGA,GAAApuB,IAAAouB,GAyDAC,GAAA,SAAAzvD,EAAApG,EAAA4M,GACA,GAAAgT,GAAApgB,IAEAA,MAAA4G,UACA5G,KAAAQ,QACAR,KAAAoN,UAEApN,KAAAs2D,uBAGAnqD,OAAAC,KAAA5L,GAAAmE,QAAA,SAAAI,GACA,GAAAkgC,GAAA94B,OAAAoqD,yBAAAn2C,EAAA5f,MAAAuE,EACAqb,GAAAk2C,oBAAAvxD,GAAAkgC,CAEA,IAAAuxB,GAAAppD,EAAA,GAAAA,EAAA,IAAAN,EAAA/H,GAAA+H,EAAA/H,GAEAsgC,EAAAL,GAAAC,EAAAr+B,EAAA4vD,EAAAp2C,EAIAjU,QAAA06B,eAAAzmB,EAAA5f,MAAAuE,EAAAsgC,KAIAgxB,IAAAh4B,UAAA39B,IAAA,WACA,MAAAV,MAAAQ,OAGA61D,GAAAh4B,UAAAK,MAAA,SAAAl+B,GACA,MAAAR,MAAAQ,WAGA61D,GAAAh4B,UAAAj+B,IAAA,SAAA2E,EAAAvE,GACAR,KAAAQ,MAAAuE,GAAAvE,GAGA61D,GAAAh4B,UAAAhnB,SAAA,WACA,GAAA+I,GAAApgB,IAEAmM,QAAAC,KAAApM,KAAAQ,OAAAmE,QAAA,SAAAI,GACA,GAAAsgC,GAAAl5B,OAAAoqD,yBAAAn2C,EAAA5f,MAAAuE,EACAsgC,GAAAjlC,KAAAilC,EAAAjlC,IAAA8kC,UAEAK,GAAAF,GAEA,IAAAA,EAAAjlC,IAAA8kC,QAAAC,WAAA1gC,QACA0H,OAAA06B,eAAAzmB,EAAA5f,MAAAuE,EAAAsgC,EAAAjlC,IAAA8kC,QAAAD,uBAKA,IAAAwxB,IAAA,SAAA7vD,EAAAa,EAAA2F,GACApN,KAAAQ,MAAAiH,EAEAzH,KAAAjB,OAAA,EAEAiB,KAAA02D,aAAA1uB,GAAApL,KAAAh2B,EAAAa,EAAA2F,GACApN,KAAA22D,aAAA1uB,GAAArL,KAAAh2B,EAAAa,EAAA2F,GACApN,KAAA22D,aAAA53D,MAAAiB,KAAA02D,aAGAvqD,OAAA06B,eAAA7mC,KAAA,WACAU,IAAA,WACA,MAAAV,MAAA22D,aAAA5xB,SAEA3kC,IAAA,SAAAU,GACAd,KAAA22D,aAAA5xB,QAAAjkC,KAKA21D,IAAAp4B,UAAA39B,IAAA,WACA,MAAAV,MAAAQ,OAGAi2D,GAAAp4B,UAAAhnB,SAAA,WACArX,KAAA22D,aAAAt/C,WACArX,KAAA02D,aAAAr/C,YAGAo/C,GAAAp4B,UAAAK,MAAA,SAAAl+B,GACA,MAAAR,MAAA22D,aAAAj4B,MAAAl+B,IAAAR,KAAA02D,aAAAh4B,MAAAl+B,GAGA,IAAAunC,KACAxnB,OAAA,SAAA7Y,EAAA0F,EAAAxG,GACA,MAAAohC,IAAAznB,OAAA7Y,EAAA0F,EAAAxG,IAAAqhC,GAAA1nB,OAAA7Y,IAGAk1B,KAAA,SAAAh2B,EAAAa,EAAA2F,GACA,UAAAqpD,IAAA7vD,EAAAa,EAAA2F,KAyCA64B,GAAA,SAAAiW,GACA,QAAAjW,GAAA55B,EAAA+5B,EAAArhC,GACAm3C,EAAA5+C,KAAA0C,KAAA,WAEAA,KAAA7B,KAAA6B,KAAAgH,OAAAqF,EACArM,KAAAomC,YAEApmC,KAAA+E,MACA/E,KAAAm7B,aAAAp2B,GAAA,MAAAA,EAAA,GAEA/E,KAAAq4C,YAAAr4C,KAAAomC,UAAAE,OAEAtmC,KAAA4N,QAAAvB,EAAAuqD,mBAEA52D,KAAA4W,gBAEA5W,KAAAwL,YACAxL,KAAA2Z,cAEA3Z,KAAAs4C,QAEAt4C,KAAAk4C,OAAA,EAGAl4C,KAAA4b,QAAAvT,OAiIA,MA9HA49B,GAAA5H,UAAAlyB,OAAA2tB,OAAAoiB,KAAA7d,WACA4H,EAAA5H,UAAA9Y,YAAA0gB,EAEAA,EAAA5H,UAAA39B,IAAA,SAAA83C,GAWA,MAVAA,IAAA3hC,GAAA7W,MAEAA,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAAQ,MAAAR,KAAAuiC,WACAviC,KAAAwc,UAAAxc,KAAAm8C,gBAAAn8C,KAAAQ,OACAR,KAAAyc,SAIA+7B,GAAAx4C,KAAAwc,QAAAxc,KAAA+vC,aAAA/vC,KAAAQ,OAGAylC,EAAA5H,UAAAkE,SAAA,WACA/rB,IACA,IAAAvN,EAEA,KACAA,EAAAjJ,KAAAomC,UAAAC,OAAA/oC,KAAA0C,KAAA4N,SACK,MAAA4mB,GAML,GALAhuB,EAAA,qBAAAxG,KAAA2b,aAAA,MAAA6Y,EAAA5uB,SAAA4uB,IAKAof,GAAA,CACAE,QAAAuB,gBAAAvB,QAAAuB,eAAA,8FACA,IAAA9uB,GAAAkf,GAAAzlC,KAAAomC,UAAAG,cACA9vB,EAAAzW,KAAAomC,UAAAI,eAAA,OAAAR,GAAAxR,EAAA/d,OAAA,EACAq9B,SAAAnyC,MAAA,GAAA6yB,EAAA,UAAAA,EAAA,eAAAjO,EAAA9P,GACAq9B,QAAAuB,gBAAAvB,QAAAwB,YAIA,GAAA1+B,GAAAD,IASA,OARA3W,MAAA62D,gBAAAjgD,GAIA,SAAA5W,OAAAiJ,IAAAjJ,KAAAQ,OACAR,KAAA0c,eAAA1c,KAAA2b,aAAA1S,GAGAA,GAGAg9B,EAAA5H,UAAArnB,aAAA,WACAhX,KAAAk4C,OAAA,EAEAl4C,KAAAu4C,MAAA5zC,QAAAuS,IACAlX,KAAAs4C,KAAA3zC,QAAAqS,IACAhX,KAAAwL,SAAA7G,QAAAqS,IACAhX,KAAA2c,oBAGAspB,EAAA5H,UAAA/nB,QAAA,SAAAvR,GACA,GAAAsD,SAAAtD,GAAA,KAAAA,EAAA,MAAA/E,KAEA,KAAAA,KAAA2Z,WAAAhL,eAAA5J,GAAA,CACA,GAAAib,GAAA,GAAAqzC,IAAArzD,KAAA+E,EACA/E,MAAAwL,SAAAzD,KAAAiY,GACAhgB,KAAA2Z,WAAA5U,GAAAib,EAGA,MAAAhgB,MAAA2Z,WAAA5U,IAGAkhC,EAAA5H,UAAApnB,KAAA,WACAjX,KAAAgX,gBAGAivB,EAAA5H,UAAAoa,UAAA,SAAArgC,EAAAC,GAEAD,IAAAC,GAAArY,KAAAgX,gBAGAivB,EAAA5H,UAAAj+B,IAAA,SAAAI,GACA,IAAAR,KAAAomC,UAAAE,OACA,SAAAtgC,OAAA,wCAAAhG,KAAA,QAGAA,MAAAomC,UAAAE,OAAA9lC,GACAR,KAAAiX,QAGAgvB,EAAA5H,UAAAw4B,gBAAA,SAAAjgD,GAKA,IAHA,GAAAwJ,GAAApgB,KAEAiI,EAAAjI,KAAA4W,aAAAnS,OACAwD,KAAA,CACA,GAAAnH,GAAAsf,EAAAxJ,aAAA3O,IACA2O,EAAA9O,QAAAhH,MAAA63C,WAAAv4B,GAKA,IADAnY,EAAA2O,EAAAnS,OACAwD,KAAA,CACA,GAAA+R,GAAApD,EAAA3O,IACAmY,EAAAxJ,aAAA9O,QAAAkS,MAAA/B,SAAAmI,GAGApgB,KAAA4W,gBAGAqvB,EAAA5H,UAAAhnB,SAAA,WAIA,IAHA,GAAA+I,GAAApgB,KAEAiI,EAAAjI,KAAA4W,aAAAnS,OACAwD,KACAmY,EAAAxJ,aAAA3O,IAAAmY,EAAAxJ,aAAA3O,GAAA0wC,WAAAv4B,EAEApgB,MAAA7B,KAAAuqC,aAAA1oC,KAAA+E,OAAA/E,kBAAA7B,KAAAuqC,aAAA1oC,KAAA+E,KACAm3C,EAAA7d,UAAAhnB,SAAA/Z,KAAA0C,OAGAimC,EAAA5H,UAAAsa,WAAA,SAAAme,GACA5a,EAAA7d,UAAAsa,WAAAr7C,KAAA0C,KAAA82D,GAEA92D,KAAAm7B,cAAA,IAAAn7B,KAAAs4C,KAAA7zC,QAAAzE,KAAAqX,YAGA4uB,GACGiW,IAEH6a,GAAA,SAAA7a,GACA,QAAA6a,GAAAnwD,GACAs1C,EAAA5+C,KAAA0C,KAAA,SACAA,KAAAQ,MAAAoG,EACA5G,KAAAmW,QAAA,EACAnW,KAAA7B,KAAA6B,KACAA,KAAA29B,YACA39B,KAAA4G,UACA5G,KAAAsM,WAUA,MAPAyqD,GAAA14B,UAAAlyB,OAAA2tB,OAAAoiB,KAAA7d,WACA04B,EAAA14B,UAAA9Y,YAAAwxC,EAEAA,EAAA14B,UAAA1iB,WAAA,WACA,eAGAo7C,GACG7a,IAEH8a,GAAA7qD,OAAAkyB,UAAA1vB,eAEAs4B,GAAA,SAAAiV,GACA,QAAAjV,GAAA93B,GACA+sC,EAAA5+C,KAAA0C,KAAA,WAGAA,KAAAsM,WAEAtM,KAAAmW,QAAA,EACAnW,KAAA7B,KAAA6B,KACAA,KAAA4G,QAAAuI,EAAAvI,QAEA5G,KAAAQ,MAAA2O,EAAAnQ,KACAgB,KAAA29B,SAAAxuB,EAAAsN,MACAzc,KAAAyc,QAEAzc,KAAA42D,mBAAAznD,EAAAvI,QACA5G,KAAA0oC,gBAGA1oC,KAAAurB,eA+JA,MA5JA0b,GAAA5I,UAAAlyB,OAAA2tB,OAAAoiB,KAAA7d,WACA4I,EAAA5I,UAAA9Y,YAAA0hB,EAEAA,EAAA5I,UAAA44B,aAAA,WAIA,MAHAj3D,MAAAk3D,eACAl3D,KAAAm3D,QAEAn3D,KAAAk3D,aAGAjwB,EAAA5I,UAAA+I,QAAA,SAAAriC,EAAAqhC,GACA,GAAAuC,GAAA,GAAA1C,IAAAjmC,KAAAomC,EAAArhC,EAGA,OAFA/E,MAAA0oC,aAAA3jC,GAAA4jC,EAEAA,GAGA1B,EAAA5I,UAAAhoB,WAAA,SAAAjJ,EAAA9M,EAAA82D,GAMA,IALA,GAAAh3C,GAAApgB,KAEAoM,EAAAe,EAAAC,GAEAtM,EAAAd,KACAoM,EAAA3H,QAAA,CACA,GAAAM,GAAAqH,EAAAtG,OACAhF,GAAAsf,EAAAzG,WAAA5U,IAAAqb,EAAA9J,QAAAvR,GAGA,MAAAjE,GAAAwc,KAAAhd,EAAA82D,IAGAnwB,EAAA5I,UAAA39B,IAAA,SAAA83C,EAAArpC,GACA,GAAAiR,GAAApgB,IAIA,IAFAw4C,GAAA3hC,GAAA7W,MAEAmP,KAAAgrC,WAAA,EAcA,MAAAn6C,MAAAQ,KAVA,KAHA,GAAAyI,GAAAjJ,KAAAk6C,aACA9tC,EAAAD,OAAAC,KAAApM,KAAA0oC,cACAzgC,EAAAmE,EAAA3H,OACAwD,KAAA,CACA,GAAA0gC,GAAAvoB,EAAAsoB,aAAAt8B,EAAAnE,GAEA0gC,GAAAxN,eACAlyB,EAAAmD,EAAAnE,IAAA0gC,EAAAjoC,OAIA,MAAAuI,IAMAg+B,EAAA5I,UAAA1iB,WAAA,WACA,UAGAsrB,EAAA5I,UAAAlkB,gBAAA,WACA,MAAAna,MAAAq3D,eAAAr3D,KAAAq3D,aAAA,GAAAN,IAAA/2D,KAAA4G,WAGAqgC,EAAA5I,UAAA2b,iBAAA,WACA,GAAAxuC,GAAA0wC,EAAA7d,UAAA2b,iBAAA18C,KAAA0C,UAAAQ,MAEAR,MAAAwL,SAAA7G,QAAA,SAAAqb,GACA,GAAAA,EAAAxB,MAAA,CACA,GAAA0R,GAAA1kB,EAAA1D,QAAAkY,IACAkQ,EAAA1kB,EAAA/C,OAAAynB,EAAA,EAAAlQ,EAAAxB,OACAhT,EAAAzD,KAAAiY,EAAAxB,SAIA,QAAA9P,KAAA1O,MAAA0oC,aACAl9B,EAAAzD,KAAA/H,KAAA0oC,aAAAh6B,GAGA,OAAAlD,IAGAy7B,EAAA5I,UAAArnB,aAAA,WACAhX,KAAAs4C,KAAA3zC,QAAAqS,KAGAiwB,EAAA5I,UAAAjoB,IAAA,SAAArR,GACA,GAAAvE,GAAAR,KAAAQ,KAGA,IADAuE,EAAA0I,EAAA1I,GACAiyD,GAAA15D,KAAAkD,EAAAuE,GAAA,QAGA,IAAAA,IAAA/E,MAAA0oC,cAAA1oC,KAAA2Z,WAAA5U,IAAA/E,KAAA2Z,WAAA5U,GAAAyZ,MAAA,QAEA,IAAAzZ,IAAA/E,MAAAurB,YAAA,QAIA,KADA,GAAAhG,GAAA/kB,EAAA+kB,YACAA,IAAAY,UAAAZ,IAAAW,OAAAX,IAAApZ,QAAA,CACA,GAAA6qD,GAAA15D,KAAAioB,EAAA8Y,UAAAt5B,GAAA,QACAwgB,iBAGA,UAGA0hB,EAAA5I,UAAA/nB,QAAA,SAAAvR,EAAAwV,GACA,kBAAAxV,EAAAqV,GACA,UAAArV,EAAA/E,KAAAma,kBAEAna,KAAAurB,YAAA5c,eAAA5J,IACAyB,EAAA,kCAAAzB,EAAAyI,OAAA,gIACAxN,KAAAurB,YAAAxmB,IAGA/E,KAAA0oC,aAAA/5B,eAAA5J,GAAA/E,KAAA0oC,aAAA3jC,GACAm3C,EAAA7d,UAAA/nB,QAAAhZ,KAAA0C,KAAA+E,EAAAwV,IAGA0sB,EAAA5I,UAAAzvB,IAAA,SAAA0oD,EAAAC,GACA,GAAAC,GAAAx3D,KAAAsW,QAAAghD,EACAE,GAAAl6C,KAAAi6C,IAGAtwB,EAAA5I,UAAAoa,UAAA,aAGAxR,EAAA5I,UAAAj+B,IAAA,SAAAI,GAEA,GAAAgc,GAAAxc,KAAAwc,OACA,IAAAA,EAAA,CACA,GAAA4/B,IAAA5/B,EAAAkiB,OAAAliB,EAAAkiB,MAAAl+B,MAAA,CAEA47C,KACA5/B,EAAAnF,WACArX,KAAAwc,QAAA,KACAxc,KAAAQ,QACAR,KAAAyc,aAGAzc,MAAAQ,QACAR,KAAAyc,OAGAzc,MAAAs4C,KAAA3zC,QAAAqS,IACAhX,KAAAwL,SAAA7G,QAAAsS,IACAjX,KAAA2c,oBAGAsqB,EAAA5I,UAAAke,SAAA,WACA,MAAAv8C,MAAAwc,QAAAxc,KAAAwc,QAAA9b,MAAAV,KAAAQ,OAGAymC,EAAA5I,UAAA5xB,OAAA,aAIAw6B,GACGiV,IAiDHnV,GAAA,GAAA6O,IAAA,aAEA5O,IACA,WACA,aACA,aACA,SACA,SACA,gBACA,WACA,eAGAmB,GAAA,EAuJAsvB,GAAA,SAAAt3D,GACAH,KAAAuoC,KAAA,GAAAqN,IAAAz1C,GACAH,KAAA03D,aACA13D,KAAAkL,SAGAusD,IAAAp5B,UAAAyK,MAAA,SAAAliC,GACA5G,KAAA03D,UAAA9wD,EAAAshC,QAAA,GAGAuvB,GAAAp5B,UAAApwB,IAAA,SAAArH,GACA,GAAAI,GAAAJ,EAAAI,MAIAA,IAAAhH,KAAA03D,UAAA1wD,EAAAkhC,OAKAE,GAAApoC,KAAAkL,MAAAlE,GAAAe,KAAAnB,GAJA4F,GAAAxM,KAAA4G,SAOA5G,MAAA03D,UAAA9wD,EAAAshC,OAGA,IAAAU,IAAA,GAAAgN,IAAA,UACA/M,GAAA,GAAA4uB,IAAA,QA2DAE,GAAA,SAAAp3D,EAAAwR,GACAxR,EAAAuH,QAAA,WACA/B,EAAA,2DAAAgM,EAAA,YAAAxR,EAAA,yBAGAP,KAAAO,OACAP,KAAA+R,QACA/R,KAAAkB,KAAA,KACAlB,KAAAkJ,QAAA,KAGAyuD,IAAAt5B,UAAAu5B,OAAA,SAAAtmC,GACA,GAAApwB,GAAAlB,KAAAkB,KAAAlB,KAAA+R,MAAA7Q,KACAX,EAAAP,KAAAO,IAEA,MAAAA,IAAAW,IACAoF,EAAAgB,GAAA/G,EAAA,WAGAW,EAAA22D,iBAAAt3D,EAAAP,KAAAkJ,QAAA,SAAA/I,GACAmxB,EAAA9kB,MACAtL,OACAb,SAAAF,MAEK,IAGLw3D,GAAAt5B,UAAAy5B,SAAA,WACA93D,KAAAkB,KAAA62D,oBAAA/3D,KAAAO,KAAAP,KAAAkJ,SAAA,GAGA,IAAA8uD,IAAA,SAAAC,EAAAlmD,GACA/R,KAAAi4D,cACAj4D,KAAA+R,QACA/R,KAAAkJ,QAAA,KAGA8uD,IAAA35B,UAAAu5B,OAAA,SAAAtmC,GACA,GAAApwB,GAAAlB,KAAA+R,MAAA7Q,IAEAlB,MAAAkJ,QAAAlJ,KAAAi4D,YAAA/2D,EAAA,SAAAf,GACA,SAAAA,UAEAA,EAAAe,KAAAf,EAAAe,QACAowB,EAAA9kB,KAAArM,MAIA63D,GAAA35B,UAAAy5B,SAAA,WACA93D,KAAAkJ,QAAAmO,WAGA,IAAA6gD,IAAA,SAAAtxD,EAAArG,GACAP,KAAA4G,UACA5G,KAAAO,OACAP,KAAAkJ,QAAA,KAGAgvD,IAAA75B,UAAAu5B,OAAA,SAAAtmC,GACA,GAAA1qB,GAAA5G,KAAA4G,OAEA5G,MAAAkJ,QAAAtC,EAAA3G,GAAAD,KAAAO,KAAA,WACA,GAAAJ,EAGAqE,WAAAC,QAAAD,UAAA,IAAAA,UAAA,GAAAtD,OACAf,EAAA+lB,MAAAmY,UAAAv4B,MAAAxI,KAAAkH,WACArE,EAAA0Q,UAAAjK,EAGA,IAAAf,GAAAqgB,MAAAmY,UAAA9rB,MAAAjV,KAAAkH,UAIA,OAHA8sB,GAAA9kB,KAAArM,EAAA0F,IAGA,KAIAqyD,GAAA75B,UAAAy5B,SAAA,WACA93D,KAAAkJ,QAAA6N,SAGA,IAAAohD,IAAA,6BACAC,GAAA,mBAEAC,GAAA,SAAAlpD,GACA,GAAAiR,GAAApgB,IAEAA,MAAA+R,MAAA5C,EAAA4C,OAAA5C,EAAAkC,eAAAU,OAAAmuB,GAAA/wB,EAAAkC,gBACArR,KAAAiK,QAAAjK,KAAA+R,MAAA24B,gBAAA1qC,KAAA+R,MAAAmuB,GAAA/wB,EAAAkC,gBACArR,KAAAlB,SAAAqQ,EAAArQ,SACAkB,KAAAqR,eAAAlC,EAAAkC,eACArR,KAAA4G,QAAAuI,EAAAkC,eAAAzK,QAEA5G,KAAAN,UAEAM,KAAAiK,QAAA7C,OAAAi4B,GACAr/B,KAAAlB,SAAA0iB,EAAA/I,MAAA,KAAA9T,QAAA,SAAA6c,GACApB,EAAA1gB,OAAAqI,KAAA,GAAAmwD,IAAA93C,EAAAnW,QAAApD,SAAA2a,MAGAxhB,KAAAlB,SAAA0iB,EAAA/I,MAAA,KAAA9T,QAAA,SAAA6c,GACA,GAAA7T,GAAAjH,EAAA,SAAA0Z,EAAAxZ,QAAA4a,EAGApB,GAAA1gB,OAAAqI,KAAA4F,EAAA,GAAAqqD,IAAArqD,EAAAyS,EAAAnW,SAAA,GAAA0tD,IAAAn2C,EAAApB,EAAAnW,YAIAjK,KAAA4N,QAAA,KAGA5N,KAAA4/B,UAAA,KACA5/B,KAAA6/B,OAAA,KAGA7/B,KAAAs4D,OAAA,KACAt4D,KAAA6F,KAAA,KAGAwyD,IAAAh6B,UAAAn8B,KAAA,WACA,GAAAke,GAAApgB,IAEAA,MAAA4N,QAAA5N,KAAAqR,eAAAyE,aAEA,IAAAhX,GAAAkB,KAAAlB,SAAAyxB,CAEAzxB,GAAAsJ,GACApI,KAAA2N,GAAA8Y,GAAA3nB,EAAAsJ,EAAArE,EAAAjF,EAAAsJ,EAAA2B,EAAAtF,QACAzE,KAAA4/B,aACA5/B,KAAA6/B,OAAA/gC,EAAAsJ,EAAA2B,EAAA6E,IAAA,SAAA3B,EAAAhF,GACA,GAAAswD,GAAAJ,GAAA5qD,KAAAN,EACA,IAAAsrD,EAEA,OACAxH,QAAAwH,EAAA,GACAnsD,KAAAmsD,EAAA,GAAAprD,EAAAorD,EAAA,GAAA/qD,OAAA,OAIA,IAAAgrD,GAAAJ,GAAA7qD,KAAAN,EACA,IAAAurD,EAEA,OACAzH,QAAA,YACA3kD,MAAAosD,EAAA,MAAA/sD,OAAA+sD,EAAA,GAAArrD,EAAAqrD,EAAA,GAAAhrD,OAAA,QAIA,IAAAmyB,GAEA7+B,EAAA8Y,GAAAwG,EAAA/O,eAAApE,EAWA,OAVAnM,GAQMA,EAAAmX,SAAAmI,IAPNuf,EAAAvf,EAAA/O,eAAAlI,QAAA8D,EAAA,SAAAnM,GACAsf,EAAAyf,OAAA53B,GAAAnH,EACAyH,EAAA6X,EAAAwf,UAAAD,GACA7+B,EAAAmX,SAAAmI,KAGAA,EAAAwf,UAAA73B,KAAA43B,IAGA7+B,MAMAd,KAAAs4D,OAAA,gBAAAx5D,GACAA,EACA,gBAAAA,GAAA0iB,EACA1iB,EAAA0iB,EACA,GAAAunB,KACAh3B,MAAA/R,KACAlB,WAAA0iB,IAGAxhB,KAAA6F,KAAA/G,EAAAqG,EACA,gBAAArG,GAAAqG,GAAArG,EAAAqG,GAAArG,EAAAqG,EACArG,EAAAgQ,EACA,GAAAi6B,KACAh3B,MAAA/R,KACAlB,WAAAgQ,QAKA9O,KAAAs4D,QAAA,gBAAAt4D,MAAAs4D,QAAAt4D,KAAAs4D,OAAAp2D,OACAlC,KAAA6F,MAAA/G,EAAAgQ,GAAA9O,KAAA6F,KAAA3D,QAGAm2D,GAAAh6B,UAAAvpB,OAAA,WACA9U,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAA+R,MAAA+C,WAIAujD,GAAAh6B,UAAA+0B,UAAA,WACApzD,KAAAN,OAAAiF,QAAA,SAAA+E,GAAwC,MAAAA,GAAAouD,cAGxCO,GAAAh6B,UAAA7xB,KAAA,SAAArM,EAAAs4D,GASA,GANA,SAAAA,UAEAt4D,MAAAwO,eAAA,aACA0Q,GAAAlf,EAAAH,KAAA+R,OAGA/R,KAAA2N,GAAA,CACA,GAAAgQ,KAEAxd,IAAAs4D,EAAAv6C,QAAA/d,GAEAH,KAAA6/B,QACA7/B,KAAA6/B,OAAAl7B,QAAA,SAAA7D,GACA,IAAAA,EAAA,MAAA6c,GAAA5V,KAAAM,OAEA,IAAAvH,EAAAiwD,QAAA,CAIA,IAHA,GAAApzD,GAAA,UAAAmD,EAAAiwD,QAAA5wD,EAAAs4D,EACArsD,EAAAtL,EAAAsL,KAAAmG,QAEAnG,EAAA3H,QAAA9G,IAAAyO,EAAAtG,QACA,OAAA6X,GAAA5V,KAAApK,GAGA,MAAAmD,GAAA0b,QACAmB,EAAA5V,KAAAjH,EAAAivC,kBAGApyB,GAAA5V,KAAAjH,EAAAJ,QAKA,IAAAkG,GAAA5G,KAAA4G,QACA8xD,EAAA9xD,EAAAzG,KAEAyG,GAAAzG,OACA,IAAA8I,GAAAjJ,KAAA2N,GAAAxH,MAAAS,EAAA+W,GAAAxM,KAGA,IAAAlI,KAAA,GACA,GAAA5I,GAAAF,IAAAE,SAAAgI,MACAhI,IACAA,EAAAgV,gBAAAhV,EAAAgV,iBACAhV,EAAAiV,iBAAAjV,EAAAiV,mBAEA7O,EAAA,YAAAzG,KAAAlB,SAAA,iEAIA8H,EAAAzG,MAAAu4D,MAGA,CACA,GAAAJ,GAAAt4D,KAAAs4D,OAAA70D,WACAoC,EAAA7F,KAAAlB,SAAAyxB,EAAAzhB,EAAA9O,KAAA6F,KAAA8yD,cAAA34D,KAAA6F,IAEA4yD,GAAAh0D,SAAAoB,IAAA4F,OAAAgtD,IAEAt4D,MAAAI,KAAA+3D,GAEAjkD,GAAArU,KAAA4G,QAAA0xD,GACAn4D,QACA0F,WAKAwyD,GAAAh6B,UAAArnB,aAAA,aAEAqhD,GAAAh6B,UAAAoa,UAAA,SAAArgC,EAAAC,GACA,GAAA+H,GAAApgB,IAEA,IAAAA,KAAA6/B,OAAA,CACA,GAAA3P,GAAAlwB,KAAA6/B,OAAA/3B,QAAAuQ,IAEA6X,IACAlwB,KAAA6/B,OAAAp3B,OAAAynB,EAAA,EAAA9X,GACAC,EAAAsgC,WAAA34C,MACAoY,KAAAqhC,eAAA,WAAkD,MAAArhC,GAAAH,SAAAmI,QAIlDi4C,GAAAh6B,UAAAjnB,OAAA,WAEA,GAAAgJ,GAAApgB,IAEAgO,IAAAiV,aAAA,WAAuC,MAAA7C,GAAA1gB,OAAAiF,QAAA,SAAA+E,GAA+C,MAAAA,GAAAkuD,OAAAx3C,KAA6B,MAGnHi4C,GAAAh6B,UAAA56B,SAAA,WAA2D,UAE3D40D,GAAAh6B,UAAA/mB,OAAA,WACA,GAAA8I,GAAApgB,KAEAlB,EAAAkB,KAAAlB,SAAAyxB,CAEAzxB,GAAAvB,GACAyC,KAAA4/B,WAAA5/B,KAAA4/B,UAAAj7B,QAAA2S,IACAtX,KAAA4/B,aAEA5/B,KAAA6/B,QAAA7/B,KAAA6/B,OAAAl7B,QAAA,SAAApH,GACAA,EAAAo7C,YAAAp7C,EAAAo7C,WAAAv4B,KAEApgB,KAAA6/B,OAAA,OAKA7/B,KAAAs4D,QAAAt4D,KAAAs4D,OAAAhhD,QAAAtX,KAAAs4D,OAAAhhD,SACAtX,KAAA6F,MAAA7F,KAAA6F,KAAAyR,QAAAtX,KAAA6F,KAAAyR,WAIA+gD,GAAAh6B,UAAA9mB,SAAA,WACAvX,KAAAN,OAAAiF,QAAA,SAAA+E,GAAwC,MAAAA,GAAAouD,cAGxCO,GAAAh6B,UAAA5xB,OAAA,YACAzM,KAAAw7B,QAAAx7B,KAAAk4C,QAEAl4C,KAAAk4C,OAAA,EAGAl4C,KAAAs4D,QAAAt4D,KAAAs4D,OAAA7rD,QAAAzM,KAAAs4D,OAAA7rD,SACAzM,KAAA6F,MAAA7F,KAAA6F,KAAA4G,QAAAzM,KAAA6F,KAAA4G,UAyCA,IAAAmsD,IAAA,GAAAhjB,IAAA,YAEA9G,GAAA,SAAAO,GACA,QAAAP,GAAA3/B,EAAA8/B,GACA,GAAA7uB,GAAApgB,IAEAqvC,GAAA/xC,KAAA0C,KAAAmP,GACAnP,KAAAoH,KAAAi4B,EAEA,IAAAx4B,GAAAizB,GAAAmV,EAAA5Q,UAEAr+B,MAAA6G,WACA7G,KAAAO,KAAA4O,EAAArQ,SAAA4K,EACA1J,KAAAqR,eAAAlC,EAAAkC,eAEArR,KAAAmS,eAEAtL,EAAAhI,IACA2H,EAAA,QAAAxG,KAAA,wEAGA,IAAAq5B,GAAAlqB,EAAArQ,SAAArB,KACA,YAAA47B,OAAA5C,QAAAtnB,EAAArQ,SAAAyxB,OACAvwB,KAAA64D,UAAAx/B,EAEAr5B,KAAA84D,WAKA,KAFA,GACA7lD,GADAjH,EAAAmD,EAAAkC,eAEArF,GAAA,CACA,GAAAA,EAAA+F,MAAA3K,OAAAytB,GAAA,CACA5hB,EAAAjH,EAAA+F,MAAAkB,SACA,OAGAjH,IAAAhF,OAIAH,EAAAG,OAAAhH,KAAAqR,eAAAzK,QACAC,EAAAoM,aAAA,KACApM,EAAA1I,KAAA0I,EAAAG,OAAA7I,KACA0I,EAAAgK,UAAA7Q,KAEA0mC,GAAA1mC,KAAA6G,UAA+BwyB,aAK/BxyB,EAAAkyD,gBAAA1/B,EAEAr5B,KAAA0qC,mBAEA1qC,KAAAs/B,aACA,IAAA05B,OACAh5D,KAAAlB,SAAAvB,OAAAoH,QAAA,SAAA7F,GACA,OAAAA,EAAA4oB,GACA,IAAAqK,IACA,IAAApC,IACA,IAAAF,IACArP,EAAAkf,WAAAv3B,KAAAgnC,IACAh9B,MAAAqO,EACA/O,eAAA+O,EAAA/O,eACAvS,aAEA,MAEA,KAAA8gD,IACA,IAAApwB,IACA,KAEA,SACAwpC,EAAAjxD,KAAAjJ,MAKAkB,KAAAs/B,WAAAv3B,KAAA,GAAAwtD,KACAxjD,MAAA/R,KACAqR,eAAArR,KAAAqR,eACAvS,SAAAk6D,KAGAh5D,KAAAi5D,iBACAj5D,KAAAlB,SAAA8oB,GAAA5nB,KAAAk5D,cAyJA,MAtJApqB,GAAAzQ,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACAyQ,EAAAzQ,UAAA9Y,YAAAupB,EAEAA,EAAAzQ,UAAAn8B,KAAA,WACAlC,KAAAs/B,WAAA36B,QAAAmS,IAEA0xB,GAAAxoC,KAAA6G,UACAwyB,SAAAr5B,KAAA64D,YAEAt2C,OAAAviB,KAAAqR,eAAAkR,SAGAviB,KAAAi5D,cAAAt0D,QAAAmS,IAEA9W,KAAA8N,OAAA,GAGAghC,EAAAzQ,UAAAvpB,OAAA,WACA9U,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAAqR,eAAAyD,WAIAg6B,EAAAzQ,UAAA86B,cAAA,WACA,GAAA/4C,GAAApgB,IAEAmM,QAAAC,KAAApM,KAAA84D,UAAAn0D,QAAA,SAAApE,GACA,GAAA6f,EAAA04C,SAAAv4D,GAAAkE,OAAA,EAEA,KADAuJ,IAAAC,MACA,GAAAjI,OAAA,kDAAkEzF,EAAA,IAAAA,EAAA,mCAKlEuuC,EAAAzQ,UAAA+0B,UAAA,WACApzD,KAAA6G,SAAAmF,UAAAhM,KAAA6G,SAAAmF,SAAAonD,aAGAtkB,EAAAzQ,UAAAr0B,OAAA,WACA,MAAAhK,MAAA6G,SAAAmF,SAAAhC,UAGA8kC,EAAAzQ,UAAAjuB,KAAA,SAAAD,GACA,MAAAnQ,MAAA6G,SAAAmF,SAAAoE,KAAAD,IAGA2+B,EAAAzQ,UAAA5rB,QAAA,SAAAtC,EAAAkC,GACArS,KAAA6G,SAAAmF,SAAAyG,QAAAtC,EAAAkC,IAGAy8B,EAAAzQ,UAAAtrB,cAAA,SAAAxS,GACA,MAAAA,IAAAP,KAAAO,SAEAP,KAAA6G,SAAAmF,SACAhM,KAAA6G,SAAAmF,SAAA+G,cAAAxS,GADA,OAFAP,KAAA6G,UAOAioC,EAAAzQ,UAAAxrB,kBAAA,SAAAtS,EAAA8R,GACAA,EAAAxE,KAAA7N,QACAqS,EAAAxD,IAAA7O,KAAA6G,UAEAwL,EAAAC,MACAtS,KAAAmS,YAAApK,KAAAsK,IAIArS,KAAA6G,SAAAmF,SAAA6G,kBAAAtS,EAAA8R,IAGAy8B,EAAAzQ,UAAAw1B,UAAA,SAAAC,GACA,MAAA9zD,MAAA6G,SAAAmF,SAAA6nD,UAAAC,IAGAhlB,EAAAzQ,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACAD,GAAA7iB,KAAA6G,SAAAvG,EAAA,KAAAwiB,GAEA9iB,KAAAm5D,gBACAn5D,KAAAs/B,WAAA36B,QAAAyS,IACApX,KAAAi5D,cAAAt0D,QAAAyS,IACA6xB,GAAAjpC,MAEAA,KAAA4f,UAAA,GAGAkvB,EAAAzQ,UAAA66B,YAAA,WACA,GAAA94C,GAAApgB,KAEAgJ,EAAAhJ,KAAAi5D,aAEA9sD,QAAAC,KAAApM,KAAAlB,SAAA8oB,GAAAjjB,QAAA,SAAAI,GACA,GAAAyP,GAAAzP,EAAA0T,MAAA,KACA3Z,EAAAshB,EAAAthB,SAAA8oB,EAAA7iB,EAEAyP,GAAA7P,QAAA,SAAA2P,GACA,GAAAnU,GAAA,GAAA+3D,IAAA93C,EAAAvZ,SAAAyN,EACAtL,GAAAjB,KAAA,GAAAswD,IAAAj4C,EAAAjgB,EAAArB,SAKAgwC,EAAAzQ,UAAAuc,SAAA,WACA56C,KAAAmS,YAAAxN,QAAAwkC,IACAkG,EAAAhR,UAAAuc,SAAAt9C,KAAA0C,OAGA8uC,EAAAzQ,UAAA56B,SAAA,WACA,MAAAzD,MAAA6G,SAAAuyD,UAGAtqB,EAAAzQ,UAAA/mB,OAAA,WACAtX,KAAA8N,OAAA,EAEA9N,KAAAs/B,WAAA36B,QAAA2S,GAEA,IAAAzQ,GAAA7G,KAAA6G,QACAA,GAAAwF,UAAAgL,WACAxQ,EAAAmF,SAAAsL,SACAzQ,EAAA4Z,WAAA9b,QAAAoS,IAEAmyB,GAAAlpC,MAEA6G,EAAAmF,SAAA4T,UAAA/Y,EAAAhI,GAAAmR,uBACAzH,EAAA1B,EAAAhI,GAAAmR,sBAAAnJ,GAGA+xD,GAAApsD,KAAA3F,IAGAioC,EAAAzQ,UAAA9mB,SAAA,SAAA24B,GACA,GAAA9vB,GAAApgB,IAEAA,MAAA4f,UAAA,EAEA5f,KAAAkwC,gBACAlwC,KAAA6G,SAAA0Q,WACAvX,KAAAs/B,WAAA36B,QAAA4S,IACAvX,KAAAi5D,cAAAt0D,QAAA4S,IACAvX,KAAAmS,YAAAxN,QAAA,SAAA0N,GAAkD,MAAAA,GAAAouB,OAAArgB,EAAAvZ,aAGlDioC,EAAAzQ,UAAA5xB,OAAA,WACAzM,KAAAk4C,OAAA,EACAl4C,KAAA6G,SAAAmF,SAAAS,SACAzM,KAAAm5D,gBACAn5D,KAAAs/B,WAAA36B,QAAA8H,IACAzM,KAAAi5D,cAAAt0D,QAAA8H,KAGAqiC,GACGO,IAEHgqB,IACA5sD,OAAA/G,EACA2R,SAAA3R,GAGA4zD,GAAA,SAAAnqD,GACAnP,KAAA+R,MAAA5C,EAAA4C,OAAA5C,EAAAkC,eAAAU,OAAAmuB,GAAA/wB,EAAAkC,gBACArR,KAAAiK,QAAAjK,KAAA+R,MAAA24B,gBAAA1qC,KAAA+R,MAAAmuB,GAAA/wB,EAAAkC,gBACArR,KAAAqR,eAAArR,KAAA+R,MAAAV,eACArR,KAAA4G,QAAA5G,KAAA+R,MAAAnL,OACA,IAAA9H,GAAAkB,KAAAlB,SAAAqQ,EAAArQ,QAEAkB,MAAAu5D,YAAA,gBAAAz6D,GAAAyxB,EAAA/O,EACAxhB,KAAAw5D,cAAA16D,EAAAyxB,EAAAzhB,EAEA9O,KAAAu5D,YACAv5D,KAAAy5D,aAAA,GAAA1wB,KACAh3B,MAAA/R,KACAlB,WAAAyxB,EAAA/O,IAGAxhB,KAAAO,KAAAzB,EAAAyxB,EAAA/O,GAAA1iB,EAAAyxB,EAGAvwB,KAAAw5D,YACAx5D,KAAA05D,aAAA,GAAA3wB,KACAh3B,MAAA/R,KACAlB,WAAAyxB,EAAAzhB,IAGAhQ,EAAAyxB,EAAAprB,GAAArG,EAAAyxB,EAAAprB,EAAApB,EACA/D,KAAA6F,QAEA7F,KAAA6F,KAAA/G,EAAAyxB,EAAAprB,MAIAnF,KAAAkB,KAAA,KACAlB,KAAA0zD,aAAA,KAEA1zD,KAAAiK,QAAA0vD,WAAA5xD,KAAA/H,MAGAs5D,IAAAj7B,UAAAn8B,KAAA,WACA,GAAAke,GAAApgB,IAEAA,MAAAu5D,cACAv5D,KAAAy5D,aAAAv3D,OACAlC,KAAAO,KAAAP,KAAAy5D,aAAAh2D,YAGAzD,KAAAw5D,aAAAx5D,KAAA05D,aAAAx3D,OAGAlC,KAAAlB,SAAAyxB,EAAAprB,GAAAnF,KAAAlB,SAAAyxB,EAAAprB,EAAApB,IACA/D,KAAA4/B,aACA5/B,KAAA6/B,OAAA7/B,KAAAlB,SAAAyxB,EAAAprB,EAAA4E,EAAA6E,IAAA,SAAA3B,EAAAhF,GACA,GAAA03B,GACA7+B,EAAA8Y,GAAAwG,EAAA/O,eAAApE,EAWA,OAVAnM,GAQMA,EAAAmX,SAAAmI,IAPNuf,EAAAvf,EAAA/O,eAAAlI,QAAA8D,EAAA,SAAAnM,GACAsf,EAAAyf,OAAA53B,GAAAnH,EACAyH,EAAA6X,EAAAwf,UAAAD,GACA7+B,EAAAmX,SAAAmI,KAGAA,EAAAwf,UAAA73B,KAAA43B,IAGA7+B,IAEAd,KAAA45D,OAAAnzC,GAAAzmB,KAAAlB,SAAAyxB,EAAAprB,EAAApB,EAAA/D,KAAAlB,SAAAyxB,EAAAprB,EAAA4E,EAAAtF,UAIA60D,GAAAj7B,UAAAvpB,OAAA,WACA9U,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAA+R,MAAA+C,WAIAwkD,GAAAj7B,UAAA+0B,UAAA,WACApzD,KAAA0zD,cAAA1zD,KAAA0zD,aAAAr8C,YAGAiiD,GAAAj7B,UAAArnB,aAAA,WAA+DhX,KAAA8U,UAE/DwkD,GAAAj7B,UAAAoa,UAAA,SAAArgC,EAAAC,EAAAiiC,GACA,GAAApqB,GAAAlwB,KAAA6/B,OAAA/3B,QAAAuQ,IACA6X,IAEA9X,EAAAD,GAAAnY,KAAAlB,SAAAyxB,EAAAprB,EAAA4E,EAAAmmB,GAAA9X,EAAAC,GACAD,IAAAC,IAEAA,EAAAsgC,WAAA34C,MACAA,KAAA6/B,OAAAp3B,OAAAynB,EAAA,EAAA9X,GACAA,KAAAshC,mBAAA15C,KAAA,QAEAs6C,GAAAt6C,KAAA8U,YAGAwkD,GAAAj7B,UAAAjnB,OAAA,WACA,GAAAgJ,GAAApgB,IAEAgO,IAAAiV,aAAA,WACA,GAAAtV,GAAAjH,EAAA,aAAA0Z,EAAAxZ,QAAAwZ,EAAA7f,KAEA,KAAAoN,EAGA,MAFArH,GAAAgB,GAAA8Y,EAAA7f,KAAA,mBACA6f,EAAAszC,aAAA2F,GAIAj5C,GAAAlf,KAAAkf,EAAAnW,QAAA/I,IAEA,IAAA2E,EAcA,IAbAua,EAAAw5C,QACA/zD,EAAAua,EAAAyf,OAAAjxB,IAAA,SAAA9N,GACA,GAAAA,EAEA,MAAAA,GAAAJ,QAEAmF,EAAAua,EAAAw5C,OAAAzzD,MAAAia,EAAAxZ,QAAAf,IAEAA,EAAAua,EAAAo5C,YAAAp5C,EAAAs5C,aAAAf,cAAAv4C,EAAAva,KAGAua,EAAAszC,aAAA/lD,EAAAxH,MAAAia,EAAAxZ,SAAAwZ,EAAAlf,MAAAuK,OAAA5F,KAEAua,EAAAszC,eAAAtzC,EAAAszC,aAAAr8C,SACA,SAAArR,OAAA,QAAAoa,EAAA,mEAEI,GACJpgB,KAAA4f,UAAA,GAGA05C,GAAAj7B,UAAA56B,SAAA,WAAuD,UAEvD61D,GAAAj7B,UAAA/mB,OAAA,WACA,GAAA8I,GAAApgB,IAEAA,MAAAu5D,aAAAv5D,KAAAy5D,aAAAniD,SACAtX,KAAAw5D,aAAAx5D,KAAA05D,aAAApiD,SACAtX,KAAA4/B,WAAA5/B,KAAA4/B,UAAAj7B,QAAA2S,IACAtX,KAAA6/B,QAAA7/B,KAAA6/B,OAAAl7B,QAAA,SAAApH,GACAA,KAAAo7C,WAAAv4B,MAIAk5C,GAAAj7B,UAAA9mB,SAAA,SAAA24B,GACAA,IAAAlwC,KAAAiK,QAAA2V,WAAA5f,KAAA0zD,cAAA1zD,KAAA0zD,aAAAr8C,WACArX,KAAA4f,UAAA,GAGA05C,GAAAj7B,UAAA5xB,OAAA,WACA,GAAAzM,KAAAk4C,MAAA,CAEAl4C,KAAAk4C,OAAA,CAEA,IAAA2hB,IAAA,CAEA,IAAA75D,KAAAu5D,aAAAv5D,KAAAy5D,aAAAvhB,MAAA,CACA,GAAA33C,GAAAP,KAAAy5D,aAAAh2D,UACAo2D,GAAAt5D,IAAAP,KAAAO,KACAP,KAAAO,OAGA,GAAAP,KAAA0zD,aACA,GAAAmG,IAAA75D,KAAA0zD,aAAAjnD,OACAzM,KAAAuX,WACAvX,KAAAoX,aAGA,IAAApX,KAAAw5D,aACA,GAAAx5D,KAAA05D,aAAAxhB,MAAA,CACA,GAAAryC,GAAA7F,KAAA05D,aAAAf,aACA34D,MAAA0zD,aAAAjnD,OAAAtG,MAAAnG,KAAA4G,QAAAf,QAGA,IAAA7F,KAAA45D,OAAA,CACA,GAAAE,GAAA95D,KAAA6/B,OAAAjxB,IAAA,SAAA9N,GACA,GAAAA,EAEA,MAAAA,GAAAJ,OAEAV,MAAA0zD,aAAAjnD,OAAAtG,MAAAnG,KAAA4G,QAAA5G,KAAA45D,OAAAzzD,MAAAnG,KAAA4G,QAAAkzD,QAGA95D,MAAA0zD,aAAAjnD,OAAAtG,MAAAnG,KAAA4G,QAAA5G,KAAA6F,KAQA7F,MAAAu5D,aAAAv5D,KAAAy5D,aAAAvhB,OACAl4C,KAAAy5D,aAAAhtD,SAGAzM,KAAAw5D,aAAAx5D,KAAA05D,aAAAxhB,OACAl4C,KAAA05D,aAAAjtD,UAIA,IAAAstD,IAAA,SAAA1qB,GACA,QAAA0qB,KACA1qB,EAAAlpC,MAAAnG,KAAAwE,WAkCA,MA/BAu1D,GAAA17B,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACA07B,EAAA17B,UAAA9Y,YAAAw0C;AAEAA,EAAA17B,UAAAn8B,KAAA,aAIA63D,EAAA17B,UAAAjnB,OAAA,aAIA2iD,EAAA17B,UAAAhnB,SAAA,aAIA0iD,EAAA17B,UAAA56B,SAAA,WACA,kBAAAzD,KAAAlB,SAAAqG,EAAA,KAGA40D,EAAA17B,UAAA/mB,OAAA,aAIAyiD,EAAA17B,UAAA9mB,SAAA,aAIAwiD,EAAA17B,UAAA5xB,OAAA,aAIAstD,GACG1qB,IA4BH2qB,GAAA,SAAA/vD,EAAA1J,GACA,SAAAA,MAAA,SAEAP,KAAAiK,UACAjK,KAAA4G,QAAAqD,EAAArD,QACA5G,KAAAqxB,UAAApnB,EAAAygC,gBAAAnqC,EAEA,IAAAmP,GAAA1P,KAAAqxB,UAAA3hB,YACAA,GAAA0lD,cAAAp1D,IAEA,IAAAc,GAAA4O,EAAA5O,KAGA,IAAAA,GAQA,GAAAA,EAAA6yD,aAEA7yD,EAAAm8C,kBACA5T,GAAA,aAAArpC,KAAA4G,aAIA,IAAA9F,EAAAu3C,WAAA,CACA,GAAAjrC,GAAAtM,EAAA6a,aAAA/X,QAAA,QAEA,OADA6C,GAAA,kCAAAwD,EAAA,mBAAAmD,EAAA,gDAAAnD,EAAA,4BAAiMrD,QAAA5G,KAAA4G,WACjM,OAhBA8I,GAAAiwB,SAAAsd,kBACAn8C,EAAA4O,EAAA5O,MAEAuoC,GAAA,IAAA35B,EAAA5Q,SAAA,gBAAAkB,KAAA4G,QAgBA5G,MAAAqxB,UAAAoQ,UAAA,EACAzhC,KAAAc,OAGA,IAAAN,GAAAM,EAAAJ,KACAV,MAAAi6D,aAAA5xD,SAAA7H,EAEA6H,SAAA7H,GAAAR,KAAAk6D,kBACA15D,EAAAR,KAAAk6D,kBACAp5D,EAAAV,IAAAI,IAEAR,KAAAq1D,SAAA,EAAA70D,EAEA,IAAA25D,GAAAj6B,GAAAlgC,KAAAiK,SAAA,SACAkwD,KACAn6D,KAAA67B,WAAAr7B,EACA25D,EAAAjuB,aAAAnkC,KAAA/H,OAIAg6D,IAAA37B,UAAAn8B,KAAA,WACAlC,KAAAc,MAAA45C,sBAAA16C,OAGAg6D,GAAA37B,UAAArnB,aAAA,WACA,GAAAoJ,GAAApgB,KAEAQ,EAAAR,KAAAuiC,UACAviC,MAAAq1D,YAAA70D,IAEAwN,GAAA1L,MAAAtC,KAAA7B,MACA6B,KAAAqxB,UAAAuR,QAAA,EACA5iC,KAAAc,MAAAV,IAAAI,GACAR,KAAAq1D,SAAA,EAAA70D,GAGAR,KAAAc,MAAAJ,QAAAF,EAAAR,KAAAqxB,UAAAuR,QAAA,EACA50B,GAAAiV,aAAA,WAA2C,MAAA7C,GAAAiR,UAAAuR,QAAA,IAE3C50B,GAAAC,QAGA+rD,GAAA37B,UAAAg3B,QAAA,SAAAjwB,EAAA5kC,GACA,MAAA4kC,QAAAplC,KAAAo6D,UAAA55D,GACAR,KAAAo6D,WAGAJ,GAAA37B,UAAAoa,UAAA,SAAArgC,EAAAC,GACA,GAAA+H,GAAApgB,IAEAA,MAAAc,OAAAd,KAAAc,QAAAuX,KAAA0iC,wBAAA/6C,MACAoY,IACApY,KAAAc,MAAAsX,EACApK,GAAAiV,aAAA,WAAuC,MAAA7K,GAAAsiC,sBAAAt6B,OAIvC45C,GAAA37B,UAAAjnB,OAAA,WACApX,KAAAkB,KAAAlB,KAAAiK,QAAA/I,KACAlB,KAAAkB,KAAA4P,SAAAoO,QAAAlf,KACAA,KAAA4f,UAAA,GAGAo6C,GAAA37B,UAAAg8B,YAAA,SAAAn5D,GACAlB,KAAAc,MAAAV,IAAAc,EAAAV,QAGAw5D,GAAA37B,UAAA/mB,OAAA,WACAtX,KAAAc,MAAAi6C,wBAAA/6C,OAGAg6D,GAAA37B,UAAA9mB,SAAA,YAUA,IAAAwzB,IAAA,SAAAivB,GACA,QAAAjvB,GAAA9gC,GACA+vD,EAAA18D,KAAA0C,KAAAiK,EAAA,WAiCA,MA9BA8gC,GAAA1M,UAAAlyB,OAAA2tB,OAAAkgC,KAAA37B,WACA0M,EAAA1M,UAAA9Y,YAAAwlB,EAEAA,EAAA1M,UAAAjnB,OAAA,WACA4iD,EAAA37B,UAAAjnB,OAAA9Z,KAAA0C,MAEAA,KAAAkB,KAAA22D,iBAAA,SAAAtuB,IAAA,GAEAvpC,KAAAkB,KAAAo5D,aACAt6D,KAAAkB,KAAA22D,iBAAA,QAAAtuB,IAAA,IAIAwB,EAAA1M,UAAA9mB,SAAA,WACAvX,KAAAkB,KAAA62D,oBAAA,SAAAxuB,IAAA,GACAvpC,KAAAkB,KAAA62D,oBAAA,QAAAxuB,IAAA,IAGAwB,EAAA1M,UAAA67B,gBAAA,WACA,QAAAl6D,KAAAiK,QAAAg3B,aAAA,YAGA8J,EAAA1M,UAAAkE,SAAA,WACA,MAAAviC,MAAAkB,KAAA2W,SAGAkzB,EAAA1M,UAAAg8B,YAAA,SAAAn5D,GACAlB,KAAAc,MAAAV,IAAAc,EAAA2W,UAGAkzB,GACGivB,IAOHtwB,GAAA,SAAAD,EAAA3oC,EAAAyhC,GACA,GAAAniB,GAAApgB,IAEAA,MAAAc,QACAd,KAAAypC,OACAzpC,KAAAuiC,SAAA,WAEA,MADAniB,GAAA5f,MAAA+hC,EAAAjlC,KAAA8iB,GACAA,EAAA5f,OAGAR,KAAA4pC,YAGAF,IAAArL,UAAAxvB,IAAA,SAAAqQ,GACAlf,KAAA4pC,SAAA7hC,KAAAmX,IAGAwqB,GAAArL,UAAAn8B,KAAA,WACAlC,KAAAQ,MAAAR,KAAAc,MAAAJ,MACAV,KAAAc,MAAA45C,sBAAA16C,MACAA,KAAA8N,OAAA,GAGA47B,GAAArL,UAAAoC,OAAA,SAAAvhB,GACA3W,EAAAvI,KAAA4pC,SAAA1qB,GACAlf,KAAA4pC,SAAAnlC,QACAzE,KAAAsX,UAIAoyB,GAAArL,UAAA/mB,OAAA,WACAtX,KAAAc,MAAAi6C,wBAAA/6C,MACAA,KAAA8N,OAAA,QACA9N,MAAAc,MAAAd,KAAAypC,MAGA,IAAA8wB,OAAAxyD,KASAkjC,GAAA,SAAA+uB,GACA,QAAA/uB,GAAAhhC,GAiBA,GAhBA+vD,EAAA18D,KAAA0C,KAAAiK,EAAA,QAEAjK,KAAAw6D,cAAA,EAKAx6D,KAAAijC,MAAAuG,GAAA,aAAAxpC,KAAAc,MAAAyhC,IACAviC,KAAAijC,MAAAp0B,IAAA7O,MAEAA,KAAAy6D,iBACAz6D,KAAAijC,MAAAw3B,gBAAA,GAKAz6D,KAAAijC,MAAAw3B,gBAAAz6D,KAAAiK,QAAAg3B,aAAA,YACA,GAAAy5B,GAAA16D,KAAAc,MAAAJ,MACAi6D,EAAA36D,KAAAiK,QAAAg3B,aAAA,QAEAj5B,GAAA0yD,EAAAC,IACAJ,GAAAj9D,KAAAo9D,EAAAC,IAiGA,MA5FA1vB,GAAA5M,UAAAlyB,OAAA2tB,OAAAkgC,KAAA37B,WACA4M,EAAA5M,UAAA9Y,YAAA0lB,EAEAA,EAAA5M,UAAAn8B,KAAA,WACAlC,KAAAijC,MAAAn1B,OACA9N,KAAAijC,MAAA/gC,QAIA+oC,EAAA5M,UAAAqf,QAAA,WACA,GAAA1a,KAAAhjC,KAAAojC,SAEA,OADApjC,MAAAojC,UAAApjC,KAAAkB,KAAA2W,QACA7X,KAAAojC,YAAAJ,GAGAiI,EAAA5M,UAAA67B,gBAAA,WASA,MADAl6D,MAAAy6D,gBAAA,MAIAxvB,EAAA5M,UAAAkE,SAAA,WACA,MAAAviC,MAAAijC,MAAAziC,OAGAyqC,EAAA5M,UAAArnB,aAAA,WACAhX,KAAAojC,UAAApjC,KAAAiK,QAAA/I,KAAA2W,QACA7X,KAAAijC,MAAAziC,MAAAR,KAAAc,MAAAJ,KACA,IAAAF,GAAAR,KAAAiK,QAAAg3B,aAAA,QACAjhC,MAAAojC,YAAAp7B,EAAAhI,KAAAijC,MAAAziC,SACAR,KAAAijC,MAAAziC,MAAAuH,KAAAvH,IACKR,KAAAojC,WAAAp7B,EAAAhI,KAAAijC,MAAAziC,UACL+H,EAAAvI,KAAAijC,MAAAziC,SAGAR,KAAAo6D,UAAA,KACAJ,EAAA37B,UAAArnB,aAAA1Z,KAAA0C,OAGAirC,EAAA5M,UAAAjnB,OAAA,WACA4iD,EAAA37B,UAAAjnB,OAAA9Z,KAAA0C,KAEA,IAAAkB,GAAAlB,KAAAkB,KAEAw5D,EAAA16D,KAAAc,MAAAJ,MACAi6D,EAAA36D,KAAAiK,QAAAg3B,aAAA,QAEAj8B,GAAA01D,GACA16D,KAAAojC,UAAAp7B,EAAA0yD,EAAAC,GAEA36D,KAAAojC,UAAAs3B,GAAAC,EAGAz5D,EAAAX,KAAA,KAAmBP,KAAAc,MAAA6a,aAAA,KACnBza,EAAA2W,QAAA7X,KAAAojC,UAEAliC,EAAA22D,iBAAA,SAAAtuB,IAAA,GAGAroC,EAAAo5D,aACAp5D,EAAA22D,iBAAA,QAAAtuB,IAAA,IAIA0B,EAAA5M,UAAAg8B,YAAA,SAAAn5D,GAGA,GAFAlB,KAAAijC,MAAA2G,SAAAjlC,QAAA,SAAAua,GAAuD,MAAAA,GAAA+6C,cAAA,IAEvD/4D,EAAA2W,QAAA,CACA,GAAA+iD,GAAA56D,KAAAijC,MAAAV,UACAq4B,GAAA7yD,KAAA/H,KAAAiK,QAAAg3B,aAAA,UAEAjhC,KAAAijC,MAAAniC,MAAAV,IAAAw6D,KAIA3vB,EAAA5M,UAAA/mB,OAAA,WACAtX,KAAAijC,MAAAxC,OAAAzgC,OAGAirC,EAAA5M,UAAA9mB,SAAA,WACA,GAAArW,GAAAlB,KAAAiK,QAAA/I,IAEAA,GAAA62D,oBAAA,SAAAxuB,IAAA,GACAroC,EAAA62D,oBAAA,QAAAxuB,IAAA,IAGA0B,GACG+uB,IAEHpvB,GAAA,SAAAovB,GACA,QAAApvB,KACAovB,EAAA7zD,MAAAnG,KAAAwE,WA4CA,MAzCAomC,GAAAvM,UAAAlyB,OAAA2tB,OAAAkgC,KAAA37B,WACAuM,EAAAvM,UAAA9Y,YAAAqlB,EAEAA,EAAAvM,UAAA67B,gBAAA,WACA,MAAAl6D,MAAAiK,QAAA+B,SAAAhM,KAAAiK,QAAA+B,SAAAvI,WAAA,IAGAmnC,EAAAvM,UAAAkE,SAAA,WACA,MAAAviC,MAAAiK,QAAA/I,KAAAohB,WAGAsoB,EAAAvM,UAAAjnB,OAAA,WACA4iD,EAAA37B,UAAAjnB,OAAA9Z,KAAA0C,KAEA,IAAAkB,GAAAlB,KAAAkB,IAEAA,GAAA22D,iBAAA,SAAAtuB,IAAA,GACAroC,EAAA22D,iBAAA,OAAAtuB,IAAA,GAEAvpC,KAAA4G,QAAAwsC,OACAlyC,EAAA22D,iBAAA,QAAAtuB,IAAA,GAEAroC,EAAAo5D,aACAp5D,EAAA22D,iBAAA,QAAAtuB,IAAA,KAKAqB,EAAAvM,UAAAg8B,YAAA,SAAAn5D,GACAlB,KAAAc,MAAAV,IAAAc,EAAAohB,YAGAsoB,EAAAvM,UAAA9mB,SAAA,WACA,GAAArW,GAAAlB,KAAAkB,IAEAA,GAAA62D,oBAAA,OAAAxuB,IAAA,GACAroC,EAAA62D,oBAAA,SAAAxuB,IAAA,GACAroC,EAAA62D,oBAAA,QAAAxuB,IAAA,GACAroC,EAAA62D,oBAAA,QAAAxuB,IAAA,IAGAqB,GACGovB,IAyBH3uB,GAAA,SAAA2uB,GACA,QAAA3uB,KACA2uB,EAAA7zD,MAAAnG,KAAAwE,WA0DA,MAvDA6mC,GAAAhN,UAAAlyB,OAAA2tB,OAAAkgC,KAAA37B,WACAgN,EAAAhN,UAAA9Y,YAAA8lB,EAEAA,EAAAhN,UAAA67B,gBAAA,WACA,UAGA7uB,EAAAhN,UAAAkE,SAAA,WACA,MAAAviC,MAAAkB,KAAAV,OAGA6qC,EAAAhN,UAAAjnB,OAAA,WACA4iD,EAAA37B,UAAAjnB,OAAA9Z,KAAA0C,KAIA,IAAAozC,GAAApzC,KAAA4G,QAAAwsC,KACApJ,GAAA,CAEA,SAAAhqC,MAAAiK,UACAmpC,EAAApzC,KAAAiK,QAAAmpC,MAGA/tC,EAAA+tC,KACApJ,GAAAoJ,EACAA,GAAA,GAGApzC,KAAAkJ,QAAA8gC,EAAAF,GAAAE,GAAAT,EAEA,IAAAroC,GAAAlB,KAAAkB,IAEAA,GAAA22D,iBAAA,SAAAtuB,IAAA,GAEA6J,IACAlyC,EAAA22D,iBAAA,QAAA73D,KAAAkJ,SAAA,GAEAhI,EAAAo5D,aACAp5D,EAAA22D,iBAAA,QAAA73D,KAAAkJ,SAAA,IAIAhI,EAAA22D,iBAAA,OAAAhuB,IAAA,IAGAwB,EAAAhN,UAAA9mB,SAAA,WACA,GAAArW,GAAAlB,KAAAiK,QAAA/I,IACAlB,MAAA4f,UAAA,EAEA1e,EAAA62D,oBAAA,SAAAxuB,IAAA,GACAroC,EAAA62D,oBAAA,QAAA/3D,KAAAkJ,SAAA,GACAhI,EAAA62D,oBAAA,QAAA/3D,KAAAkJ,SAAA,GACAhI,EAAA62D,oBAAA,OAAAluB,IAAA,IAGAwB,GACG2uB,IAEH7uB,GAAA,SAAAE,GACA,QAAAF,KACAE,EAAAllC,MAAAnG,KAAAwE,WAuBA,MApBA2mC,GAAA9M,UAAAlyB,OAAA2tB,OAAAuR,KAAAhN,WACA8M,EAAA9M,UAAA9Y,YAAA4lB,EAEAA,EAAA9M,UAAA67B,gBAAA,aAIA/uB,EAAA9M,UAAAkE,SAAA,WACA,MAAAviC,MAAAkB,KAAA25D,OAGA1vB,EAAA9M,UAAAjnB,OAAA,WACApX,KAAAiK,QAAAmpC,MAAA,EACA/H,EAAAhN,UAAAjnB,OAAA9Z,KAAA0C,OAGAmrC,EAAA9M,UAAAg8B,YAAA,SAAAn5D,GACAlB,KAAAc,MAAAV,IAAAc,EAAA25D,QAGA1vB,GACGE,IAUHC,GAAA,SAAA0uB,GACA,QAAA1uB,KACA0uB,EAAA7zD,MAAAnG,KAAAwE,WA6FA,MA1FA8mC,GAAAjN,UAAAlyB,OAAA2tB,OAAAkgC,KAAA37B,WACAiN,EAAAjN,UAAA9Y,YAAA+lB,EAEAA,EAAAjN,UAAAy8B,YAAA,WACA,GAAA16C,GAAApgB,KAEAQ,EAAAR,KAAAuiC,UAEAl6B,UAAA7H,IACAR,KAAAqxB,UAAAuR,QAAA,EACA50B,GAAAiV,aAAA,WAAwC,MAAA7C,GAAAiR,UAAAuR,QAAA,IACxC5iC,KAAAc,MAAAV,IAAAI,KAIA8qC,EAAAjN,UAAA67B,gBAAA,WACA,MAAAl6D,MAAAiK,QAAAkF,QACAoR,OAAA,SAAAzE,GAAmC,MAAAA,GAAAmlB,aAAA,cACnCryB,IAAA,SAAAkN,GAAgC,MAAAA,GAAAmlB,aAAA,YAGhCqK,EAAAjN,UAAAkE,SAAA,WAMA,OALApzB,GAAAnP,KAAAiK,QAAA/I,KAAAiO,QACA5K,EAAA4K,EAAA1K,OAEAs2D,KAEA9yD,EAAA,EAAoBA,EAAA1D,EAAS0D,GAAA,GAC7B,GAAA6T,GAAA3M,EAAAlH,EAEA,IAAA6T,EAAA4mB,SAAA,CACA,GAAAC,GAAA7mB,EAAAhL,SAAAgL,EAAAhL,SAAAtQ,MAAAsb,EAAAtb,KACAu6D,GAAAhzD,KAAA46B,IAIA,MAAAo4B,IAGAzvB,EAAAjN,UAAArnB,aAAA,WACA,GAAAqa,GAAArxB,KAAAqxB,UACA2pC,EAAA3pC,EAAAkR,WAEA/hC,EAAAR,KAAAuiC,UAMA,OAJAl6B,UAAA2yD,GAAA9yD,EAAA1H,EAAAw6D,IACAhB,EAAA37B,UAAArnB,aAAA1Z,KAAA0C,MAGAA,MAGAsrC,EAAAjN,UAAAjnB,OAAA,WACA4iD,EAAA37B,UAAAjnB,OAAA9Z,KAAA0C,MAEAA,KAAAkB,KAAA22D,iBAAA,SAAAtuB,IAAA,GAEAlhC,SAAArI,KAAAc,MAAAJ,OAEAV,KAAAgX,gBAIAs0B,EAAAjN,UAAAg8B,YAAA,SAAAn5D,GAKA,IAJA,GAAAkpC,GAAAF,GAAAhpC,GACA+G,EAAAmiC,EAAA3lC,OACAwE,EAAA,GAAAid,OAAAje,GAEAA,KAAA,CACA,GAAA6T,GAAAsuB,EAAAniC,EACAgB,GAAAhB,GAAA6T,EAAAhL,SAAAgL,EAAAhL,SAAAtQ,MAAAsb,EAAAtb,MAGAR,KAAAc,MAAAV,IAAA6I,IAGAqiC,EAAAjN,UAAA48B,SAAA,WACA,SAAAj1D,OAAA,6BAGAslC,EAAAjN,UAAA9mB,SAAA,WACAvX,KAAAkB,KAAA62D,oBAAA,SAAAxuB,IAAA,IAGA+B,EAAAjN,UAAA1f,YAAA,WACAtW,SAAArI,KAAAqxB,UAAA7wB,OAAAR,KAAAqxB,UAAA7wB,MAAAiE,QACAzE,KAAAoN,QAAAhN,IAAAJ,KAAAk7D,eAIA5vB,GACG0uB,IAEH5uB,GAAA,SAAAC,GACA,QAAAD,KACAC,EAAAllC,MAAAnG,KAAAwE,WAoBA,MAjBA4mC,GAAA/M,UAAAlyB,OAAA2tB,OAAAuR,KAAAhN,WACA+M,EAAA/M,UAAA9Y,YAAA6lB,EAEAA,EAAA/M,UAAA67B,gBAAA,aAIA9uB,EAAA/M,UAAAkE,SAAA,WACA,GAAA/hC,GAAA+E,WAAAvF,KAAAkB,KAAAV,MACA,OAAA8E,OAAA9E,GAAA6H,OAAA7H,GAGA4qC,EAAA/M,UAAAg8B,YAAA,SAAAn5D,GACA,GAAAV,GAAA+E,WAAArE,EAAAV,MACA8E,OAAA9E,IAAAR,KAAAc,MAAAV,IAAAI,IAGA4qC,GACGC,IAEHf,MAMAY,GAAA,SAAA8uB,GACA,QAAA9uB,GAAAjhC,GACA+vD,EAAA18D,KAAA0C,KAAAiK,EAAA,WAEAjK,KAAAsqC,SAAAD,GAAArqC,KAAA4G,QAAAshC,MAAAloC,KAAAiK,QAAAg3B,aAAA,SACAjhC,KAAAsqC,SAAAviC,KAAA/H,MA2CA,MAxCAkrC,GAAA7M,UAAAlyB,OAAA2tB,OAAAkgC,KAAA37B,WACA6M,EAAA7M,UAAA9Y,YAAA2lB,EAEAA,EAAA7M,UAAAkE,SAAA,WACA,MAAAviC,MAAAkB,KAAA2W,SAGAqzB,EAAA7M,UAAArnB,aAAA,WACAhJ,GAAA1L,MAAAtC,KAAA7B,MAEA6B,KAAAsqC,SAAA3lC,QAAA,SAAAua,GACAA,EAAApe,MAAAV,IAAA8e,EAAAqjB,cAGAv0B,GAAAC,OAGAi9B,EAAA7M,UAAAjnB,OAAA,WACA4iD,EAAA37B,UAAAjnB,OAAA9Z,KAAA0C,MAEAA,KAAAkB,KAAA22D,iBAAA,SAAAtuB,IAAA,GAEAvpC,KAAAkB,KAAAo5D,aACAt6D,KAAAkB,KAAA22D,iBAAA,QAAAtuB,IAAA,IAIA2B,EAAA7M,UAAAg8B,YAAA,SAAAn5D,GACAlB,KAAAc,MAAAV,IAAAc,EAAA2W,UAGAqzB,EAAA7M,UAAA/mB,OAAA,WACA/O,EAAAvI,KAAAsqC,SAAAtqC,OAGAkrC,EAAA7M,UAAA9mB,SAAA,WACAvX,KAAAkB,KAAA62D,oBAAA,SAAAxuB,IAAA,GACAvpC,KAAAkB,KAAA62D,oBAAA,QAAAxuB,IAAA,IAGA2B,GACG8uB,IASHhvB,GAAA,SAAAgvB,GACA,QAAAhvB,GAAA/gC,GACA+vD,EAAA18D,KAAA0C,KAAAiK,EAAA,QAEAjK,KAAAijC,MAAAuG,GAAA,YAAAxpC,KAAAc,MAAAypC,IACAvqC,KAAAijC,MAAAp0B,IAAA7O,MAEAiK,EAAA4N,UACA7X,KAAAijC,MAAAziC,MAAAR,KAAAuiC,YAiFA,MA7EAyI,GAAA3M,UAAAlyB,OAAA2tB,OAAAkgC,KAAA37B,WACA2M,EAAA3M,UAAA9Y,YAAAylB,EAEAA,EAAA3M,UAAAn8B,KAAA,WACA,GAAAke,GAAApgB,IAEAA,MAAAijC,MAAAn1B,OACA9N,KAAAijC,MAAA/gC,OAIAlC,KAAAm7D,sBACAnkD,aAAA,WAAgC,MAAAoJ,GAAAlf,KAAAX,KAAA,KAA8B6f,EAAAtf,MAAA6a,aAAA,OAG9D3b,KAAAc,MAAAgZ,kBAAA7B,SAAAjY,KAAAm7D,uBAGAnwB,EAAA3M,UAAA67B,gBAAA,WACA,GAAAl6D,KAAAiK,QAAAg3B,aAAA,WACA,MAAAjhC,MAAAiK,QAAAg3B,aAAA,UAIA+J,EAAA3M,UAAAkE,SAAA,WACA,MAAAviC,MAAAiK,QAAAg3B,aAAA,UAGA+J,EAAA3M,UAAArnB,aAAA,WAGAhX,KAAAkB,KAAA2W,UACA7X,KAAAijC,MAAAziC,MAAAR,KAAAuiC,WACAy3B,EAAA37B,UAAArnB,aAAA1Z,KAAA0C,QAIAgrC,EAAA3M,UAAAg3B,QAAA,SAAAjwB,EAAA5kC,GACA,GAAAR,KAAAijC,MACA,MAAAmC,QAAAplC,KAAAijC,MAAAm3B,UAAA55D,GACAR,KAAAijC,MAAAm3B,WAGApvB,EAAA3M,UAAAjnB,OAAA,WACA4iD,EAAA37B,UAAAjnB,OAAA9Z,KAAA0C,KAEA,IAAAkB,GAAAlB,KAAAkB,IAEAA,GAAAX,KAAA,KAAmBP,KAAAc,MAAA6a,aAAA,KACnBza,EAAA2W,QAAA7X,KAAAc,MAAAJ,OAAAV,KAAAiK,QAAAg3B,aAAA,SAEA//B,EAAA22D,iBAAA,SAAAtuB,IAAA,GAEAroC,EAAAo5D,aACAp5D,EAAA22D,iBAAA,QAAAtuB,IAAA,IAIAyB,EAAA3M,UAAAg8B,YAAA,SAAAn5D,GACAA,EAAA2W,SACA7X,KAAAijC,MAAAniC,MAAAV,IAAAJ,KAAAiK,QAAAg3B,aAAA,WAIA+J,EAAA3M,UAAA/mB,OAAA,WACAtX,KAAAijC,MAAAxC,OAAAzgC,MAEAA,KAAAc,MAAAgZ,kBAAA6+B,WAAA34C,KAAAm7D,uBAGAnwB,EAAA3M,UAAA9mB,SAAA,WACA,GAAArW,GAAAlB,KAAAkB,IAEAA,GAAA62D,oBAAA,SAAAxuB,IAAA,GACAroC,EAAA62D,oBAAA,QAAAxuB,IAAA,IAGAyB,GACGgvB,IAEHzuB,GAAA,SAAAyuB,GACA,QAAAzuB,KACAyuB,EAAA7zD,MAAAnG,KAAAwE,WAmGA,MAhGA+mC,GAAAlN,UAAAlyB,OAAA2tB,OAAAkgC,KAAA37B,WACAkN,EAAAlN,UAAA9Y,YAAAgmB,EAEAA,EAAAlN,UAAAy8B,YAAA,WACA,GAAA16C,GAAApgB,KAEAQ,EAAAR,KAAAuiC,UAEAl6B,UAAA7H,IACAR,KAAAqxB,UAAAuR,QAAA,EACA50B,GAAAiV,aAAA,WAAwC,MAAA7C,GAAAiR,UAAAuR,QAAA,IACxC5iC,KAAAc,MAAAV,IAAAI,KAIA+qC,EAAAlN,UAAA67B,gBAAA,WACA,GAAA7xD,SAAArI,KAAAiK,QAAAg3B,aAAA,UAIA,GAAA9xB,GAAAnP,KAAAiK,QAAAkF,QACA5K,EAAA4K,EAAA1K,MAEA,IAAAF,EAAA,CAOA,IALA,GAAA/D,GACA46D,EACAnzD,EAAA1D,EAGA0D,KAAA,CACA,GAAA6T,GAAA3M,EAAAlH,EAEA,IAAA6T,EAAAmlB,aAAA,aACAnlB,EAAAmlB,aAAA,cACAzgC,EAAAsb,EAAAmlB,aAAA,UAGAm6B,GAAA,CACA,QAKA,IAAAA,EACA,OAAAnzD,EAAA1D,GACA,IAAA4K,EAAAlH,GAAAg5B,aAAA,aACAzgC,EAAA2O,EAAAlH,GAAAg5B,aAAA,QACA,OAYA,MAJA54B,UAAA7H,IACAR,KAAAiK,QAAAygC,gBAAAlqC,eAGAA,KAGA+qC,EAAAlN,UAAAkE,SAAA,WACA,GAGAt6B,GAHAkH,EAAAnP,KAAAkB,KAAAiO,QACA5K,EAAA4K,EAAA1K,MAGA,KAAAwD,EAAA,EAAgBA,EAAA1D,EAAS0D,GAAA,GACzB,GAAA6T,GAAA3M,EAAAlH,EAEA,IAAAkH,EAAAlH,GAAAy6B,WAAAvzB,EAAAlH,GAAA66B,SACA,MAAAhnB,GAAAhL,SAAAgL,EAAAhL,SAAAtQ,MAAAsb,EAAAtb,QAKA+qC,EAAAlN,UAAAjnB,OAAA,WACA4iD,EAAA37B,UAAAjnB,OAAA9Z,KAAA0C,MACAA,KAAAkB,KAAA22D,iBAAA,SAAAtuB,IAAA,IAGAgC,EAAAlN,UAAAg8B,YAAA,SAAAn5D,GACA,GAAA4a,GAAAouB,GAAAhpC,GAAA,EACAlB,MAAAc,MAAAV,IAAA0b,EAAAhL,SAAAgL,EAAAhL,SAAAtQ,MAAAsb,EAAAtb,QAIA+qC,EAAAlN,UAAA48B,SAAA,SAAAz6D,GACAR,KAAAc,MAAAV,IAAAI,IAGA+qC,EAAAlN,UAAA9mB,SAAA,WACAvX,KAAAkB,KAAA62D,oBAAA,SAAAxuB,IAAA,IAGAgC,GACGyuB,IAyEHqB,GAAA,QAEAjsB,GAAA,SAAAC,GACA,QAAAD,GAAAjgC,GACA,GAAAiR,GAAApgB,IAYA,IAVAqvC,EAAA/xC,KAAA0C,KAAAmP,GAEAnP,KAAAmS,eAEAnS,KAAAO,KAAA4O,EAAArQ,SAAA4K,EAAAtF,cACApE,KAAAs7D,OAAA1hC,GAAA/rB,KAAA7N,KAAAO,MAGAP,KAAAgH,OAAAk5B,GAAAlgC,KAAAqR,gBAAA,GAEArR,KAAAgH,QAAA,WAAAhH,KAAAgH,OAAAzG,KACA,SAAAyF,OAAA,mEAAAhG,KAAA,UAGAA,MAAA25D,cAGA35D,KAAA0qC,mBAEA1qC,KAAAs/B,aACA,IAAA05B,OACAh5D,KAAAlB,SAAAvB,OAAAoH,QAAA,SAAA7F,GACA,OAAAA,EAAA4oB,GACA,IAAAqK,IACA,IAAA6tB,IACA,IAAApwB,IACA,IAAAG,IACA,IAAAF,IACArP,EAAAkf,WAAAv3B,KAAAgnC,IACAh9B,MAAAqO,EACA/O,eAAA+O,EAAA/O,eACAvS,aAEA,MAEA,SACAk6D,EAAAjxD,KAAAjJ,MAKAk6D,EAAAv0D,QACAzE,KAAAs/B,WAAAv3B,KAAA,GAAAwtD,KACAxjD,MAAA/R,KACAqR,eAAArR,KAAAqR,eACAvS,SAAAk6D,IAKA,KADA,GAAA/wD,GAAAjI,KAAAs/B,WAAA76B,OACAwD,KAAA,CACA,GAAA+nB,GAAA5P,EAAAkf,WAAAr3B,EACA,UAAA+nB,EAAAzvB,KAAA6f,EAAAkf,WAAAphB,QAAAkC,EAAAkf,WAAA72B,OAAAR,EAAA,OACA,QAAA+nB,EAAAzvB,KAAA6f,EAAAkf,WAAAphB,QAAAkC,EAAAkf,WAAA72B,OAAAR,EAAA,OACA,QAAA+nB,EAAAzvB,KAAA6f,EAAAkf,WAAAphB,QAAAkC,EAAAkf,WAAA72B,OAAAR,EAAA,OACA,UAAA+nB,EAAAzvB,KAAA6f,EAAAkf,WAAAphB,QAAAkC,EAAAkf,WAAA72B,OAAAR,EAAA,OACA,UAAA+nB,EAAAzvB,MACA6f,EAAAkf,WAAAv3B,KAAAqY,EAAAkf,WAAA72B,OAAAR,EAAA,OAKAkH,EAAArQ,SAAAyxB,IAAAphB,EAAAosD,eACAv7D,KAAAgM,SAAA,GAAA+8B,KACAjqC,SAAAqQ,EAAArQ,SAAAyxB,EACAxe,MAAA/R,KACAuiB,OAAA,QAIAviB,KAAAkf,QAAA,KAsSA,MAnSAkwB,GAAA/Q,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACA+Q,EAAA/Q,UAAA9Y,YAAA6pB,EAEAA,EAAA/Q,UAAAn8B,KAAA,WACAlC,KAAAs/B,WAAApgB,SAAA,EACAlf,KAAAs/B,WAAA36B,QAAAmS,IACA9W,KAAAs/B,WAAApgB,SAAA,EAEAlf,KAAAgM,UAAAhM,KAAAgM,SAAA9J,OAGAlC,KAAAkf,SAAAlf,KAAAqkC,yBAGA+K,EAAA/Q,UAAAm9B,oBAAA,WACA,GAAAC,GAAA,UAAAz7D,WAAAmzC,OAAAnzC,KAAA4G,QAAAusC,MAEA,KAAAsoB,EAAA,WAEA,IAAAzB,GAAAvvB,GAAAzqC,KAEA,KAAAg6D,EAAA,WAEA,IAAA96C,GAAA,GAAA86C,GAAAh6D,KAEA,OAAAkf,MAAApe,MACAoe,EACA,MAGAkwB,EAAA/Q,UAAA+0B,UAAA,WACApzD,KAAAs/B,WAAA36B,QAAA,SAAAQ,GAA6C,MAAAA,GAAAiuD,cAC7CpzD,KAAAgM,UAAAhM,KAAAgM,SAAAonD,aAGAhkB,EAAA/Q,UAAAr0B,OAAA,WAIA,MAFAhK,MAAA4f,UAAA5f,KAAAozD,YAEA/vD,EAAArD,KAAAkB,OAGAkuC,EAAA/Q,UAAAjuB,KAAA,SAAAD,GACA,MAAA4jC,IAAA/zC,KAAAkB,KAAAiP,GAAAnQ,KAAAkB,KACAlB,KAAAgM,SACAhM,KAAAgM,SAAAoE,KAAAD,GADA,QAKAi/B,EAAA/Q,UAAA5rB,QAAA,SAAAtC,EAAAkC,GAGA,GAAA0hC,GAAA1hC,EAAAxE,KAAA7N,KAAAkB,KACA6yC,KACA1hC,EAAAxD,IAAA7O,KAAAkB,MACAmR,EAAAC,MAAAtS,KAAAmS,YAAApK,KAAAsK,IAGArS,KAAAgM,UACAhM,KAAAgM,SAAAyG,QAAAtC,EAAAkC,IAIA+8B,EAAA/Q,UAAAtrB,cAAA,SAAAxS,GACA,GAAAP,KAAAgM,SACA,MAAAhM,MAAAgM,SAAA+G,cAAAxS,IAIA6uC,EAAA/Q,UAAAxrB,kBAAA,SAAAtS,EAAA8R,GACArS,KAAAgM,UACAhM,KAAAgM,SAAA6G,kBAAAtS,EAAA8R,IAIA+8B,EAAA/Q,UAAA+R,aAAA,WACA,aAGAhB,EAAA/Q,UAAAw1B,UAAA,WACA,MAAA7zD,MAAAkB,MAGAkuC,EAAA/Q,UAAA4C,aAAA,SAAA1gC,GACA,GAAA8wB,GAAArxB,KAAA0qC,gBAAAnqC,EACA,OAAA8wB,KAAAkR,WAAAl6B,QAGA+mC,EAAA/Q,UAAAgG,sBAAA,WACArkC,KAAAkf,UACAlf,KAAAkf,QAAA5H,SACAtX,KAAAkf,QAAA3H,aAGAvX,KAAAkf,QAAAlf,KAAAw7D,yBACAx7D,KAAAkf,QAAAhd,OACAlC,KAAA4f,UAAA5f,KAAAkf,QAAA9H,WAIAg4B,EAAA/Q,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GAEA,GAAA1C,GAAApgB,IAEAA,MAAAoiC,UAAA0J,GAAA9rC,KAEA,IAAAkB,GACAw6D,GAAA,CAEA,IAAA54C,EAEA,IADA,GAAAtB,GACAA,EAAAsB,EAAAhd,SAAA,CACA,GAAA0b,EAAAm6C,SAAA13D,gBAAAmc,EAAAthB,SAAA4K,EAAAzF,eAAAud,EAAAsgB,eAAA1hB,EAAAgiB,UAAA,CACAhiB,EAAAlf,OAAAsgB,EACAk6C,GAAA,CACA,OAEAr4D,EAAAme,GAwBA,GAnBAtgB,IACAA,EAAAstC,GAAAxuC,KAAAlB,SAAA4K,EAAA1J,KAAAoiC,UAAApiC,KAAAihC,aAAA,OACAjhC,KAAAkB,QAGA2lC,GAAA3lC,EAAA,YACAV,OACAuQ,MAAA/Q,QAMAA,KAAAqR,eAAAkR,QACArhB,EAAAgiC,aAAA,mBAAAljC,KAAAqR,eAAAkR,OAAA3T,IAAA,SAAAxG,GAA4F,UAAWA,EAAA,MAAeyH,KAAA,MAGtH6rD,GAAA17D,KAAA47D,WAAA57D,KAAA47D,UAAA16D,GAEAlB,KAAAgM,SAAA,CACA,GAAAR,GAAAkwD,EAAAhzD,EAAAxH,EAAA0iB,YAAAvb,MAEArI,MAAAgM,SAAAoL,OAAAlW,EAAAsK,GAGAA,GACAA,EAAA7G,QAAAtB,GAIA,GAAAq4D,EAAA,CAEA17D,KAAAkf,SAAAlf,KAAAkf,QAAA+6C,cAAAj6D,KAAAkf,QAAAm7C,YAAAn5D,EAGA,KADA,GAAA+G,GAAA/G,EAAAo+B,WAAA76B,OACAwD,KAAA,CACA,GAAA1H,GAAAW,EAAAo+B,WAAAr3B,GAAA1H,IACAA,KAAA6f,GAAAsqB,iBAAAxpC,EAAAuhC,gBAAAliC,IAIAP,KAAAs/B,WAAA36B,QAAAyS,IAEApX,KAAAkf,SAAAlf,KAAAkf,QAAA9H,SAEAgyB,GAAAppC,MAEAA,KAAA67D,kBAAA77D,KAAA4G,QAAAmc,qBACA/iB,KAAA67D,iBAAA1kB,SAAA,EACAnpC,GAAAsjC,mBAAAtxC,KAAA67D,mBAGAH,GACAp7D,EAAAquC,YAAAztC,GAGAlB,KAAA4f,UAAA,GAGAwvB,EAAA/Q,UAAAuc,SAAA,WACA56C,KAAAmS,YAAAxN,QAAA6mC,IACA6D,EAAAhR,UAAAuc,SAAAt9C,KAAA0C,OAGAovC,EAAA/Q,UAAA56B,SAAA,WACA,GAAAihC,GAAA1kC,KAAAlB,SAAA4K,EAEA8rD,EAAAx1D,KAAAs/B,WAAA1wB,IAAAg9B,IAAA/7B,KAAA,GAGA,YAAA7P,KAAAO,MAAAP,KAAA87D,eACAtG,GAAA,aAIA,UAAAx1D,KAAAO,MAAAkrC,GAAAzrC,QACAw1D,GAAA,WAIA,IAAA/yC,GAAAs5C,CACA/7D,MAAAs/B,WAAA36B,QAAA,SAAAqrB,GACA,UAAAA,EAAAzvB,KACAw7D,MAAA,KAAAA,EAAA,QAAAr4D,EAAAssB,EAAA4T,aACM,UAAA5T,EAAAzvB,MACNkiB,MAAA,KAAAA,EAAA,QAAA/e,EAAAssB,EAAA4T,aACAnhB,IAAA44C,GAAAxtD,KAAA4U,QAAA,MACMuN,EAAAuT,UACN9gB,MAAA,KAAAA,EAAA,QAAAve,EAAA8rB,EAAAuT,WAAA,KAAA7/B,EAAAssB,EAAA4T,aAAA,IACM5T,EAAAyT,aAAAzT,EAAAuS,aACNw5B,MAAA,KAAAA,EAAA,QAAA/rC,EAAAyT,eAIAp7B,SAAAoa,IAAA+yC,EAAA,UAAA/yC,EAAA,KAAAA,EAAA,QAAA+yC,GACAntD,SAAA0zD,IAAAvG,EAAA,UAAAuG,EAAA,KAAAA,EAAA,QAAAvG,EAEA,IAAAp0C,GAAA,IAAAsjB,EAAA8wB,EAAA,GAEA,OAAAx1D,MAAAs7D,OAAAl6C,GAGA,aAAAphB,KAAAO,MAAA8H,SAAArI,KAAAihC,aAAA,SACA7f,GAAAyH,GAAA7oB,KAAAihC,aAAA,UAIA54B,SAAArI,KAAAihC,aAAA,qBACA7f,GAAAphB,KAAAihC,aAAA,cAGAjhC,KAAAgM,WACAoV,GAAAphB,KAAAgM,SAAAvI,UAAA,sBAAAoK,KAAA7N,KAAAlB,SAAA4K,KAGA0X,GAAA,KAAAsjB,EAAA,MAIA0K,EAAA/Q,UAAA/mB,OAAA,WACAtX,KAAAs/B,WAAA36B,QAAA2S,IAEAtX,KAAAkf,SAAAlf,KAAAkf,QAAA5H,SACAtX,KAAAgM,UAAAhM,KAAAgM,SAAAsL,UAGA83B,EAAA/Q,UAAA9mB,SAAA,SAAA24B,GACA,GAAAlwC,KAAA4f,SAAA,CACA5f,KAAA4f,UAAA,CAIA,IAAAwxB,GAAApxC,KAAA67D,gBACAzqB,MAAA7hC,UAAA6hC,EAAA7hC,WAGA,WAAAvP,KAAAO,KAIAP,KAAAgK,SACKkmC,GACLliC,GAAA6pC,gBAAA73C,MAGAA,KAAAgM,UAAAhM,KAAAgM,SAAAuL,WAEAvX,KAAAkf,SAAAlf,KAAAkf,QAAA3H,WAGAvX,KAAAg8D,kBAAAh8D,KAAA4G,QAAAmc,qBACA/iB,KAAAg8D,iBAAA7kB,SAAA,EACAnpC,GAAAsjC,mBAAAtxC,KAAAg8D,mBAGAnwB,GAAA7rC,QAIAovC,EAAA/Q,UAAA5xB,OAAA,WACAzM,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EAEAl4C,KAAAs/B,WAAA36B,QAAA8H,IAEAzM,KAAAgM,UAAAhM,KAAAgM,SAAAS,WAIA2iC,GACGC,IAoDH4sB,GAAA,SAAA7sB,GACA,QAAA6sB,GAAA9sD,GACAigC,EAAA9xC,KAAA0C,KAAAmP,GACAnP,KAAAksC,gBAgBA,MAbA+vB,GAAA59B,UAAAlyB,OAAA2tB,OAAAsV,KAAA/Q,WACA49B,EAAA59B,UAAA9Y,YAAA02C,EAEAA,EAAA59B,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACAssB,EAAA/Q,UAAAjnB,OAAA9Z,KAAA0C,KAAAM,EAAAwiB,GACA9iB,KAAAkB,KAAA22D,iBAAA,QAAA5rB,IAAA,IAGAgwB,EAAA59B,UAAA9mB,SAAA,SAAA24B,GACAlwC,KAAAkB,KAAA62D,oBAAA,QAAA9rB,IAAA,GACAmD,EAAA/Q,UAAA9mB,SAAAja,KAAA0C,KAAAkwC,IAGA+rB,GACG7sB,IAcH8sB,GAAA,SAAA7sB,GACA,QAAA6sB,GAAA/sD,GACAkgC,EAAA/xC,KAAA0C,KAAAmP,GAEAnP,KAAAqR,eAAAlC,EAAAkC,eACArR,KAAAlB,SAAAqQ,EAAArQ,SACAkB,KAAA6H,MAAAsH,EAAAtH,MACAsH,EAAA4C,QAAA/R,KAAAgH,OAAAmI,EAAA4C,OAEA/R,KAAA2yB,WAAAxjB,EAAArQ,SAAAiF,EAEA/D,KAAAc,MAAA,KACAd,KAAAk4C,OAAA,EA0DA,MAvDAgkB,GAAA79B,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACA69B,EAAA79B,UAAA9Y,YAAA22C,EAEAA,EAAA79B,UAAAn8B,KAAA,WAEA,GAAAke,GAAApgB,KAEAc,EAAAg/B,GAAA9/B,KAAAqR,eAAArR,KAAAlB,UACA0B,EAAAM,IAAAJ,MAAA2H,MAEA,OAAArI,MAAA2yB,cACA3yB,KAAAc,OAAmBJ,IAAA,WAAmB,MAAAF,WAItCM,GACAA,EAAAmX,SAAAjY,MACAA,KAAAc,SAEAd,KAAA2/B,SAAA3/B,KAAAqR,eAAAlI,QAAAnJ,KAAAlB,SAAAiL,EAAA,SAAAjJ,GACAsf,EAAAtf,QACAA,EAAAmX,SAAAmI,GAEAA,EAAApJ,eACAoJ,EAAAuf,SAAA,SAKAu8B,EAAA79B,UAAArnB,aAAA,WACAhX,KAAA8U,UAGAonD,EAAA79B,UAAAoa,UAAA,SAAArgC,EAAAC,EAAAiiC,GAEA,MADAliC,GAAAD,GAAAnY,KAAAlB,SAAAsZ,EAAAC,IACArY,KAAA,SACAoY,IAAApY,KAAAc,QAEAd,KAAAc,OACAd,KAAAc,MAAA63C,WAAA34C,MAEAoY,KAAAshC,mBAAA15C,KAAA,QACAA,KAAAc,MAAAsX,EACAkiC,GAAAt6C,KAAAgX,gBACA,KAGAklD,EAAA79B,UAAA/mB,OAAA,WACAtX,KAAA2yB,WACA3yB,KAAAc,OAAAd,KAAAc,MAAA63C,WAAA34C,MACAA,KAAAc,MAAAuH,OACArI,KAAA2/B,UAAA3/B,KAAA2/B,SAAAroB,WAIA4kD,GACG7sB,IAEH8sB,GAAA,SAAAD,GACA,QAAAC,KACAD,EAAA/1D,MAAAnG,KAAAwE,WA2EA,MAxEA23D,GAAA99B,UAAAlyB,OAAA2tB,OAAAoiC,KAAA79B,WACA89B,EAAA99B,UAAA9Y,YAAA42C,EAEAA,EAAA99B,UAAAvpB,OAAA,WACA9U,KAAA+R,OAAA/R,KAAA+R,MAAA+C,SACAonD,EAAA79B,UAAAvpB,OAAAxX,KAAA0C,OAGAm8D,EAAA99B,UAAAr0B,OAAA,WACA,MAAA3G,GAAArD,KAAAkB,OAGAi7D,EAAA99B,UAAAw1B,UAAA,WACA,MAAA7zD,MAAAkB,MAGAi7D,EAAA99B,UAAAuF,UAAA,WACA,MAAA5jC,MAAAc,MAAA0C,EAAAxD,KAAAc,MAAAJ,OAAA,IAGAy7D,EAAA99B,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACA,IAAAwhB,KAAA,CACA,GAAA9jC,GAAAR,KAAA4jC,WAIA,IAFA5jC,KAAA4f,UAAA,EAEAkD,EAAA,CACA,GAAAtB,GAAAsB,EAAA,EACAtB,IAAA,IAAAA,EAAAre,UACA2f,EAAAhd,QACA0b,EAAA46C,YAAA57D,IACAghB,EAAA46C,UAAA57D,KAGAghB,EAAAxhB,KAAAkB,KAAA4B,GAAAu5D,eAAA77D,GACAsiB,EAAA,GACAxiB,EAAAuf,aAAA2B,EAAAsB,EAAA,IAEAxiB,EAAAquC,YAAAntB,IAIAxhB,KAAAkB,KAAAsgB,MAEAxhB,MAAAkB,KAAA4B,GAAAu5D,eAAA77D,GACAF,EAAAquC,YAAA3uC,KAAAkB,QAIAi7D,EAAA99B,UAAA56B,SAAA,SAAA+8B,GACA,GAAA78B,GAAA3D,KAAA4jC,WACA,OAAApD,GAAA3X,GAAAllB,MAGAw4D,EAAA99B,UAAA9mB,SAAA,SAAA24B,GACAA,GAAAlwC,KAAAgK,SACAhK,KAAA4f,UAAA,GAGAu8C,EAAA99B,UAAA5xB,OAAA,WACAzM,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAA4f,WACA5f,KAAAkB,KAAAlC,KAAAgB,KAAA4jC,eAKAu4B,EAAA99B,UAAAkO,QAAA,WACA,MAAAvsC,MAAAc,MAAAd,KAAAc,MAAAJ,MAAA2H,QAGA8zD,GACGD,IAEHI,GAAA,SAAAltB,GACA,QAAAktB,KACAltB,EAAAjpC,MAAAnG,KAAAwE,WAWA,MARA83D,GAAAj+B,UAAAlyB,OAAA2tB,OAAAsV,KAAA/Q,WACAi+B,EAAAj+B,UAAA9Y,YAAA+2C,EAEAA,EAAAj+B,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACAssB,EAAA/Q,UAAAjnB,OAAA9Z,KAAA0C,KAAAM,EAAAwiB,GACA9iB,KAAAkB,KAAAq7D,aAAAv8D,KAAAkB,KAAAV,OAGA87D,GACGltB,IAEHE,GAAA,SAAAD,GACA,QAAAC,GAAAngC,GACAkgC,EAAA/xC,KAAA0C,KAAAmP,GAEAnP,KAAAO,KAAA4O,EAAArQ,SAAA0iB,EAEAxhB,KAAA+R,MAAA5C,EAAA4C,OAAA5C,EAAAkC,eAAAU,OAAA5C,EAAAlF,SAAAi2B,GAAA/wB,EAAAkC,gBACArR,KAAAiK,QAAAkF,EAAAlF,UAAAjK,KAAA+R,MAAA24B,gBAAA1qC,KAAA+R,MAAAmuB,GAAA/wB,EAAAkC,iBACArR,KAAAqR,eAAArR,KAAAiK,QAAAoH,eACArR,KAAA4G,QAAA5G,KAAAqR,eAAAzK,QAEA5G,KAAAgM,SAAA,KAEAhM,KAAAiK,QAAAygC,gBAAA1qC,KAAAO,MAAAP,KAEAA,KAAAQ,MAAA2O,EAAArQ,SAAAyxB,EAmDA,MAhDA+e,GAAAjR,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACAiR,EAAAjR,UAAA9Y,YAAA+pB,EAEAA,EAAAjR,UAAAn8B,KAAA,WACAlC,KAAAgM,UACAhM,KAAAgM,SAAA9J,MAGA,IAAApD,GAAAkB,KAAAlB,SAAAyxB,EACAlkB,EAAArM,KAAAiK,QAAApD,SAAAwF,SAEA,QAAAvN,EAEAuN,EAAAiK,QAAAtW,KAAAO,MAAAH,KAAA,OAGA,oBAAAtB,GAAA,CACA,GAAAywB,GAAAR,GAAAjwB,EACAuN,GAAAiK,QAAAtW,KAAAO,MAAAH,IAAAmvB,IAAA/uB,MAAA1B,OAGAkG,GAAAlG,IACAstC,GAAApsC,MAAA,IAIAsvC,EAAAjR,UAAAjnB,OAAA,aAEAk4B,EAAAjR,UAAA/mB,OAAA,WACAtX,KAAAgM,UAAAhM,KAAAgM,SAAAsL,SACAtX,KAAAssC,eAAAtsC,KAAAssC,cAAAh1B,SAEAtX,KAAAiK,QAAA6D,OACA9N,KAAAsd,KAAAhd,SAAAN,KAAAc,OAAAd,KAAAsd,KAAAvL,MAAAwM,UAIA+wB,EAAAjR,UAAA9mB,SAAA,aAEA+3B,EAAAjR,UAAA5xB,OAAA,WACAzM,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EACAl4C,KAAAgM,UAAAhM,KAAAgM,SAAAS,SACAzM,KAAAssC,eAAAtsC,KAAAssC,cAAA7/B,SACAzM,KAAA4f,UAAA5f,KAAAm1D,mBAIA7lB,GACGD,IA4CHmtB,GAAA,SAAAptB,GACA,QAAAotB,GAAArtD,GACA,GAAArQ,GAAAqQ,EAAArQ,QACAA,GAAAqG,IAAArG,EAAAqG,MAIAkD,SAAAvJ,EAAAqG,EAAA3E,OAAA,YAAA1B,GAAAqG,IACArG,EAAAqG,EAAA3E,MAAA1B,EAAAyxB,GAAA,IAGA6e,EAAA9xC,KAAA0C,KAAAmP,GAEAnP,KAAAmqC,OAAAjK,GAAAlgC,KAAAgH,QAAAhH,KAAAqR,gBAAA,YA8EA,MA3EAmrD,GAAAn+B,UAAAlyB,OAAA2tB,OAAAsV,KAAA/Q,WACAm+B,EAAAn+B,UAAA9Y,YAAAi3C,EAEAA,EAAAn+B,UAAAn8B,KAAA,WACA,IAAAlC,KAAAmqC,OAEA,WADAiF,GAAA/Q,UAAAn8B,KAAA5E,KAAA0C,KAMA,IAAAy8D,GAAAz8D,KAAA0qC,gBAAAhI,QACA,IAAA+5B,GAAAp0D,SAAArI,KAAAmqC,OAAAlJ,aAAA,UACA,GAAAp5B,GAAA7H,KAAAs/B,WAAAx3B,QAAA20D,EACAz8D,MAAAs/B,WAAA72B,OAAAZ,EAAA,SACA7H,MAAA0qC,gBAAAhI,SAGA0M,EAAA/Q,UAAAn8B,KAAA5E,KAAA0C,MACAA,KAAAmqC,OAAAh7B,QAAApH,KAAA/H,OAGAw8D,EAAAn+B,UAAAvpB,OAAA,WAEA,GAAAtU,GAAAR,KAAAihC,aAAA,QACAjhC,MAAAkB,MAAAlB,KAAAkB,KAAAV,YACAR,KAAAkB,KAAA4P,SAAAtQ,SAEA4uC,EAAA/Q,UAAAvpB,OAAAxX,KAAA0C,OAGAw8D,EAAAn+B,UAAA4C,aAAA,SAAA1gC,GACA,GAAA8wB,GAAArxB,KAAA0qC,gBAAAnqC,EACA,OAAA8wB,KAAAkR,WAAA,UAAAhiC,GAAAP,KAAAgM,SAAAhM,KAAAgM,SAAAugC,UAAAlkC,QAGAm0D,EAAAn+B,UAAAy9B,WAAA,WACA,GAAAn5B,GAAA3iC,KAAAihC,aAAA,QAEA,IAAA54B,SAAAs6B,IAAA3iC,KAAAmqC,OACA,QAGA,IAAAsD,GAAAztC,KAAAmqC,OAAAlJ,aAAA,QAEA,IAAAwM,GAAA9K,EACA,QAGA,IAAA3iC,KAAAmqC,OAAAlJ,aAAA,aAAAj8B,EAAAyoC,GAEA,IADA,GAAAxlC,GAAAwlC,EAAAhpC,OACAwD,KACA,GAAAwlC,EAAAxlC,IAAA06B,EACA,UAMA65B,EAAAn+B,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACAssB,EAAA/Q,UAAAjnB,OAAA9Z,KAAA0C,KAAAM,EAAAwiB,GAEA9iB,KAAA0qC,gBAAAlqC,QACAR,KAAAkB,KAAA4P,SAAAtQ,MAAAR,KAAAihC,aAAA,WAIAu7B,EAAAn+B,UAAA/mB,OAAA,WACA83B,EAAA/Q,UAAA/mB,OAAAha,KAAA0C,MAEAA,KAAAmqC,QACA5hC,EAAAvI,KAAAmqC,OAAAh7B,QAAAnP,OAIAw8D,GACGptB,IA+FHstB,GAAA,SAAAR,GACA,QAAAQ,KACAR,EAAA/1D,MAAAnG,KAAAwE,WA4JA,MAzJAk4D,GAAAr+B,UAAAlyB,OAAA2tB,OAAAoiC,KAAA79B,WACAq+B,EAAAr+B,UAAA9Y,YAAAm3C,EAEAA,EAAAr+B,UAAAn8B,KAAA,WAEAlC,KAAAo/B,QAAAp/B,KAAAlB,SAAAiL,CAGA,IACA4yD,GADA79D,EAAAkB,KAAAo/B,QAAAoN,GAAAxsC,KAAA4G,QAAA5G,KAAAo/B,QAAAp/B,KAAAqR,iBAAA,SAGAvS,KACAkB,KAAA48D,OAAA,EACA58D,KAAA68D,YAAA78D,KAAAlB,SAAAiL,EAAAjL,IAGAA,IACAo9D,EAAA79B,UAAAn8B,KAAA5E,KAAA0C,MACAA,KAAAc,QAAA67D,EAAA38D,KAAAc,MAAAJ,QAAA,gBAAAi8D,KAAA,gBAAAA,GAAA79D,UAAAkG,EAAA23D,EAAAj1C,KACAi1C,EAAA79D,UACAkB,KAAA4E,OAAA+3D,EAAA79D,SACA69D,EAAAzvB,GAAAltC,KAAAlB,SAAAiL,EAAA4yD,EAAA79D,SAAAkB,KAAA4G,UAEA5G,KAAA4E,OAAA+3D,EAAAj1C,EAEA1nB,KAAA68D,YAAA78D,KAAAlB,SAAAiL,EAAA4yD,EAAAj1C,IACM1nB,KAAAc,OAAA,gBAAAd,MAAAc,MAAAJ,QAAAV,KAAAo/B,QAGNp/B,KAAA68D,YAAA78D,KAAAc,MAAAJ,OAFAV,KAAA68D,YAAA78D,KAAAo/B,QAAAtgC,IAMAkB,KAAAgM,SAAA,GAAA+8B,KACAh3B,MAAA/R,KACAlB,SAAAkB,KAAA88D,kBACK56D,QAGLw6D,EAAAr+B,UAAAr0B,OAAA,WACA,MAAAhK,MAAAgM,SAAAhC,UAGA0yD,EAAAr+B,UAAAjuB,KAAA,SAAAD,GACA,MAAAnQ,MAAAgM,SAAAoE,KAAAD,IAGAusD,EAAAr+B,UAAA5rB,QAAA,SAAAtC,EAAAkC,GACArS,KAAAgM,SAAAyG,QAAAtC,EAAAkC,IAGAqqD,EAAAr+B,UAAAtrB,cAAA,SAAAxS,GACA,MAAAP,MAAAgM,SAAA+G,cAAAxS,IAGAm8D,EAAAr+B,UAAAxrB,kBAAA,SAAAtS,EAAA8R,GACArS,KAAAgM,SAAA6G,kBAAAtS,EAAA8R,IAGAqqD,EAAAr+B,UAAAw1B,UAAA,SAAAC,GACA,MAAA9zD,MAAAgM,SAAA6nD,UAAAC,IAGA4I,EAAAr+B,UAAAkB,mBAAA,WACA,GAAAnf,GAAApgB,IAEAA,MAAA88D,gBAAAz0D,OAGArI,KAAAo/B,UACAp/B,KAAA88D,gBAAAtwB,GAAAxsC,KAAA4G,QAAA5G,KAAAo/B,QAAAp/B,KAAAqR,iBAIArR,KAAA88D,kBACA98D,KAAA88D,gBAAAtwB,GAAAxsC,KAAA4G,QAAA5G,KAAAO,KAAAP,KAAAqR,iBAGArR,KAAA88D,kBACAr2D,EAAA,wCAAAzG,KAAA,UACAA,KAAA88D,oBAGA98D,KAAAgxB,YACAuT,GAAA,WAAkC,MAAAnkB,GAAApU,SAAA+yB,cAAA3e,EAAA08C,mBAElC98D,KAAAgM,SAAA+yB,cAAA/+B,KAAA88D,iBAGA98D,KAAA8U,UAGA4nD,EAAAr+B,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACA9iB,KAAAgM,SAAAoL,OAAA9W,EAAAwiB,IAGA45C,EAAAr+B,UAAAw+B,YAAA,SAAAt8D,EAAAzB,GACAkB,KAAAO,OAEAzB,GAAA,OAAAA,MAAA0tC,GAAAxsC,KAAA4G,QAAArG,EAAAP,KAAAqR,iBAEAvS,GACA2H,EAAA,wCAAAlG,EAAA,KAGAP,KAAA88D,gBAAAh+D,OAGA49D,EAAAr+B,UAAA56B,SAAA,SAAA+8B,GACA,MAAAxgC,MAAAgM,SAAAvI,SAAA+8B,IAGAk8B,EAAAr+B,UAAA/mB,OAAA,WACA4kD,EAAA79B,UAAA/mB,OAAAha,KAAA0C,MACAA,KAAAgM,SAAAsL,UAGAolD,EAAAr+B,UAAA9mB,SAAA,SAAA24B,GACAlwC,KAAAgM,SAAAuL,SAAA24B,IAGAwsB,EAAAr+B,UAAA5xB,OAAA,WACA,GAAA3N,EAEAkB,MAAAk4C,QACAl4C,KAAAk4C,OAAA,EAEAl4C,KAAA48D,QACA58D,KAAAc,QACAhC,EAAAkB,KAAAc,MAAAJ,OAGA5B,GAAA,gBAAAA,QAAAkB,KAAAO,MACAP,KAAA68D,YAAA/9D,GACAkB,KAAAgM,SAAA+yB,cAAA/+B,KAAA88D,kBACOh+D,GAAA,gBAAAA,KAAA,gBAAAA,aAAAkG,EAAAlG,EAAA4oB,KACP5oB,EAAA4oB,IAAA1nB,KAAA4E,QAAA9F,aAAAkB,KAAA4E,SACA9F,YACAkB,KAAA4E,OAAA9F,WACAA,EAAAouC,GAAAltC,KAAAO,KAAAzB,WAAAkB,KAAA4G,UAEA5G,KAAA4E,OAAA9F,EAAA4oB,EAEA1nB,KAAA68D,YAAA78D,KAAAO,KAAAzB,EAAA4oB,GACA1nB,KAAAgM,SAAA+yB,cAAA/+B,KAAA88D,mBAKA98D,KAAAgM,SAAAS,WAIAiwD,GACGR,IAcHa,GAAA,SAAA5tD,GACAnP,KAAAgH,OAAAmI,EAAA4C,MAAAV,eAIArR,KAAAqR,eAAArR,KACAA,KAAA+R,MAAA5C,EAAA4C,MACA/R,KAAA4G,QAAA5G,KAAAgH,OAAAJ,QAGA5G,KAAAuiB,OAAA,UAAApT,KAAAoT,OAAAviB,KAAAgH,OAAAhH,KAAAgH,OAAAub,OAAA,KAEAviB,KAAA4N,QAAA,KACA5N,KAAA4f,UAAA,EACA5f,KAAA0R,cAEA1R,KAAAlB,SAAAqQ,EAAArQ,SAEAkB,KAAAkW,SAAA/G,EAAA+G,SACAlW,KAAAgW,OAAA7G,EAAA6G,OAEAhW,KAAAg9D,kBAAA,KACAh9D,KAAAi9D,mBAAA,KAGAj9D,KAAAgF,SAAA,EAGA+3D,IAAA1+B,UAAAn8B,KAAA,SAAA0L,GACA,GAAAwS,GAAApgB,IAEAA,MAAA4N,SACA,IAAApN,GAAAoN,EAAAlN,KAGA,IAAAV,KAAAgF,UAAAxE,GAAA,CAEAR,KAAA0R,aAEA,QADAqC,GAAAvT,EAAAiE,OACAwD,EAAA,EAAoBA,EAAA8L,EAAS9L,GAAA,EAC7BmY,EAAA1O,WAAAzJ,GAAAmY,EAAA88C,gBAAAj1D,SAKA,IAAAxC,EAAAjF,GAAA,CAIA,GAHAR,KAAAgF,SAAA,EAGAhF,KAAAkW,SAAA,CACA,GAAAuY,GAAAzuB,KAAAkW,SAAAuC,MAAA,IACAzY,MAAAgW,OAAAyY,EAAA,GACAzuB,KAAAkW,SAAAuY,EAAA,GAGAzuB,KAAA0R,WAAAvF,OAAAC,KAAA5L,GAAAoO,IAAA,SAAA7J,EAAA8C,GACA,MAAAuY,GAAA88C,gBAAAn4D,EAAA8C,KAIA,MAAA7H,OAGA+8D,GAAA1+B,UAAAvpB,OAAA,WACA9U,KAAA+R,MAAA+C,UAGAioD,GAAA1+B,UAAA6+B,gBAAA,SAAAn4D,EAAA8C,GACA,GAAAmE,GAAA,GAAA+8B,KACAh3B,MAAA/R,KACAlB,SAAAkB,KAAAlB,UAIAkN,GAAAjH,MACAiH,EAAAnE,QACAmE,EAAA+J,aAAA,CAEA,IAAAjV,GAAAd,KAAA4N,QAAA0I,QAAAvR,EAQA,OALA/E,MAAA+R,MAAAjT,SAAAk1B,IACAhoB,EAAA4J,WACA5J,EAAA4J,QAAA5V,KAAA+R,MAAAjT,SAAAk1B,EAAA,GAAAxS,GAAA1gB,GAGAkL,EAAA9J,KAAApB,IAGAi8D,GAAA1+B,UAAA+0B,UAAA,WACApzD,KAAA0R,WAAA/M,QAAA,SAAAsD,GAA4C,MAAAA,GAAAmrD,eAG5C2J,GAAA1+B,UAAAr0B,OAAA,WACA,GAAAoZ,GAAAvgB,GAEA,OADA7C,MAAA0R,WAAA/M,QAAA,SAAAqH,GAAmD,MAAAoX,GAAAurB,YAAA3iC,EAAAhC,YACnDoZ,GAGA25C,GAAA1+B,UAAAjuB,KAAA,SAAAD,GACA,GAGAlI,GAHAmY,EAAApgB,KAEAuE,EAAAvE,KAAA0R,WAAAjN,MAGA,KAAAwD,EAAA,EAAeA,EAAA1D,EAAS0D,GAAA,GACxB,GAAAk1D,GAAA/8C,EAAA1O,WAAAzJ,GAAAmI,KAAAD,EACA,IAAAgtD,EAAA,MAAAA,KAIAJ,GAAA1+B,UAAA5rB,QAAA,SAAAtC,EAAAkC,GACA,GAGApK,GAHAmY,EAAApgB,KAEAuE,EAAAvE,KAAA0R,WAAAjN,MAGA,KAAAwD,EAAA,EAAeA,EAAA1D,EAAS0D,GAAA,EACxBmY,EAAA1O,WAAAzJ,GAAAwK,QAAAtC,EAAAkC,IAIA0qD,GAAA1+B,UAAAtrB,cAAA,SAAAxS,GACA,GAGA0H,GAHAmY,EAAApgB,KAEAuE,EAAAvE,KAAA0R,WAAAjN,MAGA,KAAAwD,EAAA,EAAeA,EAAA1D,EAAS0D,GAAA,GACxB,GAAAk1D,GAAA/8C,EAAA1O,WAAAzJ,GAAA8K,cAAAxS,EACA,IAAA48D,EAAA,MAAAA,KAIAJ,GAAA1+B,UAAAxrB,kBAAA,SAAAtS,EAAA8R,GACA,GAGApK,GAHAmY,EAAApgB,KAEAuE,EAAAvE,KAAA0R,WAAAjN,MAGA,KAAAwD,EAAA,EAAeA,EAAA1D,EAAS0D,GAAA,EACxBmY,EAAA1O,WAAAzJ,GAAA4K,kBAAAtS,EAAA8R,IAIA0qD,GAAA1+B,UAAA+R,aAAA,SAAAgtB,GACA,GAAAh9C,GAAApgB,IAEA,IAAAo9D,EAAAv1D,MAAA7H,KAAA0R,WAAAjN,OAAA,EACA,OAAAwD,GAAAm1D,EAAAv1D,MAAA,EAAsCI,EAAAmY,EAAA1O,WAAAjN,OAA8BwD,IAAA,CACpE,GAAA/G,GAAAkf,EAAA1O,WAAAzJ,GAAA4rD,WAAA,EACA,IAAA3yD,EAAA,MAAAA,GAIA,MAAAlB,MAAA+R,MAAAq+B,gBAGA2sB,GAAA1+B,UAAAw1B,UAAA,SAAAC,GACA,MAAA9zD,MAAA0R,WAAA,GAAA1R,KAAA0R,WAAA,GAAAmiD,UAAAC,GAAA,MAGAiJ,GAAA1+B,UAAAoa,UAAA,SAAArgC,GACA,GAAAgI,GAAApgB,IAEAA,MAAA4N,QAAAwK,EACApY,KAAA0R,WAAA/M,QAAA,SAAAqH,GACA,GAAAlL,GAAAsX,IAAA9B,QAAAtK,EAAAjH,KAAAiH,EAAAnE,OAAAQ,MACA2D,GAAA4B,QAAA9M,EACAsf,EAAArO,MAAAjT,SAAAk1B,IACAhoB,EAAA4J,WACA5J,EAAA4J,QAAAwK,EAAArO,MAAAjT,SAAAk1B,EAAA,GAAAxS,GAAA1gB,MAKAi8D,GAAA1+B,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GAGA9iB,KAAA0R,YACA1R,KAAA0R,WAAA/M,QAAA,SAAAqH,GAAoD,MAAAA,GAAAoL,OAAA9W,EAAAwiB,KAGpD9iB,KAAA4f,UAAA,GAGAm9C,GAAA1+B,UAAAziB,QAAA,SAAAb,GACA,GAAAqF,GAAApgB,IAEAA,MAAAg9D,oBAAAh9D,KAAAi9D,mBAAAj9D,KAAA0R,WAAAa,SAEAvS,KAAAg9D,oBAAAh9D,KAAAg9D,sBAEAh9D,KAAAg9D,kBAAAj1D,KAAAgT,EAEA,IAAArJ,KAEAqJ,GAAApW,QAAA,SAAAy5C,EAAAC,GACA,GAAAD,KAAA,GAEA,GAAApyC,GAAAoU,EAAA1O,WAAA2sC,EACA3sC,GAAA0sC,GAAApyC,EAEAoyC,IAAAC,GAAAryC,MAAAksC,OAAA,MAGAl4C,KAAA0R,aAEA1R,KAAA8U,UAGAioD,GAAA1+B,UAAAuc,SAAA,WACA56C,KAAA0R,WAAA/M,QAAA,SAAAsD,GAA4C,MAAAA,GAAA2yC,cAG5CmiB,GAAA1+B,UAAA56B,SAAA,SAAA+8B,GACA,MAAAxgC,MAAA0R,WACA1R,KAAA0R,WAAA9C,IAAA4xB,EAAA9oB,GAAAD,IAAA5H,KAAA,IACA,IAGAktD,GAAA1+B,UAAA/mB,OAAA,WAEA,MADAtX,MAAA0R,WAAA/M,QAAA2S,IACAtX,MAGA+8D,GAAA1+B,UAAA9mB,SAAA,SAAA24B,GACAlwC,KAAA0R,WAAA/M,QAAAurC,EAAA14B,GAAAD,IACAvX,KAAAg9D,mBAAAh9D,KAAAi9D,oBACAj9D,KAAAi9D,mBAAAt4D,QAAA,SAAAqH,GACAA,EAAA4T,WAAAswB,EAAA14B,GAAAxL,GAAAuL,GAAAvL,MAGAhM,KAAA4f,UAAA,GAIAm9C,GAAA1+B,UAAA5xB,OAAA,WAGA,GAAA2T,GAAApgB,IAEA,IAAAA,KAAAg9D,kBAEA,WADAh9D,MAAAq9D,mBAIA,KAAAr9D,KAAAs9D,SAAA,CACAt9D,KAAAs9D,UAAA,CAEA,IAGAC,GACAC,EAEAv1D,EANAzH,EAAAR,KAAA4N,QAAAlN,MACA+8D,EAAAz9D,KAAAgF,QAIA05B,GAAA,CAGA,IAAA1+B,KAAAgF,UAAAxE,GACAi9D,IACA/+B,GAAA,EACA1+B,KAAA0R,WAAAjN,OAAAjE,EAAAiE,SACA84D,EAAAv9D,KAAA0R,WAAAjJ,OAAAjI,EAAAiE,cAGI,IAAAgB,EAAAjF,KAAAi9D,EAMJ,IALA/+B,GAAA,EACA6+B,KACAC,KACAv1D,EAAAjI,KAAA0R,WAAAjN,OAEAwD,KAAA,CACA,GAAAy1D,GAAAt9C,EAAA1O,WAAAzJ,EACAy1D,GAAA34D,MAAAvE,GACAg9D,EAAAE,EAAA34D,MAAA,GAEAqb,EAAA1O,WAAAjJ,OAAAR,EAAA,GACAs1D,EAAAx1D,KAAA21D,IAKAh/B,IACA6+B,EAAAv9D,KAAA0R,WACA1R,KAAA0R,eAGA6rD,GACAA,EAAA54D,QAAA,SAAAqH,GACAA,EAAAsL,SACAtL,EAAAuL,UAAA,KAKAvX,KAAA0R,WAAA/M,QAAA8H,GAGA,IAMA2W,GACApX,EAPA2xD,EAAA34D,EAAAxE,GACAA,EAAAiE,OACAgB,EAAAjF,GACA2L,OAAAC,KAAA5L,GAAAiE,OACA,CAKA,IAAAk5D,EAAA39D,KAAA0R,WAAAjN,OAAA,CAIA,GAHA2e,EAAApjB,KAAA4f,SAAA/c,IAAA,KACAoF,EAAAjI,KAAA0R,WAAAjN,OAEAO,EAAAxE,GACA,KAAAyH,EAAAzH,EAAAiE,QACAuH,EAAAoU,EAAA88C,gBAAAj1D,KAEAmY,EAAA1O,WAAA3J,KAAAiE,GACAoU,EAAAR,UAAA5T,EAAAoL,OAAAgM,GAEAnb,GAAA,MAIA,IAAAxC,EAAAjF,GAAA,CAEA,GAAAR,KAAAkW,WAAAlW,KAAAgW,OAAA,CACA,GAAAyY,GAAAzuB,KAAAkW,SAAAuC,MAAA,IACAzY,MAAAgW,OAAAyY,EAAA,GACAzuB,KAAAkW,SAAAuY,EAAA,GAGAtiB,OAAAC,KAAA5L,GAAAmE,QAAA,SAAAI,GACAy4D,GAAAz4D,IAAAy4D,KACAxxD,EAAAoU,EAAA88C,gBAAAn4D,EAAAkD,GAEAmY,EAAA1O,WAAA3J,KAAAiE,GACAoU,EAAAR,UAAA5T,EAAAoL,OAAAgM,GAEAnb,GAAA,KAKA,GAAAjI,KAAA4f,SAAA,CACA,GAAAtc,GAAAtD,KAAAgH,OAAAmpC,iBACAxwB,EAAA3f,KAAAgH,OAAAopC,aAAApwC,KAAA+R,MAEAzO,GAAAuc,aAAAuD,EAAAzD,IAIA3f,KAAAs9D,UAAA,IAGAP,GAAA1+B,UAAAg/B,kBAAA,WACA,GAAAj9C,GAAApgB,KAEA+a,EAAA/a,KAAAg9D,kBAAA,EAGAh9D,MAAAg9D,kBAAAzqD,MAAA,GAAA5N,QAAA,SAAAi5D,GACA7iD,EAAApW,QAAA,SAAAy5C,EAAAC,GACAtjC,EAAAsjC,GAAAuf,EAAAxf,MAOA,IACAn2C,GADA1D,EAAAvE,KAAA4N,QAAAlN,MAAA+D,OAAAo5D,EAAA79D,KAAAi9D,mBAAAx4D,OAEAq5D,IAEA/iD,GAAApW,QAAA,SAAAy5C,EAAAC,GACA,GAAAryC,GAAAoU,EAAA68C,mBAAA5e,EAGA,IAFAj+B,EAAA68C,mBAAA5e,GAAA,KAEAD,KAAA,EACA0f,EAAAzf,GAAAryC,MACK,IAAAA,EAAAnE,QAAAu2C,EAAA,CACL,GAAAt9C,GAAAsf,EAAAxS,QAAA0I,QAAA8nC,EACApyC,GAAAnE,MAAAu2C,EACApyC,EAAA4B,QAAA9M,EACAsf,EAAArO,MAAAjT,SAAAk1B,IACAhoB,EAAA4J,WACA5J,EAAA4J,QAAAwK,EAAArO,MAAAjT,SAAAk1B,EAAA,GAAAxS,GAAA1gB,MAMAd,KAAAi9D,mBAAAt4D,QAAA,SAAAwY,EAAAlV,GACAkV,IAAA2gD,EAAA71D,GAAAkV,IAIA,IAAAiG,GAAApjB,KAAA4f,SAAA/c,IAAA,KACAS,EAAAtD,KAAA4f,SAAA5f,KAAAgH,OAAAmpC,iBAAA,KAEA4tB,EAAA,cAAAhjD,EAGA,KAFA9S,EAAA81D,EAAAhjD,EAAAI,WAAA,EAEWlT,EAAA1D,EAAS0D,IAAA,CACpB,GAAAkV,GAAAiD,EAAA1O,WAAAzJ,EAEAkV,IAAA4gD,EAEA39C,EAAAR,WACAk+C,EAAA71D,IAAAmb,EAAAurB,YAAAmvB,EAAA71D,GAAA+B,UACAoZ,EAAAQ,WAAAnf,QAAAnB,EAAAuc,aAAAuD,EAAAjG,EAAA02C,eAKA12C,IAAAiD,EAAA1O,WAAAzJ,GAAAmY,EAAA88C,gBAAAj1D,MAEAmY,EAAAR,WACAk+C,EAAA71D,IAAAmb,EAAAurB,YAAAmvB,EAAA71D,GAAA+B,UAEAmT,EAAAiG,EAAAurB,YAAAxxB,EAAAnT,UAEAoW,EAAA1O,WAAAzJ,GAAAmP,OAAAgM,KAMA,GAAApjB,KAAA4f,SAAA,CACA,IAAA3X,EAAA1D,EAAkB0D,EAAA41D,EAAY51D,IAC9B61D,EAAA71D,IAAAmb,EAAAurB,YAAAmvB,EAAA71D,GAAA+B,SAGAoZ,GAAAQ,WAAAnf,QACAnB,EAAAuc,aAAAuD,EAAApjB,KAAA+R,MAAAq+B,gBAKAjkC,OAAAC,KAAA0xD,GAAAn5D,QAAA,SAAA+J,GAAmD,MAAAovD,GAAApvD,GAAA4I,SAAAC,UAAA,KAEnDvX,KAAA0R,WAAA/M,QAAA8H,IAEAzM,KAAAg9D,kBAAA,KAEAh9D,KAAA46C,WAgBA,IAwZAzhC,IAxZA6kD,GAAA,SAAA9B,GACA,QAAA8B,GAAA7uD,GACA+sD,EAAA5+D,KAAA0C,KAAAmP,GAEAnP,KAAAi+D,YAAA9uD,EAAArQ,SAAA0iB,GAAA,KACAxhB,KAAAk+D,oBAAAl+D,KAAAi+D,YACAj+D,KAAAm+D,YAAA,IAAAhvD,EAAArQ,SAAAmV,EACAjU,KAAAgM,SAAA,KAqLA,MAlLAgyD,GAAA3/B,UAAAlyB,OAAA2tB,OAAAoiC,KAAA79B,WACA2/B,EAAA3/B,UAAA9Y,YAAAy4C,EAEAA,EAAA3/B,UAAAn8B,KAAA,WACAg6D,EAAA79B,UAAAn8B,KAAA5E,KAAA0C,MAEAA,KAAAm+D,cACAn+D,KAAAo+D,QAAAp+D,KAAAqR,eAAAG,MAAAxR,KAAAqR,eAAAG,MAAA1J,QAAA9H,MAAA;AACAA,KAAAo+D,QAAAC,YAAAr+D,MAIAA,KAAAc,OACAd,KAAAk4C,OAAA,EACAl4C,KAAAyM,WACKzM,KAAAi+D,aAAAj+D,KAAAi+D,cAAAloC,IAAA/1B,KAAAo+D,SAAAp+D,KAAAo+D,QAAAE,aACLt+D,KAAAgM,SAAA,GAAA+8B,KACAh3B,MAAA/R,KACAlB,SAAAkB,KAAAlB,SAAAyxB,IACMruB,SAIN87D,EAAA3/B,UAAAr0B,OAAA,WACA,MAAAhK,MAAAgM,SAAAhM,KAAAgM,SAAAhC,SAAAnH,KAGAm7D,EAAA3/B,UAAAjuB,KAAA,SAAAD,GACA,GAAAnQ,KAAAgM,SACA,MAAAhM,MAAAgM,SAAAoE,KAAAD,IAIA6tD,EAAA3/B,UAAA5rB,QAAA,SAAAtC,EAAAkC,GACArS,KAAAgM,UACAhM,KAAAgM,SAAAyG,QAAAtC,EAAAkC,IAIA2rD,EAAA3/B,UAAAtrB,cAAA,SAAAxS,GACA,GAAAP,KAAAgM,SACA,MAAAhM,MAAAgM,SAAA+G,cAAAxS,IAIAy9D,EAAA3/B,UAAAxrB,kBAAA,SAAAtS,EAAA8R,GACArS,KAAAgM,UACAhM,KAAAgM,SAAA6G,kBAAAtS,EAAA8R,IAIA2rD,EAAA3/B,UAAAw1B,UAAA,SAAAC,GACA,MAAA9zD,MAAAgM,UAAAhM,KAAAgM,SAAA6nD,UAAAC,IAGAkK,EAAA3/B,UAAAigC,SAAA,WACA,GAAAt+D,KAAAm+D,aAAAn+D,KAAAo+D,QAAAE,WAAA,QACA,IAAA99D,GAAAR,KAAAc,MAAAd,KAAAc,MAAAqV,OAAAnW,KAAAc,MAAAN,MAAAR,KAAAc,MAAAJ,MAAA2H,MACA,UAAA7H,GAAAR,KAAAk+D,sBAAA3wB,IAAAJ,GAAA3sC,KAGAw9D,EAAA3/B,UAAAoa,UAAA,SAAArgC,EAAAC,EAAAiiC,GACA4hB,EAAA79B,UAAAoa,UAAAn7C,KAAA0C,KAAAoY,EAAAC,EAAAiiC,IACAt6C,KAAAgM,UAAAhM,KAAAi+D,cAAA3nC,IAAAt2B,KAAAi+D,cAAAloC,IACA/1B,KAAAgM,SAAAysC,UAAArgC,EAAAC,IAKA2lD,EAAA3/B,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACA9iB,KAAA4f,UAAA,EACA5f,KAAAgM,UAAAhM,KAAAgM,SAAAoL,OAAA9W,EAAAwiB,IAGAk7C,EAAA3/B,UAAAziB,QAAA,SAAAb,GACA/a,KAAAgM,UAAAhM,KAAAi+D,cAAA3wB,IACAttC,KAAAgM,SAAA4P,QAAAb,IAIAijD,EAAA3/B,UAAA56B,SAAA,SAAA+8B,GACA,MAAAxgC,MAAAgM,SAAAhM,KAAAgM,SAAAvI,SAAA+8B,GAAA,IAGAw9B,EAAA3/B,UAAA/mB,OAAA,WACA4kD,EAAA79B,UAAA/mB,OAAAha,KAAA0C,MACAA,KAAAgM,UAAAhM,KAAAgM,SAAAsL,UAGA0mD,EAAA3/B,UAAA9mB,SAAA,SAAA24B,GACAlwC,KAAA4f,UAAA5f,KAAAgM,UAAAhM,KAAAgM,SAAAuL,SAAA24B,GACAlwC,KAAA4f,UAAA,GAGAo+C,EAAA3/B,UAAA5xB,OAAA,WACA,GAAAzM,KAAAk4C,QAEAl4C,KAAAgM,UAAAhM,KAAAi+D,cAAA3nC,IAAAt2B,KAAAi+D,cAAAloC,KACA/1B,KAAAgM,SAAA4B,QAAA5N,KAAAc,OAGAd,KAAAc,OAAAd,KAAAi+D,cAAAloC,IAAA,CAEA/1B,KAAAk4C,OAAA,CAEA,IAAA13C,GAAAR,KAAAc,MAAAd,KAAAc,MAAAqV,OAAAnW,KAAAc,MAAAN,MAAAR,KAAAc,MAAAJ,MAAA2H,OACAk2D,GAAAv+D,KAAAm+D,cAAAn+D,KAAAo+D,QAAAE,WACAE,EAAAx+D,KAAAi+D,WAGA,QAAAj+D,KAAAi+D,aAAA,OAAAj+D,KAAAk+D,sBAAAl+D,KAAAi+D,YAAA7wB,GAAA5sC,EAAAR,KAAAlB,SAAAmJ,IACAu2D,OAAAx+D,KAAAi+D,aAAAj+D,KAAAgM,WACAhM,KAAA4f,UACA5f,KAAAgM,SAAAsL,SAAAC,UAAA,GAGAvX,KAAAgM,SAAA,KAGA,IAAAyyD,GAEAC,EAAA1+D,KAAAi+D,cAAA3wB,IACAttC,KAAAi+D,cAAA/pC,IACAqqC,IAAAv+D,KAAAi+D,cAAAloC,IAAA/1B,KAAAs+D,WAAAt+D,KAAAs+D,WAEA,IAAAI,EACA,GAAA1+D,KAAAgM,SACAhM,KAAAgM,SAAAS,aAEA,IAAAzM,KAAAi+D,cAAA3wB,GACAmxB,EAAA,GAAA1B,KACAhrD,MAAA/R,KACAlB,SAAAkB,KAAAlB,SAAAyxB,EACAra,SAAAlW,KAAAlB,SAAAmJ,IACQ/F,KAAAlC,KAAAc,WACD,CAEP,GAAA8M,GAAA5N,KAAAi+D,cAAA3nC,IAAAt2B,KAAAi+D,cAAAloC,GAAA/1B,KAAAc,MAAA,IACA29D,GAAA,GAAA11B,KACAh3B,MAAA/R,KACAlB,SAAAkB,KAAAlB,SAAAyxB,IACQruB,KAAA0L,OAIR5N,MAAAgM,UAAAhM,KAAA4f,UACA5f,KAAAgM,SAAAsL,SAAAC,UAAA,GAGAvX,KAAAgM,SAAA,IAGA,IAAAyyD,EAAA,CACA,GAAAz+D,KAAA4f,SAAA,CACA,GAAAtc,GAAAtD,KAAAqR,eAAA8+B,iBACAxwB,EAAA3f,KAAAqR,eAAA++B,aAAApwC,KAEA,IAAA2f,EAAA,CACA,GAAAyD,GAAAvgB,GACA47D,GAAArnD,OAAAgM,GAIAzD,EAAArc,WAAAuc,aAAAuD,EAAAzD,OAEA8+C,GAAArnD,OAAA9T,GAIAtD,KAAAgM,SAAAyyD,EAGAz+D,KAAAq+D,cACAr+D,KAAAq+D,YAAAnmB,OAAA,EACAl4C,KAAAq+D,YAAA5xD,YAIAuxD,GACG9B,IASHyC,GAAA,SAAAvvB,GACA,QAAAuvB,GAAAxvD,GACAigC,EAAA9xC,KAAA0C,KAAAmP,GACAnP,KAAAmP,WAuFA,MApFAwvD,GAAAtgC,UAAAlyB,OAAA2tB,OAAAsV,KAAA/Q,WACAsgC,EAAAtgC,UAAA9Y,YAAAo5C,EAEAA,EAAAtgC,UAAAu9B,UAAA,SAAA16D,GACA,GAAAlB,KAAAkf,QAAA,CACA,GAAAkrB,GAAAF,GAAAhpC,EAEAkpC,GAAA3lC,OAAA,IACAzE,KAAAoqC,qBAKAu0B,EAAAtgC,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACAssB,EAAA/Q,UAAAjnB,OAAA9Z,KAAA0C,KAAAM,EAAAwiB,GACA9iB,KAAA4+D,MAKA,KAHA,GAAA19D,GAAAlB,KAAAkB,KAEA+G,EAAA/G,EAAAiO,QAAA1K,OACAwD,KACA/G,EAAAiO,QAAAlH,GAAA42D,gBAAA39D,EAAAiO,QAAAlH,GAAAy6B,QAGA1iC,MAAA4f,UAAA,GAGA++C,EAAAtgC,UAAAugC,KAAA,WACA,GAAAx+C,GAAApgB,KAEA8+D,EAAA9+D,KAAAkB,IAEA,IAAA49D,EAAA,CAEA,GAAA3vD,GAAAzG,EAAAo2D,EAAA3vD,QAEA,IAAAnP,KAAAoqC,gBAOA,MANAj7B,GAAAxK,QAAA,SAAAipB,GACAxN,EAAAgqB,gBAAAtiC,QAAA8lB,IAAA,EAAAA,EAAA8U,UAAA,EACA9U,EAAA8U,UAAA,IAEA1iC,KAAAkf,QAAAm7C,YAAAyE,cACA9+D,MAAAoqC,eAIA,IAAAqD,GAAAztC,KAAAihC,aAAA,SACA89B,EAAA/+D,KAAAihC,aAAA,WAIA,IAAA54B,SAAAolC,EAAA,CACA,GAAA2tB,EAEAjsD,GAAAxK,QAAA,SAAAipB,GACA,GAAA+U,GAAA/U,EAAA9c,SAAA8c,EAAA9c,SAAAtQ,MAAAotB,EAAAptB,MACAw+D,EAAAD,EAAAvxB,GAAAC,EAAA9K,GAAA8K,GAAA9K,CAEAq8B,KACA5D,GAAA,GAGAxtC,EAAA8U,SAAAs8B,IAGA5D,GAAA2D,GACA/+D,KAAAkf,SACAlf,KAAAkf,QAAA47C,kBAOA96D,MAAAkf,SACAlf,KAAAkf,QAAA47C,gBAIA6D,EAAAtgC,UAAA5xB,OAAA,WACA2iC,EAAA/Q,UAAA5xB,OAAAnP,KAAA0C,MACAA,KAAA4+D,QAGAD,GACGvvB,IAEH6vB,GAAA,SAAA3C,GACA,QAAA2C,GAAA9vD,GACA,GAAArQ,GAAAqQ,EAAArQ,QAEAqQ,GAAAosD,cAAA,EAEAe,EAAAh/D,KAAA0C,KAAAmP,GAGAnP,KAAA0qC,gBAAAlqC,QACA1B,EAAAyxB,GAAAia,IAAqC1rC,aACrCkB,KAAAs/B,WAAAv3B,KAAAgnC,IACAh9B,MAAA/R,KACAlB,UAAkB4oB,EAAAqK,GAAAxB,EAAAzxB,EAAAyxB,EAAA/O,EAAA,SAClBnQ,eAAArR,KAAAqR,kBAGArR,KAAAgM,SAAA,GAAA+8B,KAAoCh3B,MAAA/R,KAAAuiB,OAAA,KAAAzjB,WAAAyxB,KAyBpC,MApBA0uC,GAAA5gC,UAAAlyB,OAAA2tB,OAAAwiC,KAAAj+B,WACA4gC,EAAA5gC,UAAA9Y,YAAA05C,EAEAA,EAAA5gC,UAAAvpB,OAAA,WACA,GAAAsL,GAAApgB,IAEAA,MAAAk4C,QACAl4C,KAAAk4C,OAAA,EAEAl4C,KAAA4f,WAAA5f,KAAAkf,SAAAlf,KAAAgM,UACAgC,GAAAiV,aAAA,WACA7C,EAAA83B,OAAA,EACA93B,EAAAlf,KAAAV,MAAA4f,EAAApU,SAAAvI,aAIAzD,KAAAqR,eAAAyD,WAIAmqD,GACG3C,IAEHttB,GAAA,SAAAK,GACA,QAAAL,GAAA7/B,GACAkgC,EAAA/xC,KAAA0C,KAAAmP,GACAnP,KAAAoH,KAAAwoC,GAkEA,MA/DAZ,GAAA3Q,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACA2Q,EAAA3Q,UAAA9Y,YAAAypB,EAEAA,EAAA3Q,UAAAn8B,KAAA,aAIA8sC,EAAA3Q,UAAAr0B,OAAA,WACA,MAAA3G,GAAArD,KAAAkB,OAGA8tC,EAAA3Q,UAAAw1B,UAAA,WACA,MAAA7zD,MAAAkB,MAGA8tC,EAAA3Q,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACA,IAAAwhB,KAGA,GAFAtkC,KAAA4f,UAAA,EAEAkD,EAAA,CACA,GAAAtB,GAAAsB,EAAA,EACAtB,IAAA,IAAAA,EAAAre,UACA2f,EAAAhd,QACA0b,EAAA46C,YAAAp8D,KAAAlB,WACA0iB,EAAA46C,UAAAp8D,KAAAlB,YAGA0iB,EAAAxhB,KAAAkB,KAAA4B,GAAAu5D,eAAAr8D,KAAAlB,UACAgkB,EAAA,GACAxiB,EAAAuf,aAAA2B,EAAAsB,EAAA,IAEAxiB,EAAAquC,YAAAntB,IAIAxhB,KAAAkB,KAAAsgB,MAEAxhB,MAAAkB,KAAA4B,GAAAu5D,eAAAr8D,KAAAlB,UACAwB,EAAAquC,YAAA3uC,KAAAkB,OAIA8tC,EAAA3Q,UAAA56B,SAAA,SAAA+8B,GACA,MAAAA,GAAA3X,GAAA7oB,KAAAlB,UAAAkB,KAAAlB,UAGAkwC,EAAA3Q,UAAA/mB,OAAA,aAIA03B,EAAA3Q,UAAA9mB,SAAA,SAAA24B,GACAlwC,KAAA4f,UAAAswB,GAAAlwC,KAAAgK,SACAhK,KAAA4f,UAAA,GAGAovB,EAAA3Q,UAAA5xB,OAAA,aAIAuiC,EAAA3Q,UAAAkO,QAAA,WACA,MAAAvsC,MAAAlB,UAGAkwC,GACGK,GAIH,IAAAsE,GAEG,CACH,GAAAurB,OACAC,GAAA3wB,GAAA,OAAA/rB,KAEAtJ,IAAA,SAAAzU,GAGA,GAFAA,EAAA27B,GAAA37B,IAEAw6D,GAAAx6D,GACA,GAAA2D,SAAA82D,GAAAz6D,GACAw6D,GAAAx6D,SAQA,KAHA,GAAA06D,GAAA16D,EAAAV,OAAA,GAAAC,cAAAS,EAAA0gB,UAAA,GAEAnd,EAAAssC,GAAA9vC,OACAwD,KAAA,CACA,GAAAo3D,GAAA9qB,GAAAtsC,EACA,IAAAI,SAAA82D,GAAAE,EAAAD,GAAA,CACAF,GAAAx6D,GAAA26D,EAAAD,CACA,QAMA,MAAAF,IAAAx6D,QA5BAyU,IAAA,IAgCA,IAEAw0B,IAFA2xB,GAAAnmD,GAGAy0B,GAAA,QAEA,IAAA9qC,GAAA,CACA,GAAAy8D,GAEA,IAAA3xB,KAAA9qC,IACAy8D,GAAA,OAGA,KADA,GAAAzhB,IAAAvJ,GAAA9vC,OACAq5C,MAAA,CACA,GAAAuhB,IAAA9qB,GAAAuJ,GAGA,IAFAlQ,GAAAyxB,GAAA,SAEAzxB,KAAA9qC,IAAA,CACAy8D,GAAAF,EACA,QAKAh3D,SAAAk3D,IACAz8D,GAAA+0D,iBAAA0H,GAAA,mBAAA7xB,IACAA,OAGA,cAAA5qC,KACAA,GAAA+0D,iBAAA,WAAAhqB,IACA/qC,GAAA+0D,iBAAA,UAAA/pB,MAIA5qC,GAAA20D,iBAAA,WAAAhqB,IACA3qC,GAAA20D,iBAAA,OAAAhqB,IAEA3qC,GAAA20D,iBAAA,WAAA/pB,IACA5qC,GAAA20D,iBAAA,QAAA/pB,KAGAH,IAAA,GAgBA,GAgBA6xB,IAhBAxxB,GAAA,GAAA5lB,QAAA,QAAAmsB,GAAA1kC,KAAA,WAMAq+B,GAAA,GAAA9lB,QAAA,OAAAmsB,GAAA1kC,KAAA,gBAYA,IAAA8jC,GAEG,CACH,GAOA8rB,IACAC,GACAC,GACAC,GACAC,GACAC,GAZAC,GAAAvxB,GAAA,OAAA/rB,MACAu9C,GAAA,SAAA53D,GAAkC,MAAAA,IAElC63D,MACAC,KAUA73D,UAAA03D,GAAA3uB,YACAquB,GAAA,aACAC,GAAA,gBACAC,IAAA,GACIt3D,SAAA03D,GAAAI,kBACJV,GAAA,mBACAC,GAAA,sBACAC,IAAA,GAEAA,IAAA,EAGAF,KACAG,GAAAH,GAAA,WACAI,GAAAJ,GAAA,WACAK,GAAAL,GAAA,kBAGAD,GAAA,SAAA93C,EAAAvgB,EAAAgI,EAAAixD,EAAAj3D,GAIAL,WAAA,WAKA,QAAAu3D,KAAiCp2B,aAAAq2B,GAEjC,QAAAC,KACAC,GAAAC,IACA/4C,EAAAg5C,0BAAAL,GAEA34C,EAAA9gB,QAAA4F,KAAAkb,EAAAnnB,KAAA,OAAAmnB,EAAAxmB,KAAAwmB,EAAAyvB,SACAhuC,KAoBA,QAAAw3D,GAAAxgE,GACA,GAAA0H,GAAAu4D,EAAAt4D,QAAAu4B,GAAA0N,GAAA5tC,EAAAwjC,eAEA97B,MAAA,GACAu4D,EAAA33D,OAAAZ,EAAA,GAGAu4D,EAAA37D,SAKAwlC,aAAAq2B,GACAM,KAGA,QAAAA,KACAn+C,EAAAo9C,IAAAxnD,EAAAwoD,SACAp+C,EAAAq9C,IAAAznD,EAAA/I,SACAmT,EAAAm9C,IAAAvnD,EAAAyoD,OAEAp5C,EAAAxmB,KAAA62D,oBAAA2H,GAAAiB,GAAA,GAEAF,GAAA,EACAF,IAvDA,GAAAC,GACAC,EACAH,EAeAS,GAAAr5C,EAAAxmB,KAAA4gC,cAAA,IAAApa,EAAAxmB,KAAAwjC,QAGAjiB,EAAAiF,EAAAxmB,KAAAuhB,MACApK,GACAwoD,SAAAp+C,EAAAo9C,IACAiB,OAAAr+C,EAAAq9C,IACAxwD,SAAAmT,EAAAm9C,IAGAn9C,GAAAo9C,IAAAO,EAAAxxD,IAAA0wD,IAAA1wD,IAAAq/B,IAAAp+B,KAAA,KACA4S,EAAAq9C,IAAA7xB,GAAA9+B,EAAAC,QAAA,UACAqT,EAAAm9C,IAAAzwD,EAAAG,SAAA,QA6BAoY,EAAAxmB,KAAA22D,iBAAA6H,GAAAiB,GAAA,GAGAL,EAAAx3D,WAAA,WACAs3D,KACAQ,KACMzxD,EAAAG,UAAAH,EAAA46B,OAAA,OACNriB,EAAAs5C,wBAAAX,GAEAv3D,WAAA,WAUA,IATA,GACA2gC,GACAw3B,EACAp5D,EAEAnD,EACAm5C,EACAnuC,EAPAzH,EAAAm4D,EAAA37D,OAIAy8D,KAKAj5D,KACAvD,EAAA07D,EAAAn4D,GACAwhC,EAAAs3B,EAAAr8D,EAEAi7D,KAAAO,GAAAz2B,KACAhnB,EAAA68C,GAAA56D,IAAAyC,EAAAzC,GAIAu7D,GAAAx2B,KACAw3B,EAAAv5C,EAAAy5C,SAAAz8D,GAIAu7D,GAAAx2B,GAAA/hB,EAAAy5C,SAAAz8D,IAAAyC,EAAAzC,GACAw7D,GAAAz2B,IAAAw2B,GAAAx2B,GAGAy2B,GAAAz2B,KACAhnB,EAAA68C,GAAA56D,IAAAu8D,KAKAtB,KAAAO,GAAAz2B,KAEAphC,SAAA44D,IACAA,EAAAv5C,EAAAy5C,SAAAz8D,IAKAmD,EAAAu4D,EAAAt4D,QAAApD,GACAmD,KAAA,EACArB,EAAA,oIAA2JtF,KAAAwmB,EAAAxmB,OAE3Jk/D,EAAA33D,OAAAZ,EAAA,GAKAg2C,EAAA,UAAAtwC,KAAApG,EAAAzC,IAAA,GACAgL,EAAAzI,EAAA1B,WAAA07D,GAAA17D,WAAA4B,EAAAzC,MAAA,WAA8G,MAAAyC,GAAAzC,IAG9Gw8D,EAAAn5D,MACAxH,KAAA++D,GAAA56D,GACAgL,eACAmuC,WAMA,IAAAqjB,EAAAz8D,OAAA,CACA,GAAA2K,EAEA,iBAAAD,GAAAC,QACAA,EAAAsY,EAAA9gB,QAAAwI,OAAAD,EAAAC,QAEAA,IACA3I,EAAAa,GAAA6H,EAAAC,OAAA,WACAA,EAAA4wD,KAGA5wD,EADQ,kBAAAD,GAAAC,OACRD,EAAAC,OAEA4wD,GAGA,GAAAnkB,KACAvsC,SAAAH,EAAAG,SACAF,SACA7M,KAAA,SAAA4kB,GAEA,IADA,GAAAlf,GAAAi5D,EAAAz8D,OACAwD,KAAA,CACA,GAAAvD,GAAAw8D,EAAAj5D,EACAyf,GAAAxmB,KAAAuhB,MAAA/d,EAAAnE,MAAAmE,EAAAgL,aAAAyX,GAAAziB,EAAAm5C,SAGAtuC,SAAA,WACAixD,GAAA,EACAD,WAIAC,IAAA,CAGAJ,GAAA37D,SAGAijB,EAAAxmB,KAAA62D,oBAAA2H,GAAAiB,GAAA,GACAF,GAAA,EACAF,MAEM,IACDpxD,EAAA46B,OAAA,QArNLy1B,IAAA,IAyNA,IAAA4B,IAAA5B,GAaA6B,GAAAn+D,QAAAm+D,kBAAA3tB,GAAA2tB,kBACAvnB,GAAAtJ,GAAArnC,UAEAm4D,IACAC,GAAA,cACAC,GAAA,QACAC,GAAA,SAGApwB,GAAA,SAAAliC,GACAnP,KAAA+R,MAAA5C,EAAA4C,OAAA5C,EAAAkC,eAAAU,OAAAmuB,GAAA/wB,EAAAkC,gBACArR,KAAAiK,QAAAjK,KAAA+R,MAAA24B,gBAAA1qC,KAAA+R,MAAAmuB,GAAA/wB,EAAAkC,gBACArR,KAAA4G,QAAA5G,KAAA+R,MAAAnL,QACA5G,KAAAlB,SAAAqQ,EAAArQ,SACAkB,KAAAqR,eAAAlC,EAAAkC,eACArR,KAAAmP,UACAnP,KAAA0hE,cAGArwB,IAAAhT,UAAAsjC,aAAA,SAAAl/C,EAAAjiB,EAAA2O,GACA,GAAAiR,GAAApgB,IAEA,QAAAwE,UAAAC,OACA,SAAAuB,OAAA,iFAKA,KAAA2nC,GAEA,MADA3tC,MAAA4hE,SAAAn/C,EAAAjiB,GACAs5C,EAGA,IAAA3yC,EAsBA,OApBA,gBAAAsb,IACAtb,KACAA,EAAAsb,GAAAjiB,IAEA2G,EAAAsb,EAGAtT,EAAA3O,GAQA2O,IACA1I,EAAA,iMAAAzG,KAAAO,MACA4O,EAAAnP,MAGA,GAAAwwC,IAAA,SAAAnnC,GAEA,IAAA8F,EAAAG,SAGA,MAFA8Q,GAAAwhD,SAAAz6D,OACAkC,IAYA,KAPA,GAAA2qD,GAAA7nD,OAAAC,KAAAjF,GACAi5D,KAGAyB,EAAAR,GAAAjhD,EAAArO,MAAA7Q,MAEA+G,EAAA+rD,EAAAvvD,OACAwD,KAAA,CACA,GAAAvD,GAAAsvD,EAAA/rD,GACA+uB,EAAA6qC,EAAAvC,GAAA56D,GAEA,SAAAsyB,MAAA,GAGAA,GAAA7vB,EAAAzC,KACA07D,EAAAr4D,KAAArD,GAIA0b,EAAArO,MAAA7Q,KAAAuhB,MAAA68C,GAAA56D,IAAAsyB,GAMA,MAAAopC,GAAA37D,WAKA28D,IAAAhhD,EAAAjZ,EAAAgI,EAAAixD,EAAA/2D,OAJAA,QAQAgoC,GAAAhT,UAAAn8B,KAAA,WACA,GAAAke,GAAApgB,KAEAmP,EAAAnP,KAAAmP,OACAA,GAAArQ,WACA,OAAAqQ,EAAArQ,SAAA8oB,GAAA,MAAAzY,EAAArQ,SAAA8oB,IAAA5nB,KAAAiK,QAAA4xD,iBAAA77D,MACA,OAAAmP,EAAArQ,SAAA8oB,GAAA,MAAAzY,EAAArQ,SAAA8oB,IAAA5nB,KAAAiK,QAAA+xD,iBAAAh8D,MACAA,KAAAsU,UAAAgtD,GAAAnyD,EAAArQ,SAAA8oB,GAGA,IAAAhhB,GAAA5G,KAAA+R,MAAAnL,OAEA,IAAAuI,EAAA5O,KACAP,KAAAO,KAAA4O,EAAA5O,SACI,CACJ,GAAAA,GAAA4O,EAAArQ,SAAAyxB,CAGA,IAFA,gBAAAhwB,GAAAihB,IAAAjhB,IAAAihB,GAEA,gBAAAjhB,GAAA,CACA,GAAAyL,GAAA,GAAA+8B,KACAh3B,MAAA/R,KAAA+R,MACAjT,SAAAyB,EAAAihB,IACMtf,MAKN,IAHA3B,EAAAyL,EAAAvI,WACAuI,EAAAsL,SAEA,KAAA/W,EAEA,OAIAP,KAAAO,OAGA,GAAA4O,EAAA+hC,OACAlxC,KAAAkxC,OAAA/hC,EAAA+hC,WAEA,IAAA/hC,EAAArQ,SAAAyxB,EAAAprB,IAAAgK,EAAArQ,SAAAyxB,EAAAprB,EAAApB,EACA/D,KAAAkxC,OAAA/hC,EAAArQ,SAAAyxB,EAAAprB,MAGA,IAAAgK,EAAArQ,SAAAyxB,EAAAzhB,EAAA,CAGA,GAAA4uD,GAAA,GAAA30B,KACAh3B,MAAA/R,KAAA+R,MACAjT,SAAAqQ,EAAArQ,SAAAyxB,EAAAzhB,IACM5M,MAENlC,MAAAkxC,OAAAwsB,EAAA/E,cACA+E,EAAApmD,SAIA,kBAAAtX,MAAAO,MACAP,KAAA+sC,IAAA/sC,KAAAO,KACAP,KAAAO,KAAAP,KAAA+sC,IAAAxsC,MAEAP,KAAA+sC,IAAArmC,EAAA,cAAAE,EAAA5G,KAAAO,MAGAP,KAAA+sC,KACAtmC,EAAAa,GAAAtH,KAAAO,KAAA,eAAgEqG,YAIhEuI,EAAArQ,UAAAkB,KAAAlB,SAAAyxB,EAAAprB,GAAAnF,KAAAlB,SAAAyxB,EAAAprB,EAAApB,IACA/D,KAAA4/B,aACA5/B,KAAA6/B,OAAA7/B,KAAAlB,SAAAyxB,EAAAprB,EAAA4E,EAAA6E,IAAA,SAAA3B,EAAAhF,GACA,GAAA03B,GACA7+B,EAAA8Y,GAAAwG,EAAA/O,eAAApE,EAWA,OAVAnM,GAQMA,EAAAmX,SAAAmI,IAPNuf,EAAAvf,EAAA/O,eAAAlI,QAAA8D,EAAA,SAAAnM,GACAsf,EAAAyf,OAAA53B,GAAAnH,EACAyH,EAAA6X,EAAAwf,UAAAD,GACA7+B,EAAAmX,SAAAmI,KAGAA,EAAAwf,UAAA73B,KAAA43B,IAGA7+B,IAEAd,KAAA45D,OAAAnzC,GAAAzmB,KAAAlB,SAAAyxB,EAAAprB,EAAApB,EAAA/D,KAAAlB,SAAAyxB,EAAAprB,EAAA4E,EAAAtF,UAIA4sC,GAAAhT,UAAA+0B,UAAA,aAEA/hB,GAAAhT,UAAA8iC,SAAA,SAAA99B,GACA,GAAAw+B,GAAAR,GAAArhE,KAAA+R,MAAA7Q,KAEA,oBAAAmiC,GAAA,CACA,GAAA7iC,GAAAqhE,EAAAvC,GAAAj8B,GACA,eAAA7iC,EAAA,EAAAA,EAGA,IAAAwE,EAAAq+B,GACA,SAAAr9B,OAAA,kGAMA,KAHA,GAAA2c,MAEA1a,EAAAo7B,EAAA5+B,OACAwD,KAAA,CACA,GAAAvD,GAAA2+B,EAAAp7B,GACA65D,EAAAD,EAAAvC,GAAA56D,GAEA,SAAAo9D,MAAA,GACAn/C,EAAAje,GAAAo9D,EAGA,MAAAn/C,IAGA0uB,GAAAhT,UAAA0jC,cAAA,SAAA7wB,EAAAsB,GAiBA,MAhBA,gBAAAtB,GACAA,GAAc5hC,SAAA4hC,GAGd,gBAAAA,GAEAA,EADA,SAAAA,GACe5hC,SAAA,KACV,SAAA4hC,GACU5hC,SAAA,MAEAA,SAAA,KAEX4hC,IACJA,MAGA7sC,KAAuBmuC,EAAAtB,IAGvBG,GAAAhT,UAAAoa,UAAA,SAAArgC,EAAAC,GACA,GAAA6X,GAAAlwB,KAAA6/B,OAAA/3B,QAAAuQ,IACA6X,IAEA9X,EAAAD,GAAAnY,KAAAlB,SAAAyxB,EAAAprB,EAAA4E,EAAAmmB,GAAA9X,EAAAC,GACAD,IAAAC,IAEAA,EAAAsgC,WAAA34C,MACAA,KAAA6/B,OAAAp3B,OAAAynB,EAAA,EAAA9X,GACAA,KAAAshC,mBAAA15C,KAAA,WAGAqxC,GAAAhT,UAAA2iC,wBAAA,SAAArzD,GACA/F,EAAA5H,KAAA0hE,WAAA/zD,IAGA0jC,GAAAhT,UAAAjnB,OAAA,aAEAi6B,GAAAhT,UAAAujC,SAAA,SAAAn/C,EAAAjiB,GACA,mBAAAiiB,GACAziB,KAAA+R,MAAA7Q,KAAAuhB,MAAA68C,GAAA78C,IAAAjiB,MAGA,CACA,GAAAkE,EACA,KAAAA,IAAA+d,GACAA,EAAA9T,eAAAjK,KACA1E,KAAA+R,MAAA7Q,KAAAuhB,MAAA68C,GAAA56D,IAAA+d,EAAA/d,IAKA,MAAA1E,OAGAqxC,GAAAhT,UAAA/7B,MAAA,WACA,GAKA0/D,GALA5hD,EAAApgB,KAEAkB,EAAAlB,KAAAkB,KAAAlB,KAAAiK,QAAA/I,KACA+gE,EAAA/gE,EAAA+/B,aAAA,SAGAp7B,EAAA7F,KAAAkxC,MAqBA,IAhBAlxC,KAAAuP,SAAA,SAAA2yD,GACAF,IAIA5hD,EAAAshD,WAAA/8D,QAAA,SAAAgJ,GAAgD,MAAAA,QAChDu0D,GAAA9hD,EAAA+2B,SACAhJ,GAAAjtC,EAAA+gE,GAGA7hD,EAAAw3B,SAAAnX,OAAArgB,GAEA4hD,GAAA,KAIAhiE,KAAA+sC,IAEA,WADA/sC,MAAAuP,UAKA,IAAAvP,KAAA45D,OAAA,CACA,GAAAj8C,GAAA3d,KAAA6/B,OAAAjxB,IAAA,SAAA9N,GACA,GAAAA,EAEA,MAAAA,GAAAJ,OAEAmF,GAAA7F,KAAA45D,OAAAzzD,MAAAnG,KAAA4G,QAAA+W,GAGA,GAAAvU,GAAApJ,KAAA+sC,IAAA5mC,MAAAnG,KAAA4G,SAAA5G,MAAAyL,OAAA5F,GACAuD,MAAAG,KAAAvJ,KAAAuP,WAGA8hC,GAAAhT,UAAA56B,SAAA,WAAwD,UAExD4tC,GAAAhT,UAAA/mB,OAAA,WACAtX,KAAA4/B,WAAA5/B,KAAA4/B,UAAAj7B,QAAA2S,KAGA+5B,GAAAhT,UAAAqiC,0BAAA,SAAA/yD,GACApF,EAAAvI,KAAA0hE,WAAA/zD,IAGA0jC,GAAAhT,UAAA9mB,SAAA,aAEA85B,GAAAhT,UAAA5xB,OAAA,YAEA,IAEA6hC,IACAC,GAHAK,KAKA,KACAJ,GAAA,SAAAlsB,UAAA,MACG,MAAAkS,GACH8Z,IAAA,EAEAC,IACA4zB,OAAA,gCACAC,OAAA,+CACAC,OAAA,+CACAC,IAAA,yCACAC,QAAA,mCA6EA,GAAAC,IAAA,SAAAtG,GACA,QAAAsG,GAAArzD,GACA+sD,EAAA5+D,KAAA0C,KAAAmP,GAkGA,MA/FAqzD,GAAAnkC,UAAAlyB,OAAA2tB,OAAAoiC,KAAA79B,WACAmkC,EAAAnkC,UAAA9Y,YAAAi9C,EAEAA,EAAAnkC,UAAAr0B,OAAA,WACA,GAAAoZ,GAAAvgB,GAEA,OADA7C,MAAAwiC,MAAA79B,QAAA,SAAAzD,GAA2C,MAAAkiB,GAAAurB,YAAAztC,KAC3CkiB,GAGAo/C,EAAAnkC,UAAAjuB,KAAA,SAAAD,GACA,GAGAlI,GAHAmY,EAAApgB,KAEAuE,EAAAvE,KAAAwiC,MAAA/9B,MAGA,KAAAwD,EAAA,EAAgBA,EAAA1D,EAAS0D,GAAA,GACzB,GAAA/G,GAAAkf,EAAAoiB,MAAAv6B,EAEA,QAAA/G,EAAAiC,SAAA,CAEA,GAAA4wC,GAAA7yC,EAAAiP,GAAA,MAAAjP,EAEA,IAAAuhE,GAAAvhE,EAAAkC,cAAA+M,EACA,IAAAsyD,EAAA,MAAAA,IAGA,aAGAD,EAAAnkC,UAAA5rB,QAAA,SAAAtC,EAAAkC,GACA,GAGApK,GAHAmY,EAAApgB,KAEAuE,EAAAvE,KAAAwiC,MAAA/9B,MAGA,KAAAwD,EAAA,EAAgBA,EAAA1D,EAAS0D,GAAA,GACzB,GAAA/G,GAAAkf,EAAAoiB,MAAAv6B,EAEA,QAAA/G,EAAAiC,SAAA,CAEAkP,EAAAxE,KAAA3M,IAAAmR,EAAAxD,IAAA3N,EAEA,IAAAwhE,GAAAxhE,EAAA4zC,iBAAA3kC,EACA,IAAAuyD,EAAA,CACA,GACAr3D,GADAs3D,EAAAD,EAAAj+D,MAGA,KAAA4G,EAAA,EAAkBA,EAAAs3D,EAAct3D,GAAA,EAChCgH,EAAAxD,IAAA6zD,EAAAr3D,QAMAm3D,EAAAnkC,UAAAtrB,cAAA,WACA,aAGAyvD,EAAAnkC,UAAAw1B,UAAA,WACA,MAAA7zD,MAAAwiC,MAAA,IAGAggC,EAAAnkC,UAAAjnB,OAAA,SAAA9W,GACA,GAAAgoB,GAAAtoB,KAAAc,MAAAd,KAAAc,MAAAJ,MAAA,EACAV,MAAAwiC,MAAA4L,GAAA9lB,EAAAtoB,KAAAqR,eAAA8+B,iBAAA7vC,GACAN,KAAA4f,UAAA,GAGA4iD,EAAAnkC,UAAA56B,SAAA,WACA,MAAAzD,MAAAc,OAAA,MAAAd,KAAAc,MAAAJ,MAAA2nB,GAAA,GAAAroB,KAAAc,MAAAJ,OAAA,IAGA8hE,EAAAnkC,UAAA9mB,SAAA,WACAvX,KAAAwiC,OAAAxiC,KAAAwiC,MAAA79B,QAAA,SAAAzD,GAA6D,MAAAmC,GAAAnC,KAC7DlB,KAAA4f,UAAA,GAGA4iD,EAAAnkC,UAAA5xB,OAAA,WACA,GAAAzM,KAAA4f,UAAA5f,KAAAk4C,MAAA,CACAl4C,KAAAk4C,OAAA,EAEAl4C,KAAAuX,UACA,IAAA6L,GAAAvgB,GACA7C,MAAAoX,OAAAgM,EAEA,IAAA9f,GAAAtD,KAAAqR,eAAA8+B,iBACAxwB,EAAA3f,KAAAqR,eAAA++B,aAAApwC,KAEAsD,GAAAuc,aAAAuD,EAAAzD,OAGA3f,MAAAk4C,OAAA,GAIAsqB,GACGtG,IAEH0G,GAAA,SAAAvzB,GACA,QAAAuzB,GAAAzzD,GACAkgC,EAAA/xC,KAAA0C,KAAAmP,GAEAnP,KAAAiT,UAAA9D,EAAAkC,eAAAzK,QACA5G,KAAA6Q,UAAA7Q,KAAAiT,UAAApC,UAEA7Q,KAAAogC,kBAAAjxB,EAAAkC,eACArR,KAAAqR,eAAArR,KAAA6Q,UAAAQ,eAGArR,KAAAO,KAAA4O,EAAArQ,SAAA0iB,GAAA,GAiGA,MA9FAohD,GAAAvkC,UAAAlyB,OAAA2tB,OAAAuV,KAAAhR,WACAukC,EAAAvkC,UAAA9Y,YAAAq9C,EAEAA,EAAAvkC,UAAAn8B,KAAA,WACA,GAAA3B,GAAAP,KAAAO,MAEAP,KAAA6Q,UAAAioD,SAAAv4D,KAAAP,KAAA6Q,UAAAioD,SAAAv4D,QAAAwH,KAAA/H,KAGA,IAAAlB,GAAAkB,KAAAiT,UAAA8lD,gBAAAx4D,GAAA,UAEA,iBAAAzB,KACAA,EAAAorB,GAAAprB,GAAA4oB,GAGA5oB,IACA0H,EAAA,wCAAAjG,EAAA,KAA6EqG,QAAA5G,KAAA4G,UAC7E9H,MAGAkB,KAAAgM,SAAA,GAAA+8B,KACAh3B,MAAA/R,KACA4G,QAAA5G,KAAAiT,UAAAjM,OACAlI,aACKoD,QAGL0gE,EAAAvkC,UAAAvpB,OAAA,WACA9U,KAAAk4C,QACAl4C,KAAAogC,kBAAAtrB,SACA9U,KAAAk4C,OAAA,IAIA0qB,EAAAvkC,UAAAr0B,OAAA,WACA,MAAAhK,MAAAgM,SAAAhC,UAGA44D,EAAAvkC,UAAAjuB,KAAA,SAAAD,GACA,MAAAnQ,MAAAgM,SAAAoE,KAAAD,IAGAyyD,EAAAvkC,UAAA5rB,QAAA,SAAAtC,EAAAsyD,GACAziE,KAAAgM,SAAAyG,QAAAtC,EAAAsyD,IAGAG,EAAAvkC,UAAAtrB,cAAA,SAAAxS,GACA,MAAAP,MAAAgM,SAAA+G,cAAAxS,IAGAqiE,EAAAvkC,UAAAxrB,kBAAA,SAAAtS,EAAAkiE,GACAziE,KAAAgM,SAAA6G,kBAAAtS,EAAAkiE,IAGAG,EAAAvkC,UAAA+R,aAAA,WACA,MAAApwC,MAAAogC,kBAAAgQ,aAAApwC,OAGA4iE,EAAAvkC,UAAAw1B,UAAA,SAAAC,GACA,MAAA9zD,MAAAgM,SAAA6nD,UAAAC,IAGA8O,EAAAvkC,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACA,MAAA9iB,MAAAgM,SAAAoL,OAAA9W,EAAAwiB,IAGA8/C,EAAAvkC,UAAAw+B,YAAA,SAAAt8D,GACA,GAAAzB,GAAAkB,KAAAqR,eAAAzK,QAAAyyB,SAAA94B,EAEA,iBAAAzB,KACAA,EAAAorB,GAAAprB,GAAA4oB,GAGA1nB,KAAA88D,gBAAAh+D,OAGA8jE,EAAAvkC,UAAA56B,SAAA,SAAA+8B,GACA,MAAAxgC,MAAAgM,SAAAvI,SAAA+8B,IAGAoiC,EAAAvkC,UAAA/mB,OAAA,WACAtX,KAAAgM,SAAAsL,SACA/O,EAAAvI,KAAA6Q,UAAAioD,SAAA94D,KAAAO,MAAAP,OAGA4iE,EAAAvkC,UAAA9mB,SAAA,SAAA24B,GACAlwC,KAAAgM,SAAAuL,SAAA24B,IAGA0yB,EAAAvkC,UAAA5xB,OAAA,WACAzM,KAAAk4C,OAAA,EACAl4C,KAAAgM,SAAAS,UAGAm2D,GACGvzB,IAmCHG,KACAA,IAAAzb,IAAA6/B,GACApkB,GAAAhW,IAAAugC,GACAvqB,GAAA/a,IAAA0nC,GACA3sB,GAAA1b,IAAA4oC,GACAltB,GAAAvb,IAAA+pC,GACAxuB,GAAAnc,IAAAmvC,GACAhzB,GAAA3a,IAAA+tC,GAEApzB,GAAAzd,IAAAwd,GACAC,GAAAoQ,IAAA0V,GACA9lB,GAAAhgB,IAAA8pC,GACA9pB,GAAA7f,IAAA0oC,GACA7oB,GAAA/f,IAAA4hB,EAEA,IAAAlC,KACA0zB,QAAA9I,GACA+I,KAAA7G,GACAj5D,MAAAs5D,GACAxgD,OAAA0gD,GACAryB,OAAAw0B,GACAhM,SAAAsM,IA6EAl2B,GAAA,SAAA55B,GACAnP,KAAA+R,MAAA5C,EAAA4C,MAEA/R,KAAAmW,QAAAhH,EAAA4C,MAAAV,eACArR,KAAAgH,OAAAhH,KAAAmW,OAAA,KAAAnW,KAAA+R,MAAAV,eACArR,KAAA4G,QAAAuI,EAAAvI,UAAA5G,KAAAmW,OAAAhH,EAAA4C,MAAA/R,KAAAgH,OAAAJ,SAEA5G,KAAAuW,gBAAAvW,KAAAmW,QAAAnW,KAAA4G,QAAAiK,UAAA7Q,KAAA4G,QAAAiK,UAAAQ,eAAA,KAEArR,KAAA4N,QAAA,KACA5N,KAAA4f,UAAA,EAGA5f,KAAAuiB,OAAA,UAAApT,KAAAoT,OAAAviB,KAAAgH,OAAAhH,KAAAgH,OAAAub,OAAA,KAEAviB,KAAA4/B,aAEA5/B,KAAAk4C,OAAA,EACAl4C,KAAA+iE,UAAA/iE,KAAAgjE,YAAA,EAEAhjE,KAAAlB,SAAAqQ,EAAArQ,aACAkB,KAAAijE,cAGAl6B,IAAA1K,UAAAn8B,KAAA,SAAA0L,GAUA,MATA5N,MAAA4N,UACA5N,KAAAwR,MAAA7M,QAAAmS,IACA9W,KAAA8N,OAAA,EAKA9N,KAAAk4C,OAAAl4C,KAAAyM,SAEAzM,MAGA+oC,GAAA1K,UAAAvpB,OAAA,WACA9U,KAAA+iE,UAAA/iE,KAAAgjE,YAAA,EAEAhjE,KAAAk4C,QACAl4C,KAAAk4C,OAAA,EAEAl4C,KAAAmW,OACAnW,KAAA4G,QAAAiK,UACA7Q,KAAA4G,QAAAiK,UAAAiE,SACM9U,KAAA8N,OACNE,GAAAupC,YAAAv3C,MAGAA,KAAA+R,MAAA+C,WAKAi0B,GAAA1K,UAAA4kC,YAAA,WAEA,GAAA7iD,GAAApgB,KAEA+T,EAAA/T,KAAAlB,SAAA2F,MACAzE,MAAAwR,QACA,QAAAvJ,GAAA,EAAmBA,EAAA8L,EAAS9L,IAC5BmY,EAAA5O,MAAAvJ,GAAA8mC,IAAkC19B,eAAA+O,EAAAthB,SAAAshB,EAAAthB,SAAAmJ,GAAAJ,MAAAI,KAIlC8gC,GAAA1K,UAAA+0B,UAAA,WACApzD,KAAAwR,MAAA7M,QAAA,SAAAsD,GAAuC,MAAAA,GAAAmrD,eAGvCrqB,GAAA1K,UAAAr0B,OAAA,WACA,GAAAoZ,GAAAvgB,GAEA,OADA7C,MAAAwR,MAAA7M,QAAA,SAAAmN,GAA0C,MAAAsR,GAAAurB,YAAA78B,EAAA9H,YAC1CoZ,GAGA2lB,GAAA1K,UAAAjuB,KAAA,SAAAD,GACA,GAGAlI,GAHAmY,EAAApgB,KAEAuE,EAAAvE,KAAAwR,MAAA/M,MAGA,KAAAwD,EAAA,EAAeA,EAAA1D,EAAS0D,GAAA,GACxB,GAAAk1D,GAAA/8C,EAAA5O,MAAAvJ,GAAAmI,KAAAD,EACA,IAAAgtD,EAAA,MAAAA,KAIAp0B,GAAA1K,UAAA5rB,QAAA,SAAAtC,EAAAkC,GACA,GAAA+N,GAAApgB,IAEA,IAAAA,KAAAwR,MAAA,CACA,GACAvJ,GADA1D,EAAAvE,KAAAwR,MAAA/M,MAGA,KAAAwD,EAAA,EAAgBA,EAAA1D,EAAS0D,GAAA,GACzB,GAAA6J,GAAAsO,EAAA5O,MAAAvJ,EAEA6J,GAAAW,SACAX,EAAAW,QAAAtC,EAAAkC,IAKA,MAAAA,IAGA02B,GAAA1K,UAAAtrB,cAAA,SAAAxS,GACA,GAGA0H,GAHAmY,EAAApgB,KAEAuE,EAAAvE,KAAAwR,MAAA/M,MAGA,KAAAwD,EAAA,EAAeA,EAAA1D,EAAS0D,GAAA,GACxB,GAAAk1D,GAAA/8C,EAAA5O,MAAAvJ,GAAA8K,cAAAxS,EACA,IAAA48D,EAAA,MAAAA,KAIAp0B,GAAA1K,UAAAxrB,kBAAA,SAAAtS,EAAA8R,GACA,GAAA+N,GAAApgB,IAEA,IAAAA,KAAAwR,MAAA,CACA,GACAvJ,GADA1D,EAAAvE,KAAAwR,MAAA/M,MAGA,KAAAwD,EAAA,EAAgBA,EAAA1D,EAAS0D,GAAA,GACzB,GAAA6J,GAAAsO,EAAA5O,MAAAvJ,EAEA6J,GAAAe,mBACAf,EAAAe,kBAAAtS,EAAA8R,IAKA,MAAAA,IAGA02B,GAAA1K,UAAAvoB,YAAA,WAEA,IADA,GAAA9J,GAAAhM,KACAgM,MAAA4B,SAAA5B,IAAAhF,MACA,OAAAgF,GACAA,EAAA4B,QADA5N,KAAA4G,QAAAyF,WAIA08B,GAAA1K,UAAA+R,aAAA,SAAAt+B,GAEA,GAAAsO,GAAApgB,IAEA,IAAA8R,EACA,OAAA7J,GAAA6J,EAAAjK,MAAA,EAAiCI,EAAAmY,EAAA5O,MAAA/M,OAAyBwD,IAC1D,GAAAmY,EAAA5O,MAAAvJ,GAAA,CAEA,GAAA/G,GAAAkf,EAAA5O,MAAAvJ,GAAA4rD,WAAA,EACA,IAAA3yD,EAAA,MAAAA,GAMA,MAAAlB,MAAAmW,OACAnW,KAAA4G,QAAAiK,UACA7Q,KAAA4G,QAAAiK,UAAAQ,eAAA++B,aAAApwC,KAAA4G,QAAAiK,WAKA,KAGA7Q,KAAAgH,OAAAhH,KAAA+R,MAAAq+B,aAAApwC,MAAA,QAGA+oC,GAAA1K,UAAA8R,eAAA,WACA,GAAAnkC,GAAAhM,IAEA,IACA,GAAAgM,EAAA+F,MAAA3K,OAAAuxB,GACA,MAAA3sB,GAAA+F,MAAA7Q,IAGA,IAAA8K,EAAAmK,SAAAnK,EAAApF,QAAAiK,UACA,MAAA7E,GAAApF,QAAA/H,EAIAmN,GADAA,EAAA+F,MAAA3K,OAAAytB,GACA7oB,EAAA+F,MAAAquB,kBAEAp0B,EAAAuK,iBAAAvK,EAAAhF,aAEIgF,EAEJ,UAAAhG,OAAA,+BAGA+iC,GAAA1K,UAAAnkB,sBAAA,WAGA,IAFA,GAAAlO,GAAAhM,MAEAgM,EAAAhF,QAAAgF,EAAAuK,mBAAAvK,EAAA+J,aACA/J,IAAAhF,QAAAgF,EAAAuK,eAGA,OAAAvK,IAGA+8B,GAAA1K,UAAAw1B,UAAA,SAAAC,GAIA,OADA5yD,GAFAkf,EAAApgB,KAGAiI,EAAA,EAAmBA,EAAAmY,EAAA5O,MAAA/M,OAAyBwD,IAG5C,GAFA/G,EAAAkf,EAAA5O,MAAAvJ,GAAA4rD,WAAA,GAGA,MAAA3yD,EAIA,OAAA4yD,GAAA,KAEA9zD,KAAAgH,OAAAopC,aAAApwC,KAAA+R,QAKAg3B,GAAA1K,UAAAs6B,YAAA,WACA,GAAA34D,KAAA+iE,UAAA,CACA,GAAAplD,MACA/Y,EAAA6qC,GAAAzvC,KAAAwR,MAAAmM,EAAA3d,KAAA4G,QAAAshC,OACA3Y,EAAAR,GAAA,IAAAnqB,EAAA,IAAA+Y,EAEA3d,MAAAkjE,SAAA3zC,EACAA,EAAA/uB,OACAR,KAAAyD,YAEAzD,KAAA+iE,WAAA,EAGA,MAAA/iE,MAAAkjE,UAGAn6B,GAAA1K,UAAAoa,UAAA,SAAArgC,GACApY,KAAA4N,QAAAwK,GAGA2wB,GAAA1K,UAAAjnB,OAAA,SAAA9W,EAAAwiB,GACA,GAAA9iB,KAAA4f,SAAA,SAAA5Z,OAAA,gCACAhG,MAAA4f,UAAA,EAEA5f,KAAAwR,MAAA7M,QAAA,SAAAmN,GAA0C,MAAAA,GAAAsF,OAAA9W,EAAAwiB,MAG1CimB,GAAA1K,UAAAU,cAAA,SAAAjgC,GACA,GAAAqkE,GAAAnjE,KAAA8N,MACAs1D,EAAApjE,KAAA4f,QAYA,IARAujD,IACAC,GAAApjE,KAAAuX,UAAA,GACAvX,KAAAsX,UAGAtX,KAAAlB,WACAkB,KAAAijE,cAEAE,IACAnjE,KAAAkC,KAAAlC,KAAA4N,SAEAw1D,GAAA,CACA,GAAA9/D,GAAAtD,KAAAmwC,iBACAxwB,EAAA3f,KAAAowC,cAEA,IAAAzwB,EAAA,CACA,GAAAyD,GAAAvgB,GACA7C,MAAAoX,OAAAgM,GACA9f,EAAAuc,aAAAuD,EAAAzD,OAEA3f,MAAAoX,OAAA9T,KAMAylC,GAAA1K,UAAAl1B,QAAA,SAAArK,EAAA+J,GACA,IAAA7I,KAAA4N,SAAA5N,KAAAgH,OAAAmC,QACA,MAAAnJ,MAAAgH,OAAAmC,QAAArK,EAAA+J,EAGA,IAAA82B,GAAA,GAAAod,IAAA/8C,KAAAlB,EAAA+J,EAGA,OAFA7I,MAAA4/B,UAAA73B,KAAA43B,GAEAA,GAGAoJ,GAAA1K,UAAAuc,SAAA,WACA56C,KAAAwR,MAAA7M,QAAA,SAAAsD,GAAuC,MAAAA,GAAA2yC,cAGvC7R,GAAA1K,UAAAglC,OAAA,WACA,MAAArjE,MAAAyD,YAGAslC,GAAA1K,UAAA56B,SAAA,SAAA+8B,GACA,MAAAxgC,MAAAwR,MAAA5C,IAAA4xB,EAAA9oB,GAAAD,IAAA5H,KAAA,KAGAk5B,GAAA1K,UAAA/mB,OAAA,WAIA,MAHAtX,MAAAwR,MAAA7M,QAAA2S,IACAtX,KAAA8N,OAAA,EAEA9N,MAGA+oC,GAAA1K,UAAA9mB,SAAA,SAAA24B,GACAlwC,KAAAwR,MAAA7M,QAAAurC,EAAAF,GAAAz4B,IACAvX,KAAA4f,UAAA,GAGAmpB,GAAA1K,UAAA5xB,OAAA,WACAzM,KAAAk4C,QACAl4C,KAAAs9D,SAKKt9D,KAAAmW,QACLnI,GAAAwpC,kBAAAx3C,OALAA,KAAAk4C,OAAA,EACAl4C,KAAAs9D,UAAA,EACAt9D,KAAAwR,MAAA7M,QAAA8H,IACAzM,KAAAs9D,UAAA,KAOAv0B,GAAA1K,UAAAkO,QAAA,WACA,OAAAvsC,KAAAwR,MAAA/M,OACA,MAAAzE,MAAAwR,MAAA,GAAA+6B,SAGA,IAAAvsC,KAAAgjE,WAAA,CACA,GAAArlD,MACA/Y,EAAA6qC,GAAAzvC,KAAAwR,MAAAmM,EAAA3d,KAAA4G,QAAAshC,OACA3Y,EAAAR,GAAAnqB,EAAA+Y,EAEA3d,MAAAQ,MAAA+uB,EACAA,EAAA/uB,MACAR,KAAAyD,WAEAzD,KAAAgjE,YAAA,EAGA,MAAAhjE,MAAAQ,MA8CA,IAAA8iE,IAAAjoD,GAAA,WAAAC,KAQAioD,GAAAloD,GAAA,SAAAC,KAEAkoD,GAAAnoD,GAAA,QAAAC,KAEAmoD,GAAApoD,GAAA,UAAAC,KAMAm1B,GAAA,GAAAmF,IAAA,YA+FAlE,GAAA,GAAAkE,IAAA,YAuBA8tB,GAAAroD,GAAA,WAAAC,KAgBAi3B,IACA1jC,IAAAI,EACAU,QAAAC,GACA5F,OAAA8F,GACAM,KAAAF,GACAuC,QAAAP,GACAW,kBAAAF,GACAI,cAAAD,GACAI,cAAAF,GACAI,WAAAD,GACA3G,KAAA+I,GACA7U,IAAA4Z,GACAmF,eACAkkD,OAAAjkD,GACApC,KAAA2C,GACA5D,MAAAC,GACA6D,WACAW,eACAG,eAGA7L,IAAAkM,GACArhB,GAAAshB,GACA67B,KAAAz7B,GACAxQ,IAAAmtC,GACAv2C,KAAAw2C,GACAnnC,OAAAkM,GACAob,MAAAF,GACAgB,gBACAT,cAAAkR,GACApyB,QAAAylD,GACAljE,IAAAiwC,GACAvqC,MAAAy9D,GACAnlD,KAAAolD,GACA/6D,OAAAg7D,GACAnlD,SAAAgyB,GACAj5B,SAAAk5B,GACA5vC,OAAA+vC,GACAkzB,MAAAhzB,GACAizB,MAAAjzB,GACAwoB,OAAAroB,GACAsyB,OAAAtyB,GACAC,UACAI,WAAAH,GACA1yB,OAAAgzB,GACAh6B,SAAAk6B,GACAvzB,QAAAwlD,GACAj3D,OAAAqQ,GACA6B,YAAAgzB,IAiLAmyB,GAAA,UAEA,UACAnoB,MAAA9iC,MAAAirD,UACAx1C,QAAA+P,UAAAld,OAAA2iD,UACA33D,QAAAC,OAAA03D,UACA59C,OAAAmY,UAAAv2B,UAAAg8D,UACA59C,OAAAmY,UAAA15B,UAAAm/D,UACA59C,OAAAmY,UAAAzvB,MAAAk1D,UACA59C,OAAAmY,UAAA9d,SAAAujD,IACA5gE,cAAA20D,mBAAAiM,GAEA,SAAA99D,OAAA,uNAuDA,OA7CA3B,GAAA3F,GAAA2/B,UAAAkU,GAAAC,IACA9zC,GAAA2/B,UAAA9Y,YAAA7mB,GAGAA,GAAA8zC,SAAA9zC,GAAA2/B,UAGA/e,GAAA5gB,IAGAC,OAAoB8zC,UAAA,EAAAjyC,OAAA,GACpBwoC,gBAAoByJ,UAAA,EAAAjyC,OAAA,GAGpB6xC,QAAoB7xC,MAAA6xC,IACpBvlC,WAAoBtM,MAAAsM,GACpB2S,aAAoBjf,MAAA+e,IACpBozB,UAAoBnyC,MAAAmyC,IACpBzoB,OAAoB1pB,MAAA0pB,IACpB0oB,cAAoBpyC,MAAAoyC,IACpBnlC,aAAoBjN,MAAAiN,GACpB4U,QAAoB7hB,MAAA6hB,IAGpBmB,SAAoBhjB,MAAAgwC,IAGpB7sB,SAAoB8uB,UAAA,EAAAjyC,OAAA,GACpB4zC,KAAoB5zC,MAAA4zC,IACpBr1C,OAAoByB,MAAAsnC,IAGpBi8B,SAAoBvjE,MAAA,SAGpBm9B,UAAoB8U,UAAA,EAAAjyC,UACpBZ,YAAoB6yC,UAAA,EAAAjyC,UACpBm5D,YAAoBlnB,UAAA,EAAAjyC,UACpB4O,QAAoBqjC,UAAA,EAAAjyC,MAAA4O,IACpB1P,QAAoB+yC,UAAA,EAAAjyC,UACpB+G,eAAoBkrC,UAAA,EAAAjyC,MAAA+G,IACpB8xB,UAAoBoZ,UAAA,EAAAjyC,UACpBwjE,aAAoBvxB,UAAA,EAAAjyC,YAGpB9B,OJ8M8BpB,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,GKt1hBvBC,EAAAD,SAAgB0qB,EAAA,EAAAF,IAAYA,EAAA,EAAAhe,EAAA,UAAmB,KAAMge,EAAA,EAAAhe,EAAA,OAAA6mB,IAAuB7I,EAAA,EAAA6I,IAAY7I,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,aAAA7I,EAAA,KAAoC6I,IAAQ7I,EAAA,EAAAhe,EAAA,KAAA6mB,GAAA,yBAA4C,KAAM7I,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,aAAA7I,EAAA,KAAoC6I,IAAQ7I,EAAA,EAAAhe,EAAA,QAAA6mB,GAAA,cAAqC7I,EAAA,EAAAhe,EAAA,QAAAnM,IAAwBikB,EAAA,SAAA+O,EAAA,cAAA7I,EAAA,KAAwClG,EAAA,OAAA+O,EAAA,OAAA7I,EAAA,KAA+BlG,EAAA,OAAA+O,EAAA,QAAA7I,EAAA,KAAgClG,EAAA,QAAA+O,IAAkB7I,EAAA,EAAA3d,EAAA,SAAiB2d,EAAA,QAAa,KAAMA,EAAA,EAAAhe,EAAA,MAAe,KAAMge,EAAA,EAAAhe,EAAA,SAAAnM,IAAyBikB,EAAA,MAAA+O,EAAA,eAAA7I,EAAA,KAAoC6I,GAAA,gBAAqB/O,EAAA,GAAAzX,EAAA,cAA0B,KAAM2d,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,YAAA7I,EAAA,KAAmC6I,IAAQ7I,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,yBAAA7I,EAAA,KAAgD6I,IAAQ7I,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,QAAA7I,EAAA,KAA+B6I,IAAQ7I,EAAA,EAAA6I,IAAY7I,EAAA,EAAAhe,EAAA,MAAA6mB,GAAA,qBAA0C7I,EAAA,EAAAhe,EAAA,SAAA6mB,IAAyB7I,EAAA,EAAA3d,EAAA,aAAqByX,EAAA,GAAAzX,EAAA,QAAoB,KAAM2d,EAAA,EAAAhe,EAAA,MAAA6mB,GAAA,uBAA4C7I,EAAA,EAAAhe,EAAA,SAAA6mB,IAAyB7I,EAAA,EAAA6I,GAAA,QAAA/O,EAAA,GAAAzX,EAAA,SAAuC2d,EAAA,EAAAlG,EAAA,GAAA+O,GAAA,UAAAtc,EAAA,OAAsC,KAAMyT,EAAA,EAAA6I,IAAY7I,EAAA,EAAAhe,EAAA,SAAAnM,IAAyBikB,EAAA,MAAA+O,EAAA,UAAA7I,EAAA,KAA+B6I,GAAA,aAAkB/O,EAAA,GAAApZ,GAAc2B,GAAA,QAAAhG,EAAA,WAA4B2jB,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,QAAA7I,EAAA,KAA+B6I,GAAA,KAAY7I,EAAA,EAAA6I,IAAY7I,EAAA,EAAAhe,EAAA,MAAA6mB,GAAA,kBAAuC7I,EAAA,EAAAhe,EAAA,SAAA6mB,IAAyB7I,EAAA,EAAA3d,EAAA,uBAA+ByX,EAAA,GAAApZ,GAAc2B,GAAA,4BAAAhG,EAAA,YAAgD,KAAM2jB,EAAA,EAAA6I,IAAY7I,EAAA,EAAAhe,EAAA,MAAA6mB,GAAA,gBAAmC/O,EAAA,GAAAzX,EAAA,eAA2B,KAAM2d,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,aAAA7I,EAAA,KAAoC6I,IAAQ7I,EAAA,EAAAhe,EAAA,QAAA6mB,GAAA,cAAqC7I,EAAA,EAAAhe,EAAA,QAAAnM,IAAwBikB,EAAA,SAAA+O,EAAA,aAAA7I,EAAA,KAAuClG,EAAA,OAAA+O,EAAA,QAAA7I,EAAA,KAAgClG,EAAA,QAAA+O,IAAkB7I,EAAA,EAAA3d,EAAA,sBAA8B2d,EAAA,UAAe,KAAMA,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,iBAAA7I,EAAA,KAA0ClG,EAAA,QAAA+O,EAAA,eAAA7I,EAAA,KAAwClG,EAAA,UAAA+O,EAAA,aAAA7I,EAAA,KAAsC6I,IAAQ7I,EAAA,EAAA6I,GAAA,WAAA/O,EAAA,GAAAzX,EAAA,YAA6C2d,EAAA,EAAAlG,EAAA,GAAA+O,GAAA,QAAAtc,EAAA,KAAkC,KAAMyT,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,aAAA7I,EAAA,KAAoC6I,IAAQ7I,EAAA,EAAAhe,EAAA,SAAAnM,IAAyBikB,EAAA,SAAA+O,EAAA,cAAA7I,EAAA,KAAwClG,EAAA,QAAA+O,IAAkB7I,EAAA,EAAA3d,EAAA,kBAA0B2d,EAAA,KAAS6I,IAAQ7I,EAAA,EAAAhe,EAAA,SAAAnM,IAAyBikB,EAAA,QAAA+O,EAAA,MAAA7I,EAAA,KAA6B6I,GAAA,SAAe,KAAM7I,EAAA,EAAAhe,EAAA,SAAAnM,IAAyBikB,EAAA,QAAA+O,EAAA,MAAA7I,EAAA,KAA6B6I,GAAA,WAAiB,KAAM7I,EAAA,EAAAhe,EAAA,SAAAnM,IAAyBikB,EAAA,QAAA+O,EAAA,OAAA7I,EAAA,KAA8B6I,GAAA,aAAmB,KAAM7I,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,aAAA7I,EAAA,KAAoC6I,IAAQ7I,EAAA,EAAAhe,EAAA,QAAAnM,IAAwBikB,EAAA,SAAA+O,EAAA,cAAA7I,EAAA,KAAwClG,EAAA,OAAA+O,EAAA,QAAA7I,EAAA,KAAgClG,EAAA,MAAA+O,EAAA,MAAA7I,EAAA,KAA6BlG,EAAA,MAAA+O,EAAA,OAAA7I,EAAA,KAA8BlG,EAAA,QAAA+O,IAAkB7I,EAAA,EAAA3d,EAAA,kBAA0B2d,EAAA,QAAa,KAAMA,EAAA,EAAAhe,EAAA,MAAAnM,IAAsBikB,EAAA,QAAA+O,EAAA,aAAA7I,EAAA,KAAoC6I,IAAQ7I,EAAA,EAAAhe,EAAA,QAAAnM,IAAwBikB,EAAA,SAAA+O,EAAA,cAAA7I,EAAA,KAAwClG,EAAA,OAAA+O,EAAA,QAAA7I,EAAA,KAAgClG,EAAA,QAAA+O,IAAkB7I,EAAA,EAAA3d,EAAA,kBAA0B2d,EAAA,aAAiBhe,OL41hBp6F,SAASvM,EAAQD,EAASH,GAE/B,YM91hBDI,GAAOD,QAAW,WAMd,QAAS+mE,GAAgB9lE,GACrB,GAAI0S,GAAYnS,EAAQ2zC,QACpBvzC,SAAUA,EACViB,OAAQ,WACJC,KAAKC,GAAG,aAAa,SAASE,GAC1BH,KAAKW,OAAO,YAERX,KAAKU,IAAI,eACTV,KAAKI,KAAKhB,YAAW,MAG7BY,KAAKC,GAAG,eAAe,SAASE,GAC5B2zC,QAAQ5tC,IAAI,UACZlG,KAAKW,OAAO,cACZX,KAAKI,IAAI,YAAY,OAIjC,OAAOyQ,GArBX,GAAInS,GAAU3B,EAAQ,GAClB+B,EAAW/B,EAAQ,EAuBvB,OAAOknE,ONq2hBL,SAAS9mE,EAAQD,GOh4hBvBC,EAAAD,QAAA,wCPs4hBM,SAASC,EAAQD,EAASH,IQv3hBhC,SAAA6F,GAGA,GAAAshE,GAAAnnE,EAAA,EACA,KAAAmnE,EACA,SAAAl+D,OAAA,kEAEApD,GAAAshE,IAYC,SAAAA,GAED,QAAAC,KACA,6CAAAvgE,QAAA,iBAAAuB,EAAAC,GACA,MAAAA,GAAA,GAAA6V,KAAAkK,UAAA,KAAAhgB,EAAA,EAAAC,EAAA,IAAAA,GAAA3B,SAAA,MAIA,QAAA2gE,GAAAC,EAAAC,GACA,GAAAD,EAAA,CACA,IAAAC,EACA,MAAAD,EAGA,QAAAE,KAAAF,GACAA,EAAA11D,eAAA41D,IAEA,mBAAAD,GAAAC,KACAD,EAAAC,GAAAF,EAAAE,IAOA,MAAAD,OAUA,GAAA9iE,GAAA,SAAAgjE,EAAAr1D,GACA,GAAAs1D,GAAAzkE,IAEAmP,QAEA,IACAu1D,GADAC,EAAAx1D,EAAAy1D,wBAAA,GAIA5kE,MAAA6kE,WAAA,GAAAX,GAAAM,EAAA,KAAAr1D,GACAnP,KAAAq2C,MAAA70C,EAAAsjE,WACA9kE,KAAAgJ,YACAhJ,KAAA+kE,iBACA/kE,KAAAqkE,eAAA,KAGArkE,KAAAglE,QAAA,SAAAxwC,GACA,IACAsf,QAAAnyC,MAAA6yB,GACO,MAAA9qB,KAKP,IAAAu7D,GAAA,WACAR,EAAAI,WAAA1iE,KAAA4Z,KAAAC,WAA2C5U,KAAA,UAG3CpH,MAAA6kE,WAAApjE,OAAA,WAEAwjE,IACAP,EAAAQ,YAAAD,EAAAN,GACAF,EAAApuB,MAAA70C,EAAA2jE,KACAV,EAAAhjE,QAAAgjE,EAAAhjE,UAGAzB,KAAA6kE,WAAAziE,QAAA,SAAAsH,GACA+6D,EAAApuB,MAAA70C,EAAA4jE,OACAV,GAAAW,cAAAX,GACAD,EAAAriE,SAAAqiE,EAAAriE,QAAAsH,IAGA1J,KAAA6kE,WAAAS,UAAA,SAAA57D,GACA,GAAA67D,GAAAxpD,KAAAmO,MAAAxgB,EAAA1K,KAWA,IARAumE,EAAAC,cACAr5D,OAAA06B,eAAA0+B,EAAA,SACA/kE,MAAA,SAAAoF,EAAA0+D,EAAAz7D,GACA47D,EAAAtiE,KAAAojE,EAAAC,aAAA5/D,EAAA0+D,EAAAz7D,MAKA47D,EAAAz7D,SAAAu8D,EAAAE,SAGA,OADAz8D,GAAAy7D,EAAAz7D,SAAAu8D,EAAAE,SACAx9D,EAAA,EAAuBA,EAAAe,EAAAvE,OAAqBwD,IAC5C,QAAAs9D,EAAAn+D,KACA4B,EAAAf,IAAyBy9D,YAAAH,EAAAG,YAAAC,YAAAJ,EAAAI,YAAA//D,QAAA2/D,EAAA3/D,UAEzBoD,EAAAf,GAAA,KAAAs9D,OAGO,IAAAd,EAAAM,cAAAQ,EAAAE,SAAA,CAEP,GAAAv8D,GAAAu7D,EAAAM,cAAAQ,EAAAE,eACAhB,GAAAM,cAAAQ,EAAAE,SACA,QAAAF,EAAAn+D,KACA8B,GAAmBw8D,YAAAH,EAAAG,YAAAC,YAAAJ,EAAAI,YAAA//D,QAAA2/D,EAAA3/D,UAEnBsD,EAAA,KAAAq8D,OAGA,YAAAA,EAAAn+D,KACAq9D,EAAAO,QAAAO,OAEA,KACAzxB,QAAA1tC,KAAA,iCAAAm/D,GACW,MAAA77D,MAgBXlI,GAAA68B,UAAAl8B,KAAA,SAAAsjE,EAAA7/D,EAAA0+D,EAAAz7D,GAEA,GAAA7I,KAAAq2C,OAAA70C,EAAA2jE,KACA,SAAAn/D,OAAA,oBAGA,mBAAAs+D,KACAz7D,EAAAy7D,EACAA,KAGA,IAAAsB,IACAx+D,KAAA,OACAq+D,UACAnB,QAAAF,EAAApkE,KAAAqkE,eAAAC,GACAxiE,KAAA8D,EAGA,IAAAiD,EAAA,CACA,GAAA28D,GAAArB,GACAyB,GAAAJ,eACAxlE,KAAA+kE,cAAAS,GAAA38D,EAGA7I,KAAA6kE,WAAA1iE,KAAA4Z,KAAAC,UAAA4pD,KAUApkE,EAAA68B,UAAAwnC,QAAA,SAAAJ,EAAA7/D,EAAA0+D,GAEA,GAAAtkE,KAAAq2C,OAAA70C,EAAA2jE,KACA,SAAAn/D,OAAA,oBAGAhG,MAAA6kE,WAAA1iE,KAAA4Z,KAAAC,WACA5U,KAAA,UACAq+D,UACAnB,QAAAF,EAAApkE,KAAAqkE,eAAAC,GACAxiE,KAAA8D,MAWApE,EAAA68B,UAAA38B,gBAAA,SAAA+jE,EAAAnB,EAAAz7D,GAEA,GAAA7I,KAAAq2C,OAAA70C,EAAA2jE,KACA,SAAAn/D,OAAA,oBAGA,mBAAAs+D,KACAz7D,EAAAy7D,EACAA,MAIAtkE,KAAAgJ,SAAAy8D,KACAzlE,KAAAgJ,SAAAy8D,MAEAzlE,KAAA6kE,WAAA1iE,KAAA4Z,KAAAC,WACA5U,KAAA,WACAq+D,UACAnB,QAAAF,EAAApkE,KAAAqkE,eAAAC,OAIAtkE,KAAAgJ,SAAAy8D,GAAA19D,KAAAc,IAUArH,EAAA68B,UAAAh8B,kBAAA,SAAAojE,EAAAnB,EAAAz7D,GAEA,GAAA7I,KAAAq2C,OAAA70C,EAAA2jE,KACA,SAAAn/D,OAAA,oBAGA,IAAAgD,GAAAhJ,KAAAgJ,SAAAy8D,EAEA,IAAAz8D,EAAA,CAEA,kBAAAs7D,KACAz7D,EAAAy7D,EACAA,KAGA,IAAAp0C,GAAAlnB,EAAAlB,QAAAe,EACAqnB,KAAA,IACAlnB,EAAAP,OAAAynB,EAAA,GACA,IAAAlnB,EAAAvE,SAEAzE,KAAA6kE,WAAA1iE,KAAA4Z,KAAAC,WACA5U,KAAA,aACAq+D,UACAnB,QAAAF,EAAApkE,KAAAqkE,eAAAC,YAGAtkE,MAAAgJ,SAAAy8D,OASAjkE,EAAA68B,UAAA/L,MAAA,WACAtyB,KAAAq2C,MAAA70C,EAAAuzB,QACA/0B,KAAA6kE,WAAAvyC,SAGA9wB,EAAAsjE,WAAA,EACAtjE,EAAA2jE,KAAA,EACA3jE,EAAAuzB,QAAA,EACAvzB,EAAA4jE,OAAA,EAGA,mBAAAjoE,MAAAD,QACAA,EAAAC,EAAAD,QAAAsE,EAEAtE,EAAAsE,cRi5hBM,SAASrE,EAAQD,EAASH,IS7riBhC,SAAA4F,GAAA,YAEA,IAAAmjE,GAAA/oE,EAAA,EAEAI,GAAAD,QAAAH,EAAA,IAAA+oE,GAGA,kBAAAnjE,IACAmG,WAAAnG,EAAAojE,eAAA,KTksiB8BzoE,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,GU9siBhC,YAEAI,GAAAD,SAEAH,EAAA,GACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IAAAA,EAAA,KAGAA,EAAA,IACAA,EAAA,IAAAA,EAAA,KACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IAAAA,EAAA,KACAA,EAAA,MVstiBM,SAASI,EAAQD,EAASH,IWtuiBhC,SAAAipE,GAAA,YAcA,SAAAC,GAAAC,GACA,IAAAD,EAAAE,UACA,SAAAngE,OAAA,kCAGAogE,GAAA9oE,KAAA0C,MACAqmE,EAAA,cAAAH,EAEA,IAAAzB,GAAAzkE,KACAwkE,EAAA8B,EAAAC,QAAAL,EAAA,aAEA1B,GADA,UAAAA,EAAAjyD,MAAA,KACA,MAAAiyD,EAAAjyD,MAAA,GAEA,KAAAiyD,EAAAjyD,MAAA,GAEAvS,KAAAwkE,MAEAxkE,KAAAwmE,GAAA,GAAAC,GAAAzmE,KAAAwkE,KACAxkE,KAAAwmE,GAAAlB,UAAA,SAAA57D,GACA28D,EAAA,gBAAA38D,EAAA1K,MACAylE,EAAAiC,KAAA,UAAAh9D,EAAA1K,OAQAgB,KAAA2mE,UAAAC,EAAAC,UAAA,WACAR,EAAA,UACA5B,EAAA+B,GAAAl0C,UAEAtyB,KAAAwmE,GAAApkE,QAAA,SAAAsH,GACA28D,EAAA,cAAA38D,EAAA+e,KAAA/e,EAAAstC,QACAytB,EAAAiC,KAAA,QAAAh9D,EAAA+e,KAAA/e,EAAAstC,QACAytB,EAAAqC,YAEA9mE,KAAAwmE,GAAAxB,QAAA,SAAAt7D,GACA28D,EAAA,cAAA38D,GACA+6D,EAAAiC,KAAA,4CACAjC,EAAAqC,YApDA,GAAAF,GAAA7pE,EAAA,IACAupE,EAAAvpE,EAAA,IACAgqE,EAAAhqE,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aACAK,EAAA1pE,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,gCA+CAgqE,EAAAd,EAAAG,GAEAH,EAAA5nC,UAAAl8B,KAAA,SAAAnD,GACA,GAAA4C,GAAA,IAAA5C,EAAA,GACAqnE,GAAA,OAAAzkE,GACA5B,KAAAwmE,GAAArkE,KAAAP,IAGAqkE,EAAA5nC,UAAA/L,MAAA,WACA+zC,EAAA,SACArmE,KAAAwmE,IACAxmE,KAAAwmE,GAAAl0C,QAEAtyB,KAAA8mE,YAGAb,EAAA5nC,UAAAyoC,SAAA,WACAT,EAAA,WACA,IAAAG,GAAAxmE,KAAAwmE,EACAA,KACAA,EAAAlB,UAAAkB,EAAApkE,QAAAokE,EAAAxB,QAAA,MAEA4B,EAAAM,UAAAlnE,KAAA2mE,WACA3mE,KAAA2mE,UAAA3mE,KAAAwmE,GAAA,KACAxmE,KAAAmnE,sBAGAlB,EAAAE,QAAA,WAEA,MADAE,GAAA,aACAI,GAEAR,EAAAmB,cAAA,YAMAnB,EAAAoB,WAAA,EAEAlqE,EAAAD,QAAA+oE,IX0uiB8B3oE,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,GYp0iBvB,QAAAoqE,KACA,SAAAthE,OAAA,mCAEA,QAAAuhE,KACA,SAAAvhE,OAAA,qCAsBA,QAAAwhE,GAAAC,GACA,GAAAC,IAAA5+D,WAEA,MAAAA,YAAA2+D,EAAA,EAGA,KAAAC,IAAAJ,IAAAI,IAAA5+D,WAEA,MADA4+D,GAAA5+D,WACAA,WAAA2+D,EAAA,EAEA,KAEA,MAAAC,GAAAD,EAAA,GACK,MAAA/9D,GACL,IAEA,MAAAg+D,GAAApqE,KAAA,KAAAmqE,EAAA,GACS,MAAA/9D,GAET,MAAAg+D,GAAApqE,KAAA0C,KAAAynE,EAAA,KAMA,QAAAE,GAAAC,GACA,GAAAC,IAAA59B,aAEA,MAAAA,cAAA29B,EAGA,KAAAC,IAAAN,IAAAM,IAAA59B,aAEA,MADA49B,GAAA59B,aACAA,aAAA29B,EAEA,KAEA,MAAAC,GAAAD,GACK,MAAAl+D,GACL,IAEA,MAAAm+D,GAAAvqE,KAAA,KAAAsqE,GACS,MAAAl+D,GAGT,MAAAm+D,GAAAvqE,KAAA0C,KAAA4nE,KAYA,QAAAE,KACAC,GAAAC,IAGAD,GAAA,EACAC,EAAAvjE,OACAyG,EAAA88D,EAAAv8D,OAAAP,GAEA+8D,GAAA,EAEA/8D,EAAAzG,QACAyjE,KAIA,QAAAA,KACA,IAAAH,EAAA,CAGA,GAAA/9B,GAAAw9B,EAAAM,EACAC,IAAA,CAGA,KADA,GAAAxjE,GAAA2G,EAAAzG,OACAF,GAAA,CAGA,IAFAyjE,EAAA98D,EACAA,OACA+8D,EAAA1jE,GACAyjE,GACAA,EAAAC,GAAAE,KAGAF,IAAA,EACA1jE,EAAA2G,EAAAzG,OAEAujE,EAAA,KACAD,GAAA,EACAJ,EAAA39B,IAiBA,QAAAqF,GAAAo4B,EAAAhgE,GACAzH,KAAAynE,MACAznE,KAAAyH,QAYA,QAAA/B,MAhKA,GAOAgiE,GACAG,EARA7B,EAAA7oE,EAAAD,YAgBA,WACA,IAEAwqE,EADA,kBAAA5+D,YACAA,WAEAw+D,EAEK,MAAA59D,GACLg+D,EAAAJ,EAEA,IAEAO,EADA,kBAAA59B,cACAA,aAEAs9B,EAEK,MAAA79D,GACLm+D,EAAAN,KAuDA,IAEAS,GAFA98D,KACA68D,GAAA,EAEAE,GAAA,CAyCAjC,GAAAoC,SAAA,SAAAX,GACA,GAAA5hE,GAAA,GAAAqgB,OAAA1hB,UAAAC,OAAA,EACA,IAAAD,UAAAC,OAAA,EACA,OAAAwD,GAAA,EAAuBA,EAAAzD,UAAAC,OAAsBwD,IAC7CpC,EAAAoC,EAAA,GAAAzD,UAAAyD,EAGAiD,GAAAnD,KAAA,GAAAsnC,GAAAo4B,EAAA5hE,IACA,IAAAqF,EAAAzG,QAAAsjE,GACAP,EAAAU,IASA74B,EAAAhR,UAAA8pC,IAAA,WACAnoE,KAAAynE,IAAAthE,MAAA,KAAAnG,KAAAyH,QAEAu+D,EAAAqC,MAAA,UACArC,EAAAsC,SAAA,EACAtC,EAAAgB,OACAhB,EAAAuC,QACAvC,EAAAwC,QAAA,GACAxC,EAAAyC,YAIAzC,EAAA/lE,GAAAyF,EACAsgE,EAAA0C,YAAAhjE,EACAsgE,EAAA5oB,KAAA13C,EACAsgE,EAAA5wD,IAAA1P,EACAsgE,EAAA2C,eAAAjjE,EACAsgE,EAAAmB,mBAAAzhE,EACAsgE,EAAAU,KAAAhhE,EAEAsgE,EAAA9mD,QAAA,SAAA3e,GACA,SAAAyF,OAAA,qCAGAggE,EAAA4C,IAAA,WAA2B,WAC3B5C,EAAA6C,MAAA,SAAAC,GACA,SAAA9iE,OAAA,mCAEAggE,EAAA+C,MAAA,WAA4B,WZs1iBtB,SAAS5rE,EAAQD,EAASH,IazgjBhC,SAAA4F,GAAA,YAEA,IAAAwiB,GAAApoB,EAAA,IAEAisE,KACAC,GAAA,EAEAC,EAAAvmE,EAAAwmE,QAAAxmE,EAAAwmE,OAAAC,KAAAzmE,EAAAwmE,OAAAC,IAAAC,OAGAlsE,GAAAD,SACAo9D,YAAA,SAAAn6D,EAAAuhB,GACA,mBAAA/e,GAAAk1D,iBACAl1D,EAAAk1D,iBAAA13D,EAAAuhB,GAAA,GACK/e,EAAA3E,UAAA2E,EAAA23D,cAIL33D,EAAA3E,SAAAs8D,YAAA,KAAAn6D,EAAAuhB,GAEA/e,EAAA23D,YAAA,KAAAn6D,EAAAuhB,KAIA4nD,YAAA,SAAAnpE,EAAAuhB,GACA,mBAAA/e,GAAAk1D,iBACAl1D,EAAAo1D,oBAAA53D,EAAAuhB,GAAA,GACK/e,EAAA3E,UAAA2E,EAAA2mE,cACL3mE,EAAA3E,SAAAsrE,YAAA,KAAAnpE,EAAAuhB,GACA/e,EAAA2mE,YAAA,KAAAnpE,EAAAuhB,KAIAmlD,UAAA,SAAAnlD,GACA,GAAAwnD,EACA,WAGA,IAAAj8D,GAAAkY,EAAAxhB,OAAA,EAKA,OAJAqlE,GAAA/7D,GAAAyU,EACAunD,GACAngE,WAAA9I,KAAAupE,uBAAA;AAEAt8D,GAGAi6D,UAAA,SAAAj6D,GACAA,IAAA+7D,UACAA,GAAA/7D,IAIAs8D,uBAAA,WACA,OAAAt8D,KAAA+7D,GACAA,EAAA/7D,WACA+7D,GAAA/7D,IAKA,IAAAu8D,GAAA,WACAP,IAGAA,GAAA,EACA9rE,EAAAD,QAAAqsE,0BAKAL,IACA/rE,EAAAD,QAAAo9D,YAAA,SAAAkP,Kb8gjB8BlsE,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,GczljBhC,YAGA,IAAA0sE,GAAA1sE,EAAA,IAIA2sE,EAAA,kCACAvsE,GAAAD,SACAyG,OAAA,SAAAc,GAIA,OAHAsP,GAAA21D,EAAAjlE,OACAklE,EAAAF,EAAAG,YAAAnlE,GACAolE,KACA5hE,EAAA,EAAmBA,EAAAxD,EAAYwD,IAC/B4hE,EAAA9hE,KAAA2hE,EAAAl8D,OAAAm8D,EAAA1hE,GAAA8L,EAAA,GAEA,OAAA81D,GAAAh6D,KAAA,KAGArI,OAAA,SAAAuM,GACA,MAAAkH,MAAAiK,MAAAjK,KAAAkK,SAAApR,IAGA+1D,aAAA,SAAA/1D,GACA,GAAA2T,IAAA,IAAA3T,EAAA,IAAAtP,OACAhH,EAAA,GAAAyoB,OAAAwB,EAAA,GAAA7X,KAAA,IACA,QAAApS,EAAAuC,KAAAwH,OAAAuM,IAAAxB,OAAAmV,MdkmjBM,SAASvqB,EAAQD,Ie5njBvB,SAAAyF,GAAA,YAEAA,GAAA8mE,QAAA9mE,EAAA8mE,OAAAM,gBACA5sE,EAAAD,QAAA0sE,YAAA,SAAAnlE,GACA,GAAAklE,GAAA,GAAAK,YAAAvlE,EAEA,OADA9B,GAAA8mE,OAAAM,gBAAAJ,GACAA,GAGAxsE,EAAAD,QAAA0sE,YAAA,SAAAnlE,GAEA,OADAklE,GAAA,GAAAzjD,OAAAzhB,GACAwD,EAAA,EAAmBA,EAAAxD,EAAYwD,IAC/B0hE,EAAA1hE,GAAAgT,KAAAiK,MAAA,IAAAjK,KAAAkK,SAEA,OAAAwkD,MfkojB8BrsE,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,IgBppjBhC,SAAAipE,GAAA,YAEA,IAAAiE,GAAAltE,EAAA,IAEAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,gCAGAI,EAAAD,SACAgtE,UAAA,SAAA1F,GACA,IAAAA,EACA,WAGA,IAAA/mE,GAAA,GAAAwsE,GAAAzF,EACA,cAAA/mE,EAAA0sE,SACA,WAGA,IAAAC,GAAA3sE,EAAA2sE,IAKA,OAJAA,KACAA,EAAA,WAAA3sE,EAAA0sE,SAAA,YAGA1sE,EAAA0sE,SAAA,KAAA1sE,EAAA8D,SAAA,IAAA6oE,GAGAC,cAAA,SAAAllE,EAAAC,GACA,GAAAmiC,GAAAvnC,KAAAkqE,UAAA/kE,KAAAnF,KAAAkqE,UAAA9kE,EAEA,OADAihE,GAAA,OAAAlhE,EAAAC,EAAAmiC,GACAA,GAGA+iC,cAAA,SAAAnlE,EAAAC,GACA,MAAAD,GAAAsT,MAAA,UAAArT,EAAAqT,MAAA,SAGA8tD,QAAA,SAAA/B,EAAAlpD,GACA,GAAAivD,GAAA/F,EAAA/rD,MAAA,IACA,OAAA8xD,GAAA,GAAAjvD,GAAAivD,EAAA,OAAAA,EAAA,QAGAC,SAAA,SAAAhG,EAAAiG,GACA,MAAAjG,MAAA18D,QAAA,cAAA2iE,EAAA,IAAAA,OhB0pjB8BntE,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,GiB1sjBhC,YA6CA,SAAA2tE,GAAAjF,GACA,GAAAp4D,GAAAs9D,EAAAp9D,KAAAk4D,EAEA,QACA0E,SAAA98D,EAAA,GAAAA,EAAA,GAAAjJ,cAAA,GACAwmE,UAAAv9D,EAAA,GACAw9D,KAAAx9D,EAAA,GAAAA,EAAA,OAeA,QAAA48D,GAAAxE,EAAAnkE,EAAAylB,GACA,KAAA/mB,eAAAiqE,IACA,UAAAA,GAAAxE,EAAAnkE,EAAAylB,EAGA,IACAmD,GAAA4gD,EAAAjjE,EAAA9C,EAGAgmE,EAJAC,EAAAC,EAAAp9D,KAAA43D,GAEAr+D,QAAA9F,GACAkjE,EAAAxkE,KAEAiI,EAAA,CAgCA,KAnBA,WAAAb,GAAA,WAAAA,IACA2f,EAAAzlB,EACAA,EAAA,MAGAylB,GAAA,kBAAAA,KACAA,EAAAwjD,EAAArgD,OAGA5oB,EAAA4pE,EAAA5pE,GAKAypE,EAAAL,EAAAjF,GACAjB,EAAA2F,SAAAY,EAAAZ,UAAA7oE,EAAA6oE,UAAA,GACA3F,EAAAoG,QAAAG,EAAAH,SAAAtpE,EAAAspE,QACAnF,EAAAsF,EAAAF,KAEQ5iE,EAAAwzB,EAAAh3B,OAAyBwD,IACjC6iE,EAAArvC,EAAAxzB,GACAiiB,EAAA4gD,EAAA,GACA/lE,EAAA+lE,EAAA,GAEA5gD,MACAs6C,EAAAz/D,GAAA0gE,EACK,gBAAAv7C,KACLriB,EAAA49D,EAAA39D,QAAAoiB,MACA,gBAAA4gD,GAAA,IACAtG,EAAAz/D,GAAA0gE,EAAAlzD,MAAA,EAAA1K,GACA49D,IAAAlzD,MAAA1K,EAAAijE,EAAA,MAEAtG,EAAAz/D,GAAA0gE,EAAAlzD,MAAA1K,GACA49D,IAAAlzD,MAAA,EAAA1K,MAGKA,EAAAqiB,EAAA3c,KAAAk4D,MACLjB,EAAAz/D,GAAA8C,EAAA,GACA49D,IAAAlzD,MAAA,EAAAkzD,EAAAhhE,OAAAoD,EAAA,GAAApD,SAGA+/D,EAAAz/D,GAAAy/D,EAAAz/D,KAAA+lE,EAAA,aAAA/lE,GAAAimE,EAAA1pE,EAAAyD,IAAA,OAMA+lE,EAAA,KACAtG,EAAAz/D,GAAAy/D,EAAAz/D,GAAAX,cASA2iB,KAAAy9C,EAAAnyD,MAAA0U,EAAAy9C,EAAAnyD,QAOA84D,EAAA3G,EAAA4F,KAAA5F,EAAA2F,YACA3F,EAAA4G,KAAA5G,EAAAjjE,SACAijE,EAAA4F,KAAA,IAMA5F,EAAA6G,SAAA7G,EAAA8G,SAAA,GACA9G,EAAA+G,OACAT,EAAAtG,EAAA+G,KAAA9yD,MAAA,KACA+rD,EAAA6G,SAAAP,EAAA,OACAtG,EAAA8G,SAAAR,EAAA,QAMAtG,EAAAjN,OAAAiN,EAAA2F,UAAA3F,EAAA4G,MAAA,UAAA5G,EAAA2F,SAAA3F,EAAA2F,SAAA,KAAA3F,EAAA4G,KAAA,OACA5G,EAAAgH,KAAAhH,EAAA/gE,WA1KA,GAAA0nE,GAAApuE,EAAA,IACAmuE,EAAAnuE,EAAA,IACAwtE,EAAAxtE,EAAA,IACAkuE,EAAA,YACAN,EAAA,0CAcAlvC,IACA,aACA,cACA,iBACA,eACAgwC,IAAA,OAAApjE,OAAA,MACA,mBACAojE,IAAA,WAAApjE,OAAA,KAiKA4hE,GAAA5rC,UAAAj+B,IAAA,SAAAia,EAAA7Z,EAAAmN,GACA,GAAA62D,GAAAxkE,IAEA,WAAAqa,GACA,gBAAA7Z,MAAAiE,SACAjE,GAAAmN,GAAA48D,EAAArgD,OAAA1pB,IAGAgkE,EAAAnqD,GAAA7Z,GACG,SAAA6Z,GACHmqD,EAAAnqD,GAAA7Z,EAEA2qE,EAAA3qE,EAAAgkE,EAAA2F,UAGK3pE,IACLgkE,EAAA4G,KAAA5G,EAAAjjE,SAAA,IAAAf,IAHAgkE,EAAA4G,KAAA5G,EAAAjjE,SACAijE,EAAAnqD,GAAA,KAIG,aAAAA,GACHmqD,EAAAnqD,GAAA7Z,EAEAgkE,EAAA4F,OAAA5pE,GAAA,IAAAgkE,EAAA4F,MACA5F,EAAA4G,KAAA5qE,GACG,SAAA6Z,GACHmqD,EAAAnqD,GAAA7Z,EAEA,QAAAqN,KAAArN,IACAA,IAAAiY,MAAA,KACA+rD,EAAA4F,KAAA5pE,EAAA2Q,MACAqzD,EAAAjjE,SAAAf,EAAAqP,KAAA,OAEA20D,EAAAjjE,SAAAf,EACAgkE,EAAA4F,KAAA,KAEG,aAAA/vD,GACHmqD,EAAA2F,SAAA3pE,EAAA4D,cACAogE,EAAAoG,SAAAj9D,GAEA62D,EAAAnqD,GAAA7Z,CAGA,QAAAyH,GAAA,EAAiBA,EAAAwzB,EAAAh3B,OAAyBwD,IAAA,CAC1C,GAAAyjE,GAAAjwC,EAAAxzB,EAEAyjE,GAAA,KACAlH,EAAAkH,EAAA,IAAAlH,EAAAkH,EAAA,IAAAtnE,eAOA,MAHAogE,GAAAjN,OAAAiN,EAAA2F,UAAA3F,EAAA4G,MAAA,UAAA5G,EAAA2F,SAAA3F,EAAA2F,SAAA,KAAA3F,EAAA4G,KAAA,OACA5G,EAAAgH,KAAAhH,EAAA/gE,WAEA+gE,GAUAyF,EAAA5rC,UAAA56B,SAAA,SAAAuY,GACAA,GAAA,kBAAAA,OAAAuuD,EAAAvuD,UAEA,IAAA3J,GACAmyD,EAAAxkE,KACAmqE,EAAA3F,EAAA2F,QAEAA,IAAA,MAAAA,EAAAnmE,OAAAmmE,EAAA1lE,OAAA,KAAA0lE,GAAA,IAEA,IAAAlhE,GAAAkhE,GAAA3F,EAAAoG,QAAA,QAeA,OAbApG,GAAA6G,WACApiE,GAAAu7D,EAAA6G,SACA7G,EAAA8G,WAAAriE,GAAA,IAAAu7D,EAAA8G,UACAriE,GAAA,KAGAA,GAAAu7D,EAAA4G,KAAA5G,EAAAmH,SAEAt5D,EAAA,gBAAAmyD,GAAAnyD,MAAA2J,EAAAwoD,EAAAnyD,OAAAmyD,EAAAnyD,MACAA,IAAApJ,GAAA,MAAAoJ,EAAArO,OAAA,OAAAqO,KAEAmyD,EAAA/6B,OAAAxgC,GAAAu7D,EAAA/6B,MAEAxgC,GAOAghE,EAAAS,kBACAT,EAAA3oE,SAAA4pE,EACAjB,EAAAM,KAEAptE,EAAAD,QAAA+sE,GjBitjBM,SAAS9sE,EAAQD,GkB9+jBvB,YAWAC,GAAAD,QAAA,SAAAktE,EAAAD,GAIA,GAHAA,IAAA1xD,MAAA,QACA2xD,MAEAA,EAAA,QAEA,QAAAD,GACA,WACA,SACA,YAAAC,CAEA,aACA,UACA,aAAAA,CAEA,WACA,YAAAA,CAEA,cACA,YAAAA,CAEA,YACA,SAGA,WAAAA,IlBs/jBM,SAASjtE,EAAQD,EAASH,ImB1hkBhC,SAAA4F,GAAA,YAEA,IAWAsnE,GAXAW,EAAA,gCAUAgB,GAAcniC,KAAA,EAAAp3B,MAAA,EAedlV,GAAAD,QAAA,SAAA2uE,GACAA,KAAAlpE,EAAArB,aACA2oE,KAAAltE,EAAA,GAEA,IAEAgI,GAFA+mE,KACA1kE,QAAAykE,EAGA,cAAAA,EAAA1B,SACA2B,EAAA,GAAA7B,GAAA8B,SAAAF,EAAAF,kBACG,eAAAvkE,EAAA,CACH0kE,EAAA,GAAA7B,GAAA4B,KACA,KAAA9mE,IAAA6mE,SAAAE,GAAA/mE,OACG,eAAAqC,EAAA,CACH,IAAArC,IAAA8mE,GACA9mE,IAAA6mE,KACAE,EAAA/mE,GAAA8mE,EAAA9mE,GAGAsD,UAAAyjE,EAAAlB,UACAkB,EAAAlB,UAAA/8D,KAAAg+D,EAAAL,OAIA,MAAAM,MnB+hkB8BxuE,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,GoBtlkBvB,YAWA,SAAA8uE,GAAA35D,GAUA,IATA,GAEAgI,GAFA0M,EAAA,sBACA9d,KASAoR,EAAA0M,EAAAxZ,KAAA8E,GACApJ,EAAAgjE,mBAAA5xD,EAAA,KAAA4xD,mBAAA5xD,EAAA,KAGA,MAAApR,GAWA,QAAAijE,GAAAvuE,EAAAwb,GACAA,KAAA,EAEA,IAAApL,KAKA,iBAAAoL,OAAA,IAEA,QAAApU,KAAApH,GACAyY,EAAA9Y,KAAAK,EAAAoH,IACAgJ,EAAAhG,KAAAokE,mBAAApnE,GAAA,IAAAonE,mBAAAxuE,EAAAoH,IAIA,OAAAgJ,GAAAtJ,OAAA0U,EAAApL,EAAA8B,KAAA,QAnDA,GAAAuG,GAAAjK,OAAAkyB,UAAA1vB,cAyDAzR,GAAA8e,UAAAkwD,EACAhvE,EAAAgtB,MAAA8hD,GpB6lkBM,SAAS7uE,EAAQD,EAASH,GqBlnkBhC,QAAAqvE,KAEA,0BAAApuE,UAAAquE,gBAAA5pD,OAEAphB,OAAAyyC,kBAAAw4B,SAAAx4B,QAAAy4B,WAAAz4B,QAAA04B,QAGAnuE,UAAAouE,UAAAroE,cAAAiJ,MAAA,mBAAA8G,SAAAiU,OAAAtD,GAAA,QAkBA,QAAA4nD,KACA,GAAA7mE,GAAArB,UACA4nE,EAAApsE,KAAAosE,SASA,IAPAvmE,EAAA,IAAAumE,EAAA,SACApsE,KAAAoiC,WACAgqC,EAAA,WACAvmE,EAAA,IACAumE,EAAA,WACA,IAAAlvE,EAAAyvE,SAAA3sE,KAAA4sE,OAEAR,EAAA,MAAAvmE,EAEA,IAAArI,GAAA,UAAAwC,KAAA6sE,KACAhnE,MAAA,GAAArI,EAAA,kBAAAiO,OAAAya,MAAAmY,UAAA9rB,MAAAjV,KAAAuI,EAAA,GAKA,IAAAgC,GAAA,EACAilE,EAAA,CAYA,OAXAjnE,GAAA,GAAAjC,QAAA,oBAAAyJ,GACA,OAAAA,IACAxF,IACA,OAAAwF,IAGAy/D,EAAAjlE,MAIAhC,EAAA4C,OAAAqkE,EAAA,EAAAtvE,GACAqI,EAUA,QAAAK,KAGA,sBAAA4tC,UACAA,QAAA5tC,KACAigB,SAAAkY,UAAAl4B,MAAA7I,KAAAw2C,QAAA5tC,IAAA4tC,QAAAtvC,WAUA,QAAAuoE,GAAA7oC,GACA,IACA,MAAAA,EACAhnC,EAAAsiB,QAAAwtD,WAAA,SAEA9vE,EAAAsiB,QAAA6mD,MAAAniC,EAEG,MAAAx6B,KAUH,QAAAujE,KACA,GAAAljE,EACA,KACAA,EAAA7M,EAAAsiB,QAAA6mD,MACG,MAAA38D,IACH,MAAAK,GAoBA,QAAAmjE,KACA,IACA,MAAA7rE,QAAA8rE,aACG,MAAAzjE,KA/JHxM,EAAAC,EAAAD,QAAAH,EAAA,IACAG,EAAAgJ,MACAhJ,EAAAwvE,aACAxvE,EAAA6vE,OACA7vE,EAAA+vE,OACA/vE,EAAAkvE,YACAlvE,EAAAsiB,QAAA,mBAAA2pD,SACA,mBAAAA,QAAA3pD,QACA2pD,OAAA3pD,QAAAg4C,MACA0V,IAMAhwE,EAAAkwE,QACA,gBACA,cACA,YACA,aACA,aACA,WAyBAlwE,EAAAmwE,WAAAhiE,EAAA,SAAAuc,GACA,MAAA7L,MAAAC,UAAA4L,IAgGA1qB,EAAAowE,OAAAL,MrBirkBM,SAAS9vE,EAAQD,EAASH,GsBtxkBhC,QAAAwwE,KACA,MAAArwE,GAAAkwE,OAAAI,IAAAtwE,EAAAkwE,OAAA3oE,QAWA,QAAA4hE,GAAAjkC,GAGA,QAAAU,MAKA,QAAAqjC,KAEA,GAAA1B,GAAA0B,EAGAsH,GAAA,GAAA9xB,MACA+xB,EAAAD,GAAAE,GAAAF,EACAhJ,GAAAmI,KAAAc,EACAjJ,EAAAnhC,KAAAqqC,EACAlJ,EAAAgJ,OACAE,EAAAF,EAGA,MAAAhJ,EAAA2H,YAAA3H,EAAA2H,UAAAlvE,EAAAkvE,aACA,MAAA3H,EAAAoI,OAAApI,EAAA2H,YAAA3H,EAAAoI,MAAAU,IAEA,IAAA1nE,GAAAqgB,MAAAmY,UAAA9rB,MAAAjV,KAAAkH,UAEAqB,GAAA,GAAA3I,EAAA0wE,OAAA/nE,EAAA,IAEA,gBAAAA,GAAA,KAEAA,GAAA,MAAA4F,OAAA5F,GAIA,IAAAgC,GAAA,CACAhC,GAAA,GAAAA,EAAA,GAAAjC,QAAA,sBAAAyJ,EAAA1H,GAEA,UAAA0H,EAAA,MAAAA,EACAxF,IACA,IAAAgmE,GAAA3wE,EAAAmwE,WAAA1nE,EACA,sBAAAkoE,GAAA,CACA,GAAAxwD,GAAAxX,EAAAgC,EACAwF,GAAAwgE,EAAAvwE,KAAAmnE,EAAApnD,GAGAxX,EAAA4C,OAAAZ,EAAA,GACAA,IAEA,MAAAwF,KAGA,kBAAAnQ,GAAAwvE,aACA7mE,EAAA3I,EAAAwvE,WAAAvmE,MAAAs+D,EAAA5+D,GAEA,IAAAioE,GAAA3H,EAAAjgE,KAAAhJ,EAAAgJ,KAAA4tC,QAAA5tC,IAAAhE,KAAA4xC,QACAg6B,GAAA3nE,MAAAs+D,EAAA5+D,GAlDAi9B,EAAAqjC,SAAA,EAoDAA,WAAA,CAEA,IAAAx4D,GAAAzQ,EAAAipE,QAAA/jC,GAAA+jC,EAAArjC,CAIA,OAFAn1B,GAAAy0B,YAEAz0B,EAWA,QAAA2/D,GAAAppC,GACAhnC,EAAA6vE,KAAA7oC,EAKA,QAHAzrB,IAAAyrB,GAAA,IAAAzrB,MAAA,UACAlU,EAAAkU,EAAAhU,OAEAwD,EAAA,EAAiBA,EAAA1D,EAAS0D,IAC1BwQ,EAAAxQ,KACAi8B,EAAAzrB,EAAAxQ,GAAArE,QAAA,aACA,MAAAsgC,EAAA,GACAhnC,EAAA6wE,MAAAhmE,KAAA,GAAAqgB,QAAA,IAAA8b,EAAA12B,OAAA,SAEAtQ,EAAAokE,MAAAv5D,KAAA,GAAAqgB,QAAA,IAAA8b,EAAA,OAWA,QAAA8pC,KACA9wE,EAAAowE,OAAA,IAWA,QAAAnH,GAAA5lE,GACA,GAAA0H,GAAA1D,CACA,KAAA0D,EAAA,EAAA1D,EAAArH,EAAA6wE,MAAAtpE,OAAyCwD,EAAA1D,EAAS0D,IAClD,GAAA/K,EAAA6wE,MAAA9lE,GAAA4F,KAAAtN,GACA,QAGA,KAAA0H,EAAA,EAAA1D,EAAArH,EAAAokE,MAAA78D,OAAyCwD,EAAA1D,EAAS0D,IAClD,GAAA/K,EAAAokE,MAAAr5D,GAAA4F,KAAAtN,GACA,QAGA,UAWA,QAAAqtE,GAAAvwD,GACA,MAAAA,aAAArX,OAAAqX,EAAA5G,OAAA4G,EAAAzX,QACAyX,EA3LAngB,EAAAC,EAAAD,QAAAmpE,EACAnpE,EAAA0wE,SACA1wE,EAAA8wE,UACA9wE,EAAAowE,SACApwE,EAAAipE,UACAjpE,EAAAyvE,SAAA5vE,EAAA,IAMAG,EAAAokE,SACApkE,EAAA6wE,SAQA7wE,EAAAmwE,aAMA,IAMAM,GANAH,EAAA,GtBg/kBM,SAASrwE,EAAQD,GuB3+kBvB,QAAAgtB,GAAA9I,GAEA,GADAA,EAAA,GAAAA,IACAA,EAAA3c,OAAA,MACA,GAAA4I,GAAA,wHAAAE,KAAA6T,EACA,IAAA/T,EAAA,CACA,GAAAmU,GAAAjc,WAAA8H,EAAA,IACAjG,GAAAiG,EAAA,UAAAjJ,aACA,QAAAgD,GACA,YACA,WACA,UACA,SACA,QACA,MAAAoa,GAAA1X,CACA,YACA,UACA,QACA,MAAA0X,GAAA1S,CACA,aACA,WACA,UACA,SACA,QACA,MAAA0S,GAAAysD,CACA,eACA,aACA,WACA,UACA,QACA,MAAAzsD,GAAAjkB,CACA,eACA,aACA,WACA,UACA,QACA,MAAAikB,GAAAzd,CACA,oBACA,kBACA,YACA,WACA,SACA,MAAAyd,MAYA,QAAA0sD,GAAAR,GACA,MAAAA,IAAA5+D,EAAAmM,KAAAkzD,MAAAT,EAAA5+D,GAAA,IACA4+D,GAAAO,EAAAhzD,KAAAkzD,MAAAT,EAAAO,GAAA,IACAP,GAAAnwE,EAAA0d,KAAAkzD,MAAAT,EAAAnwE,GAAA,IACAmwE,GAAA3pE,EAAAkX,KAAAkzD,MAAAT,EAAA3pE,GAAA,IACA2pE,EAAA,KAWA,QAAAU,GAAAV,GACA,MAAAW,GAAAX,EAAA5+D,EAAA,QACAu/D,EAAAX,EAAAO,EAAA,SACAI,EAAAX,EAAAnwE,EAAA,WACA8wE,EAAAX,EAAA3pE,EAAA,WACA2pE,EAAA,MAOA,QAAAW,GAAAX,EAAAlsD,EAAAjhB,GACA,KAAAmtE,EAAAlsD,GACA,MAAAksD,GAAA,IAAAlsD,EAAAvG,KAAAiK,MAAAwoD,EAAAlsD,GAAA,IAAAjhB,EACA0a,KAAAqzD,KAAAZ,EAAAlsD,GAAA,IAAAjhB,EAAA,IAvHA,GAAAwD,GAAA,IACAxG,EAAA,GAAAwG,EACAkqE,EAAA,GAAA1wE,EACAuR,EAAA,GAAAm/D,EACAnkE,EAAA,OAAAgF,CAeA3R,GAAAD,QAAA,SAAAmgB,EAAAlO,GAEA,MADAA,SACA,gBAAAkO,GAAA6M,EAAA7M,GACAlO,EAAAi/D,KACAA,EAAA/wD,GACA6wD,EAAA7wD,KvBynlBM,SAASlgB,EAAQD,GwBrplBvB,kBAAAiP,QAAA2tB,OAEA38B,EAAAD,QAAA,SAAAqxE,EAAAC,GACAD,EAAAE,OAAAD,EACAD,EAAAlwC,UAAAlyB,OAAA2tB,OAAA00C,EAAAnwC,WACA9Y,aACA/kB,MAAA+tE,EACAjpC,YAAA,EACAmN,UAAA,EACAC,cAAA,MAMAv1C,EAAAD,QAAA,SAAAqxE,EAAAC,GACAD,EAAAE,OAAAD,CACA,IAAAE,GAAA,YACAA,GAAArwC,UAAAmwC,EAAAnwC,UACAkwC,EAAAlwC,UAAA,GAAAqwC,GACAH,EAAAlwC,UAAA9Y,YAAAgpD,IxB8plBM,SAASpxE,EAAQD,EAASH,GyBlrlBhC,YAMA,SAAAqpE,KACAuI,EAAArxE,KAAA0C,MALA,GAAA+mE,GAAAhqE,EAAA,IACA4xE,EAAA5xE,EAAA,GAOAgqE,GAAAX,EAAAuI,GAEAvI,EAAA/nC,UAAA8oC,mBAAA,SAAA//D,GACAA,QACApH,MAAA4uE,WAAAxnE,GAEApH,KAAA4uE,eAIAxI,EAAA/nC,UAAA+e,KAAA,SAAAh2C,EAAAsa,GAIA,QAAAmtD,KACApK,EAAAkE,eAAAvhE,EAAAynE,GAEAC,IACAA,GAAA,EACAptD,EAAAvb,MAAAnG,KAAAwE,YARA,GAAAigE,GAAAzkE,KACA8uE,GAAA,CAWA9uE,MAAAC,GAAAmH,EAAAynE,IAGAzI,EAAA/nC,UAAAqoC,KAAA,SAAAt/D,GACA,GAAAqa,GAAAzhB,KAAA4uE,WAAAxnE,EACA,IAAAqa,EAIA,OADA5b,GAAAqgB,MAAAmY,UAAA9rB,MAAAjV,KAAAkH,UAAA,GACAyD,EAAA,EAAiBA,EAAAwZ,EAAAhd,OAAsBwD,IACvCwZ,EAAAxZ,GAAA9B,MAAAnG,KAAA6F,IAIAugE,EAAA/nC,UAAAp+B,GAAAmmE,EAAA/nC,UAAAqqC,YAAAiG,EAAAtwC,UAAAw5B,iBACAuO,EAAA/nC,UAAAsqC,eAAAgG,EAAAtwC,UAAA05B,oBAEA56D,EAAAD,QAAAkpE,gBzByrlBM,SAASjpE,EAAQD,G0B3ulBvB,YAMA,SAAAyxE,KACA3uE,KAAA4uE,cAGAD,EAAAtwC,UAAAw5B,iBAAA,SAAAkX,EAAArtD,GACAqtD,IAAA/uE,MAAA4uE,aACA5uE,KAAA4uE,WAAAG,MAEA,IAAAC,GAAAhvE,KAAA4uE,WAAAG,EAEAC,GAAAlnE,QAAA4Z,MAAA,IAEAstD,IAAAvjE,QAAAiW,KAEA1hB,KAAA4uE,WAAAG,GAAAC,GAGAL,EAAAtwC,UAAA05B,oBAAA,SAAAgX,EAAArtD,GACA,GAAAstD,GAAAhvE,KAAA4uE,WAAAG,EACA,IAAAC,EAAA,CAGA,GAAA9+C,GAAA8+C,EAAAlnE,QAAA4Z,EACA,OAAAwO,MAAA,OACA8+C,EAAAvqE,OAAA,EAEAzE,KAAA4uE,WAAAG,GAAAC,EAAAz8D,MAAA,EAAA2d,GAAAzkB,OAAAujE,EAAAz8D,MAAA2d,EAAA,UAEAlwB,MAAA4uE,WAAAG,IALA,SAWAJ,EAAAtwC,UAAA4wC,cAAA,SAAA9uE,GACA,GAAAunB,GAAAvnB,EAAAiH,KACAvB,EAAAqgB,MAAAmY,UAAA9rB,MAAAjV,KAAAkH,UAAA,EAQA,IAHAxE,KAAA,KAAA0nB,IACA1nB,KAAA,KAAA0nB,GAAAvhB,MAAAnG,KAAA6F,GAEA6hB,IAAA1nB,MAAA4uE,WAGA,OADAntD,GAAAzhB,KAAA4uE,WAAAlnD,GACAzf,EAAA,EAAmBA,EAAAwZ,EAAAhd,OAAsBwD,IACzCwZ,EAAAxZ,GAAA9B,MAAAnG,KAAA6F,IAKA1I,EAAAD,QAAAyxE,G1BkvlBM,SAASxxE,EAAQD,I2B7ylBvB,SAAAyF,GAAAxF,EAAAD,QAAAyF,EAAAusE,WAAAvsE,EAAAwsE,e3BizlB8B7xE,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,I4BrzlBhC,SAAA4F,GAAA,YAUA,SAAAysE,GAAAlJ,GACA,IAAAmJ,EAAAlJ,UAAAmJ,EAAAnJ,QACA,SAAAngE,OAAA,kCAEAupE,GAAAjyE,KAAA0C,KAAAkmE,EAAA,iBAAAsJ,EAAAF,GAZA,GAAAvI,GAAAhqE,EAAA,IACAwyE,EAAAxyE,EAAA,IACAyyE,EAAAzyE,EAAA,IACAuyE,EAAAvyE,EAAA,IACAsyE,EAAAtyE,EAAA,IACAurE,EAAAvrE,EAAA,GAUAgqE,GAAAqI,EAAAG,GAEAH,EAAAjJ,QAAA,SAAAsJ,GACA,OAAAA,EAAAC,cAKApH,EAAAqH,WAIAL,EAAAnJ,UAGAiJ,EAAAhI,cAAA,gBACAgI,EAAA/H,WAAA,EAKA+H,EAAAQ,WAAAjtE,EAAA3E,SAEAb,EAAAD,QAAAkyE,I5ByzlB8B9xE,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,I6Br2lBhC,SAAAipE,GAAA,YAYA,SAAA6J,GAAAC,GACA,gBAAAtL,EAAAuL,EAAAlnE,GACAw9D,EAAA,qBAAA7B,EAAAuL,EACA,IAAAC,KACA,iBAAAD,KACAC,EAAA1L,SAAqB2L,eAAA,cAErB,IAAAC,GAAA5J,EAAAC,QAAA/B,EAAA,aACA2L,EAAA,GAAAL,GAAA,OAAAI,EAAAH,EAAAC,EAUA,OATAG,GAAA/yB,KAAA,kBAAAgzB,GAIA,MAHA/J,GAAA,SAAA+J,GACAD,EAAA,KAEA,MAAAC,GAAA,MAAAA,EACAvnE,EAAA,GAAA7C,OAAA,eAAAoqE,QAEAvnE,OAEA,WACAw9D,EAAA,SACA8J,EAAA79C,QACA69C,EAAA,IAEA,IAAA37C,GAAA,GAAAxuB,OAAA,UACAwuB,GAAA/L,KAAA,IACA5f,EAAA2rB,KAKA,QAAA+6C,GAAArJ,EAAAmK,EAAAC,EAAAR,GACAS,EAAAjzE,KAAA0C,KAAAkmE,EAAAmK,EAAAR,EAAAC,GAAAQ,EAAAR,GAzCA,GAAA/I,GAAAhqE,EAAA,IACAupE,EAAAvpE,EAAA,IACAwzE,EAAAxzE,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,iCAqCAgqE,EAAAwI,EAAAgB,GAEApzE,EAAAD,QAAAqyE,I7By2lB8BjyE,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,I8B75lBhC,SAAAipE,GAAA,YAaA,SAAAuK,GAAArK,EAAAmK,EAAAG,EAAAF,EAAAR,GACA,GAAAW,GAAAnK,EAAAC,QAAAL,EAAAmK,EACAhK,GAAAoK,EACA,IAAAhM,GAAAzkE,IACA0wE,GAAApzE,KAAA0C,KAAAkmE,EAAAsK,GAEAxwE,KAAA2wE,KAAA,GAAAC,GAAAN,EAAAG,EAAAX,GACA9vE,KAAA2wE,KAAA1wE,GAAA,mBAAA2B,GACAykE,EAAA,eAAAzkE,GACA6iE,EAAAiC,KAAA,UAAA9kE,KAEA5B,KAAA2wE,KAAAvzB,KAAA,iBAAA30B,EAAAuuB,GACAqvB,EAAA,aAAA59C,EAAAuuB,GACAytB,EAAAkM,KAAA,KACAlM,EAAAiC,KAAA,QAAAj+C,EAAAuuB,GACAytB,EAAAnyC,UA1BA,GAAAy0C,GAAAhqE,EAAA,IACAupE,EAAAvpE,EAAA,IACA2zE,EAAA3zE,EAAA,IACA6zE,EAAA7zE,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,sCAsBAgqE,EAAAwJ,EAAAG,GAEAH,EAAAlyC,UAAA/L,MAAA,WACA+zC,EAAA,SACArmE,KAAAmnE,qBACAnnE,KAAA2wE,OACA3wE,KAAA2wE,KAAA10B,QACAj8C,KAAA2wE,KAAA,MAEA3wE,KAAAg8C,QAGA7+C,EAAAD,QAAAqzE,I9Bi6lB8BjzE,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,I+Bj9lBhC,SAAAipE,GAAA,YAWA,SAAA0K,GAAAlM,EAAArlE,GACAknE,EAAA7B,GACA4B,EAAA9oE,KAAA0C,MACAA,KAAA6wE,cACA7wE,KAAAb,SACAa,KAAAwkE,MAdA,GAAAuC,GAAAhqE,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aAGAC,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,sCAWAgqE,EAAA2J,EAAAtK,GAEAsK,EAAAryC,UAAAl8B,KAAA,SAAAyD,GACAygE,EAAA,OAAAzgE,GACA5F,KAAA6wE,WAAA9oE,KAAAnC,GACA5F,KAAA8wE,UACA9wE,KAAA+wE,gBAYAL,EAAAryC,UAAA2yC,iBAAA,WACA3K,EAAA,mBACA,IACA4K,GADAxM,EAAAzkE,IAEAA,MAAA8wE,SAAA,WACAzK,EAAA,YACA5B,EAAAqM,SAAA,KACA7mC,aAAAgnC,IAEAA,EAAAnoE,WAAA,WACAu9D,EAAA,WACA5B,EAAAqM,SAAA,KACArM,EAAAsM,gBACG,KAGHL,EAAAryC,UAAA0yC,aAAA,WACA1K,EAAA,eAAArmE,KAAA6wE,WAAApsE,OACA,IAAAggE,GAAAzkE,IACA,IAAAA,KAAA6wE,WAAApsE,OAAA,GACA,GAAAsrE,GAAA,IAAA/vE,KAAA6wE,WAAAhhE,KAAA,QACA7P,MAAA8wE,SAAA9wE,KAAAb,OAAAa,KAAAwkE,IAAAuL,EAAA,SAAAv7C,GACAiwC,EAAAqM,SAAA,KACAt8C,GACA6xC,EAAA,QAAA7xC,GACAiwC,EAAAiC,KAAA,QAAAlyC,EAAA/L,MAAA,uBAAA+L,GACAiwC,EAAAqC,YAEArC,EAAAuM,qBAGAhxE,KAAA6wE,gBAIAH,EAAAryC,UAAAyoC,SAAA,WACAT,EAAA,YACArmE,KAAAmnE,sBAGAuJ,EAAAryC,UAAA2d,KAAA,WACAqqB,EAAA,QACArmE,KAAA8mE,WACA9mE,KAAA8wE,WACA9wE,KAAA8wE,WACA9wE,KAAA8wE,SAAA,OAIA3zE,EAAAD,QAAAwzE,I/Bq9lB8BpzE,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,IgC/imBhC,SAAAipE,GAAA,YAWA,SAAA4K,GAAAN,EAAAY,EAAApB,GACAzJ,EAAA6K,GACA9K,EAAA9oE,KAAA0C,MACAA,KAAAswE,WACAtwE,KAAAkxE,aACAlxE,KAAA8vE,aACA9vE,KAAAmxE,oBAfA,GAAApK,GAAAhqE,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aAGAC,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,8BAYAgqE,EAAA6J,EAAAxK,GAEAwK,EAAAvyC,UAAA8yC,kBAAA,WACA9K,EAAA,oBACA,IAAA5B,GAAAzkE,KACA2wE,EAAA3wE,KAAA2wE,KAAA,GAAA3wE,MAAAswE,SAAAtwE,KAAAkxE,WAAAlxE,KAAA8vE,WAEAa,GAAA1wE,GAAA,mBAAA2B,GACAykE,EAAA,UAAAzkE,GACA6iE,EAAAiC,KAAA,UAAA9kE,KAGA+uE,EAAAvzB,KAAA,iBAAA30B,EAAAuuB,GACAqvB,EAAA,QAAA59C,EAAAuuB,EAAAytB,EAAA2M,eACA3M,EAAAkM,OAAA,KAEAlM,EAAA2M,gBACA,YAAAp6B,EACAytB,EAAA0M,qBAEA1M,EAAAiC,KAAA,QAAAj+C,GAAA,KAAAuuB,GACAytB,EAAA0C,0BAMAyJ,EAAAvyC,UAAA4d,MAAA,WACAoqB,EAAA,SACArmE,KAAAmnE,qBACAnnE,KAAAoxE,eAAA,EACApxE,KAAA2wE,MACA3wE,KAAA2wE,KAAA10B,SAIA9+C,EAAAD,QAAA0zE,IhCmjmB8BtzE,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,IiC/mmBhC,SAAAipE,GAAA,YAWA,SAAAwJ,GAAAhL,EAAAsL,GACAzJ,EAAA7B,GACA4B,EAAA9oE,KAAA0C,KACA,IAAAykE,GAAAzkE,IAEAA,MAAAqxE,eAAA,EAEArxE,KAAAmwE,GAAA,GAAAL,GAAA,OAAAtL,EAAA,MACAxkE,KAAAmwE,GAAAlwE,GAAA,QAAAD,KAAAsxE,cAAApvE,KAAAlC,OACAA,KAAAmwE,GAAA/yB,KAAA,kBAAAgzB,EAAAt/C,GACAu1C,EAAA,SAAA+J,EAAAt/C,GACA2zC,EAAA6M,cAAAlB,EAAAt/C,GACA2zC,EAAA0L,GAAA,IACA,IAAAn5B,GAAA,MAAAo5B,EAAA,qBACA/J,GAAA,QAAArvB,GACAytB,EAAAiC,KAAA,aAAA1vB,GACAytB,EAAAqC,aAzBA,GAAAC,GAAAhqE,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aAGAC,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,mCAuBAgqE,EAAAyI,EAAApJ,GAEAoJ,EAAAnxC,UAAAizC,cAAA,SAAAlB,EAAAt/C,GAEA,GADAu1C,EAAA,gBAAA+J,GACA,MAAAA,GAAAt/C,EAIA,OAAAZ,IAAA,GAAsBlwB,KAAAqxE,gBAAAnhD,EAAA,GACtB,GAAAqhD,GAAAzgD,EAAAve,MAAAvS,KAAAqxE,eAEA,IADAnhD,EAAAqhD,EAAAzpE,QAAA,MACAooB,KAAA,EACA,KAEA,IAAAtuB,GAAA2vE,EAAAh/D,MAAA,EAAA2d,EACAtuB,KACAykE,EAAA,UAAAzkE,GACA5B,KAAA0mE,KAAA,UAAA9kE,MAKA4tE,EAAAnxC,UAAAyoC,SAAA,WACAT,EAAA,YACArmE,KAAAmnE,sBAGAqI,EAAAnxC,UAAA4d,MAAA,WACAoqB,EAAA,SACArmE,KAAAmwE,KACAnwE,KAAAmwE,GAAA79C,QACA+zC,EAAA,SACArmE,KAAA0mE,KAAA,qBACA1mE,KAAAmwE,GAAA,MAEAnwE,KAAA8mE,YAGA3pE,EAAAD,QAAAsyE,IjCmnmB8BlyE,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,GkC5rmBhC,YAMA,SAAAuyE,GAAA9zC,EAAAgpC,EAAAuL,EAAAx1D,GACAi3D,EAAAl0E,KAAA0C,KAAAw7B,EAAAgpC,EAAAuL,EAAAx1D,GALA,GAAAwsD,GAAAhqE,EAAA,IACAy0E,EAAAz0E,EAAA,GAOAgqE,GAAAuI,EAAAkC,GAEAlC,EAAAnJ,QAAAqL,EAAArL,SAAAqL,EAAAC,aAEAt0E,EAAAD,QAAAoyE,GlCmsmBM,SAASnyE,EAAQD,EAASH,ImCjtmBhC,SAAA4F,EAAAqjE,GAAA,YAcA,SAAA0L,GAAAl2C,EAAAgpC,EAAAuL,EAAAx1D,GACA8rD,EAAA7qC,EAAAgpC,EACA,IAAAC,GAAAzkE,IACAomE,GAAA9oE,KAAA0C,MAEA8I,WAAA,WACA27D,EAAAkN,OAAAn2C,EAAAgpC,EAAAuL,EAAAx1D,IACG,GAnBH,GAAA6rD,GAAArpE,EAAA,IAAAqpE,aACAW,EAAAhqE,EAAA,IACA6pE,EAAA7pE,EAAA,IACAupE,EAAAvpE,EAAA,IACA60E,EAAAjvE,EAAAkvE,eAGAxL,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,kCAaAgqE,EAAA2K,EAAAtL,GAEAsL,EAAArzC,UAAAszC,OAAA,SAAAn2C,EAAAgpC,EAAAuL,EAAAx1D,GACA,GAAAkqD,GAAAzkE,IAEA,KACAA,KAAA8xE,IAAA,GAAAF,GACG,MAAAxpE,IAEH,IAAApI,KAAA8xE,IAIA,MAHAzL,GAAA,UACArmE,KAAA0mE,KAAA,iCACA1mE,MAAA8mE,UAKAtC,GAAA8B,EAAAkE,SAAAhG,EAAA,UAAA7oB,OAIA37C,KAAA2mE,UAAAC,EAAAC,UAAA,WACAR,EAAA,kBACA5B,EAAAqC,UAAA,IAEA,KACA9mE,KAAA8xE,IAAAzhD,KAAAmL,EAAAgpC,GAAA,GACAxkE,KAAAgqC,SAAA,WAAAhqC,MAAA8xE,MACA9xE,KAAA8xE,IAAA9nC,QAAAhqC,KAAAgqC,QACAhqC,KAAA8xE,IAAAC,UAAA,WACA1L,EAAA,eACA5B,EAAAiC,KAAA,eACAjC,EAAAqC,UAAA,KAGG,MAAAp9D,GAKH,MAJA28D,GAAA,YAAA38D,GAEA1J,KAAA0mE,KAAA,mBACA1mE,MAAA8mE,UAAA,GAWA,GAPAvsD,KAAAy3D,gBAAAN,EAAAD,eACApL,EAAA,mBAIArmE,KAAA8xE,IAAAG,gBAAA,QAEA13D,KAAA+pD,QACA,OAAAv/D,KAAAwV,GAAA+pD,QACAtkE,KAAA8xE,IAAAI,iBAAAntE,EAAAwV,EAAA+pD,QAAAv/D,GAIA/E,MAAA8xE,IAAAK,mBAAA,WACA,GAAA1N,EAAAqN,IAAA,CACA,GACAhhD,GAAAs/C,EADAhoE,EAAAq8D,EAAAqN,GAGA,QADAzL,EAAA,aAAAj+D,EAAAgqE,YACAhqE,EAAAgqE,YACA,OAGA,IACAhC,EAAAhoE,EAAAgoE,OACAt/C,EAAA1oB,EAAAiqE,aACS,MAAA3oE,IACT28D,EAAA,SAAA+J,GAEA,OAAAA,IACAA,EAAA,KAIA,MAAAA,GAAAt/C,KAAArsB,OAAA,IACA4hE,EAAA,SACA5B,EAAAiC,KAAA,QAAA0J,EAAAt/C,GAEA,MACA,QACAs/C,EAAAhoE,EAAAgoE,OACA/J,EAAA,SAAA+J,GAEA,OAAAA,IACAA,EAAA,KAIA,QAAAA,GAAA,QAAAA,IACAA,EAAA,GAGA/J,EAAA,SAAA+J,EAAAhoE,EAAAiqE,cACA5N,EAAAiC,KAAA,SAAA0J,EAAAhoE,EAAAiqE,cACA5N,EAAAqC,UAAA,KAMA,KACArC,EAAAqN,IAAA3vE,KAAA4tE,GACG,MAAArmE,GACH+6D,EAAAiC,KAAA,eACAjC,EAAAqC,UAAA,KAIA4K,EAAArzC,UAAAyoC,SAAA,SAAA7qB,GAEA,GADAoqB,EAAA,WACArmE,KAAA8xE,IAAA,CAYA,GATA9xE,KAAAmnE,qBACAP,EAAAM,UAAAlnE,KAAA2mE,WAGA3mE,KAAA8xE,IAAAK,mBAAA,aACAnyE,KAAA8xE,IAAAC,YACA/xE,KAAA8xE,IAAAC,UAAA,MAGA91B,EACA,IACAj8C,KAAA8xE,IAAA71B,QACK,MAAA7zC,IAELpI,KAAA2mE,UAAA3mE,KAAA8xE,IAAA,OAGAJ,EAAArzC,UAAA/L,MAAA,WACA+zC,EAAA,SACArmE,KAAA8mE,UAAA,IAGA4K,EAAAvL,UAAAyL,CAGA,IAAAU,IAAA,UAAA7mE,OAAA,UAAAoE,KAAA,MACA6hE,EAAAvL,SAAAmM,IAAA3vE,KACA0jE,EAAA,6BACAuL,EAAA,WACA,IACA,UAAAjvE,GAAA2vE,GAAA,qBACK,MAAA5oE,GACL,cAGAgoE,EAAAvL,UAAA,GAAAyL,GAGA,IAAAW,IAAA,CACA,KACAA,EAAA,uBAAAX,GACC,MAAAY,IAEDd,EAAAD,aAAAc,EAEAp1E,EAAAD,QAAAw0E,InCqtmB8Bp0E,KAAKJ,EAAU,WAAa,MAAO8C,SAAYjD,EAAoB,MAI3F,SAASI,EAAQD,EAASH,GoCj5mBhC,YAMA,SAAAsyE,GAAA7zC,EAAAgpC,EAAAuL,GACAyB,EAAAl0E,KAAA0C,KAAAw7B,EAAAgpC,EAAAuL,GACAiC,eAAA,IANA,GAAAjL,GAAAhqE,EAAA,IACAy0E,EAAAz0E,EAAA,GASAgqE,GAAAsI,EAAAmC,GAEAnC,EAAAlJ,QAAAqL,EAAArL,QAEAhpE,EAAAD,QAAAmyE,GpCw5mBM,SAASlyE,EAAQD,IqCx6mBvB,SAAAyF,GAAA,YAEAxF,GAAAD,SACAyyE,QAAA,WACA,MAAAhtE,GAAAtE,WACA,SAAAwP,KAAAlL,EAAAtE,UAAAouE,YAGAgG,YAAA,WACA,MAAA9vE,GAAAtE,WACA,aAAAwP,KAAAlL,EAAAtE,UAAAouE,YAIAiG,UAAA,WAEA,IAAA/vE,EAAA3E,SACA,QAGA,KACA,QAAA2E,EAAA3E,SAAA20E,OACK,MAAAjpE,GACL,crC+6mB8BpM,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,GsC18mBhC,YAYA,SAAA61E,GAAA1M,GACA,IAAA2M,EAAA1M,QACA,SAAAngE,OAAA,kCAEAupE,GAAAjyE,KAAA0C,KAAAkmE,EAAA,iBAAAsJ,EAAAqD,GAdA,GAAA9L,GAAAhqE,EAAA,IACAwyE,EAAAxyE,EAAA,IACAyyE,EAAAzyE,EAAA,IACA81E,EAAA91E,EAAA,GAcAgqE,GAAA6L,EAAArD,GAEAqD,EAAAzM,QAAA,SAAAsJ,GACA,OAAAA,EAAAqD,gBAAArD,EAAAC,aAGAmD,EAAA1M,SAAAsJ,EAAAsD,aAGAH,EAAAxL,cAAA,gBACAwL,EAAAvL,WAAA,EAEAlqE,EAAAD,QAAA01E,GtCi9mBM,SAASz1E,EAAQD,EAASH,IuCh/mBhC,SAAAipE,EAAArjE,GAAA,YAkBA,SAAAkwE,GAAAr3C,EAAAgpC,EAAAuL,GACA1J,EAAA7qC,EAAAgpC,EACA,IAAAC,GAAAzkE,IACAomE,GAAA9oE,KAAA0C,MAEA8I,WAAA,WACA27D,EAAAkN,OAAAn2C,EAAAgpC,EAAAuL,IACG,GAvBH,GAAA3J,GAAArpE,EAAA,IAAAqpE,aACAW,EAAAhqE,EAAA,IACAi2E,EAAAj2E,EAAA,IACAurE,EAAAvrE,EAAA,IACAupE,EAAAvpE,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,iCAiBAgqE,EAAA8L,EAAAzM,GAEAyM,EAAAx0C,UAAAszC,OAAA,SAAAn2C,EAAAgpC,EAAAuL,GACA1J,EAAA,SACA,IAAA5B,GAAAzkE,KACAizE,EAAA,GAAAtwE,GAAAuwE,cAEA1O,GAAA8B,EAAAkE,SAAAhG,EAAA,UAAA7oB,OAEAs3B,EAAAjO,QAAA,WACAqB,EAAA,WACA5B,EAAA0O,UAEAF,EAAAlB,UAAA,WACA1L,EAAA,aACA5B,EAAA0O,UAEAF,EAAAG,WAAA,WACA/M,EAAA,WAAA4M,EAAAZ,cACA5N,EAAAiC,KAAA,YAAAuM,EAAAZ,eAEAY,EAAAI,OAAA,WACAhN,EAAA,QACA5B,EAAAiC,KAAA,aAAAuM,EAAAZ,cACA5N,EAAAqC,UAAA,IAEA9mE,KAAAizE,MACAjzE,KAAA2mE,UAAAqM,EAAAnM,UAAA,WACApC,EAAAqC,UAAA,IAEA,KAEA9mE,KAAAizE,IAAA5iD,KAAAmL,EAAAgpC,GACAxkE,KAAAgqC,UACAhqC,KAAAizE,IAAAjpC,QAAAhqC,KAAAgqC,SAEAhqC,KAAAizE,IAAA9wE,KAAA4tE,GACG,MAAA3nE,GACHpI,KAAAmzE,WAIAN,EAAAx0C,UAAA80C,OAAA,WACAnzE,KAAA0mE,KAAA,eACA1mE,KAAA8mE,UAAA,IAGA+L,EAAAx0C,UAAAyoC,SAAA,SAAA7qB,GAEA,GADAoqB,EAAA,UAAApqB,GACAj8C,KAAAizE,IAAA,CAOA,GAJAjzE,KAAAmnE,qBACA6L,EAAA9L,UAAAlnE,KAAA2mE,WAEA3mE,KAAAizE,IAAAlB,UAAA/xE,KAAAizE,IAAAjO,QAAAhlE,KAAAizE,IAAAG,WAAApzE,KAAAizE,IAAAI,OAAA,KACAp3B,EACA,IACAj8C,KAAAizE,IAAAh3B,QACK,MAAA7zC,IAELpI,KAAA2mE,UAAA3mE,KAAAizE,IAAA,OAGAJ,EAAAx0C,UAAA/L,MAAA,WACA+zC,EAAA,SACArmE,KAAA8mE,UAAA,IAIA+L,EAAA1M,WAAAxjE,EAAAuwE,iBAAA5K,EAAAoK,aAEAv1E,EAAAD,QAAA21E,IvCo/mB8Bv1E,KAAKJ,EAASH,EAAoB,IAAM,WAAa,MAAOiD,WAIpF,SAAS7C,EAAQD,EAASH,GwC5lnBhC,YASA,SAAAu2E,GAAApN,GACA,IAAAoN,EAAAnN,UACA,SAAAngE,OAAA,kCAGAupE,GAAAjyE,KAAA0C,KAAAkmE,EAAA,eAAAqN,EAAAjE,GAZA,GAAAvI,GAAAhqE,EAAA,IACAwyE,EAAAxyE,EAAA,IACAw2E,EAAAx2E,EAAA,IACAuyE,EAAAvyE,EAAA,IACAy2E,EAAAz2E,EAAA,GAWAgqE,GAAAuM,EAAA/D,GAEA+D,EAAAnN,QAAA,WACA,QAAAqN,GAGAF,EAAAlM,cAAA,cACAkM,EAAAjM,WAAA,EAEAlqE,EAAAD,QAAAo2E,GxCmmnBM,SAASn2E,EAAQD,EAASH,IyC7nnBhC,SAAAipE,GAAA,YAYA,SAAAuN,GAAA/O,GACA6B,EAAA7B,GACA4B,EAAA9oE,KAAA0C,KAEA,IAAAykE,GAAAzkE,KACAyzE,EAAAzzE,KAAAyzE,GAAA,GAAAD,GAAAhP,EACAiP,GAAAnO,UAAA,SAAA57D,GACA28D,EAAA,UAAA38D,EAAA1K,MACAylE,EAAAiC,KAAA,UAAAgN,UAAAhqE,EAAA1K,QAEAy0E,EAAAzO,QAAA,SAAAt7D,GACA28D,EAAA,QAAAoN,EAAArB,WAAA1oE,EAGA,IAAAstC,GAAA,IAAAy8B,EAAArB,WAAA,qBACA3N,GAAAqC,WACArC,EAAAkP,OAAA38B,IA1BA,GAAA+vB,GAAAhqE,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aACAoN,EAAAz2E,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,2CAuBAgqE,EAAAwM,EAAAnN,GAEAmN,EAAAl1C,UAAA4d,MAAA,WACAoqB,EAAA,SACArmE,KAAA8mE,WACA9mE,KAAA2zE,OAAA,SAGAJ,EAAAl1C,UAAAyoC,SAAA,WACAT,EAAA,UACA,IAAAoN,GAAAzzE,KAAAyzE,EACAA,KACAA,EAAAnO,UAAAmO,EAAAzO,QAAA,KACAyO,EAAAnhD,QACAtyB,KAAAyzE,GAAA,OAIAF,EAAAl1C,UAAAs1C,OAAA,SAAA38B,GACAqvB,EAAA,QAAArvB,EACA,IAAAytB,GAAAzkE,IAIA8I,YAAA,WACA27D,EAAAiC,KAAA,aAAA1vB,GACAytB,EAAA0C,sBACG,MAGHhqE,EAAAD,QAAAq2E,IzCionB8Bj2E,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,I0CnsnBvB,SAAAyF,GAAAxF,EAAAD,QAAAyF,EAAAixE,c1CusnB8Bt2E,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,I2C3snBhC,SAAA4F,GAAA,YAEA,IAAAokE,GAAAhqE,EAAA,IACA82E,EAAA92E,EAAA,IACA+2E,EAAA/2E,EAAA,GAGAI,GAAAD,QAAA,SAAA62E,GAEA,QAAAC,GAAA9N,EAAA+N,GACAJ,EAAAv2E,KAAA0C,KAAA+zE,EAAA3M,cAAAlB,EAAA+N,GAqBA,MAlBAlN,GAAAiN,EAAAH,GAEAG,EAAA7N,QAAA,SAAA3B,EAAAiL,GACA,IAAA9sE,EAAA3E,SACA,QAGA,IAAAk2E,GAAAJ,EAAAzhC,UAA0Co9B,EAE1C,OADAyE,GAAAC,YAAA,EACAJ,EAAA5N,QAAA+N,IAAAL,EAAA1N,WAGA6N,EAAA5M,cAAA,UAAA2M,EAAA3M,cACA4M,EAAApE,UAAA,EACAoE,EAAA3M,WAAAwM,EAAAxM,WAAA0M,EAAA1M,WAAA,EAEA2M,EAAAI,gBAAAL,EAEAC,K3CgtnB8B12E,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,I4CnvnBhC,SAAAipE,GAAA,YAyBA,SAAA6N,GAAAE,EAAA7N,EAAA+N,GACA,IAAAJ,EAAA1N,UACA,SAAAngE,OAAA,kCAEAogE,GAAA9oE,KAAA0C,KAEA,IAAAykE,GAAAzkE,IACAA,MAAAu3D,OAAA+O,EAAA4D,UAAA+J,GACAj0E,KAAAi0E,UACAj0E,KAAAkmE,WACAlmE,KAAA+zE,YACA/zE,KAAAq0E,SAAAlvD,EAAAxhB,OAAA,EAEA,IAAA2wE,GAAAhO,EAAAC,QAAA0N,EAAA,oBAAAj0E,KAAAq0E,QACAhO,GAAA0N,EAAA7N,EAAAoO,GAEAt0E,KAAAu0E,UAAAC,EAAAC,aAAAH,EAAA,SAAAvqE,GACAs8D,EAAA,gBACA5B,EAAAiC,KAAA,0CAAA38D,EAAA,KACA06D,EAAAnyC,UAGAtyB,KAAA00E,kBAAA10E,KAAA20E,SAAAzyE,KAAAlC,MACAgzE,EAAA1Y,YAAA,UAAAt6D,KAAA00E,mBAtCA,GAAA3N,GAAAhqE,EAAA,IACA63E,EAAA73E,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aACAoC,EAAAzrE,EAAA,IACAupE,EAAAvpE,EAAA,IACAy3E,EAAAz3E,EAAA,IACAi2E,EAAAj2E,EAAA,IACAooB,EAAApoB,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,uCA6BAgqE,EAAA8M,EAAAzN,GAEAyN,EAAAx1C,UAAA/L,MAAA,WAGA,GAFA+zC,EAAA,SACArmE,KAAAmnE,qBACAnnE,KAAAu0E,UAAA,CACAvB,EAAA1J,YAAA,UAAAtpE,KAAA00E,kBACA,KAGA10E,KAAA60E,YAAA,KACK,MAAAzsE,IACLpI,KAAAu0E,UAAAz8C,UACA93B,KAAAu0E,UAAA,KACAv0E,KAAA00E,kBAAA10E,KAAAu0E,UAAA,OAIAV,EAAAx1C,UAAAs2C,SAAA,SAAAjrE,GAEA,GADA28D,EAAA,UAAA38D,EAAA1K,OACAsnE,EAAA+D,cAAA3gE,EAAA6tD,OAAAv3D,KAAAu3D,QAEA,WADA8O,GAAA,kBAAA38D,EAAA6tD,OAAAv3D,KAAAu3D,OAIA,IAAAud,EACA,KACAA,EAAAF,EAAA1qD,MAAAxgB,EAAA1K,MACG,MAAAwzE,GAEH,WADAnM,GAAA,WAAA38D,EAAA1K,MAIA,GAAA81E,EAAAT,WAAAr0E,KAAAq0E,SAEA,WADAhO,GAAA,uBAAAyO,EAAAT,SAAAr0E,KAAAq0E,SAIA,QAAAS,EAAA1tE,MACA,QACApH,KAAAu0E,UAAAl3E,SAEA2C,KAAA60E,YAAA,IAAAD,EAAA54D,WACAwsD,EACAxoE,KAAA+zE,UACA/zE,KAAAkmE,SACAlmE,KAAAi0E,UAEA,MACA,SACAj0E,KAAA0mE,KAAA,UAAAoO,EAAA91E,KACA,MACA,SACA,GAAA+1E,EACA,KACAA,EAAAH,EAAA1qD,MAAA4qD,EAAA91E,MACK,MAAAwzE,GAEL,WADAnM,GAAA,WAAAyO,EAAA91E,MAGAgB,KAAA0mE,KAAA,QAAAqO,EAAA,GAAAA,EAAA,IACA/0E,KAAAsyB,UAKAuhD,EAAAx1C,UAAAw2C,YAAA,SAAAztE,EAAApI,GACAqnE,EAAA,cAAAj/D,EAAApI,GACAgB,KAAAu0E,UAAAS,KAAAJ,EAAA54D,WACAq4D,SAAAr0E,KAAAq0E,SACAjtE,OACApI,QAAA,KACGgB,KAAAu3D,SAGHsc,EAAAx1C,UAAAl8B,KAAA,SAAAyD,GACAygE,EAAA,OAAAzgE,GACA5F,KAAA60E,YAAA,IAAAjvE,IAGAiuE,EAAA1N,QAAA,WACA,MAAAqO,GAAAS,eAGApB,EAAAzM,cAAA,SACAyM,EAAAxM,WAAA,EAEAlqE,EAAAD,QAAA22E,I5CuvnB8Bv2E,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,GAE/B,GAAIm4E,I6Cv4nBL,SAAA/3E,EAAAwF,IACC,WA2BD,QAAAwyE,GAAAvnE,EAAA1Q,GAuCA,QAAAkZ,GAAA7V,GACA,GAAA6V,EAAA7V,KAAA60E,EAEA,MAAAh/D,GAAA7V,EAEA,IAAA80E,EACA,6BAAA90E,EAGA80E,EAAA,gBACO,YAAA90E,EAGP80E,EAAAj/D,EAAA,mBAAAA,EAAA,kBACO,CACP,GAAA5V,GAAA80E,EAAA,oDAEA,sBAAA/0E,EAAA,CACA,GAAAyb,GAAA9e,EAAA8e,UAAAu5D,EAAA,kBAAAv5D,IAAAw5D,CACA,IAAAD,EAAA,EAEA/0E,EAAA,WACA,WACai1E,OAAAj1E,CACb,KACA+0E,EAGA,MAAAv5D,EAAA,IAGA,MAAAA,EAAA,GAAA05D,KACA,MAAA15D,EAAA,GAAAsS,KAKAtS,EAAA25D,KAAAP,GAGAp5D,EAAAo5D,QAGAp5D,MAAAo5D,GAMA,MAAAp5D,EAAAxb,IACA,OAAAwb,GAAAxb,KAGA,UAAAwb,GAAAo5D,KAEA,QAAAp5D,EAAA,OAKA,oBAAAA,GAAAo5D,EAAAO,EAAA,QAGA35D,GAA2B7W,GAAA3E,GAAA,6BAAoD80E,GAE/E,MAAAt5D,EAAA,KAAAxb,IACA,iBAAAwb,GAAA,cAGA,iCAAAA,EAAA,GAAA2/B,IAAA,UAEA,iCAAA3/B,EAAA,GAAA2/B,GAAA,UAGA,iCAAA3/B,EAAA,GAAA2/B,IAAA,eAGA,8BAAA3/B,EAAA,GAAA2/B,IAAA,IACa,MAAA4wB,GACbgJ,GAAA,GAGAF,EAAAE,EAGA,iBAAAh1E,EAAA,CACA,GAAA2pB,GAAAhtB,EAAAgtB,KACA,sBAAAA,GACA,IAIA,OAAAA,EAAA,OAAAA,GAAA,IAEA1pB,EAAA0pB,EAAAorD,EACA,IAAAM,GAAA,GAAAp1E,EAAA,EAAAiE,QAAA,IAAAjE,EAAA,IACA,IAAAo1E,EAAA,CACA,IAEAA,GAAA1rD,EAAA,QACmB,MAAAqiD,IACnB,GAAAqJ,EACA,IAIAA,EAAA,IAAA1rD,EAAA,MACqB,MAAAqiD,IAErB,GAAAqJ,EACA,IAIAA,EAAA,IAAA1rD,EAAA,MACqB,MAAAqiD,OAIR,MAAAA,GACbqJ,GAAA,EAGAP,EAAAO,GAGA,MAAAx/D,GAAA7V,KAAA80E,EApKAznE,MAAAzP,EAAA,UACAjB,MAAAiB,EAAA,SAGA,IAAAu3E,GAAA9nE,EAAA,QAAAzP,EAAA,OACAmwB,EAAA1gB,EAAA,QAAAzP,EAAA,OACAgO,EAAAyB,EAAA,QAAAzP,EAAA,OACAw9C,EAAA/tC,EAAA,MAAAzP,EAAA,KACA03E,EAAAjoE,EAAA,aAAAzP,EAAA,YACAqL,EAAAoE,EAAA,WAAAzP,EAAA,UACA8c,EAAArN,EAAA,MAAAzP,EAAA,KACA23E,EAAAloE,EAAA,MAAAzP,EAAA,IAGA,iBAAA23E,QACA54E,EAAA8e,UAAA85D,EAAA95D,UACA9e,EAAAgtB,MAAA4rD,EAAA5rD,MAIA,IAEA6rD,GAAApxE,EAAAywE,EAFAY,EAAA7pE,EAAAkyB,UACAs3C,EAAAK,EAAAvyE,SAIA+xE,EAAA,GAAA75B,IAAA,gBACA,KAGA65B,IAAAS,mBAAA,YAAAT,EAAAU,eAAA,IAAAV,EAAAW,cAIA,IAAAX,EAAAY,eAAA,IAAAZ,EAAAa,iBAAA,GAAAb,EAAAc,iBAAA,KAAAd,EAAAe,qBACK,MAAAhK,IAqIL,IAAAn2D,EAAA,SAEA,GAAAogE,GAAA,oBACAC,EAAA,gBACAC,EAAA,kBACAC,EAAA,kBACAC,EAAA,iBACAC,EAAA,mBAGAC,EAAA1gE,EAAA,wBAGA,KAAAo/D,EACA,GAAAtwD,GAAAjK,EAAAiK,MAGA6xD,GAAA,4CAGAC,EAAA,SAAAC,EAAAC,GACA,MAAAH,GAAAG,GAAA,KAAAD,EAAA,MAAA/xD,GAAA+xD,EAAA,MAAAC,MAAA,QAAAhyD,GAAA+xD,EAAA,KAAAC,GAAA,KAAAhyD,GAAA+xD,EAAA,KAAAC,GAAA,KAwHA,KAlHAnB,EAAAC,EAAArnE,kBACAonE,EAAA,SAAAlV,GACA,GAA0Bt7C,GAA1B2N,IA4BA,QA3BAA,EAAA4iC,UAAA,KAAA5iC,EAAA4iC,WAGAryD,SAAA,GACWyvB,GAAAzvB,UAAAkyE,EAGXI,EAAA,SAAAlV,GAIA,GAAAxgE,GAAAL,KAAA81D,UAAA7sD,EAAA43D,KAAA7gE,KAAA81D,UAAA,KAAA91D,KAGA,OADAA,MAAA81D,UAAAz1D,EACA4I,IAIAsc,EAAA2N,EAAA3N,YAGAwwD,EAAA,SAAAlV,GACA,GAAA75D,IAAAhH,KAAAulB,gBAAA8Y,SACA,OAAAwiC,KAAA7gE,SAAA6gE,IAAA75D,IAAAhH,KAAA6gE,KAAA75D,EAAA65D,MAGA3tC,EAAA,KACA6iD,EAAAz4E,KAAA0C,KAAA6gE,KAMAl8D,EAAA,SAAA+C,EAAAmB,GACA,GAAAsuE,GAAAjkD,EAAA2tC,EAAAuW,EAAA,GAKAD,EAAA,WACAn3E,KAAAusC,QAAA,IACSlO,UAAAkO,QAAA,EAGTrZ,EAAA,GAAAikD,EACA,KAAAtW,IAAA3tC,GAEA6iD,EAAAz4E,KAAA41B,EAAA2tC,IACAuW,GAsDA,OAnDAD,GAAAjkD,EAAA,KAGAkkD,EAoBAzyE,EAFS,GAAAyyE,EAET,SAAA1vE,EAAAmB,GAEA,GAA4Bg4D,GAA5B3tC,KAA4BmkD,EAAA1B,EAAAr4E,KAAAoK,IAAA8uE,CAC5B,KAAA3V,IAAAn5D,GAIA2vE,GAAA,aAAAxW,GAAAkV,EAAAz4E,KAAA41B,EAAA2tC,MAAA3tC,EAAA2tC,GAAA,KAAAkV,EAAAz4E,KAAAoK,EAAAm5D,IACAh4D,EAAAg4D,IAMA,SAAAn5D,EAAAmB,GACA,GAAAg4D,GAAAyW,EAAAD,EAAA1B,EAAAr4E,KAAAoK,IAAA8uE,CACA,KAAA3V,IAAAn5D,GACA2vE,GAAA,aAAAxW,IAAAkV,EAAAz4E,KAAAoK,EAAAm5D,KAAAyW,EAAA,gBAAAzW,IACAh4D,EAAAg4D,IAKAyW,GAAAvB,EAAAz4E,KAAAoK,EAAAm5D,EAAA,iBACAh4D,EAAAg4D,KA1CA3tC,GAAA,6GAGAvuB,EAAA,SAAA+C,EAAAmB,GACA,GAAAg4D,GAAAp8D,EAAA4yE,EAAA1B,EAAAr4E,KAAAoK,IAAA8uE,EACAe,GAAAF,GAAA,kBAAA3vE,GAAA6d,aAAAiyD,QAAA9vE,GAAAiH,iBAAAjH,EAAAiH,gBAAAonE,CACA,KAAAlV,IAAAn5D,GAGA2vE,GAAA,aAAAxW,IAAA0W,EAAAj6E,KAAAoK,EAAAm5D,IACAh4D,EAAAg4D,EAIA,KAAAp8D,EAAAyuB,EAAAzuB,OAAyCo8D,EAAA3tC,IAAAzuB,GAA8B8yE,EAAAj6E,KAAAoK,EAAAm5D,IAAAh4D,EAAAg4D,OAgCvEl8D,EAAA+C,EAAAmB,KASAuN,EAAA,mBAEA,GAAAqhE,IACAC,GAAA,OACAC,GAAA,MACAC,EAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,EAAA,OAKAC,EAAA,SACAC,EAAA,SAAAC,EAAA33E,GAGA,OAAAy3E,GAAAz3E,GAAA,IAAA+R,OAAA4lE,IAOAC,EAAA,QACAC,EAAA,SAAA73E,GAGA,IAFA,GAAAyI,GAAA,IAAApB,EAAA,EAAApD,EAAAjE,EAAAiE,OAAA6zE,GAAAxB,GAAAryE,EAAA,GACA8zE,EAAAD,IAAAxB,EAAAt2E,EAAAiY,MAAA,IAAAjY,GACgBqH,EAAApD,EAAgBoD,IAAA,CAChC,GAAA2wE,GAAAh4E,EAAAypB,WAAApiB,EAGA,QAAA2wE,GACA,sDACAvvE,GAAAwuE,EAAAe,EACA,MACA,SACA,GAAAA,EAAA,IACAvvE,GAAAmvE,EAAAF,EAAA,EAAAM,EAAA/0E,SAAA,IACA,OAEAwF,GAAAqvE,EAAAC,EAAA1wE,GAAArH,EAAAwD,OAAA6D,IAGA,MAAAoB,GAAA,KAKAwvE,EAAA,SAAA5X,EAAAn5D,EAAAmB,EAAA4sC,EAAAijC,EAAAC,EAAAliE,GACA,GAAAjW,GAAAgjC,EAAAyzC,EAAAC,EAAA0B,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAjvE,EAAApC,EAAApD,EAAA0U,EAAAlQ,CACA,KAEAzI,EAAAkH,EAAAm5D,GACW,MAAA0L,IACX,mBAAA/rE,MAEA,GADAgjC,EAAAmyC,EAAAr4E,KAAAkD,GACAgjC,GAAAizC,GAAAV,EAAAz4E,KAAAkD,EAAA,UA4Ca,kBAAAA,GAAAi1E,SAAAjyC,GAAAkzC,GAAAlzC,GAAAmzC,GAAAnzC,GAAAozC,GAAAb,EAAAz4E,KAAAkD,EAAA,aAKbA,IAAAi1E,OAAA5U,QAhDA,IAAArgE,GAAA,KAAAA,EAAA,KAIA,GAAAw2E,EAAA,CAKA,IADA4B,EAAA1zD,EAAA1kB,EAAA,OACAy2E,EAAA/xD,EAAA0zD,EAAA,iBAAgE5B,EAAAC,EAAA,MAAA2B,EAA6B3B,KAC7F,IAAAC,EAAAhyD,GAAA0zD,EAAA5B,EAAAC,EAAA,WAAuED,EAAAC,EAAAC,EAAA,IAAA0B,EAAiC1B,KACxG0B,EAAA,EAAAA,EAAA5B,EAAAC,EAAAC,GAKA2B,GAAAr4E,EAAA,mBAGAs4E,EAAA5zD,EAAA2zD,EAAA,SACAE,EAAA7zD,EAAA2zD,EAAA,QACAG,EAAA9zD,EAAA2zD,EAAA,QACAI,EAAAJ,EAAA,QAEA5B,GAAAz2E,EAAAy1E,iBACAiB,EAAA12E,EAAA01E,cACA0C,EAAAp4E,EAAA21E,aACA2C,EAAAt4E,EAAA41E,cACA2C,EAAAv4E,EAAA61E,gBACA2C,EAAAx4E,EAAA81E,gBACA2C,EAAAz4E,EAAA+1E,oBAGA/1E,IAAAy2E,GAAA,GAAAA,GAAA,KAAAA,EAAA,WAAAiB,EAAA,EAAAjB,EAAA,GAAAA,KAAAiB,EAAA,EAAAjB,IACA,IAAAiB,EAAA,EAAAhB,EAAA,OAAAgB,EAAA,EAAAU,GAGA,IAAAV,EAAA,EAAAY,GAAA,IAAAZ,EAAA,EAAAa,GAAA,IAAAb,EAAA,EAAAc,GAEA,IAAAd,EAAA,EAAAe,GAAA,QAEAz4E,GAAA,IAeA,IALAqI,IAGArI,EAAAqI,EAAAvL,KAAAoK,EAAAm5D,EAAArgE,IAEA,OAAAA,EACA,YAGA,IADAgjC,EAAAmyC,EAAAr4E,KAAAkD,GACAgjC,GAAAqzC,EAEA,SAAAr2E,CACW,IAAAgjC,GAAAkzC,EAGX,MAAAl2E,IAAA,KAAAA,EAAA,OAAAA,EAAA,MACW,IAAAgjC,GAAAmzC,EAEX,MAAA0B,GAAA,GAAA73E,EAGA,oBAAAA,GAAA,CAGA,IAAAiE,EAAAgS,EAAAhS,OAAuCA,KACvC,GAAAgS,EAAAhS,KAAAjE,EAEA,KAAAgJ,IASA,IALAiN,EAAA1O,KAAAvH,GACA04E,KAEA//D,EAAAw/D,EACAA,GAAAD,EACAl1C,GAAAozC,EAAA,CAEA,IAAA/uE,EAAA,EAAApD,EAAAjE,EAAAiE,OAAoDoD,EAAApD,EAAgBoD,IACpEoC,EAAAwuE,EAAA5wE,EAAArH,EAAAqI,EAAA4sC,EAAAijC,EAAAC,EAAAliE,GACAyiE,EAAAnxE,KAAAkC,IAAAmrE,EAAA,OAAAnrE,EAEAhB,GAAAiwE,EAAAz0E,OAAAi0E,EAAA,MAAAC,EAAAO,EAAArpE,KAAA,MAAA8oE,GAAA,KAAAx/D,EAAA,QAAA+/D,EAAArpE,KAAA,kBAKAlL,GAAA8wC,GAAAj1C,EAAA,SAAAqgE,GACA,GAAA52D,GAAAwuE,EAAA5X,EAAArgE,EAAAqI,EAAA4sC,EAAAijC,EAAAC,EAAAliE,EACAxM,KAAAmrE,GAOA8D,EAAAnxE,KAAAswE,EAAAxX,GAAA,KAAA6X,EAAA,QAAAzuE,KAGAhB,EAAAiwE,EAAAz0E,OAAAi0E,EAAA,MAAwDC,EAAAO,EAAArpE,KAAA,MAAA8oE,GAAA,KAAAx/D,EAAA,IAA0E,IAAO+/D,EAAArpE,KAAA,SAA0B,IAInK,OADA4G,GAAAtF,MACAlI,GAKA/L,GAAA8e,UAAA,SAAApX,EAAA2b,EAAA43D,GACA,GAAAO,GAAA7vE,EAAA4sC,EAAAjS,CACA,IAAAg0C,QAAAj3D,OACA,IAAAijB,EAAAmyC,EAAAr4E,KAAAijB,KAAAi2D,EACA3tE,EAAA0X,MACa,IAAAijB,GAAAozC,EAAA,CAEbnhC,IACA,QAAAj1C,GAAAqH,EAAA,EAAApD,EAAA8b,EAAA9b,OAAgEoD,EAAApD,EAAgBjE,EAAA+f,EAAA1Y,KAAA27B,EAAAmyC,EAAAr4E,KAAAkD,IAAAgjC,GAAAmzC,GAAAnzC,GAAAkzC,KAAAjhC,EAAAj1C,GAAA,KAGhF,GAAA23E,EACA,IAAA30C,EAAAmyC,EAAAr4E,KAAA66E,KAAAzB,GAGA,IAAAyB,KAAA,KACA,IAAAO,EAAA,GAAAP,EAAA,KAAAA,EAAA,IAAiEO,EAAAj0E,OAAA0zE,EAA2BO,GAAA,UAE/El1C,IAAAmzC,IACb+B,EAAAP,EAAA1zE,QAAA,GAAA0zE,IAAA5lE,MAAA,MAMA,OAAAkmE,GAAA,IAAAj4E,KAA0CA,EAAA,IAAAoE,EAAApE,GAAAqI,EAAA4sC,EAAAijC,EAAA,QAK1C,IAAAtiE,EAAA,eACA,GAgBA+iE,GAAAC,EAhBA5pB,EAAAlhC,EAAAkhC,aAIA6pB,GACA3B,GAAA,KACAC,GAAA,IACA2B,GAAA,IACAC,GAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,KACAC,IAAA,MAOA19B,EAAA,WAEA,KADAk9B,GAAAC,EAAA,KACAvD,KAMA+D,EAAA,WAEA,IADA,GAAAp5E,GAAAsoC,EAAA+wC,EAAAC,EAAAtB,EAAA5zE,EAAAw0E,EAAA30E,EAAAG,EAAAH,OACA00E,EAAA10E,GAEA,OADA+zE,EAAA5zE,EAAAqlB,WAAAkvD,IAEA,+BAGAA,GACA,MACA,mDAKA,MAFA34E,GAAAs2E,EAAAlyE,EAAAZ,OAAAm1E,GAAAv0E,EAAAu0E,GACAA,IACA34E,CACA,SAKA,IAAAA,EAAA,IAAA24E,IAA0CA,EAAA10E,GAE1C,GADA+zE,EAAA5zE,EAAAqlB,WAAAkvD,GACAX,EAAA,GAGAv8B,QACmB,QAAAu8B,EAKnB,OADAA,EAAA5zE,EAAAqlB,aAAAkvD,IAEA,oEAEA34E,GAAA64E,EAAAb,GACAW,GACA,MACA,UAKA,IADArwC,IAAAqwC,EACAU,EAAAV,EAAA,EAAkDA,EAAAU,EAAkBV,IACpEX,EAAA5zE,EAAAqlB,WAAAkvD,GAGAX,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,KAAAA,GAAA,IAAAA,GAAA,IAEAv8B,GAIAz7C,IAAAgvD,EAAA,KAAA5qD,EAAA2N,MAAAu2B,EAAAqwC,GACA,MACA,SAEAl9B,QAEmB,CACnB,OAAAu8B,EAGA,KAKA,KAHAA,EAAA5zE,EAAAqlB,WAAAkvD,GACArwC,EAAAqwC,EAEAX,GAAA,QAAAA,GAAA,IAAAA,GACAA,EAAA5zE,EAAAqlB,aAAAkvD,EAGA34E,IAAAoE,EAAA2N,MAAAu2B,EAAAqwC,GAGA,OAAAv0E,EAAAqlB,WAAAkvD,GAGA,MADAA,KACA34E,CAGAy7C,IACA,SASA,GAPAnT,EAAAqwC,EAEA,IAAAX,IACAsB,GAAA,EACAtB,EAAA5zE,EAAAqlB,aAAAkvD,IAGAX,GAAA,IAAAA,GAAA,IAQA,IANA,IAAAA,MAAA5zE,EAAAqlB,WAAAkvD,EAAA,GAAAX,GAAA,IAAAA,GAAA,KAEAv8B,IAEA69B,GAAA,EAEwBX,EAAA10E,IAAA+zE,EAAA5zE,EAAAqlB,WAAAkvD,GAAAX,GAAA,IAAAA,GAAA,IAA6FW,KAGrH,OAAAv0E,EAAAqlB,WAAAkvD,GAAA,CAGA,IAFAU,IAAAV,EAE0BU,EAAAp1E,IAAA+zE,EAAA5zE,EAAAqlB,WAAA4vD,GAAArB,GAAA,IAAAA,GAAA,IAAmGqB,KAC7HA,GAAAV,GAEAl9B,IAEAk9B,EAAAU,EAKA,GADArB,EAAA5zE,EAAAqlB,WAAAkvD,GACA,KAAAX,GAAA,IAAAA,EAAA,CAQA,IAPAA,EAAA5zE,EAAAqlB,aAAAkvD,GAGA,IAAAX,GAAA,IAAAA,GACAW,IAGAU,EAAAV,EAA0CU,EAAAp1E,IAAA+zE,EAAA5zE,EAAAqlB,WAAA4vD,GAAArB,GAAA,IAAAA,GAAA,IAAmGqB,KAC7IA,GAAAV,GAEAl9B,IAEAk9B,EAAAU,EAGA,OAAAj1E,EAAA2N,MAAAu2B,EAAAqwC,GAOA,GAJAW,GACA79B,IAGA,QAAAr3C,EAAA2N,MAAA4mE,IAAA,GAEA,MADAA,IAAA,GACA,CACiB,aAAAv0E,EAAA2N,MAAA4mE,IAAA,GAEjB,MADAA,IAAA,GACA,CACiB,YAAAv0E,EAAA2N,MAAA4mE,IAAA,GAEjB,MADAA,IAAA,EACA,IAGAl9B,KAKA,WAIAv7C,EAAA,SAAAF,GACA,GAAA04E,GAAAa,CAKA,IAJA,KAAAv5E,GAEAy7C,IAEA,gBAAAz7C,GAAA,CACA,SAAAs2E,EAAAt2E,EAAAwD,OAAA,GAAAxD,EAAA,IAEA,MAAAA,GAAA+R,MAAA,EAGA,SAAA/R,EAAA,CAGA,IADA04E,KAEA14E,EAAAo5E,IAEA,KAAAp5E,EAHqBu5E,OAAA,GASrBA,IACA,KAAAv5E,GACAA,EAAAo5E,IACA,KAAAp5E,GAEAy7C,KAIAA,KAIA,KAAAz7C,GACAy7C,IAEAi9B,EAAAnxE,KAAArH,EAAAF,GAEA,OAAA04E,GACa,QAAA14E,EAAqB,CAGlC,IADA04E,KAEA14E,EAAAo5E,IAEA,KAAAp5E,EAHqBu5E,OAAA,GAQrBA,IACA,KAAAv5E,GACAA,EAAAo5E,IACA,KAAAp5E,GAEAy7C,KAIAA,KAMA,KAAAz7C,GAAA,gBAAAA,IAAA,MAAAs2E,EAAAt2E,EAAAwD,OAAA,GAAAxD,EAAA,UAAAo5E,KACA39B,IAEAi9B,EAAA14E,EAAA+R,MAAA,IAAA7R,EAAAk5E,IAEA,OAAAV,GAGAj9B,IAEA,MAAAz7C,IAIAiM,EAAA,SAAA7H,EAAAi8D,EAAAh4D,GACA,GAAAoB,GAAA+vE,EAAAp1E,EAAAi8D,EAAAh4D,EACAoB,KAAAmrE,QACAxwE,GAAAi8D,GAEAj8D,EAAAi8D,GAAA52D,GAOA+vE,EAAA,SAAAp1E,EAAAi8D,EAAAh4D,GACA,GAAApE,GAAAjE,EAAAoE,EAAAi8D,EACA,oBAAArgE,MAIA,GAAAm1E,EAAAr4E,KAAAkD,IAAAo2E,EACA,IAAAnyE,EAAAjE,EAAAiE,OAAyCA,KACzCgI,EAAAjM,EAAAiE,EAAAoE,OAGAlE,GAAAnE,EAAA,SAAAqgE,GACAp0D,EAAAjM,EAAAqgE,EAAAh4D,IAIA,OAAAA,GAAAvL,KAAAsH,EAAAi8D,EAAArgE,GAIAtD,GAAAgtB,MAAA,SAAAtlB,EAAAiE,GACA,GAAAI,GAAAzI,CAUA,OATA24E,GAAA,EACAC,EAAA,GAAAx0E,EACAqE,EAAAvI,EAAAk5E,KAEA,KAAAA,KACA39B,IAGAk9B,EAAAC,EAAA,KACAvwE,GAAA8sE,EAAAr4E,KAAAuL,IAAA2tE,EAAAwD,GAAAx5E,KAAwFA,EAAA,IAAAyI,EAAAzI,GAAA,GAAAqI,GAAAI,IAMxF,MADA/L,GAAA,aAAAi4E,EACAj4E,EA31BA,GAAA+8E,GAAAl9E,EAAA,IAGAy6E,GACA0C,UAAA,EACAxyE,QAAA,GAIAyyE,EAAA3C,QAAAt6E,WAAAiG,UAAAjG,EAMAiB,EAAAq5E,QAAAn2E,kBAAArB,KACAo6E,EAAAD,GAAA3C,QAAAr6E,WAAAgG,UAAA,gBAAAR,KA80BA,KA50BAy3E,KAAA,SAAAA,KAAA,SAAAA,KAAA,OAAAA,IACAj8E,EAAAi8E,GA20BAD,IAAAF,EAEA9E,EAAAh3E,EAAAg8E,OACG,CAEH,GAAArE,GAAA33E,EAAA4d,KACAs+D,EAAAl8E,EAAA,MACAm8E,GAAA,EAEA1F,EAAAO,EAAAh3E,IAAA,OAGAo8E,WAAA,WAOA,MANAD,KACAA,GAAA,EACAn8E,EAAA4d,KAAA+5D,EACA33E,EAAA,MAAAk8E,EACAvE,EAAAuE,EAAA,MAEAzF,IAIAz2E,GAAA4d,MACAmO,MAAA0qD,EAAA1qD,MACAlO,UAAA44D,EAAA54D,WAKAi+D,IACA/E,EAAA,WACA,MAAAN,IACKt3E,KAAAJ,EAAAH,EAAAG,EAAAC,KAAAkL,SAAA6sE,IAAA/3E,EAAAD,QAAAg4E,OAEJ53E,KAAA0C,Q7Cy4nB6B1C,KAAKJ,EAASH,EAAoB,IAAII,GAAU,WAAa,MAAO6C,WAI5F,SAAS7C,EAAQD,G8ClxpBvBC,EAAAD,QAAA,SAAAC,GAQA,MAPAA,GAAAq9E,kBACAr9E,EAAAugC,UAAA,aACAvgC,EAAAs9E,SAEAt9E,EAAAqO,YACArO,EAAAq9E,gBAAA,GAEAr9E,I9C0xpBM,SAASA,EAAQD,I+ClypBvB,SAAAw9E,GAAAv9E,EAAAD,QAAAw9E,I/CsypB8Bp9E,KAAKJ,OAI7B,SAASC,EAAQD,GgD1ypBvBC,EAAAD,QAAA,ShDgzpBM,SAASC,EAAQD,EAASH,IiDhzpBhC,SAAAipE,EAAArjE,GAAA,YAEA,IAAAqwE,GAAAj2E,EAAA,IACA63E,EAAA73E,EAAA,IACAurE,EAAAvrE,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,mCAGAI,EAAAD,SACAy9E,QAAA,MACAC,gBAAA,KAEAC,uBAAA,WACA19E,EAAAD,QAAAy9E,UAAAh4E,KACAA,EAAAxF,EAAAD,QAAAy9E,cAIA9F,YAAA,SAAAztE,EAAApI,GACA2D,EAAAqE,SAAArE,EACAA,EAAAqE,OAAA6tE,YAAAD,EAAA54D,WACAq4D,SAAAl3E,EAAAD,QAAA09E,gBACAxzE,OACApI,QAAA,KACO,KAEPqnE,EAAA,wCAAAj/D,EAAApI,IAIAy1E,aAAA,SAAAH,EAAAwG,GACA,GACA7J,GAAAtK,EADAoU,EAAAp4E,EAAA3E,SAAAwwC,cAAA,UAEAwsC,EAAA,WACA3U,EAAA,YACAp8B,aAAAgnC,EAEA,KACA8J,EAAA1H,OAAA,KACO,MAAAjrE,IACP2yE,EAAA/V,QAAA,MAEAltC,EAAA,WACAuuC,EAAA,WACA0U,IACAC,IAIAlyE,WAAA,WACAiyE,GACAA,EAAAz3E,WAAAC,YAAAw3E,GAEAA,EAAA,MACS,GACT/H,EAAA9L,UAAAP,KAGA3B,EAAA,SAAAxwC,GACA6xC,EAAA,UAAA7xC,GACAumD,IACAjjD,IACAgjD,EAAAtmD,KAGAwgD,EAAA,SAAApzE,EAAA21D,GACA8O,EAAA,OAAAzkE,EAAA21D,EACA,KAGAzuD,WAAA,WACAiyE,KAAAE,eACAF,EAAAE,cAAApG,YAAAjzE,EAAA21D,IAES,GACF,MAAAnvD,KAuBP,OApBA2yE,GAAAG,IAAA5G,EACAyG,EAAAt4D,MAAA04D,QAAA,OACAJ,EAAAt4D,MAAAo3D,SAAA,WACAkB,EAAA/V,QAAA,WACAA,EAAA,YAEA+V,EAAA1H,OAAA,WACAhN,EAAA,UAGAp8B,aAAAgnC,GACAA,EAAAnoE,WAAA,WACAk8D,EAAA;EACO,MAEPriE,EAAA3E,SAAA8D,KAAA6sC,YAAAosC,GACA9J,EAAAnoE,WAAA,WACAk8D,EAAA,YACK,MACL2B,EAAAqM,EAAAnM,UAAA/uC,IAEAk9C,OACAl9C,UACAz6B,OAAA29E,IAMAI,eAAA,SAAA9G,EAAAwG,GACA,GAEA7J,GAAAtK,EACAoU,EAHAzI,GAAA,UAAA7mE,OAAA,UAAAoE,KAAA,KACA/M,EAAA,GAAAH,GAAA2vE,GAAA,YAGA0I,EAAA,WACA/wC,aAAAgnC,GACA8J,EAAA/V,QAAA,MAEAltC,EAAA,WACAh1B,IACAk4E,IACAhI,EAAA9L,UAAAP,GACAoU,EAAAz3E,WAAAC,YAAAw3E,GACAA,EAAAj4E,EAAA,KACAu4E,mBAGArW,EAAA,SAAAj7D,GACAs8D,EAAA,UAAAt8D,GACAjH,IACAg1B,IACAgjD,EAAA/wE,KAGAirE,EAAA,SAAApzE,EAAA21D,GACA,IAGAzuD,WAAA,WACAiyE,KAAAE,eACAF,EAAAE,cAAApG,YAAAjzE,EAAA21D,IAES,GACF,MAAAnvD,KAGPtF,GAAAutB,OACAvtB,EAAAw4E,MAAA,kCACA34E,EAAA3E,SAAA20E,OAAA,sBAEA7vE,EAAAwvB,QACAxvB,EAAAy4E,aAAAp+E,EAAAD,QAAAy9E,SAAAh4E,EAAAxF,EAAAD,QAAAy9E,QACA,IAAAn9E,GAAAsF,EAAA0rC,cAAA,MAYA,OAXA1rC,GAAAhB,KAAA6sC,YAAAnxC,GACAu9E,EAAAj4E,EAAA0rC,cAAA,UACAhxC,EAAAmxC,YAAAosC,GACAA,EAAAG,IAAA5G,EACAyG,EAAA/V,QAAA,WACAA,EAAA,YAEAiM,EAAAnoE,WAAA,WACAk8D,EAAA,YACK,MACL2B,EAAAqM,EAAAnM,UAAA/uC,IAEAk9C,OACAl9C,UACAz6B,OAAA29E,KAKA79E,EAAAD,QAAA+3E,eAAA,EACAtyE,EAAA3E,WAGAb,EAAAD,QAAA+3E,eAAA,kBAAAtyE,GAAAkyE,aACA,gBAAAlyE,GAAAkyE,eAAAvM,EAAAmK,iBjDqzpB8Bn1E,KAAKJ,EAASH,EAAoB,IAAM,WAAa,MAAOiD,WAIpF,SAAS7C,EAAQD,GkD5+pBvB,YAEAC,GAAAD,SACAuI,SAAA,SAAA9H,GACA,GAAAyJ,SAAAzJ,EACA,oBAAAyJ,GAAA,WAAAA,KAAAzJ,GAGA00C,OAAA,SAAA10C,GACA,IAAAqC,KAAAyF,SAAA9H,GACA,MAAAA,EAGA,QADAiH,GAAAF,EACAuD,EAAA,EAAAxD,EAAAD,UAAAC,OAA8CwD,EAAAxD,EAAYwD,IAAA,CAC1DrD,EAAAJ,UAAAyD,EACA,KAAAvD,IAAAE,GACAuH,OAAAkyB,UAAA1vB,eAAArR,KAAAsH,EAAAF,KACA/G,EAAA+G,GAAAE,EAAAF,IAIA,MAAA/G,MlDq/pBM,SAASR,EAAQD,EAASH,GmD1gqBhC,YAQA,SAAAy+E,GAAAtV,GACA,IAAAuV,EAAAtV,QACA,SAAAngE,OAAA,kCAEAupE,GAAAjyE,KAAA0C,KAAAkmE,EAAA,YAAAuV,EAAApM,GAVA,GAAAtI,GAAAhqE,EAAA,IACA0+E,EAAA1+E,EAAA,IACAsyE,EAAAtyE,EAAA,IACAwyE,EAAAxyE,EAAA,GAUAgqE,GAAAyU,EAAAjM,GAEAiM,EAAArV,QAAA,SAAAsJ,GACA,MAAAgM,GAAAtV,SAAAsJ,EAAA0E,YAGAqH,EAAApU,cAAA,WACAoU,EAAAnU,WAAA,EAEAlqE,EAAAD,QAAAs+E,GnDihqBM,SAASr+E,EAAQD,EAASH,IoDziqBhC,SAAAipE,EAAArjE,GAAA,YAcA,SAAA84E,GAAAjX,GACA6B,EAAA7B,GACA4B,EAAA9oE,KAAA0C,KACA,IAAAykE,GAAAzkE,IACAw0E,GAAAqG,yBAEA76E,KAAA5C,GAAA,IAAA+nB,EAAAxhB,OAAA,GACA6gE,EAAA8B,EAAAkE,SAAAhG,EAAA,KAAAyH,mBAAAuI,EAAAmG,QAAA,IAAA36E,KAAA5C,KAEAipE,EAAA,iBAAAoV,EAAAC,gBACA,IAAAC,GAAAF,EAAAC,gBACAlH,EAAA4G,eAAA5G,EAAAC,YAEA9xE,GAAA6xE,EAAAmG,SAAA36E,KAAA5C,KACAkF,MAAA,WACA+jE,EAAA,SACA5B,EAAA8P,UAAAl3E,UAEAuI,QAAA,SAAA5G,GACAqnE,EAAA,UAAArnE,GACAylE,EAAAiC,KAAA,UAAA1nE,IAEAg9C,KAAA,WACAqqB,EAAA,QACA5B,EAAAqC,WACArC,EAAAkP,OAAA,aAGA3zE,KAAAu0E,UAAAoH,EAAAnX,EAAA,WACA6B,EAAA,YACA5B,EAAAqC,WACArC,EAAAkP,OAAA,eA3CA,GAAA5M,GAAAhqE,EAAA,IACAy3E,EAAAz3E,EAAA,IACAupE,EAAAvpE,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aACAjhD,EAAApoB,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,wCAsCAgqE,EAAA0U,EAAArV,GAEAqV,EAAAp9C,UAAA4d,MAAA,WACAoqB,EAAA,SACArmE,KAAA8mE,WACA9mE,KAAA2zE,OAAA,SAGA8H,EAAAp9C,UAAAyoC,SAAA,WACAT,EAAA,YACArmE,KAAAu0E,YACAv0E,KAAAu0E,UAAAz8C,UACA93B,KAAAu0E,UAAA,YAEA5xE,GAAA6xE,EAAAmG,SAAA36E,KAAA5C,KAGAq+E,EAAAp9C,UAAAs1C,OAAA,SAAA38B,GACAqvB,EAAA,SAAArvB,GACAh3C,KAAA0mE,KAAA,aAAA1vB,GACAh3C,KAAAmnE,sBAGAsU,EAAAC,iBAAA,CAGA,IAAApJ,IAAA,UAAA7mE,OAAA,UAAAoE,KAAA,IACA,IAAAyiE,IAAA3vE,GACA,IACA84E,EAAAC,kBAAA,GAAA/4E,GAAA2vE,GAAA,YACG,MAAAlqE,IAGHqzE,EAAAtV,QAAAsV,EAAAC,iBAAAlH,EAAAS,cAEA93E,EAAAD,QAAAu+E,IpD6iqB8Bn+E,KAAKJ,EAASH,EAAoB,IAAM,WAAa,MAAOiD,WAIpF,SAAS7C,EAAQD,EAASH,GqDroqBhC,YASA,SAAA6+E,GAAA1V,GACA,IAAAmJ,EAAAlJ,UAAAmJ,EAAAnJ,QACA,SAAAngE,OAAA,kCAEAupE,GAAAjyE,KAAA0C,KAAAkmE,EAAA,OAAAsJ,EAAAF,GAXA,GAAAvI,GAAAhqE,EAAA,IACAwyE,EAAAxyE,EAAA,IACAyyE,EAAAzyE,EAAA,IACAuyE,EAAAvyE,EAAA,IACAsyE,EAAAtyE,EAAA,GAUAgqE,GAAA6U,EAAArM,GAEAqM,EAAAzV,QAAA,SAAAsJ,GACA,OAAAA,EAAAC,gBAIAL,EAAAlJ,UAAAsJ,EAAA0E,aAGA7E,EAAAnJ,UAGAyV,EAAAxU,cAAA,cACAwU,EAAAvU,WAAA,EAEAlqE,EAAAD,QAAA0+E,GrD4oqBM,SAASz+E,EAAQD,EAASH,GsD5qqBhC,YASA,SAAA8+E,GAAA3V,GACA,IAAA2M,EAAA1M,QACA,SAAAngE,OAAA,kCAEAupE,GAAAjyE,KAAA0C,KAAAkmE,EAAA,OAAAsJ,EAAAqD,GAXA,GAAA9L,GAAAhqE,EAAA,IACAwyE,EAAAxyE,EAAA,IACA61E,EAAA71E,EAAA,IACAyyE,EAAAzyE,EAAA,IACA81E,EAAA91E,EAAA,GAUAgqE,GAAA8U,EAAAtM,GAEAsM,EAAA1V,QAAAyM,EAAAzM,QACA0V,EAAAzU,cAAA,cACAyU,EAAAxU,WAAA,EAEAlqE,EAAAD,QAAA2+E,GtDmrqBM,SAAS1+E,EAAQD,EAASH,IuDzsqBhC,SAAA4F,GAAA,YAgBA,SAAAm5E,GAAA5V,GACA,IAAA4V,EAAA3V,UACA,SAAAngE,OAAA,kCAEAuqE,GAAAjzE,KAAA0C,KAAAkmE,EAAA,SAAA6V,EAAAC,GAVA,GAAAjV,GAAAhqE,EAAA,IACAwzE,EAAAxzE,EAAA,IACAi/E,EAAAj/E,EAAA,IACAg/E,EAAAh/E,EAAA,GAUAgqE,GAAA+U,EAAAvL,GAEAuL,EAAA3V,QAAA,WACA,QAAAxjE,EAAA3E,UAGA89E,EAAA1U,cAAA,gBACA0U,EAAAzU,WAAA,EACAyU,EAAAlM,UAAA,EAEAzyE,EAAAD,QAAA4+E,IvD6sqB8Bx+E,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,IwDlvqBhC,SAAAipE,EAAArjE,GAAA,YAeA,SAAAq5E,GAAAxX,GACA6B,EAAA7B,EACA,IAAAC,GAAAzkE,IACAomE,GAAA9oE,KAAA0C,MAEA4mE,EAAAiU,yBAEA76E,KAAA5C,GAAA,IAAA+nB,EAAAxhB,OAAA,EACA,IAAAs4E,GAAA3V,EAAAkE,SAAAhG,EAAA,KAAA2H,mBAAAvF,EAAA+T,QAAA,IAAA36E,KAAA5C,IAEAuF,GAAAikE,EAAA+T,SAAA36E,KAAA5C,IAAA4C,KAAAk8E,UAAAh6E,KAAAlC,MACAA,KAAAm8E,cAAAF,GAGAj8E,KAAAo8E,UAAAtzE,WAAA,WACAu9D,EAAA,WACA5B,EAAA4X,OAAA,GAAAr2E,OAAA,8CACGg2E,EAAAhyC,SA9BH,GAAA48B,GAAA7pE,EAAA,IACAooB,EAAApoB,EAAA,IACAurE,EAAAvrE,EAAA,IACAupE,EAAAvpE,EAAA,IACAgqE,EAAAhqE,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aAGAC,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,qCAuBAgqE,EAAAiV,EAAA5V,GAEA4V,EAAA39C,UAAA4d,MAAA,WAEA,GADAoqB,EAAA,SACA1jE,EAAAikE,EAAA+T,SAAA36E,KAAA5C,IAAA,CACA,GAAAo3B,GAAA,GAAAxuB,OAAA,0BACAwuB,GAAA/L,KAAA,IACAzoB,KAAAq8E,OAAA7nD,KAIAwnD,EAAAhyC,QAAA,KACAgyC,EAAAM,mBAAA,IAEAN,EAAA39C,UAAA69C,UAAA,SAAAl9E,GACAqnE,EAAA,YAAArnE,GACAgB,KAAA8mE,WAEA9mE,KAAAu8E,WAIAv9E,IACAqnE,EAAA,UAAArnE,GACAgB,KAAA0mE,KAAA,UAAA1nE,IAEAgB,KAAA0mE,KAAA,wBACA1mE,KAAAmnE,uBAGA6U,EAAA39C,UAAAg+C,OAAA,SAAA7nD,GACA6xC,EAAA,SAAA7xC,GACAx0B,KAAA8mE,WACA9mE,KAAAu8E,UAAA,EACAv8E,KAAA0mE,KAAA,QAAAlyC,EAAA/L,KAAA+L,EAAA5uB,SACA5F,KAAAmnE,sBAGA6U,EAAA39C,UAAAyoC,SAAA,WAOA,GANAT,EAAA,YACAp8B,aAAAjqC,KAAAo8E,WACAp8E,KAAAw8E,UACAx8E,KAAAw8E,QAAAl5E,WAAAC,YAAAvD,KAAAw8E,SACAx8E,KAAAw8E,QAAA,MAEAx8E,KAAA0yD,OAAA,CACA,GAAAA,GAAA1yD,KAAA0yD,MAGAA,GAAApvD,WAAAC,YAAAmvD,GACAA,EAAAyf,mBAAAzf,EAAAsS,QACAtS,EAAA2gB,OAAA3gB,EAAA+pB,QAAA,KACAz8E,KAAA0yD,OAAA,WAEA/vD,GAAAikE,EAAA+T,SAAA36E,KAAA5C,KAGA4+E,EAAA39C,UAAAq+C,aAAA,WACArW,EAAA,eACA,IAAA5B,GAAAzkE,IACAA,MAAA28E,aAIA38E,KAAA28E,WAAA7zE,WAAA,WACA27D,EAAAmY,YACAnY,EAAA4X,OAAA,GAAAr2E,OAAA,8CAEGg2E,EAAAM,sBAGHN,EAAA39C,UAAA89C,cAAA,SAAA3X,GACA6B,EAAA,gBAAA7B,EACA,IAEAgY,GAFA/X,EAAAzkE,KACA0yD,EAAA1yD,KAAA0yD,OAAA/vD,EAAA3E,SAAAwwC,cAAA,SAwCA,IArCAkkB,EAAAt1D,GAAA,IAAA+nB,EAAAxhB,OAAA,GACA+uD,EAAAwoB,IAAA1W,EACA9R,EAAAtrD,KAAA,kBACAsrD,EAAAmqB,QAAA,QACAnqB,EAAAsS,QAAAhlE,KAAA08E,aAAAx6E,KAAAlC,MACA0yD,EAAA2gB,OAAA,WACAhN,EAAA,UACA5B,EAAA4X,OAAA,GAAAr2E,OAAA,6CAKA0sD,EAAAyf,mBAAA,WAEA,GADA9L,EAAA,qBAAA3T,EAAA0f,YACA,gBAAAvkE,KAAA6kD,EAAA0f,YAAA,CACA,GAAA1f,KAAAoqB,SAAApqB,EAAA+pB,QAAA,CACAhY,EAAAmY,YAAA,CACA,KAEAlqB,EAAA+pB,UACS,MAAAr0E,KAETsqD,GACA+R,EAAA4X,OAAA,GAAAr2E,OAAA,0DAcA,mBAAA0sD,GAAAqqB,OAAAp6E,EAAA3E,SAAAs8D,YAIA,GAAAgO,EAAAqH,UASA6M,EAAAx8E,KAAAw8E,QAAA75E,EAAA3E,SAAAwwC,cAAA,UACAguC,EAAA1rD,KAAA,wCAA0B4hC,EAAAt1D,GAAA,oCAC1Bs1D,EAAAqqB,MAAAP,EAAAO,OAAA,MAXA,CAEA,IACArqB,EAAAoqB,QAAApqB,EAAAt1D,GACAs1D,EAAAvyD,MAAA,UACO,MAAAiI,IACPsqD,EAAAqqB,OAAA,EAQA,mBAAArqB,GAAAqqB,QACArqB,EAAAqqB,OAAA,EAGA,IAAAC,GAAAr6E,EAAA3E,SAAAwgD,qBAAA,UACAw+B,GAAAn9D,aAAA6yC,EAAAsqB,EAAAtuC,YACA8tC,GACAQ,EAAAn9D,aAAA28D,EAAAQ,EAAAtuC,aAIAvxC,EAAAD,QAAA8+E,IxDsvqB8B1+E,KAAKJ,EAASH,EAAoB,IAAM,WAAa,MAAOiD,WAIpF,SAAS7C,EAAQD,EAASH,IyD56qBhC,SAAAipE,EAAArjE,GAAA,YAaA,SAAA8xE,GAAAr3E,GACAipE,EAAA,eAAAjpE,EACA,KAEA,MAAAuF,GAAA3E,SAAAwwC,cAAA,iBAAApxC,EAAA,MACG,MAAAgL,GACH,GAAA2yE,GAAAp4E,EAAA3E,SAAAwwC,cAAA,SAEA,OADAusC,GAAAx6E,KAAAnD,EACA29E,GAIA,QAAAkC,KACA5W,EAAA,cACAvD,EAAAngE,EAAA3E,SAAAwwC,cAAA,QACAs0B,EAAArgD,MAAA04D,QAAA,OACArY,EAAArgD,MAAAo3D,SAAA,WACA/W,EAAAtnC,OAAA,OACAsnC,EAAAoa,QAAA,oCACApa,EAAAqa,cAAA,QAEAC,EAAAz6E,EAAA3E,SAAAwwC,cAAA,YACA4uC,EAAA78E,KAAA,IACAuiE,EAAAn0B,YAAAyuC,GAEAz6E,EAAA3E,SAAA8D,KAAA6sC,YAAAm0B,GApCA,GAAA39C,GAAApoB,EAAA,IACAupE,EAAAvpE,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,kCAGA,IAAA+lE,GAAAsa,CA8BAjgF,GAAAD,QAAA,SAAAsnE,EAAAuL,EAAAlnE,GACAw9D,EAAA7B,EAAAuL,GACAjN,GACAma,GAEA,IAAA7/E,GAAA,IAAA+nB,EAAAxhB,OAAA,EACAm/D,GAAAxiE,OAAAlD,EACA0lE,EAAAxK,OAAAgO,EAAAkE,SAAAlE,EAAAC,QAAA/B,EAAA,oBAAApnE,EAEA,IAAA29E,GAAAtG,EAAAr3E,EACA29E,GAAA39E,KACA29E,EAAAt4D,MAAA04D,QAAA,OACArY,EAAAn0B,YAAAosC,EAEA,KACAqC,EAAA58E,MAAAuvE,EACG,MAAArmE,IAGHo5D,EAAAua,QAEA,IAAArb,GAAA,SAAAxtC,GACA6xC,EAAA,YAAAjpE,EAAAo3B,GACAumD,EAAA/V,UAGA+V,EAAA5I,mBAAA4I,EAAA/V,QAAA+V,EAAA1H,OAAA,KAGAvqE,WAAA,WACAu9D,EAAA,cAAAjpE,GACA29E,EAAAz3E,WAAAC,YAAAw3E,GACAA,EAAA,MACK,KACLqC,EAAA58E,MAAA,GAGAqI,EAAA2rB,IAgBA,OAdAumD,GAAA/V,QAAA,WACAqB,EAAA,UAAAjpE,GACA4kE,KAEA+Y,EAAA1H,OAAA,WACAhN,EAAA,SAAAjpE,GACA4kE,KAEA+Y,EAAA5I,mBAAA,SAAAzoE,GACA28D,EAAA,qBAAAjpE,EAAA29E,EAAA3I,WAAA1oE,GACA,aAAAqxE,EAAA3I,YACApQ,KAGA,WACAqE,EAAA,UAAAjpE,GACA4kE,EAAA,GAAAh8D,OAAA,gBzDk7qB8B1I,KAAKJ,EAASH,EAAoB,IAAM,WAAa,MAAOiD,WAIpF,SAAS7C,EAAQD,EAASH,I0DthrBhC,SAAAipE,EAAArjE,GAAA,YAiCA,SAAAuhE,GAAAM,EAAA8Y,EAAAnuE,GACA,KAAAnP,eAAAkkE,IACA,UAAAA,GAAAM,EAAA8Y,EAAAnuE,EAEA,IAAA3K,UAAAC,OAAA,EACA,SAAA+E,WAAA,uEAEAmlE,GAAArxE,KAAA0C,MAEAA,KAAAoyE,WAAAlO,EAAAY,WACA9kE,KAAAu9E,WAAA,GACAv9E,KAAAmqE,SAAA,GAGAh7D,QACAA,EAAAquE,qBACAt3E,EAAAE,KAAA,kEAEApG,KAAAy9E,qBAAAtuE,EAAAuuE,UAEA,IAAAC,GAAAxuE,EAAAwuE,WAAA,CACA,sBAAAA,GACA39E,KAAA49E,mBAAAD,MACG,oBAAAA,GAKH,SAAAn0E,WAAA,8EAJAxJ,MAAA49E,mBAAA,WACA,MAAAz4D,GAAAxhB,OAAAg6E,IAMA39E,KAAA69E,QAAA1uE,EAAA2uE,QAAA34D,EAAA2kD,aAAA,IAGA,IAAAiU,GAAA,GAAA9T,GAAAzF,EACA,KAAAuZ,EAAA3S,OAAA2S,EAAA5T,SACA,SAAA0L,aAAA,YAAArR,EAAA,eACG,IAAAuZ,EAAAt0C,KACH,SAAAosC,aAAA,sCACG,cAAAkI,EAAA5T,UAAA,WAAA4T,EAAA5T,SACH,SAAA0L,aAAA,yDAAAkI,EAAA5T,SAAA,oBAGA,IAAA6T,GAAA,WAAAD,EAAA5T,QAEA,cAAA0B,EAAA1B,WAAA6T,EACA,SAAAh4E,OAAA,kGAKAs3E,GAEGp3D,MAAAlhB,QAAAs4E,KACHA,OAFAA,IAMA,IAAAW,GAAAX,EAAAl/D,MACA6/D,GAAAt5E,QAAA,SAAA4tC,EAAAtqC,GACA,IAAAsqC,EACA,SAAAsjC,aAAA,wBAAAtjC,EAAA,gBAEA,IAAAtqC,EAAAg2E,EAAAx5E,OAAA,GAAA8tC,IAAA0rC,EAAAh2E,EAAA,GACA,SAAA4tE,aAAA,wBAAAtjC,EAAA,qBAKA,IAAA3kB,GAAA04C,EAAA4D,UAAA2B,EAAAL,KACAxrE,MAAAk+E,QAAAtwD,IAAAxpB,cAAA,KAGA25E,EAAA39E,IAAA,WAAA29E,EAAApS,SAAA/nE,QAAA,YAGA5D,KAAAwkE,IAAAuZ,EAAAvS,KACAnF,EAAA,YAAArmE,KAAAwkE,KAKAxkE,KAAAm+E,UACAzO,YAAApH,EAAAoK,YACAyB,WAAA7N,EAAA+D,cAAArqE,KAAAwkE,IAAAqH,EAAAL,MACAuH,WAAAzM,EAAAgE,cAAAtqE,KAAAwkE,IAAAqH,EAAAL,OAGAxrE,KAAAo+E,IAAA,GAAAC,GAAAr+E,KAAAwkE,IAAAxkE,KAAAm+E,UACAn+E,KAAAo+E,IAAAhhC,KAAA,SAAAp9C,KAAAs+E,aAAAp8E,KAAAlC,OAKA,QAAAu+E,GAAA91D,GACA,aAAAA,MAAA,KAAAA,GAAA,KA9HA1rB,EAAA,GAEA,IAAAktE,GAAAltE,EAAA,IACAgqE,EAAAhqE,EAAA,IACA63E,EAAA73E,EAAA,IACAooB,EAAApoB,EAAA,IACAyjC,EAAAzjC,EAAA,IACAupE,EAAAvpE,EAAA,IACAi2E,EAAAj2E,EAAA,IACAg3E,EAAAh3E,EAAA,IACA+2E,EAAA/2E,EAAA,IACAurE,EAAAvrE,EAAA,IACAmJ,EAAAnJ,EAAA,IACAyhF,EAAAzhF,EAAA,IACA4xE,EAAA5xE,EAAA,IACA8uE,EAAA9uE,EAAA,IACA0hF,EAAA1hF,EAAA,IACA2hF,EAAA3hF,EAAA,IACAshF,EAAAthF,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WAEAtkE,EAAAg8E,IAAA5hF,EAAA,IACAspE,EAAA1jE,EAAAg8E,IAAA,sBAGA,IAAAjB,EA+FA3W,GAAA7C,EAAAyK,GAMAzK,EAAA7lC,UAAA/L,MAAA,SAAA7J,EAAAuuB,GAEA,GAAAvuB,IAAA81D,EAAA91D,GACA,SAAAziB,OAAA,mCAGA,IAAAgxC,KAAAvyC,OAAA,IACA,SAAAoxE,aAAA,wCAIA,IAAA71E,KAAAoyE,aAAAlO,EAAAnvC,SAAA/0B,KAAAoyE,aAAAlO,EAAAkB,OAAA,CAKA,GAAAwZ,IAAA,CACA5+E,MAAA2zE,OAAAlrD,GAAA,IAAAuuB,GAAA,iBAAA4nC,KAGA1a,EAAA7lC,UAAAl8B,KAAA,SAAAnD,GAMA,GAHA,gBAAAA,KACAA,EAAA,GAAAA,GAEAgB,KAAAoyE,aAAAlO,EAAAY,WACA,SAAA9+D,OAAA,iEAEAhG,MAAAoyE,aAAAlO,EAAAiB,MAGAnlE,KAAA6+E,WAAA18E,KAAAq+B,EAAA63C,MAAAr5E,KAGAklE,EAAAsE,QAAAzrE,EAAA,IAEAmnE,EAAAY,WAAA,EACAZ,EAAAiB,KAAA,EACAjB,EAAAnvC,QAAA,EACAmvC,EAAAkB,OAAA,EAEAlB,EAAA7lC,UAAAigD,aAAA,SAAA7O,EAAAqP,GAGA,GAFAzY,EAAA,eAAAyY,GACA9+E,KAAAo+E,IAAA,MACA3O,EAEA,WADAzvE,MAAA2zE,OAAA,gCAMA3zE,MAAA++E,KAAA/+E,KAAAg/E,SAAAF,GAEA9+E,KAAAi/E,UAAAxP,EAAAyP,SAAAzP,EAAAyP,SAAAl/E,KAAAwkE,IACAiL,EAAAqE,EAAAzhC,OAAAo9B,EAAAzvE,KAAAm+E,UACA9X,EAAA,OAAAoJ,EAEA,IAAA0P,GAAAzB,EAAA0B,gBAAAp/E,KAAAy9E,qBAAAhO,EACAzvE,MAAAq/E,YAAAF,EAAAG,KACAjZ,EAAArmE,KAAAq/E,YAAA56E,OAAA,uBAEAzE,KAAAu/E,YAGArb,EAAA7lC,UAAAkhD,SAAA,WACA,OAAAC,GAAAx/E,KAAAq/E,YAAAv5E,QAAgD05E,EAAWA,EAAAx/E,KAAAq/E,YAAAv5E,QAAA,CAE3D,GADAugE,EAAA,UAAAmZ,EAAApY,eACAoY,EAAA5P,YACAjtE,EAAA3E,SAAA8D,MACA,mBAAAa,GAAA3E,SAAAo0E,YACA,aAAAzvE,EAAA3E,SAAAo0E,YACA,gBAAAzvE,EAAA3E,SAAAo0E,YAIA,MAHA/L,GAAA,oBACArmE,KAAAq/E,YAAAnhE,QAAAshE,OACAxM,GAAA1Y,YAAA,OAAAt6D,KAAAu/E,SAAAr9E,KAAAlC,MAMA,IAAAy/E,GAAAz/E,KAAA++E,KAAAS,EAAAnY,YAAA,GACArnE,MAAA0/E,oBAAA52E,WAAA9I,KAAA2/E,kBAAAz9E,KAAAlC,MAAAy/E,GACApZ,EAAA,gBAAAoZ,EAEA,IAAAG,GAAAtZ,EAAAC,QAAAvmE,KAAAi/E,UAAA,IAAAj/E,KAAA69E,QAAA,IAAA79E,KAAA49E,qBACAvX,GAAA,gBAAAuZ,EACA,IAAAC,GAAA,GAAAL,GAAAI,EAAA5/E,KAAAi/E,UAMA,OALAY,GAAA5/E,GAAA,UAAAD,KAAA8/E,kBAAA59E,KAAAlC,OACA6/E,EAAAziC,KAAA,QAAAp9C,KAAA+/E,gBAAA79E,KAAAlC,OACA6/E,EAAAzY,cAAAoY,EAAApY,mBACApnE,KAAA6+E,WAAAgB,GAIA7/E,KAAA2zE,OAAA,iCAGAzP,EAAA7lC,UAAAshD,kBAAA,WACAtZ,EAAA,qBACArmE,KAAAoyE,aAAAlO,EAAAY,YACA9kE,KAAA+/E,gBAAA,6BAIA7b,EAAA7lC,UAAAyhD,kBAAA,SAAAl+E,GACAykE,EAAA,oBAAAzkE,EACA,IAGAmuE,GAHAtL,EAAAzkE,KACAoH,EAAAxF,EAAA2Q,MAAA,KACAkkB,EAAA70B,EAAA2Q,MAAA,EAKA,QAAAnL,GACA,QAEA,WADApH,MAAAggF,OAEA,SAGA,MAFAhgF,MAAAivE,cAAA,GAAAuP,GAAA,kBACAnY,GAAA,YAAArmE,KAAA+zE,WAIA,GAAAt9C,EACA,IACAs5C,EAAA6E,EAAA1qD,MAAAuM,GACK,MAAA/sB,GACL28D,EAAA,WAAA5vC,GAIA,sBAAAs5C,GAEA,WADA1J,GAAA,gBAAA5vC,EAIA,QAAArvB,GACA,QACA8e,MAAAlhB,QAAA+qE,IACAA,EAAAprE,QAAA,SAAAlH,GACA4oE,EAAA,UAAA5B,EAAAsP,UAAAt2E,GACAgnE,EAAAwK,cAAA,GAAAyP,GAAAjhF,KAGA,MACA,SACA4oE,EAAA,UAAArmE,KAAA+zE,UAAAhE,GACA/vE,KAAAivE,cAAA,GAAAyP,GAAA3O,GACA,MACA,SACA7pD,MAAAlhB,QAAA+qE,IAAA,IAAAA,EAAAtrE,QACAzE,KAAA2zE,OAAA5D,EAAA,GAAAA,EAAA,SAMA7L,EAAA7lC,UAAA0hD,gBAAA,SAAAt3D,EAAAuuB,GAQA,MAPAqvB,GAAA,kBAAArmE,KAAA+zE,UAAAtrD,EAAAuuB,GACAh3C,KAAA6+E,aACA7+E,KAAA6+E,WAAA1X,qBACAnnE,KAAA6+E,WAAA,KACA7+E,KAAA+zE,UAAA,MAGAwK,EAAA91D,IAAA,MAAAA,GAAAzoB,KAAAoyE,aAAAlO,EAAAY,eAKA9kE,MAAA2zE,OAAAlrD,EAAAuuB,OAJAh3C,MAAAu/E,YAOArb,EAAA7lC,UAAA2hD,MAAA,WACA3Z,EAAA,QAAArmE,KAAA6+E,WAAAzX,cAAApnE,KAAAoyE,YACApyE,KAAAoyE,aAAAlO,EAAAY,YACA9kE,KAAA0/E,sBACAz1C,aAAAjqC,KAAA0/E,qBACA1/E,KAAA0/E,oBAAA,MAEA1/E,KAAAoyE,WAAAlO,EAAAiB,KACAnlE,KAAA+zE,UAAA/zE,KAAA6+E,WAAAzX,cACApnE,KAAAivE,cAAA,GAAAuP,GAAA,SACAnY,EAAA,YAAArmE,KAAA+zE,YAIA/zE,KAAA2zE,OAAA,6BAIAzP,EAAA7lC,UAAAs1C,OAAA,SAAAlrD,EAAAuuB,EAAA4nC,GACAvY,EAAA,SAAArmE,KAAA+zE,UAAAtrD,EAAAuuB,EAAA4nC,EAAA5+E,KAAAoyE,WACA,IAAA6N,IAAA,CAaA,IAXAjgF,KAAAo+E,MACA6B,GAAA,EACAjgF,KAAAo+E,IAAA9rD,QACAtyB,KAAAo+E,IAAA,MAEAp+E,KAAA6+E,aACA7+E,KAAA6+E,WAAAvsD,QACAtyB,KAAA6+E,WAAA,KACA7+E,KAAA+zE,UAAA,MAGA/zE,KAAAoyE,aAAAlO,EAAAkB,OACA,SAAAp/D,OAAA,oDAGAhG,MAAAoyE,WAAAlO,EAAAnvC,QACAjsB,WAAA,WACA9I,KAAAoyE,WAAAlO,EAAAkB,OAEA6a,GACAjgF,KAAAivE,cAAA,GAAAuP,GAAA,SAGA,IAAA90E,GAAA,GAAA+0E,GAAA,QACA/0E,GAAAk1E,aAAA,EACAl1E,EAAA+e,QAAA,IACA/e,EAAAstC,SAEAh3C,KAAAivE,cAAAvlE,GACA1J,KAAAslE,UAAAtlE,KAAAoC,QAAApC,KAAAglE,QAAA,KACAqB,EAAA,iBACGnkE,KAAAlC,MAAA,IAKHkkE,EAAA7lC,UAAA2gD,SAAA,SAAAF,GAOA,MAAAA,GAAA,IACA,EAAAA,EAEA,IAAAA,GAGA3hF,EAAAD,QAAA,SAAAgjF,GAGA,MAFAxC,GAAA3J,EAAAmM,GACAnjF,EAAA,IAAAmnE,EAAAgc,GACAhc,K1D2hrB8B5mE,KAAKJ,EAASH,EAAoB,IAAM,WAAa,MAAOiD,WAIpF,SAAS7C,EAAQD,G2Dx5rBvB,YAyEA,SAAAijF,GAAArsE,GACA,GAAA0N,IAAA1N,CAMA,OALA0N,OACAA,EAAA,EACK,IAAAA,OAAA,KAAAA,MAAA,OACLA,KAAA,OAAAvG,KAAAiK,MAAAjK,KAAAmlE,IAAA5+D,KAEAA,EAGA,QAAA6+D,GAAAj4E,GACA,MAAAA,KAAA,EAWA,QAAAk4E,MA3FA,GA4BAz5C,GA5BA05C,EAAAr6D,MAAAmY,UACAmiD,EAAAr0E,OAAAkyB,UACAoiD,EAAAt6D,SAAAkY,UACAqiD,EAAApyD,OAAA+P,UACAsiD,EAAAJ,EAAAhuE,MAEAquE,EAAAJ,EAAA/8E,SACA4zE,EAAA,SAAAh6D,GACA,4BAAAmjE,EAAA/8E,SAAAnG,KAAA+f,IAEArY,EAAA,SAAArH,GACA,yBAAAijF,EAAAtjF,KAAAK,IAEAy5B,EAAA,SAAAz5B,GACA,0BAAAijF,EAAAtjF,KAAAK,IAGAkjF,EAAA10E,OAAA06B,gBAAA,WACA,IAEA,MADA16B,QAAA06B,kBAAgC,SAChC,EACK,MAAAn9B,GACL,YAQAm9B,GADAg6C,EACA,SAAAn5E,EAAAnH,EAAAi7B,EAAAslD,IACAA,GAAAvgF,IAAAmH,IACAyE,OAAA06B,eAAAn/B,EAAAnH,GACAmyC,cAAA,EACApN,YAAA,EACAmN,UAAA,EACAjyC,MAAAg7B,KAIA,SAAA9zB,EAAAnH,EAAAi7B,EAAAslD,IACAA,GAAAvgF,IAAAmH,KACAA,EAAAnH,GAAAi7B,GAGA,IAAAlc,GAAA,SAAA5X,EAAAkH,EAAAkyE,GACA,OAAAvgF,KAAAqO,GACA4xE,EAAA7xE,eAAArR,KAAAsR,EAAArO,IACAsmC,EAAAn/B,EAAAnH,EAAAqO,EAAArO,GAAAugF,IAKAC,EAAA,SAAAnzD,GACA,SAAAA,EACA,SAAApkB,WAAA,iBAAAokB,EAAA,aAEA,OAAAzhB,QAAAyhB,GAoCAtO,GAAAmhE,GACAv+E,KAAA,SAAA8+E,GAEA,GAAA1gF,GAAAN,IAEA,KAAAq3E,EAAA/2E,GACA,SAAAkJ,WAAA,kDAAAlJ,EAmFA,QA9EAuF,GAAA86E,EAAArjF,KAAAkH,UAAA,GAUAy8E,EAAA,WAEA,GAAAjhF,eAAA8N,GAAA,CAiBA,GAAA7E,GAAA3I,EAAA6F,MACAnG,KACA6F,EAAA4F,OAAAk1E,EAAArjF,KAAAkH,YAEA,OAAA2H,QAAAlD,OACAA,EAEAjJ,KAsBA,MAAAM,GAAA6F,MACA66E,EACAn7E,EAAA4F,OAAAk1E,EAAArjF,KAAAkH,cAaA08E,EAAAjmE,KAAAlH,IAAA,EAAAzT,EAAAmE,OAAAoB,EAAApB,QAIA08E,KACAl5E,EAAA,EAAuBA,EAAAi5E,EAAiBj5E,IACxCk5E,EAAAp5E,KAAA,IAAAE,EASA,IAAA6F,GAAAqY,SAAA,6BAAAg7D,EAAAtxE,KAAA,mDAA8HoxE,EA8B9H,OA5BA3gF,GAAA+9B,YACAiiD,EAAAjiD,UAAA/9B,EAAA+9B,UACAvwB,EAAAuwB,UAAA,GAAAiiD,GAEAA,EAAAjiD,UAAA,MAwBAvwB,KAYAwR,EAAA4G,OAAyBlhB,WAGzB,IAAAo8E,GAAAj1E,OAAA,KACAk1E,EAAA,MAAAD,EAAA,UAAAA,IAEAE,EAAA,SAAA9lD,GAEA,GAAA+lD,IAAA,EACAC,GAAA,CAWA,OAVAhmD,KACAA,EAAAl+B,KAAA,eAAAmkF,EAAAC,EAAA9zE,GACA,gBAAAA,KAA8C2zE,GAAA,KAG9C/lD,EAAAl+B,MAAA,cAEAkkF,EAAA,gBAAAxhF,OACS,QAETw7B,GAAA+lD,GAAAC,EAGAliE,GAAAihE,GACA57E,QAAA,SAAA8iE,GACA,GAAA//D,GAAAq5E,EAAA/gF,MACAykE,EAAA4c,GAAAjqD,EAAAp3B,WAAAyY,MAAA,IAAA/Q,EACAi6E,EAAAn9E,UAAA,GACAyD,GAAA,EACAxD,EAAAggE,EAAAhgE,SAAA,CAGA,KAAA4yE,EAAA5P,GACA,SAAAj+D,UAGA,QAAAvB,EAAAxD,GACAwD,IAAAw8D,IAIAgD,EAAAnqE,KAAAqkF,EAAAld,EAAAx8D,KAAAP,MAIC45E,EAAAf,EAAA57E,SAKD,IAAAi9E,GAAA17D,MAAAmY,UAAAv2B,UAAA,KAAAA,QAAA,SACAwX,GAAAihE,GACAz4E,QAAA,SAAA+5E,GACA,GAAApd,GAAA4c,GAAAjqD,EAAAp3B,WAAAyY,MAAA,IAAAsoE,EAAA/gF,MACAyE,EAAAggE,EAAAhgE,SAAA,CAEA,KAAAA,EACA,QAGA,IAAAwD,GAAA,CAOA,KANAzD,UAAAC,OAAA,IACAwD,EAAAk4E,EAAA37E,UAAA,KAIAyD,KAAA,EAAAA,EAAAgT,KAAAlH,IAAA,EAAAtP,EAAAwD,GACcA,EAAAxD,EAAYwD,IAC1B,GAAAA,IAAAw8D,MAAAx8D,KAAA45E,EACA,MAAA55E,EAGA,YAEC25E,EAsBD,IAAAE,GAAApB,EAAAjoE,KAEA,UAAAA,MAAA,WAAAhU,QACA,QAAAgU,MAAA,YAAAhU,QACA,cAAAgU,MAAA,YACA,WAAAA,MAAA,WAAAhU,QACA,GAAAgU,MAAA,MAAAhU,QACA,IAAAgU,MAAA,QAAAhU,OAAA,GAEA,WACA,GAAAs9E,GAAA,gBAAAx0E,KAAA,MAEAmzE,GAAAjoE,MAAA,SAAAupE,EAAAC,GACA,GAAAt+E,GAAA3D,IACA,aAAAgiF,GAAA,IAAAC,EACA,QAIA,wBAAArB,EAAAtjF,KAAA0kF,GACA,MAAAF,GAAAxkF,KAAA0C,KAAAgiF,EAAAC,EAGA,IAOAC,GAAA70E,EAAA80E,EAAAC,EAPAn/E,KACAo/E,GAAAL,EAAAM,WAAA,SACAN,EAAAO,UAAA,SACAP,EAAAQ,SAAA,SACAR,EAAAS,OAAA,QACAC,EAAA,CAmBA,KAhBAV,EAAA,GAAA55D,QAAA45D,EAAAp9E,OAAAy9E,EAAA,KACA1+E,GAAA,GACAo+E,IAEAG,EAAA,GAAA95D,QAAA,IAAA45D,EAAAp9E,OAAA,WAAAy9E,IASAJ,EAAA,SAAAA,GACA,MACA5B,EAAA4B,IACA50E,EAAA20E,EAAAz0E,KAAA5J,MAEAw+E,EAAA90E,EAAAxF,MAAAwF,EAAA,GAAA5I,SACA09E,EAAAO,IACAz/E,EAAA8E,KAAApE,EAAA4O,MAAAmwE,EAAAr1E,EAAAxF,SAGAk6E,GAAA10E,EAAA5I,OAAA,GACA4I,EAAA,GAAAzJ,QAAAs+E,EAAA,WACA,OAAAj6E,GAAA,EAA2CA,EAAAzD,UAAAC,OAAA,EAA0BwD,IACrE,SAAAzD,UAAAyD,KACAoF,EAAApF,GAAA,UAKAoF,EAAA5I,OAAA,GAAA4I,EAAAxF,MAAAlE,EAAAc,QACA87E,EAAAx4E,KAAA5B,MAAAlD,EAAAoK,EAAAkF,MAAA,IAEA6vE,EAAA/0E,EAAA,GAAA5I,OACAi+E,EAAAP,EACAl/E,EAAAwB,QAAAw9E,MAIAD,EAAAG,YAAA90E,EAAAxF,OACAm6E,EAAAG,WAUA,OAPAO,KAAA/+E,EAAAc,QACA29E,GAAAJ,EAAAn0E,KAAA,KACA5K,EAAA8E,KAAA,IAGA9E,EAAA8E,KAAApE,EAAA4O,MAAAmwE,IAEAz/E,EAAAwB,OAAAw9E,EAAAh/E,EAAAsP,MAAA,EAAA0vE,GAAAh/E,MAUC,IAAAwV,MAAA,UAAAhU,SACDi8E,EAAAjoE,MAAA,SAAAupE,EAAAC,GACA,gBAAAD,GAAA,IAAAC,KACAH,EAAAxkF,KAAA0C,KAAAgiF,EAAAC,IAMA,IAAAzb,GAAA,iDAGAmc,EAAA,IACAC,EAAA,IAAApc,EAAA,IACAqc,EAAA,GAAAz6D,QAAA,IAAAw6D,IAAA,KACAE,EAAA,GAAA16D,QAAAw6D,IAAA,MACAG,EAAArC,EAAAv/D,OAAAqlD,EAAArlD,SAAAwhE,EAAAxhE,OACA7B,GAAAohE,GAGAv/D,KAAA,WACA,YAAAnhB,MAAA,OAAAA,KACA,SAAAwJ,WAAA,iBAAAxJ,KAAA,aAEA,OAAAsuB,QAAAtuB,MAAA4D,QAAAi/E,EAAA,IAAAj/E,QAAAk/E,EAAA,MAECC,EAOD,IAAAC,GAAAtC,EAAAlzE,OACAy1E,EAAA,GAAAz1E,QAAA,WAAAA,QAAA,EACA8R,GAAAohE,GACAlzE,OAAA,SAAAlL,EAAAmC,GACA,MAAAu+E,GAAA1lF,KACA0C,KACAsC,EAAA,IAAAA,EAAAtC,KAAAyE,OAAAnC,GAAA,IAAAA,EACAmC,KAGCw+E,I3Di6rBK,SAAS9lF,EAAQD,EAASH,G4Dz3sBhC,YAEA,IAKAmmF,GALAtO,EAAA73E,EAAA,IAIAomF,EAAA,0/BAKAC,EAAA,SAAAC,GACA,GAAAp7E,GACAq7E,KACA9lF,IACA,KAAAyK,EAAA,EAAaA,EAAA,MAAWA,IACxBzK,EAAAuK,KAAAumB,OAAAkhC,aAAAvnD,GAQA,OANAo7E,GAAAlB,UAAA,EACA3kF,EAAAqS,KAAA,IAAAjM,QAAAy/E,EAAA,SAAAl+E,GAEA,MADAm+E,GAAAn+E,GAAA,cAAAA,EAAA8kB,WAAA,GAAAxmB,SAAA,KAAA8O,OAAA,GACA,KAEA8wE,EAAAlB,UAAA,EACAmB,EAMAnmF,GAAAD,SACAm7E,MAAA,SAAA10E,GACA,GAAA4/E,GAAA3O,EAAA54D,UAAArY,EAIA,OADAw/E,GAAAhB,UAAA,EACAgB,EAAAt1E,KAAA01E,IAIAL,IACAA,EAAAE,EAAAD,IAGAI,EAAA3/E,QAAAu/E,EAAA,SAAAh+E,GACA,MAAA+9E,GAAA/9E,MARAo+E,K5D24sBM,SAASpmF,EAAQD,EAASH,I6Dh7sBhC,SAAAipE,GAAA,YAEA,IAAAK,GAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,sCAGAI,EAAAD,QAAA,SAAAgjF,GACA,OACAd,gBAAA,SAAAoE,EAAA/T,GACA,GAAAiO,IACA4B,QACAmE,UAkCA,OAhCAD,GAEO,gBAAAA,KACPA,OAFAA,KAKAtD,EAAAv7E,QAAA,SAAAsG,GACA,GAAAA,EAIA,oBAAAA,EAAAm8D,eAAAqI,EAAAiU,aAAA,MACArd,GAAA,oCAIAmd,EAAA/+E,QACA++E,EAAA17E,QAAAmD,EAAAm8D,kBAAA,MACAf,GAAA,mBAAAp7D,EAAAm8D,oBAIAn8D,EAAAk7D,QAAAsJ,IACApJ,EAAA,UAAAp7D,EAAAm8D,eACAsW,EAAA4B,KAAAv3E,KAAAkD,GACAA,EAAAmpE,iBACAsJ,EAAA+F,OAAA17E,KAAAkD,EAAAmpE,kBAGA/N,EAAA,WAAAp7D,EAAAm8D,kBAGAsW,O7Du7sB8BpgF,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,I8Dz+sBvB,SAAAyF,GAAA,YAEA,IAAAghF,OACA,sBAAAh/E,QAAA,SAAAi/E,GACA,GAAAC,GAAAlhF,EAAAmxC,SAAAnxC,EAAAmxC,QAAA8vC,IAAAjhF,EAAAmxC,QAAA8vC,GAAAz9E,KACAw9E,GAAAC,GAAAC,EAAA,WACA,MAAAlhF,GAAAmxC,QAAA8vC,GAAAz9E,MAAAxD,EAAAmxC,QAAAtvC,YACG,QAAAo/E,EAAA,aAAoCD,EAAAz9E,MAGvC/I,EAAAD,QAAAymF,I9D6+sB8BrmF,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,G+D3/sBvB,YAEA,SAAAshF,GAAAzP,GACA/uE,KAAAoH,KAAA2nE,EAGAyP,EAAAngD,UAAAylD,UAAA,SAAA/U,EAAAgV,EAAAC,GAKA,MAJAhkF,MAAAoH,KAAA2nE,EACA/uE,KAAAikF,QAAAF,EACA/jF,KAAAgkF,aACAhkF,KAAAkkF,WAAA,GAAAvoC,MACA37C,MAGAw+E,EAAAngD,UAAA/oB,gBAAA,aACAkpE,EAAAngD,UAAAhpB,eAAA,aAEAmpE,EAAA2F,gBAAA,EACA3F,EAAA4F,UAAA,EACA5F,EAAA6F,eAAA,EAEAlnF,EAAAD,QAAAshF,G/DkgtBM,SAASrhF,EAAQD,IgEvhtBvB,SAAAyF,GAAA,YAEAxF,GAAAD,QAAAyF,EAAArB,WACAi2D,OAAA,sBACA4S,SAAA,OACAiB,KAAA,YACAhB,KAAA,GACAoB,KAAA,oBACA/hC,KAAA,MhE4htB8BnsC,KAAKJ,EAAU,WAAa,MAAO8C,WAI3D,SAAS7C,EAAQD,EAASH,GiExitBhC,YAMA,SAAA0hF,KACAD,EAAAlhF,KAAA0C,MACAA,KAAA8jF,UAAA,eACA9jF,KAAA4+E,UAAA,EACA5+E,KAAAyoB,KAAA,EACAzoB,KAAAg3C,OAAA,GATA,GAAA+vB,GAAAhqE,EAAA,IACAyhF,EAAAzhF,EAAA,GAWAgqE,GAAA0X,EAAAD,GAEArhF,EAAAD,QAAAuhF,GjE+itBM,SAASthF,EAAQD,EAASH,GkE/jtBhC,YAMA,SAAA2hF,GAAA1/E,GACAw/E,EAAAlhF,KAAA0C,MACAA,KAAA8jF,UAAA,iBACA9jF,KAAAhB,OAPA,GAAA+nE,GAAAhqE,EAAA,IACAyhF,EAAAzhF,EAAA,GASAgqE,GAAA2X,EAAAF,GAEArhF,EAAAD,QAAAwhF,GlEsktBM,SAASvhF,EAAQD,EAASH,ImEpltBhC,SAAAipE,GAAA,YAkBA,SAAAqY,GAAApK,EAAAqQ,GACAje,EAAA4N,EACA,IAAAxP,GAAAzkE,IACAomE,GAAA9oE,KAAA0C,MAEA8I,WAAA,WACA27D,EAAA8f,MAAAtQ,EAAAqQ,IACG,GAvBH,GAAAle,GAAArpE,EAAA,IAAAqpE,aACAW,EAAAhqE,EAAA,IACAupE,EAAAvpE,EAAA,IACAynF,EAAAznF,EAAA,IACA0nF,EAAA1nF,EAAA,IACA2nF,EAAA3nF,EAAA,IACA4nF,EAAA5nF,EAAA,IACA6nF,EAAA7nF,EAAA,IACA8nF,EAAA9nF,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,oCAaAgqE,EAAAsX,EAAAjY,GAIAiY,EAAAyG,aAAA,SAAA7Q,EAAAzP,EAAA8f,GAEA,MAAAA,GAAAnQ,WACA,GAAA0Q,GAAArgB,EAAAkgB,GAEAD,EAAAte,QACA,GAAA0e,GAAArgB,EAAAigB,GAEAD,EAAAre,SAAAme,EAAAvR,WACA,GAAA8R,GAAArgB,EAAAggB,GAEAI,EAAAze,UACA,GAAAye,GAAA3Q,EAAAzP,GAEA,GAAAqgB,GAAArgB,EAAAmgB,IAGAtG,EAAAhgD,UAAAkmD,MAAA,SAAAtQ,EAAAqQ,GACA,GAAA7f,GAAAzkE,KACAwkE,EAAA8B,EAAAC,QAAA0N,EAAA,QAEA5N,GAAA,QAAA7B,GAEAxkE,KAAAmwE,GAAAkO,EAAAyG,aAAA7Q,EAAAzP,EAAA8f,GAEAtkF,KAAA+kF,WAAAj8E,WAAA,WACAu9D,EAAA,WACA5B,EAAAqC,UAAA,GACArC,EAAAiC,KAAA,WACG2X,EAAAr0C,SAEHhqC,KAAAmwE,GAAA/yB,KAAA,kBAAAqyB,EAAAqP,GACAzY,EAAA,SAAAoJ,EAAAqP,GACAra,EAAAqC,UAAA,GACArC,EAAAiC,KAAA,SAAA+I,EAAAqP,MAIAT,EAAAhgD,UAAAyoC,SAAA,SAAA8X,GACAvY,EAAA,YACAp8B,aAAAjqC,KAAA+kF,YACA/kF,KAAA+kF,WAAA,MACAnG,GAAA5+E,KAAAmwE,IACAnwE,KAAAmwE,GAAA79C,QAEAtyB,KAAAmwE,GAAA,MAGAkO,EAAAhgD,UAAA/L,MAAA,WACA+zC,EAAA,SACArmE,KAAAmnE,qBACAnnE,KAAA8mE,UAAA,IAGAuX,EAAAr0C,QAAA,IAEA7sC,EAAAD,QAAAmhF,InEwltB8B/gF,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,GoEprtBhC,YAMA,SAAA4nF,KACA,GAAAlgB,GAAAzkE,IACAomE,GAAA9oE,KAAA0C,MAEAA,KAAAmH,GAAA2B,WAAA,WACA27D,EAAAiC,KAAA,oBACGie,EAAA36C,SAVH,GAAAo8B,GAAArpE,EAAA,IAAAqpE,aACAW,EAAAhqE,EAAA,GAYAgqE,GAAA4d,EAAAve,GAEAue,EAAAtmD,UAAA/L,MAAA,WACA2X,aAAAjqC,KAAAmH,KAGAw9E,EAAA36C,QAAA,IAEA7sC,EAAAD,QAAAynF,GpE2rtBM,SAASxnF,EAAQD,EAASH,IqElttBhC,SAAAipE,EAAArjE,GAAA,YAeA,SAAAiiF,GAAA3Q,EAAAzP,GACA,GAAAC,GAAAzkE,IACAomE,GAAA9oE,KAAA0C,KAEA,IAAAglF,GAAA,WACA,GAAAC,GAAAxgB,EAAAwgB,IAAA,GAAApR,GAAAqR,EAAA9d,cAAA5C,EAAAyP,EAEAgR,GAAA7nC,KAAA,mBAAAx7C,GACA,GAAAA,EAAA,CACA,GAAAkN,EACA,KACAA,EAAA8lE,EAAA1qD,MAAAtoB,GACS,MAAA8H,GAIT,MAHA28D,GAAA,WAAAzkE,GACA6iE,EAAAiC,KAAA,cACAjC,GAAAnyC,QAIA,GAAAm9C,GAAA3gE,EAAA,GAAAgwE,EAAAhwE,EAAA,EACA21D,GAAAiC,KAAA,SAAA+I,EAAAqP,GAEAra,EAAAnyC,UAGA2yD,EAAA7nC,KAAA,mBACAqnB,EAAAiC,KAAA,UACAjC,EAAAnyC,UAKA3vB,GAAA3E,SAAA8D,KAGAkjF,IAFApe,EAAAtM,YAAA,OAAA0qB,GA9CA,GAAA5e,GAAArpE,EAAA,IAAAqpE,aACAW,EAAAhqE,EAAA,IACA63E,EAAA73E,EAAA,IACA6pE,EAAA7pE,EAAA,IACA82E,EAAA92E,EAAA,IACAmoF,EAAAnoF,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,kCA0CAgqE,EAAA6d,EAAAxe,GAEAwe,EAAAze,QAAA,WACA,MAAA0N,GAAA1N,WAGAye,EAAAvmD,UAAA/L,MAAA,WACAtyB,KAAAilF,KACAjlF,KAAAilF,IAAA3yD,QAEAtyB,KAAAmnE,qBACAnnE,KAAAilF,IAAA,MAGA9nF,EAAAD,QAAA0nF,IrEsttB8BtnF,KAAKJ,EAASH,EAAoB,IAAM,WAAa,MAAOiD,WAIpF,SAAS7C,EAAQD,EAASH,GsE9xtBhC,YASA,SAAAmoF,GAAAhf,GACA,GAAAzB,GAAAzkE,IACAomE,GAAA9oE,KAAA0C,MAEAA,KAAAmlF,GAAA,GAAAN,GAAA3e,EAAAmJ,GACArvE,KAAAmlF,GAAA/nC,KAAA,kBAAAqyB,EAAAqP,GACAra,EAAA0gB,GAAA,KACA1gB,EAAAiC,KAAA,UAAAkO,EAAA54D,WAAAyzD,EAAAqP,OAdA,GAAA/X,GAAAhqE,EAAA,IACAqpE,EAAArpE,EAAA,IAAAqpE,aACAwO,EAAA73E,EAAA,IACAsyE,EAAAtyE,EAAA,IACA8nF,EAAA9nF,EAAA,GAcAgqE,GAAAme,EAAA9e,GAEA8e,EAAA9d,cAAA,uBAEA8d,EAAA7mD,UAAA/L,MAAA,WACAtyB,KAAAmlF,KACAnlF,KAAAmlF,GAAA7yD,QACAtyB,KAAAmlF,GAAA,MAEAnlF,KAAAmnE,sBAGAhqE,EAAAD,QAAAgoF,GtEqytBM,SAAS/nF,EAAQD,EAASH,IuEr0tBhC,SAAAipE,GAAA,YAaA,SAAA6e,GAAArgB,EAAAsL,GACA1J,EAAA9oE,KAAA0C,KAEA,IAAAykE,GAAAzkE,KACAuhE,GAAA,GAAA5lB,KACA37C,MAAAmwE,GAAA,GAAAL,GAAA,MAAAtL,GAEAxkE,KAAAmwE,GAAA/yB,KAAA,kBAAAgzB,EAAAt/C,GACA,GAAA2+C,GAAAqP,CACA,UAAA1O,EAAA,CAEA,GADA0O,GAAA,GAAAnjC,MAAA4lB,EACAzwC,EACA,IACA2+C,EAAAmF,EAAA1qD,MAAA4G,GACS,MAAApnB,GACT28D,EAAA,WAAAv1C,GAIAgjD,EAAAruE,SAAAgqE,KACAA,MAGAhL,EAAAiC,KAAA,SAAA+I,EAAAqP,GACAra,EAAA0C,uBAnCA,GAAAf,GAAArpE,EAAA,IAAAqpE,aACAW,EAAAhqE,EAAA,IACA63E,EAAA73E,EAAA,IACA+2E,EAAA/2E,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,gCA+BAgqE,EAAA8d,EAAAze,GAEAye,EAAAxmD,UAAA/L,MAAA,WACAtyB,KAAAmnE,qBACAnnE,KAAAmwE,GAAA79C,SAGAn1B,EAAAD,QAAA2nF,IvEy0tB8BvnF,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,IwE73tBhC,SAAAipE,GAAA,YAEA,IAAAM,GAAAvpE,EAAA,IACAi2E,EAAAj2E,EAAA,IACA63E,EAAA73E,EAAA,IACAqoF,EAAAroF,EAAA,IACAsoF,EAAAtoF,EAAA,IACAy3E,EAAAz3E,EAAA,IACA8uE,EAAA9uE,EAAA,IAGAspE,EAAA,YACA,gBAAAL,EAAAgB,IAAAC,WACAZ,EAAAtpE,EAAA,uCAGAI,EAAAD,QAAA,SAAAgnE,EAAAgc,GACA,GAAAoF,KACApF,GAAAv7E,QAAA,SAAA4gF,GACAA,EAAAnR,kBACAkR,EAAAC,EAAAnR,gBAAAhN,eAAAme,EAAAnR,mBAMAkR,EAAAD,EAAAje,eAAAie,CACA,IAAAG,EAGAthB,GAAAuhB,iBAAA,WAEA,GAAAhC,EACAjP,GAAAoG,gBAAA/O,EAAApiC,KAAAl3B,MAAA,EACA,IAAAmzE,GAAA,SAAAh8E,GACA,GAAAA,EAAA9E,SAAAoC,SAGA,mBAAAw+E,KACAA,EAAA97E,EAAA6tD,QAEA7tD,EAAA6tD,SAAAiuB,GAAA,CAIA,GAAA1Q,EACA,KACAA,EAAAF,EAAA1qD,MAAAxgB,EAAA1K,MACO,MAAAwzE,GAEP,WADAnM,GAAA,WAAA38D,EAAA1K,MAIA,GAAA81E,EAAAT,WAAAG,EAAAoG,gBAGA,OAAA9F,EAAA1tE,MACA,QACA,GAAA3J,EACA,KACAA,EAAAm3E,EAAA1qD,MAAA4qD,EAAA91E,MACS,MAAAwzE,GACTnM,EAAA,WAAAyO,EAAA91E,KACA,OAEA,GAAAwpE,GAAA/qE,EAAA,GACAs2E,EAAAt2E,EAAA,GACAyoE,EAAAzoE,EAAA,GACAw2E,EAAAx2E,EAAA,EAGA,IAFA4oE,EAAAmC,EAAAuL,EAAA7N,EAAA+N,GAEAzL,IAAAtE,EAAAsE,QACA,SAAAxiE,OAAA,0CACAwiE,EAAA,mBACAtE,EAAAsE,QAAA,KAGA,KAAAlC,EAAA+D,cAAAnE,EAAA2F,EAAAL,QACAlF,EAAA+D,cAAA4J,EAAApI,EAAAL,MACA,SAAAxlE,OAAA,6DACA6lE,EAAAL,KAAA,KAAAtF,EAAA,KAAA+N,EAAA,IAEAwP,GAAA,GAAA2B,GAAA,GAAAE,GAAAvR,GAAA7N,EAAA+N,GACA,MACA,SACAwP,EAAAkC,MAAA7Q,EAAA91E,KACA,MACA,SACAykF,GACAA,EAAA9P,SAEA8P,EAAA,OAKAzQ,GAAA1Y,YAAA,UAAAorB,GAGAlR,EAAAK,YAAA,SxEm4tB8Bv3E,KAAKJ,EAASH,EAAoB,MAI1D,SAASI,EAAQD,EAASH,GyE1+tBhC,YAMA,SAAAqoF,GAAArR,GACA/zE,KAAA6+E,WAAA9K,EACAA,EAAA9zE,GAAA,UAAAD,KAAA8/E,kBAAA59E,KAAAlC,OACA+zE,EAAA9zE,GAAA,QAAAD,KAAA+/E,gBAAA79E,KAAAlC,OAPA,GAAA40E,GAAA73E,EAAA,IACAy3E,EAAAz3E,EAAA,GASAqoF,GAAA/mD,UAAA0hD,gBAAA,SAAAt3D,EAAAuuB,GACAw9B,EAAAK,YAAA,IAAAD,EAAA54D,WAAAyM,EAAAuuB,MAEAouC,EAAA/mD,UAAAyhD,kBAAA,SAAA8F,GACApR,EAAAK,YAAA,IAAA+Q,IAEAR,EAAA/mD,UAAAsnD,MAAA,SAAA3mF,GACAgB,KAAA6+E,WAAA18E,KAAAnD,IAEAomF,EAAA/mD,UAAAs1C,OAAA,WACA3zE,KAAA6+E,WAAAvsD,QACAtyB,KAAA6+E,WAAA1X,sBAGAhqE,EAAAD,QAAAkoF,GzEi/tBM,SAASjoF,EAAQD,EAASH,G0E3guBhC,GAAA8oF,GAAAC,EAAA5Q,GAAC,SAAA/2E,EAAAyE,GAGDkjF,GAAA/oF,EAAA,GAAAA,EAAA,KAAA8oF,EAAA,EAAA3Q,EAAA,kBAAA2Q,KAAA1/E,MAAAjJ,EAAA4oF,GAAAD,IAAAx9E,SAAA6sE,IAAA/3E,EAAAD,QAAAg4E,KAWCl1E,KAAA,SAAAtB,EAAAqnF,GA6GD,QAAAC,GAAA1xE,EAAA2xE,EAAArnD,GACAlgC,EAAAgB,OAAA4U,GAAA4xE,EAAA5xE,EAAA2xE,EAAArnD,GASA,QAAAsnD,GAAA5xE,EAAA2xE,EAAArnD,GACA,gBAAA19B,EAAAsL,GA4BA,QAAA6K,KACA8uE,EAAAjlF,GAAAklF,gBACAllF,GAAAmlF,QA7BA,GAAAC,GAAAH,EAAAjlF,GAEAqlF,EAAA,OAAAD,EAAA5lF,IAAAulF,EAEA,KAAAM,EAAA,CAEA,GAAAC,GAAA,GAAA5nD,GAAA6nD,gBAAA7nD,EAAAzvB,SAGAA,EAAA2jD,EAAA5xD,EAAA+kF,EACA92E,IACAq3E,EAAApmF,IAAA+O,GAEAm3E,EAAAz3E,IAAA23E,GAEAE,EAAAJ,GAiBA,MAbAA,GAAArmF,GAAAqU,EAAA,SAAA5K,GACA8C,GACAtL,OACAb,SAAAqJ,OAUc2N,aAad,QAAAqvE,GAAAJ,GACA,OAAAr+E,GAAA,EAAmBA,EAAAq+E,EAAAK,YAAAliF,OAAsCwD,IAAA,CACzD,GAAAu+E,GAAAF,EAAAK,YAAA1+E,GACAg+E,EAAAO,EAAAr3E,QAAAhP,KAEA,IAAAqyC,EAAAyzC,GAAAt3E,eAAA,iBAGA,OADAi4E,GAAAp0C,EAAAyzC,GAAAY,cACAn4E,EAAA,EAAqBA,EAAAk4E,EAAAniF,OAA2BiK,IAEhD43E,EAAA5lF,IAAAkmF,EAAAl4E,KAGA83E,EAAAK,cAAAD,EAAAl4E,KAeA,QAAAokD,GAAA5xD,EAAA6D,GAKA,OAHA9B,GADAuyD,EAAAt0D,EAAAo+B,WAEAwnD,EAAA,GAAA1+D,QAAA,cAAArjB,EAAA,UAEAkD,EAAAutD,EAAA/wD,OAAA,EAAgCwD,GAAA,EAAQA,IAAA,CACxC,GAAA+nB,GAAAwlC,EAAAvtD,GACA1K,EAAAyyB,EAAAzvB,KAAA8M,MAAAy5E,EAEAvpF,KACA0F,UACAA,EAAA1F,EAAA,IAAAwpF,EAAA/2D,EAAAxvB,MAAAjD,EAAA,KAGA,MAAA0F,GAgBA,QAAA8jF,GAAA3lE,EAAArc,GACA,MAAAqc,GAAA/T,OAAA+T,EAAA/T,MAAA,sBAAA+T,EACAxL,EAAA7Q,IAAA6Q,EAAA7Q,GAAAqc,IACAxL,EAAA+zB,IAAAvoB,MA+BA,QAAA+kE,GAAAjlF,GACA,MAAAA,GAAAmlF,QAAAnlF,EAAAmlF,SAEAnlF,EAAAmlF,QAAA,GAAAN,GAAAiB,QAAA9lF,GAA6CylF,iBAC7CzlF,EAAAmlF,SAjQA,GAqFAzwE,GArFA48B,GACA7yC,KACA8mF,gBAAAV,EAAAkB,IACA93E,SACA0pE,KAAA,KAEAn5E,QACA,QAGAwnF,WACAT,gBAAAV,EAAAkB,IACA93E,SACAg4E,KAAA,EACAhnF,MAAA,aAEA0mF,eAAA,OACAnnF,QACA,cAGA0nF,OACAX,gBAAAV,EAAAsB,MACAl4E,WACAzP,QACA,QACA,YACA,aACA,UACA,cAGA4nF,KACAb,gBAAAV,EAAAwB,IACAp4E,SACAq4E,UAAAzB,EAAA0B,sBAEAZ,eAAA,SACAnnF,QACA,MACA,WACA,UACA,SACA,YACA,UACA,WACA,QACA,YAGAgoF,OACAjB,gBAAAV,EAAA4B,MACAx4E,WACAzP,QACA,QACA,YAGAkoF,QACAnB,gBAAAV,EAAA8B,OACA14E,WACAzP,QACA,SACA,cACA,aACA,YACA,iBAGAooF,OACArB,gBAAAV,EAAAgC,MACA54E,WACA03E,eAAA,UACAnnF,QACA,QACA,aACA,YACA,WACA,cACA,UACA,aAQA,QAAAumF,KAAAzzC,GACA,GAAAA,EAAA7jC,eAAAs3E,GAGA,OADAvmF,GAAA8yC,EAAAyzC,GAAAvmF,OACAuI,EAAA,EAAmBA,EAAAvI,EAAA+E,OAAmBwD,IACtC+9E,EAAAtmF,EAAAuI,GAAAg+E,EAAAzzC,EAAAyzC,GAwKA,OAhCArwE,IACA+zB,KACA2mB,MAAA,EACAC,OAAA,EACAloD,iBACAmoD,KAAA,MAEAg3B,WACAQ,KAAAjC,EAAAkC,eACAt+C,IAAAo8C,EAAAmC,cACAC,GAAApC,EAAAqC,aACAC,KAAAtC,EAAAuC,eACAp4B,KAAA61B,EAAAwC,eACAp4B,MAAA41B,EAAAyC,gBACAC,WAAA1C,EAAA0B,qBACAiB,SAAA3C,EAAA4C,sBAiBUn2C,e1EohuBJ,SAASr1C,EAAQD,EAASH,G2E5yuBhC,GAAAm4E,IAKA,SAAA7zE,EAAArD,EAAA4qF,EAAAvgF,GACA,YAkBA,SAAAwgF,GAAAl7E,EAAAq8B,EAAAp8B,GACA,MAAA9E,YAAAggF,EAAAn7E,EAAAC,GAAAo8B,GAYA,QAAA++C,GAAAlzC,EAAAloC,EAAAC,GACA,QAAAsY,MAAAlhB,QAAA6wC,KACAwb,EAAAxb,EAAAjoC,EAAAD,GAAAC,IACA,GAWA,QAAAyjD,GAAA1zD,EAAAqrF,EAAAp7E,GACA,GAAA3F,EAEA,IAAAtK,EAIA,GAAAA,EAAAgH,QACAhH,EAAAgH,QAAAqkF,EAAAp7E,OACK,IAAAjQ,EAAA8G,SAAA4D,EAEL,IADAJ,EAAA,EACAA,EAAAtK,EAAA8G,QACAukF,EAAA1rF,KAAAsQ,EAAAjQ,EAAAsK,KAAAtK,GACAsK,QAGA,KAAAA,IAAAtK,GACAA,EAAAgR,eAAA1G,IAAA+gF,EAAA1rF,KAAAsQ,EAAAjQ,EAAAsK,KAAAtK,GAYA,QAAA+/B,GAAAlC,EAAAj7B,EAAAqF,GACA,GAAAqjF,GAAA,sBAAA1oF,EAAA,KAAAqF,EAAA,QACA,mBACA,GAAA8D,GAAA,GAAA1D,OAAA,mBACAyQ,EAAA/M,KAAA+M,MAAA/M,EAAA+M,MAAA7S,QAAA,sBACAA,QAAA,kBACAA,QAAA,+CAA+D,sBAE/DsC,EAAA7E,EAAAyyC,UAAAzyC,EAAAyyC,QAAA1tC,MAAA/E,EAAAyyC,QAAA5tC,IAIA,OAHAA,IACAA,EAAA5I,KAAA+D,EAAAyyC,QAAAm1C,EAAAxyE,GAEA+kB,EAAAr1B,MAAAnG,KAAAwE,YAwEA,QAAA0kF,GAAAlpE,EAAA7R,EAAAsnC,GACA,GACA0zC,GADAC,EAAAj7E,EAAAkwB,SAGA8qD,GAAAnpE,EAAAqe,UAAAlyB,OAAA2tB,OAAAsvD,GACAD,EAAA5jE,YAAAvF,EACAmpE,EAAAjsD,OAAAksD,EAEA3zC,GACA4zC,GAAAF,EAAA1zC,GAUA,QAAAqzC,GAAAn7E,EAAAC,GACA,kBACA,MAAAD,GAAAxH,MAAAyH,EAAApJ,YAWA,QAAA8kF,GAAAjsE,EAAAxX,GACA,aAAAwX,IAAAksE,GACAlsE,EAAAlX,MAAAN,IAAA,IAAAwC,IAAAxC,GAEAwX,EASA,QAAAmsE,GAAAC,EAAAC,GACA,MAAAD,KAAAphF,EAAAqhF,EAAAD,EASA,QAAAE,GAAArpF,EAAAspF,EAAA1gF,GACAmoD,EAAAw4B,EAAAD,GAAA,SAAAxiF,GACA9G,EAAAu3D,iBAAAzwD,EAAA8B,GAAA,KAUA,QAAA4gF,GAAAxpF,EAAAspF,EAAA1gF,GACAmoD,EAAAw4B,EAAAD,GAAA,SAAAxiF,GACA9G,EAAAy3D,oBAAA3wD,EAAA8B,GAAA,KAWA,QAAA6gF,GAAA7oF,EAAA8F,GACA,KAAA9F,GAAA,CACA,GAAAA,GAAA8F,EACA,QAEA9F,KAAAoC,WAEA,SASA,QAAA0mF,GAAA5oE,EAAAhR,GACA,MAAAgR,GAAAtZ,QAAAsI,IAAA,EAQA,QAAAy5E,GAAAzoE,GACA,MAAAA,GAAAD,OAAA1I,MAAA,QAUA,QAAAwxE,GAAA/O,EAAA9qE,EAAA85E,GACA,GAAAhP,EAAApzE,UAAAoiF,EACA,MAAAhP,GAAApzE,QAAAsI,EAGA,KADA,GAAAnI,GAAA,EACAA,EAAAizE,EAAAz2E,QAAA,CACA,GAAAylF,GAAAhP,EAAAjzE,GAAAiiF,IAAA95E,IAAA85E,GAAAhP,EAAAjzE,KAAAmI,EACA,MAAAnI,EAEAA,KAEA,SASA,QAAAS,GAAA/K,GACA,MAAAuoB,OAAAmY,UAAA9rB,MAAAjV,KAAAK,EAAA,GAUA,QAAAwsF,GAAAjP,EAAAn2E,EAAAqZ,GAKA,IAJA,GAAA86D,MACAv7D,KACA1V,EAAA,EAEAA,EAAAizE,EAAAz2E,QAAA,CACA,GAAA4Y,GAAAtY,EAAAm2E,EAAAjzE,GAAAlD,GAAAm2E,EAAAjzE,EACAgiF,GAAAtsE,EAAAN,GAAA,GACA67D,EAAAnxE,KAAAmzE,EAAAjzE,IAEA0V,EAAA1V,GAAAoV,EACApV,IAaA,MAVAmW,KAIA86D,EAHAn0E,EAGAm0E,EAAA96D,KAAA,SAAAjZ,EAAAC,GACA,MAAAD,GAAAJ,GAAAK,EAAAL,KAHAm0E,EAAA96D,QAQA86D,EASA,QAAA9/D,GAAAzb,EAAAkjE,GAKA,IAJA,GAAA1nD,GAAAzU,EACA0lF,EAAAvpB,EAAA,GAAA58D,cAAA48D,EAAAtuD,MAAA,GAEAtK,EAAA,EACAA,EAAAoiF,GAAA5lF,QAAA,CAIA,GAHA0U,EAAAkxE,GAAApiF,GACAvD,EAAA,EAAAyU,EAAAixE,EAAAvpB,EAEAn8D,IAAA/G,GACA,MAAA+G,EAEAuD,KAEA,MAAAI,GAQA,QAAAiiF,KACA,MAAAC,MAQA,QAAAC,GAAAvgF,GACA,GAAAnH,GAAAmH,EAAAwgF,eAAAxgF,CACA,OAAAnH,GAAA4nF,aAAA5nF,EAAAy4E,cAAAl6E,EAyCA,QAAAi7D,GAAAtxD,EAAAnC,GACA,GAAA47D,GAAAzkE,IACAA,MAAAgL,UACAhL,KAAA6I,WACA7I,KAAAiK,QAAAe,EAAAf,QACAjK,KAAAM,OAAA0K,EAAAmE,QAAAw7E,YAIA3qF,KAAA4qF,WAAA,SAAAC,GACAvB,EAAAt+E,EAAAmE,QAAAm+D,QAAAtiE,KACAy5D,EAAAv7D,QAAA2hF,IAIA7qF,KAAA0S,OAoCA,QAAAo4E,GAAA9/E,GACA,GAAA+/E,GACAC,EAAAhgF,EAAAmE,QAAA67E,UAaA,YAVAD,EADAC,EACAA,EACKC,GACLC,EACKC,GACLC,EACKC,GAGLC,EAFAC,GAIAvgF,EAAAwgF,GASA,QAAAA,GAAAxgF,EAAA+jE,EAAA/rE,GACA,GAAAyoF,GAAAzoF,EAAA0oF,SAAAjnF,OACAknF,EAAA3oF,EAAA4oF,gBAAAnnF,OACAonF,EAAA9c,EAAA+c,IAAAL,EAAAE,IAAA,EACAI,EAAAhd,GAAAid,GAAAC,KAAAR,EAAAE,IAAA,CAEA3oF,GAAA6oF,YACA7oF,EAAA+oF,YAEAF,IACA7gF,EAAAkhF,YAKAlpF,EAAA+rE,YAGAod,EAAAnhF,EAAAhI,GAGAgI,EAAA07D,KAAA,eAAA1jE,GAEAgI,EAAAohF,UAAAppF,GACAgI,EAAAkhF,QAAAG,UAAArpF,EAQA,QAAAmpF,GAAAnhF,EAAAhI,GACA,GAAAkpF,GAAAlhF,EAAAkhF,QACAR,EAAA1oF,EAAA0oF,SACAY,EAAAZ,EAAAjnF,MAGAynF,GAAAK,aACAL,EAAAK,WAAAC,EAAAxpF,IAIAspF,EAAA,IAAAJ,EAAAO,cACAP,EAAAO,cAAAD,EAAAxpF,GACK,IAAAspF,IACLJ,EAAAO,eAAA,EAGA,IAAAF,GAAAL,EAAAK,WACAE,EAAAP,EAAAO,cACAC,EAAAD,IAAAE,OAAAJ,EAAAI,OAEAA,EAAA3pF,EAAA2pF,OAAAC,EAAAlB,EACA1oF,GAAAkhF,UAAArrE,KACA7V,EAAA6pF,UAAA7pF,EAAAkhF,UAAAqI,EAAArI,UAEAlhF,EAAA8pF,MAAAC,EAAAL,EAAAC,GACA3pF,EAAAgqF,SAAAC,EAAAP,EAAAC,GAEAO,EAAAhB,EAAAlpF,GACAA,EAAAmqF,gBAAAC,EAAApqF,EAAAqqF,OAAArqF,EAAAsqF,OAEA,IAAAC,GAAAC,EAAAxqF,EAAA6pF,UAAA7pF,EAAAqqF,OAAArqF,EAAAsqF,OACAtqF,GAAAyqF,iBAAAF,EAAAnlF,EACApF,EAAA0qF,iBAAAH,EAAAzjF,EACA9G,EAAAuqF,gBAAAnN,GAAAmN,EAAAnlF,GAAAg4E,GAAAmN,EAAAzjF,GAAAyjF,EAAAnlF,EAAAmlF,EAAAzjF,EAEA9G,EAAA2qF,MAAAlB,EAAAmB,EAAAnB,EAAAf,YAAA,EACA1oF,EAAA6qF,SAAApB,EAAAqB,EAAArB,EAAAf,YAAA,EAEA1oF,EAAA+qF,YAAA7B,EAAAG,UAAArpF,EAAA0oF,SAAAjnF,OACAynF,EAAAG,UAAA0B,YAAA/qF,EAAA0oF,SAAAjnF,OAAAynF,EAAAG,UAAA0B,YADA/qF,EAAA0oF,SAAAjnF,OAGAupF,EAAA9B,EAAAlpF,EAGA,IAAA1C,GAAA0K,EAAAf,OACA8/E,GAAA/mF,EAAAirF,SAAA3tF,YACAA,EAAA0C,EAAAirF,SAAA3tF,QAEA0C,EAAA1C,SAGA,QAAA4sF,GAAAhB,EAAAlpF,GACA,GAAA2pF,GAAA3pF,EAAA2pF,OACAuB,EAAAhC,EAAAiC,gBACAC,EAAAlC,EAAAkC,cACA/B,EAAAH,EAAAG,aAEArpF,GAAA+rE,YAAA+c,IAAAO,EAAAtd,YAAAid,KACAoC,EAAAlC,EAAAkC,WACAhmF,EAAAikF,EAAAgB,QAAA,EACAvjF,EAAAuiF,EAAAiB,QAAA,GAGAY,EAAAhC,EAAAiC,aACA/lF,EAAAukF,EAAAvkF,EACA0B,EAAA6iF,EAAA7iF,IAIA9G,EAAAqqF,OAAAe,EAAAhmF,GAAAukF,EAAAvkF,EAAA8lF,EAAA9lF,GACApF,EAAAsqF,OAAAc,EAAAtkF,GAAA6iF,EAAA7iF,EAAAokF,EAAApkF,GAQA,QAAAkkF,GAAA9B,EAAAlpF,GACA,GAEAqrF,GAAAC,EAAAC,EAAA/G,EAFAgH,EAAAtC,EAAAuC,cAAAzrF,EACA6pF,EAAA7pF,EAAAkhF,UAAAsK,EAAAtK,SAGA,IAAAlhF,EAAA+rE,WAAAkd,KAAAY,EAAA6B,IAAAF,EAAAH,WAAAhmF,GAAA,CACA,GAAAglF,GAAArqF,EAAAqqF,OAAAmB,EAAAnB,OACAC,EAAAtqF,EAAAsqF,OAAAkB,EAAAlB,OAEA1lE,EAAA4lE,EAAAX,EAAAQ,EAAAC,EACAgB,GAAA1mE,EAAAxf,EACAmmF,EAAA3mE,EAAA9d,EACAukF,EAAAjO,GAAAx4D,EAAAxf,GAAAg4E,GAAAx4D,EAAA9d,GAAA8d,EAAAxf,EAAAwf,EAAA9d,EACA09E,EAAA4F,EAAAC,EAAAC,GAEApB,EAAAuC,aAAAzrF,MAGAqrF,GAAAG,EAAAH,SACAC,EAAAE,EAAAF,UACAC,EAAAC,EAAAD,UACA/G,EAAAgH,EAAAhH,SAGAxkF,GAAAqrF,WACArrF,EAAAsrF,YACAtrF,EAAAurF,YACAvrF,EAAAwkF,YAQA,QAAAgF,GAAAxpF,GAKA,IAFA,GAAA0oF,MACAzjF,EAAA,EACAA,EAAAjF,EAAA0oF,SAAAjnF,QACAinF,EAAAzjF,IACA0mF,QAAAxgB,GAAAnrE,EAAA0oF,SAAAzjF,GAAA0mF,SACAC,QAAAzgB,GAAAnrE,EAAA0oF,SAAAzjF,GAAA2mF,UAEA3mF,GAGA,QACAi8E,UAAArrE,KACA6yE,WACAiB,OAAAC,EAAAlB,GACA2B,OAAArqF,EAAAqqF,OACAC,OAAAtqF,EAAAsqF,QASA,QAAAV,GAAAlB,GACA,GAAAY,GAAAZ,EAAAjnF,MAGA,QAAA6nF,EACA,OACAlkF,EAAA+lE,GAAAud,EAAA,GAAAiD,SACA7kF,EAAAqkE,GAAAud,EAAA,GAAAkD,SAKA,KADA,GAAAxmF,GAAA,EAAA0B,EAAA,EAAA7B,EAAA,EACAA,EAAAqkF,GACAlkF,GAAAsjF,EAAAzjF,GAAA0mF,QACA7kF,GAAA4hF,EAAAzjF,GAAA2mF,QACA3mF,GAGA,QACAG,EAAA+lE,GAAA/lE,EAAAkkF,GACAxiF,EAAAqkE,GAAArkE,EAAAwiF,IAWA,QAAAkB,GAAAX,EAAAzkF,EAAA0B,GACA,OACA1B,IAAAykF,GAAA,EACA/iF,IAAA+iF,GAAA,GAUA,QAAAO,GAAAhlF,EAAA0B,GACA,MAAA1B,KAAA0B,EACAm+E,GAGA7H,GAAAh4E,IAAAg4E,GAAAt2E,GACA1B,EAAA,EAAAmgF,GAAAC,GAEA1+E,EAAA,EAAAs+E,GAAAE,GAUA,QAAA2E,GAAA4B,EAAAC,EAAAzrD;AACAA,IACAA,EAAA0rD,GAEA,IAAA3mF,GAAA0mF,EAAAzrD,EAAA,IAAAwrD,EAAAxrD,EAAA,IACAv5B,EAAAglF,EAAAzrD,EAAA,IAAAwrD,EAAAxrD,EAAA,GAEA,OAAApoB,MAAA+zE,KAAA5mF,IAAA0B,KAUA,QAAAijF,GAAA8B,EAAAC,EAAAzrD,GACAA,IACAA,EAAA0rD,GAEA,IAAA3mF,GAAA0mF,EAAAzrD,EAAA,IAAAwrD,EAAAxrD,EAAA,IACAv5B,EAAAglF,EAAAzrD,EAAA,IAAAwrD,EAAAxrD,EAAA,GACA,YAAApoB,KAAAg0E,MAAAnlF,EAAA1B,GAAA6S,KAAAi0E,GASA,QAAApB,GAAAxrF,EAAA2L,GACA,MAAA8+E,GAAA9+E,EAAA,GAAAA,EAAA,GAAAkhF,IAAApC,EAAAzqF,EAAA,GAAAA,EAAA,GAAA6sF,IAUA,QAAAvB,GAAAtrF,EAAA2L,GACA,MAAAg/E,GAAAh/E,EAAA,GAAAA,EAAA,GAAAkhF,IAAAlC,EAAA3qF,EAAA,GAAAA,EAAA,GAAA6sF,IAiBA,QAAA5D,KACAvrF,KAAAovF,KAAAC,GACArvF,KAAAsvF,MAAAC,GAEAvvF,KAAAwvF,SAAA,EAEAlzB,EAAAn2D,MAAAnG,KAAAwE,WAoEA,QAAA0mF,KACAlrF,KAAAovF,KAAAK,GACAzvF,KAAAsvF,MAAAI,GAEApzB,EAAAn2D,MAAAnG,KAAAwE,WAEAxE,KAAA2vF,MAAA3vF,KAAAgL,QAAAkhF,QAAA0D,iBAoEA,QAAAC,KACA7vF,KAAA8vF,SAAAC,GACA/vF,KAAAsvF,MAAAU,GACAhwF,KAAAiwF,SAAA,EAEA3zB,EAAAn2D,MAAAnG,KAAAwE,WAsCA,QAAA0rF,GAAArF,EAAAzjF,GACA,GAAAuiC,GAAAjhC,EAAAmiF,EAAAsF,SACAzyC,EAAAh1C,EAAAmiF,EAAAuF,eAMA,OAJAhpF,IAAA4kF,GAAAC,MACAtiD,EAAAwgD,EAAAxgD,EAAAl+B,OAAAiyC,GAAA,mBAGA/T,EAAA+T,GAiBA,QAAA0tC,KACAprF,KAAA8vF,SAAAO,GACArwF,KAAAswF,aAEAh0B,EAAAn2D,MAAAnG,KAAAwE,WA0BA,QAAA+rF,GAAA1F,EAAAzjF,GACA,GAAAopF,GAAA9nF,EAAAmiF,EAAAsF,SACAG,EAAAtwF,KAAAswF,SAGA,IAAAlpF,GAAA0kF,GAAA2E,KAAA,IAAAD,EAAA/rF,OAEA,MADA6rF,GAAAE,EAAA,GAAA/lE,aAAA,GACA+lE,IAGA,IAAAvoF,GACAyoF,EACAN,EAAA1nF,EAAAmiF,EAAAuF,gBACAO,KACArwF,EAAAN,KAAAM,MAQA,IALAowF,EAAAF,EAAAjwE,OAAA,SAAAqwE,GACA,MAAA7G,GAAA6G,EAAAtwF,YAIA8G,IAAA0kF,GAEA,IADA7jF,EAAA,EACAA,EAAAyoF,EAAAjsF,QACA6rF,EAAAI,EAAAzoF,GAAAwiB,aAAA,EACAxiB,GAMA,KADAA,EAAA,EACAA,EAAAmoF,EAAA3rF,QACA6rF,EAAAF,EAAAnoF,GAAAwiB,aACAkmE,EAAA5oF,KAAAqoF,EAAAnoF,IAIAb,GAAA4kF,GAAAC,WACAqE,GAAAF,EAAAnoF,GAAAwiB,YAEAxiB,GAGA,OAAA0oF,GAAAlsF,QAMA0lF,EAAAuG,EAAAjlF,OAAAklF,GAAA,iBACAA,GAPA,OAwBA,QAAArF,KACAhvB,EAAAn2D,MAAAnG,KAAAwE,UAEA,IAAA0E,GAAA4/E,EAAA9oF,KAAAkJ,QAAAlJ,KACAA,MAAA4wF,MAAA,GAAAxF,GAAAprF,KAAAgL,QAAA9B,GACAlJ,KAAA6wF,MAAA,GAAAtF,GAAAvrF,KAAAgL,QAAA9B,GAEAlJ,KAAA8wF,aAAA,KACA9wF,KAAA+wF,eAqCA,QAAAC,GAAAjiB,EAAAkiB,GACAliB,EAAA+c,IACA9rF,KAAA8wF,aAAAG,EAAArF,gBAAA,GAAAnhE,WACAymE,EAAA5zF,KAAA0C,KAAAixF,IACKliB,GAAAid,GAAAC,KACLiF,EAAA5zF,KAAA0C,KAAAixF,GAIA,QAAAC,GAAAD,GACA,GAAAL,GAAAK,EAAArF,gBAAA,EAEA,IAAAgF,EAAAnmE,aAAAzqB,KAAA8wF,aAAA,CACA,GAAAK,IAAyB/oF,EAAAwoF,EAAAjC,QAAA7kF,EAAA8mF,EAAAhC,QACzB5uF,MAAA+wF,YAAAhpF,KAAAopF,EACA,IAAAC,GAAApxF,KAAA+wF,YACAM,EAAA,WACA,GAAAppF,GAAAmpF,EAAAtpF,QAAAqpF,EACAlpF,IAAA,GACAmpF,EAAA3oF,OAAAR,EAAA,GAGAa,YAAAuoF,EAAAC,KAIA,QAAAC,GAAAN,GAEA,OADA7oF,GAAA6oF,EAAAhD,SAAAU,QAAA7kF,EAAAmnF,EAAAhD,SAAAW,QACA3mF,EAAA,EAAmBA,EAAAjI,KAAA+wF,YAAAtsF,OAA6BwD,IAAA,CAChD,GAAAyf,GAAA1nB,KAAA+wF,YAAA9oF,GACAupF,EAAAv2E,KAAAmlE,IAAAh4E,EAAAsf,EAAAtf,GAAAqpF,EAAAx2E,KAAAmlE,IAAAt2E,EAAA4d,EAAA5d,EACA,IAAA0nF,GAAAE,IAAAD,GAAAC,GACA,SAGA,SAsBA,QAAAC,GAAA3mF,EAAAxK,GACAR,KAAAgL,UACAhL,KAAAI,IAAAI,GAmGA,QAAAoxF,GAAAC,GAEA,GAAA7H,EAAA6H,EAAAC,IACA,MAAAA,GAGA,IAAAC,GAAA/H,EAAA6H,EAAAG,IACAC,EAAAjI,EAAA6H,EAAAK,GAMA,OAAAH,IAAAE,EACAH,GAIAC,GAAAE,EACAF,EAAAC,GAAAE,GAIAlI,EAAA6H,EAAAM,IACAA,GAGAC,GAGA,QAAAC,KACA,IAAAC,GACA,QAEA,IAAAC,MACAC,EAAAnxF,EAAAoxF,KAAApxF,EAAAoxF,IAAAC,QAOA,QANA,4DAAA/tF,QAAA,SAAA0Y,GAIAk1E,EAAAl1E,IAAAm1E,GAAAnxF,EAAAoxF,IAAAC,SAAA,eAAAr1E,KAEAk1E,EA4CA,QAAAI,IAAAxjF,GACAnP,KAAAmP,QAAAk6E,MAA4BrpF,KAAAwyC,SAAArjC,OAE5BnP,KAAA5C,GAAAktF,IAEAtqF,KAAAgL,QAAA,KAGAhL,KAAAmP,QAAAm+D,OAAAkc,EAAAxpF,KAAAmP,QAAAm+D,QAAA,GAEAttE,KAAAq2C,MAAAu8C,GAEA5yF,KAAA6yF,gBACA7yF,KAAA8yF,eAqOA,QAAAC,IAAA18C,GACA,MAAAA,GAAA28C,GACA,SACK38C,EAAA48C,GACL,MACK58C,EAAA68C,GACL,OACK78C,EAAA88C,GACL,QAEA,GAQA,QAAAC,IAAA5L,GACA,MAAAA,IAAAc,GACA,OACKd,GAAAY,GACL,KACKZ,GAAAe,GACL,OACKf,GAAAgB,GACL,QAEA,GASA,QAAA6K,IAAAC,EAAA9M,GACA,GAAAx7E,GAAAw7E,EAAAx7E,OACA,OAAAA,GACAA,EAAAtK,IAAA4yF,GAEAA,EAQA,QAAAC,MACAZ,GAAAxsF,MAAAnG,KAAAwE,WA6DA,QAAAgvF,MACAD,GAAAptF,MAAAnG,KAAAwE,WAEAxE,KAAAyzF,GAAA,KACAzzF,KAAA0zF,GAAA,KA4EA,QAAAC,MACAJ,GAAAptF,MAAAnG,KAAAwE,WAsCA,QAAAovF,MACAjB,GAAAxsF,MAAAnG,KAAAwE,WAEAxE,KAAA6zF,OAAA,KACA7zF,KAAA8zF,OAAA,KAmEA,QAAAC,MACAR,GAAAptF,MAAAnG,KAAAwE,WA8BA,QAAAwvF,MACAT,GAAAptF,MAAAnG,KAAAwE,WA2DA,QAAAyvF,MACAtB,GAAAxsF,MAAAnG,KAAAwE,WAIAxE,KAAAk0F,OAAA,EACAl0F,KAAAm0F,SAAA,EAEAn0F,KAAA6zF,OAAA,KACA7zF,KAAA8zF,OAAA,KACA9zF,KAAAquB,MAAA,EAqGA,QAAA03D,IAAA97E,EAAAkF,GAGA,MAFAA,SACAA,EAAAw3E,YAAA6C,EAAAr6E,EAAAw3E,YAAAZ,GAAAvzC,SAAA4hD,QACA,GAAApN,IAAA/8E,EAAAkF,GAiIA,QAAA63E,IAAA/8E,EAAAkF,GACAnP,KAAAmP,QAAAk6E,MAA4BtD,GAAAvzC,SAAArjC,OAE5BnP,KAAAmP,QAAAw7E,YAAA3qF,KAAAmP,QAAAw7E,aAAA1gF,EAEAjK,KAAAgJ,YACAhJ,KAAAksF,WACAlsF,KAAA2mF,eACA3mF,KAAAq0F,eAEAr0F,KAAAiK,UACAjK,KAAAgD,MAAA8nF,EAAA9qF,MACAA,KAAAs0F,YAAA,GAAA3C,GAAA3xF,UAAAmP,QAAAmlF,aAEAC,GAAAv0F,MAAA,GAEAqxD,EAAArxD,KAAAmP,QAAAw3E,YAAA,SAAA70E,GACA,GAAA00E,GAAAxmF,KAAA6O,IAAA,GAAAiD,GAAA,GAAAA,EAAA,IACAA,GAAA,IAAA00E,EAAAK,cAAA/0E,EAAA,IACAA,EAAA,IAAA00E,EAAAgO,eAAA1iF,EAAA,KACK9R,MA4PL,QAAAu0F,IAAAvpF,EAAA6D,GACA,GAAA5E,GAAAe,EAAAf,OACA,IAAAA,EAAAwY,MAAA,CAGA,GAAA/d,EACA2sD,GAAArmD,EAAAmE,QAAAslF,SAAA,SAAAj0F,EAAAD,GACAmE,EAAA0U,EAAAnP,EAAAwY,MAAAliB,GACAsO,GACA7D,EAAAqpF,YAAA3vF,GAAAuF,EAAAwY,MAAA/d,GACAuF,EAAAwY,MAAA/d,GAAAlE,GAEAyJ,EAAAwY,MAAA/d,GAAAsG,EAAAqpF,YAAA3vF,IAAA,KAGAmK,IACA7D,EAAAqpF,iBASA,QAAAK,IAAAv0F,EAAAnB,GACA,GAAA21F,GAAA32F,EAAA42F,YAAA,QACAD,GAAA7Q,UAAA3jF,GAAA,MACAw0F,EAAAE,QAAA71F,EACAA,EAAAsB,OAAA2uE,cAAA0lB,GAngFA,GA+FAtL,IA/FAgB,IAAA,iCACAyK,GAAA92F,EAAAwwC,cAAA,OAEA+6C,GAAA,WAEApb,GAAAlzD,KAAAkzD,MACAiS,GAAAnlE,KAAAmlE,IACAvnE,GAAA8iC,KAAA9iC,GA0FAwwE,IADA,kBAAAl9E,QAAAk9E,OACA,SAAA/oF,GACA,GAAAA,IAAA+H,GAAA,OAAA/H,EACA,SAAAkJ,WAAA,6CAIA,QADAvG,GAAAkJ,OAAA7L,GACAuH,EAAA,EAA2BA,EAAArD,UAAAC,OAA0BoD,IAAA,CACrD,GAAAjD,GAAAJ,UAAAqD,EACA,IAAAjD,IAAAyD,GAAA,OAAAzD,EACA,OAAAmwF,KAAAnwF,GACAA,EAAA+J,eAAAomF,KACA9xF,EAAA8xF,GAAAnwF,EAAAmwF,IAKA,MAAA9xF,IAGAkJ,OAAAk9E,MAWA,IAAAh3C,IAAA3U,EAAA,SAAAngB,EAAA29D,EAAA7+D,GAGA,IAFA,GAAAjQ,GAAAD,OAAAC,KAAA8uE,GACAjzE,EAAA,EACAA,EAAAmE,EAAA3H,UACA4X,MAAAkB,EAAAnR,EAAAnE,MAAAI,KACAkV,EAAAnR,EAAAnE,IAAAizE,EAAA9uE,EAAAnE,KAEAA,GAEA,OAAAsV,IACC,0BASDlB,GAAAqhB,EAAA,SAAAngB,EAAA29D,GACA,MAAA7oC,IAAA90B,EAAA29D,GAAA,IACC,yBAiNDqP,GAAA,EAeAyK,GAAA,wCAEA3J,GAAA,gBAAAhqF,GACA4pF,GAAA7xE,EAAA/X,EAAA,kBAAAgH,EACA8iF,GAAAE,IAAA2J,GAAAnnF,KAAAxP,UAAAouE,WAEAwoB,GAAA,QACAC,GAAA,MACAC,GAAA,QACAC,GAAA,SAEA1G,GAAA,GAEA5C,GAAA,EACA2E,GAAA,EACAzE,GAAA,EACAC,GAAA,EAEAhE,GAAA,EACAM,GAAA,EACAC,GAAA,EACAJ,GAAA,EACAE,GAAA,GAEAb,GAAAc,GAAAC,GACAG,GAAAP,GAAAE,GACAJ,GAAAT,GAAAkB,GAEAoG,IAAA,SACAI,IAAA,oBA4BA7yB,GAAAj+B,WAKAn1B,QAAA,aAKAwJ,KAAA,WACA1S,KAAAovF,MAAAzF,EAAA3pF,KAAAiK,QAAAjK,KAAAovF,KAAApvF,KAAA4qF,YACA5qF,KAAA8vF,UAAAnG,EAAA3pF,KAAAM,OAAAN,KAAA8vF,SAAA9vF,KAAA4qF,YACA5qF,KAAAsvF,OAAA3F,EAAAa,EAAAxqF,KAAAiK,SAAAjK,KAAAsvF,MAAAtvF,KAAA4qF,aAMAxE,QAAA,WACApmF,KAAAovF,MAAAtF,EAAA9pF,KAAAiK,QAAAjK,KAAAovF,KAAApvF,KAAA4qF,YACA5qF,KAAA8vF,UAAAhG,EAAA9pF,KAAAM,OAAAN,KAAA8vF,SAAA9vF,KAAA4qF,YACA5qF,KAAAsvF,OAAAxF,EAAAU,EAAAxqF,KAAAiK,SAAAjK,KAAAsvF,MAAAtvF,KAAA4qF,aA4TA,IAAAyK,KACAC,UAAAxJ,GACAyJ,UAAA9E,GACA+E,QAAAxJ,IAGAqD,GAAA,YACAE,GAAA,mBAgBArG,GAAAqC,EAAAjvB,GAKApzD,QAAA,SAAA2hF,GACA,GAAA9b,GAAAsmB,GAAAxK,EAAAzjF,KAGA2nE,GAAA+c,IAAA,IAAAjB,EAAA4K,SACAz1F,KAAAwvF,SAAA,GAGAzgB,EAAA0hB,IAAA,IAAA5F,EAAAh/E,QACAkjE,EAAAid,IAIAhsF,KAAAwvF,UAIAzgB,EAAAid,KACAhsF,KAAAwvF,SAAA,GAGAxvF,KAAA6I,SAAA7I,KAAAgL,QAAA+jE,GACA2c,UAAAb,GACAe,iBAAAf,GACA6K,YAAAP,GACAlH,SAAApD,OAKA,IAAA8K,KACAC,YAAA9J,GACA+J,YAAApF,GACAqF,UAAA9J,GACA+J,cAAA9J,GACA+J,WAAA/J,IAIAgK,IACAC,EAAAjB,GACAkB,EAAAjB,GACAkB,EAAAjB,GACAkB,EAAAjB,IAGA3F,GAAA,cACAC,GAAA,qCAGAruF,GAAAi1F,iBAAAj1F,EAAAk1F,eACA9G,GAAA,gBACAC,GAAA,6CAiBAxG,EAAAgC,EAAA5uB,GAKApzD,QAAA,SAAA2hF,GACA,GAAA8E,GAAA3vF,KAAA2vF,MACA6G,GAAA,EAEAC,EAAA5L,EAAAzjF,KAAAhD,cAAAR,QAAA,SACAmrE,EAAA4mB,GAAAc,GACAf,EAAAO,GAAApL,EAAA6K,cAAA7K,EAAA6K,YAEAgB,EAAAhB,GAAAT,GAGA0B,EAAA1M,EAAA0F,EAAA9E,EAAA+L,UAAA,YAGA7nB,GAAA+c,KAAA,IAAAjB,EAAA4K,QAAAiB,GACAC,EAAA,IACAhH,EAAA5nF,KAAA8iF,GACA8L,EAAAhH,EAAAlrF,OAAA,GAESsqE,GAAAid,GAAAC,MACTuK,GAAA,GAIAG,EAAA,IAKAhH,EAAAgH,GAAA9L,EAEA7qF,KAAA6I,SAAA7I,KAAAgL,QAAA+jE,GACA2c,SAAAiE,EACA/D,iBAAAf,GACA6K,cACAzH,SAAApD,IAGA2L,GAEA7G,EAAAlnF,OAAAkuF,EAAA,MAKA,IAAAE,KACAC,WAAAhL,GACAiL,UAAAtG,GACAuG,SAAAhL,GACAiL,YAAAhL,IAGA8D,GAAA,aACAC,GAAA,2CAeA9G,GAAA2G,EAAAvzB,GACApzD,QAAA,SAAA2hF,GACA,GAAAzjF,GAAAyvF,GAAAhM,EAAAzjF,KAOA,IAJAA,IAAA0kF,KACA9rF,KAAAiwF,SAAA,GAGAjwF,KAAAiwF,QAAA,CAIA,GAAAE,GAAAD,EAAA5yF,KAAA0C,KAAA6qF,EAAAzjF,EAGAA,IAAA4kF,GAAAC,KAAAkE,EAAA,GAAA1rF,OAAA0rF,EAAA,GAAA1rF,SAAA,IACAzE,KAAAiwF,SAAA,GAGAjwF,KAAA6I,SAAA7I,KAAAgL,QAAA5D,GACAskF,SAAAyE,EAAA,GACAvE,gBAAAuE,EAAA,GACAuF,YAAAT,GACAhH,SAAApD,OAsBA,IAAAqM,KACAJ,WAAAhL,GACAiL,UAAAtG,GACAuG,SAAAhL,GACAiL,YAAAhL,IAGAoE,GAAA,2CAcAnH,GAAAkC,EAAA9uB,GACApzD,QAAA,SAAA2hF,GACA,GAAAzjF,GAAA8vF,GAAArM,EAAAzjF,MACA+oF,EAAAI,EAAAjzF,KAAA0C,KAAA6qF,EAAAzjF,EACA+oF,IAIAnwF,KAAA6I,SAAA7I,KAAAgL,QAAA5D,GACAskF,SAAAyE,EAAA,GACAvE,gBAAAuE,EAAA,GACAuF,YAAAT,GACAhH,SAAApD,MA4EA,IAAAyG,IAAA,KACAI,GAAA,EAaAxI,GAAAoC,EAAAhvB,GAOApzD,QAAA,SAAA8B,EAAAmsF,EAAAC,GACA,GAAAV,GAAAU,EAAA1B,aAAAT,GACAoC,EAAAD,EAAA1B,aAAAP,EAEA,MAAAkC,GAAAD,EAAAE,oBAAAF,EAAAE,mBAAAC,kBAAA,CAKA,GAAAb,EACA1F,EAAA1zF,KAAA0C,KAAAm3F,EAAAC,OACS,IAAAC,GAAA9F,EAAAj0F,KAAA0C,KAAAo3F,GACT,MAGAp3F,MAAA6I,SAAAmC,EAAAmsF,EAAAC,KAMAhR,QAAA,WACApmF,KAAA4wF,MAAAxK,UACApmF,KAAA6wF,MAAAzK,YA0CA,IAAAoR,IAAAp+E,EAAA07E,GAAAryE,MAAA,eACA6vE,GAAAkF,KAAAnvF,EAGAovF,GAAA,UACArF,GAAA,OACAD,GAAA,eACAL,GAAA,OACAE,GAAA,QACAE,GAAA,QACAwF,GAAArF,GAcAV,GAAAtzD,WAKAj+B,IAAA,SAAAI,GAEAA,GAAAi3F,KACAj3F,EAAAR,KAAAonC,WAGAkrD,IAAAtyF,KAAAgL,QAAAf,QAAAwY,OAAAi1E,GAAAl3F,KACAR,KAAAgL,QAAAf,QAAAwY,MAAA+0E,IAAAh3F,GAEAR,KAAA6xF,QAAArxF,EAAA4D,cAAA+c,QAMA1U,OAAA,WACAzM,KAAAI,IAAAJ,KAAAgL,QAAAmE,QAAAmlF,cAOAltD,QAAA,WACA,GAAAyqD,KAMA,OALAxgC,GAAArxD,KAAAgL,QAAA27E,YAAA,SAAAH,GACA8C,EAAA9C,EAAAr3E,QAAAm+D,QAAAkZ,MACAqL,IAAApmF,OAAA+6E,EAAAmR,qBAGA/F,EAAAC,EAAAhiF,KAAA,OAOA+nF,gBAAA,SAAA50F,GACA,GAAAirF,GAAAjrF,EAAAirF,SACAzG,EAAAxkF,EAAAmqF,eAGA,IAAAntF,KAAAgL,QAAAkhF,QAAA2L,UAEA,WADA5J,GAAA54E,gBAIA,IAAAw8E,GAAA7xF,KAAA6xF,QACAiG,EAAA9N,EAAA6H,EAAAC,MAAA4F,GAAA5F,IACAG,EAAAjI,EAAA6H,EAAAK,MAAAwF,GAAAxF,IACAH,EAAA/H,EAAA6H,EAAAG,MAAA0F,GAAA1F,GAEA,IAAA8F,EAAA,CAGA,GAAAC,GAAA,IAAA/0F,EAAA0oF,SAAAjnF,OACAuzF,EAAAh1F,EAAAgqF,SAAA,EACAiL,EAAAj1F,EAAA6pF,UAAA,GAEA,IAAAkL,GAAAC,GAAAC,EACA,OAIA,MAAAlG,IAAAE,EAAA,OAKA6F,GACA7F,GAAAzK,EAAAC,IACAsK,GAAAvK,EAAAmB,GACA3oF,KAAAk4F,WAAAjK,GAHA,QAWAiK,WAAA,SAAAjK,GACAjuF,KAAAgL,QAAAkhF,QAAA2L,WAAA,EACA5J,EAAA54E,kBAiFA,IAAAu9E,IAAA,EACAO,GAAA,EACAD,GAAA,EACAD,GAAA,EACAkF,GAAAlF,GACAD,GAAA,GACAoF,GAAA,EAwBAzF,IAAAt0D,WAKAmU,YAOApyC,IAAA,SAAA+O,GAKA,MAJAk6E,IAAArpF,KAAAmP,WAGAnP,KAAAgL,SAAAhL,KAAAgL,QAAAspF,YAAA7nF,SACAzM,MAQA6mF,cAAA,SAAAyM,GACA,GAAAvK,EAAAuK,EAAA,gBAAAtzF,MACA,MAAAA,KAGA,IAAA6yF,GAAA7yF,KAAA6yF,YAMA,OALAS,GAAAD,GAAAC,EAAAtzF,MACA6yF,EAAAS,EAAAl2F,MACAy1F,EAAAS,EAAAl2F,IAAAk2F,EACAA,EAAAzM,cAAA7mF,OAEAA,MAQAq4F,kBAAA,SAAA/E,GACA,MAAAvK,GAAAuK,EAAA,oBAAAtzF,MACAA,MAGAszF,EAAAD,GAAAC,EAAAtzF,YACAA,MAAA6yF,aAAAS,EAAAl2F,IACA4C,OAQAw0F,eAAA,SAAAlB,GACA,GAAAvK,EAAAuK,EAAA,iBAAAtzF,MACA,MAAAA,KAGA,IAAA8yF,GAAA9yF,KAAA8yF,WAMA,OALAQ,GAAAD,GAAAC,EAAAtzF,MACAiqF,EAAA6I,EAAAQ,MAAA,IACAR,EAAA/qF,KAAAurF,GACAA,EAAAkB,eAAAx0F,OAEAA,MAQAs4F,mBAAA,SAAAhF,GACA,GAAAvK,EAAAuK,EAAA,qBAAAtzF,MACA,MAAAA,KAGAszF,GAAAD,GAAAC,EAAAtzF,KACA,IAAA6H,GAAAoiF,EAAAjqF,KAAA8yF,YAAAQ,EAIA,OAHAzrF,IAAA,GACA7H,KAAA8yF,YAAArqF,OAAAZ,EAAA,GAEA7H,MAOAu4F,mBAAA,WACA,MAAAv4F,MAAA8yF,YAAAruF,OAAA,GAQA+zF,iBAAA,SAAAlF,GACA,QAAAtzF,KAAA6yF,aAAAS,EAAAl2F,KAQAspE,KAAA,SAAA1jE,GAIA,QAAA0jE,GAAAvmE,GACAskE,EAAAz5D,QAAA07D,KAAAvmE,EAAA6C,GAJA,GAAAyhE,GAAAzkE,KACAq2C,EAAAr2C,KAAAq2C,KAOAA,GAAA48C,IACAvsB,EAAAjC,EAAAt1D,QAAAhP,MAAA4yF,GAAA18C,IAGAqwB,EAAAjC,EAAAt1D,QAAAhP,OAEA6C,EAAAy1F,iBACA/xB,EAAA1jE,EAAAy1F,iBAIApiD,GAAA48C,IACAvsB,EAAAjC,EAAAt1D,QAAAhP,MAAA4yF,GAAA18C,KAUAqiD,QAAA,SAAA11F,GACA,MAAAhD,MAAA24F,UACA34F,KAAA0mE,KAAA1jE,QAGAhD,KAAAq2C,MAAA+hD,KAOAO,QAAA,WAEA,IADA,GAAA1wF,GAAA,EACAA,EAAAjI,KAAA8yF,YAAAruF,QAAA,CACA,KAAAzE,KAAA8yF,YAAA7qF,GAAAouC,OAAA+hD,GAAAxF,KACA,QAEA3qF,KAEA,UAOAmkF,UAAA,SAAAgL,GAGA,GAAAwB,GAAAvP,MAAsC+N,EAGtC,OAAA9N,GAAAtpF,KAAAmP,QAAAm+D,QAAAttE,KAAA44F,KAOA54F,KAAAq2C,OAAA8hD,GAAAnF,GAAAoF,MACAp4F,KAAAq2C,MAAAu8C,IAGA5yF,KAAAq2C,MAAAr2C,KAAAgmE,QAAA4yB,QAIA54F,KAAAq2C,OAAA88C,GAAAD,GAAAD,GAAAD,KACAhzF,KAAA04F,QAAAE,MAfA54F,KAAA0+B,aACA1+B,KAAAq2C,MAAA+hD,MAyBApyB,QAAA,SAAAoxB,KAOAO,eAAA,aAOAj5D,MAAA,cA8DAwqD,EAAAqK,GAAAZ,IAKAngD,UAKAk5C,SAAA,GASAmN,SAAA,SAAA71F,GACA,GAAA81F,GAAA94F,KAAAmP,QAAAu8E,QACA,YAAAoN,GAAA91F,EAAA0oF,SAAAjnF,SAAAq0F,GASA9yB,QAAA,SAAAhjE,GACA,GAAAqzC,GAAAr2C,KAAAq2C,MACA04B,EAAA/rE,EAAA+rE,UAEAgqB,EAAA1iD,GAAA88C,GAAAD,IACA8F,EAAAh5F,KAAA64F,SAAA71F,EAGA,OAAA+1F,KAAAhqB,EAAAkd,KAAA+M,GACA3iD,EAAA28C,GACS+F,GAAAC,EACTjqB,EAAAid,GACA31C,EAAA48C,GACa58C,EAAA88C,GAGb98C,EAAA68C,GAFAC,GAIAiF,MAiBAlP,EAAAsK,GAAAD,IAKA/gD,UACAryC,MAAA,MACA84F,UAAA,GACAvN,SAAA,EACAlE,UAAAU,IAGAyP,eAAA,WACA,GAAAnQ,GAAAxnF,KAAAmP,QAAAq4E,UACAqK,IAOA,OANArK,GAAAC,IACAoK,EAAA9pF,KAAAmqF,IAEA1K,EAAAmB,IACAkJ,EAAA9pF,KAAAiqF,IAEAH,GAGAqH,cAAA,SAAAl2F,GACA,GAAAmM,GAAAnP,KAAAmP,QACAgqF,GAAA,EACAnM,EAAAhqF,EAAAgqF,SACAxF,EAAAxkF,EAAAwkF,UACAp/E,EAAApF,EAAAqqF,OACAvjF,EAAA9G,EAAAsqF,MAeA,OAZA9F,GAAAr4E,EAAAq4E,YACAr4E,EAAAq4E,UAAAC,IACAD,EAAA,IAAAp/E,EAAA6/E,GAAA7/E,EAAA,EAAAmgF,GAAAC,GACA2Q,EAAA/wF,GAAApI,KAAAyzF,GACAzG,EAAA/xE,KAAAmlE,IAAAp9E,EAAAqqF,UAEA7F,EAAA,IAAA19E,EAAAm+E,GAAAn+E,EAAA,EAAAs+E,GAAAE,GACA6Q,EAAArvF,GAAA9J,KAAA0zF,GACA1G,EAAA/xE,KAAAmlE,IAAAp9E,EAAAsqF,UAGAtqF,EAAAwkF,YACA2R,GAAAnM,EAAA79E,EAAA8pF,WAAAzR,EAAAr4E,EAAAq4E,WAGAqR,SAAA,SAAA71F,GACA,MAAAuwF,IAAAl1D,UAAAw6D,SAAAv7F,KAAA0C,KAAAgD,KACAhD,KAAAq2C,MAAA88C,MAAAnzF,KAAAq2C,MAAA88C,KAAAnzF,KAAAk5F,cAAAl2F,KAGA0jE,KAAA,SAAA1jE,GAEAhD,KAAAyzF,GAAAzwF,EAAAqqF,OACArtF,KAAA0zF,GAAA1wF,EAAAsqF,MAEA,IAAA9F,GAAA4L,GAAApwF,EAAAwkF,UAEAA,KACAxkF,EAAAy1F,gBAAAz4F,KAAAmP,QAAAhP,MAAAqnF,GAEAxnF,KAAAk9B,OAAAwpC,KAAAppE,KAAA0C,KAAAgD,MAcAkmF,EAAAyK,GAAAJ,IAKA/gD,UACAryC,MAAA,QACA84F,UAAA,EACAvN,SAAA,GAGAiM,eAAA,WACA,OAAA7F,KAGA+G,SAAA,SAAA71F,GACA,MAAAhD,MAAAk9B,OAAA27D,SAAAv7F,KAAA0C,KAAAgD,KACAiY,KAAAmlE,IAAAp9E,EAAA2qF,MAAA,GAAA3tF,KAAAmP,QAAA8pF,WAAAj5F,KAAAq2C,MAAA88C,KAGAzsB,KAAA,SAAA1jE,GACA,OAAAA,EAAA2qF,MAAA,CACA,GAAAyL,GAAAp2F,EAAA2qF,MAAA,YACA3qF,GAAAy1F,gBAAAz4F,KAAAmP,QAAAhP,MAAAi5F,EAEAp5F,KAAAk9B,OAAAwpC,KAAAppE,KAAA0C,KAAAgD,MAiBAkmF,EAAA0K,GAAAjB,IAKAngD,UACAryC,MAAA,QACAurF,SAAA,EACA7S,KAAA,IACAogB,UAAA,GAGAtB,eAAA,WACA,OAAAvF,KAGApsB,QAAA,SAAAhjE,GACA,GAAAmM,GAAAnP,KAAAmP,QACAkqF,EAAAr2F,EAAA0oF,SAAAjnF,SAAA0K,EAAAu8E,SACA4N,EAAAt2F,EAAAgqF,SAAA79E,EAAA8pF,UACAM,EAAAv2F,EAAA6pF,UAAA19E,EAAA0pE,IAMA,IAJA74E,KAAA8zF,OAAA9wF,GAIAs2F,IAAAD,GAAAr2F,EAAA+rE,WAAAid,GAAAC,MAAAsN,EACAv5F,KAAA0+B,YACS,IAAA17B,EAAA+rE,UAAA+c,GACT9rF,KAAA0+B,QACA1+B,KAAA6zF,OAAAhL,EAAA,WACA7oF,KAAAq2C,MAAA8hD,GACAn4F,KAAA04F,WACavpF,EAAA0pE,KAAA74E,UACJ,IAAAgD,EAAA+rE,UAAAid,GACT,MAAAmM,GAEA,OAAAC,KAGA15D,MAAA,WACAuL,aAAAjqC,KAAA6zF,SAGAntB,KAAA,SAAA1jE,GACAhD,KAAAq2C,QAAA8hD,KAIAn1F,KAAA+rE,UAAAid,GACAhsF,KAAAgL,QAAA07D,KAAA1mE,KAAAmP,QAAAhP,MAAA,KAAA6C,IAEAhD,KAAA8zF,OAAA5P,UAAArrE,KACA7Y,KAAAgL,QAAA07D,KAAA1mE,KAAAmP,QAAAhP,MAAAH,KAAA8zF,aAeA5K,EAAA6K,GAAAR,IAKA/gD,UACAryC,MAAA,SACA84F,UAAA,EACAvN,SAAA,GAGAiM,eAAA,WACA,OAAA7F,KAGA+G,SAAA,SAAA71F,GACA,MAAAhD,MAAAk9B,OAAA27D,SAAAv7F,KAAA0C,KAAAgD,KACAiY,KAAAmlE,IAAAp9E,EAAA6qF,UAAA7tF,KAAAmP,QAAA8pF,WAAAj5F,KAAAq2C,MAAA88C,OAcAjK,EAAA8K,GAAAT,IAKA/gD,UACAryC,MAAA,QACA84F,UAAA,GACA5K,SAAA,GACA7G,UAAAC,GAAAkB,GACA+C,SAAA,GAGAiM,eAAA,WACA,MAAAnE,IAAAn1D,UAAAs5D,eAAAr6F,KAAA0C,OAGA64F,SAAA,SAAA71F,GACA,GACAqrF,GADA7G,EAAAxnF,KAAAmP,QAAAq4E,SAWA,OARAA,IAAAC,GAAAkB,IACA0F,EAAArrF,EAAAuqF,gBACS/F,EAAAC,GACT4G,EAAArrF,EAAAyqF,iBACSjG,EAAAmB,KACT0F,EAAArrF,EAAA0qF,kBAGA1tF,KAAAk9B,OAAA27D,SAAAv7F,KAAA0C,KAAAgD,IACAwkF,EAAAxkF,EAAAmqF,iBACAnqF,EAAAgqF,SAAAhtF,KAAAmP,QAAA8pF,WACAj2F,EAAA+qF,aAAA/tF,KAAAmP,QAAAu8E,UACAtL,GAAAiO,GAAAruF,KAAAmP,QAAAk/E,UAAArrF,EAAA+rE,UAAAid,IAGAtlB,KAAA,SAAA1jE,GACA,GAAAwkF,GAAA4L,GAAApwF,EAAAmqF,gBACA3F,IACAxnF,KAAAgL,QAAA07D,KAAA1mE,KAAAmP,QAAAhP,MAAAqnF,EAAAxkF,GAGAhD,KAAAgL,QAAA07D,KAAA1mE,KAAAmP,QAAAhP,MAAA6C,MA2BAkmF,EAAA+K,GAAAtB,IAKAngD,UACAryC,MAAA,MACAurF,SAAA,EACAvE,KAAA,EACAqS,SAAA,IACA3gB,KAAA,IACAogB,UAAA,EACAQ,aAAA,IAGA9B,eAAA,WACA,OAAAxF,KAGAnsB,QAAA,SAAAhjE,GACA,GAAAmM,GAAAnP,KAAAmP,QAEAkqF,EAAAr2F,EAAA0oF,SAAAjnF,SAAA0K,EAAAu8E,SACA4N,EAAAt2F,EAAAgqF,SAAA79E,EAAA8pF,UACAS,EAAA12F,EAAA6pF,UAAA19E,EAAA0pE,IAIA,IAFA74E,KAAA0+B,QAEA17B,EAAA+rE,UAAA+c,IAAA,IAAA9rF,KAAAquB,MACA,MAAAruB,MAAA25F,aAKA,IAAAL,GAAAI,GAAAL,EAAA,CACA,GAAAr2F,EAAA+rE,WAAAid,GACA,MAAAhsF,MAAA25F,aAGA,IAAAC,IAAA55F,KAAAk0F,OAAAlxF,EAAAkhF,UAAAlkF,KAAAk0F,MAAA/kF,EAAAqqF,SACAK,GAAA75F,KAAAm0F,SAAAlH,EAAAjtF,KAAAm0F,QAAAnxF,EAAA2pF,QAAAx9E,EAAAsqF,YAEAz5F,MAAAk0F,MAAAlxF,EAAAkhF,UACAlkF,KAAAm0F,QAAAnxF,EAAA2pF,OAEAkN,GAAAD,EAGA55F,KAAAquB,OAAA,EAFAruB,KAAAquB,MAAA,EAKAruB,KAAA8zF,OAAA9wF,CAIA,IAAA82F,GAAA95F,KAAAquB,MAAAlf,EAAAg4E,IACA,QAAA2S,EAGA,MAAA95F,MAAAu4F,sBAGAv4F,KAAA6zF,OAAAhL,EAAA,WACA7oF,KAAAq2C,MAAA8hD,GACAn4F,KAAA04F,WACqBvpF,EAAAqqF,SAAAx5F,MACrBmzF,IANAgF,GAUA,MAAAC,KAGAuB,YAAA,WAIA,MAHA35F,MAAA6zF,OAAAhL,EAAA,WACA7oF,KAAAq2C,MAAA+hD,IACSp4F,KAAAmP,QAAAqqF,SAAAx5F,MACTo4F,IAGA15D,MAAA,WACAuL,aAAAjqC,KAAA6zF,SAGAntB,KAAA,WACA1mE,KAAAq2C,OAAA8hD,KACAn4F,KAAA8zF,OAAAgG,SAAA95F,KAAAquB,MACAruB,KAAAgL,QAAA07D,KAAA1mE,KAAAmP,QAAAhP,MAAAH,KAAA8zF,YAoBA/N,GAAAhiB,QAAA,QAMAgiB,GAAAvzC,UAOAunD,WAAA,EAQAzF,YAAAmD,GAMAnqB,QAAA,EASAqd,YAAA,KAOAK,WAAA,KAOAoJ,SAEAL,IAA4BzmB,QAAA,KAC5BqmB,IAA2BrmB,QAAA,IAAc,YACzC0mB,IAA2BxM,UAAAC,MAC3B+L,IAAyBhM,UAAAC,KAAgC,WACzDwM,KACAA,IAAyB9zF,MAAA,YAAAgnF,KAAA,IAA4B,SACrDyM,KAQAa,UAMAuF,WAAA,OAOAC,YAAA,OASAC,aAAA,OAOAC,eAAA,OAOAC,SAAA,OAQAC,kBAAA,iBAIA,IAAAC,IAAA,EACAC,GAAA,CA+BAvT,IAAA3oD,WAMAj+B,IAAA,SAAA+O,GAaA,MAZAk6E,IAAArpF,KAAAmP,WAGAA,EAAAmlF,aACAt0F,KAAAs0F,YAAA7nF,SAEA0C,EAAAw7E,cAEA3qF,KAAAgD,MAAAojF,UACApmF,KAAAgD,MAAA1C,OAAA6O,EAAAw7E,YACA3qF,KAAAgD,MAAA0P,QAEA1S,MASAg8C,KAAA,SAAAnK,GACA7xC,KAAAksF,QAAAsO,QAAA3oD,EAAA0oD,GAAAD,IASAlO,UAAA,SAAAgL,GACA,GAAAlL,GAAAlsF,KAAAksF,OACA,KAAAA,EAAAsO,QAAA,CAKAx6F,KAAAs0F,YAAAsD,gBAAAR,EAEA,IAAA5Q,GACAG,EAAA3mF,KAAA2mF,YAKA8T,EAAAvO,EAAAuO,gBAIAA,QAAApkD,MAAA8hD,MACAsC,EAAAvO,EAAAuO,cAAA,KAIA,KADA,GAAAxyF,GAAA,EACAA,EAAA0+E,EAAAliF,QACA+hF,EAAAG,EAAA1+E,GAQAikF,EAAAsO,UAAAD,IACAE,GAAAjU,GAAAiU,IACAjU,EAAAgS,iBAAAiC,GAGAjU,EAAA9nD,QAFA8nD,EAAA4F,UAAAgL,IAOAqD,GAAAjU,EAAAnwC,OAAA88C,GAAAD,GAAAD,MACAwH,EAAAvO,EAAAuO,cAAAjU,GAEAv+E,MASAvH,IAAA,SAAA8lF,GACA,GAAAA,YAAAmM,IACA,MAAAnM,EAIA,QADAG,GAAA3mF,KAAA2mF,YACA1+E,EAAA,EAAuBA,EAAA0+E,EAAAliF,OAAwBwD,IAC/C,GAAA0+E,EAAA1+E,GAAAkH,QAAAhP,OAAAqmF,EACA,MAAAG,GAAA1+E,EAGA,cASA4G,IAAA,SAAA23E,GACA,GAAAuC,EAAAvC,EAAA,MAAAxmF,MACA,MAAAA,KAIA,IAAA07D,GAAA17D,KAAAU,IAAA8lF,EAAAr3E,QAAAhP,MASA,OARAu7D,IACA17D,KAAAygC,OAAAi7B,GAGA17D,KAAA2mF,YAAA5+E,KAAAy+E,GACAA,EAAAx7E,QAAAhL,KAEAA,KAAAs0F,YAAA7nF,SACA+5E,GAQA/lD,OAAA,SAAA+lD,GACA,GAAAuC,EAAAvC,EAAA,SAAAxmF,MACA,MAAAA,KAMA,IAHAwmF,EAAAxmF,KAAAU,IAAA8lF,GAGA,CACA,GAAAG,GAAA3mF,KAAA2mF,YACA9+E,EAAAoiF,EAAAtD,EAAAH,EAEA3+E,MAAA,IACA8+E,EAAAl+E,OAAAZ,EAAA,GACA7H,KAAAs0F,YAAA7nF,UAIA,MAAAzM,OASAC,GAAA,SAAAP,EAAAwJ,GACA,GAAAxJ,IAAA2I,GAGAa,IAAAb,EAAA,CAIA,GAAAW,GAAAhJ,KAAAgJ,QAKA,OAJAqoD,GAAAw4B,EAAAnqF,GAAA,SAAAS,GACA6I,EAAA7I,GAAA6I,EAAA7I,OACA6I,EAAA7I,GAAA4H,KAAAmB,KAEAlJ,OASAoV,IAAA,SAAA1V,EAAAwJ,GACA,GAAAxJ,IAAA2I,EAAA,CAIA,GAAAW,GAAAhJ,KAAAgJ,QAQA,OAPAqoD,GAAAw4B,EAAAnqF,GAAA,SAAAS,GACA+I,EAGAF,EAAA7I,IAAA6I,EAAA7I,GAAAsI,OAAAwhF,EAAAjhF,EAAA7I,GAAA+I,GAAA,SAFAF,GAAA7I,KAKAH,OAQA0mE,KAAA,SAAAvmE,EAAAnB,GAEAgB,KAAAmP,QAAA4qF,WACArF,GAAAv0F,EAAAnB,EAIA,IAAAgK,GAAAhJ,KAAAgJ,SAAA7I,IAAAH,KAAAgJ,SAAA7I,GAAAoS,OACA,IAAAvJ,KAAAvE,OAAA,CAIAzF,EAAAoI,KAAAjH,EACAnB,EAAAqW,eAAA,WACArW,EAAAivF,SAAA54E,iBAIA,KADA,GAAApN,GAAA,EACAA,EAAAe,EAAAvE,QACAuE,EAAAf,GAAAjJ,GACAiJ,MAQAm+E,QAAA,WACApmF,KAAAiK,SAAAsqF,GAAAv0F,MAAA,GAEAA,KAAAgJ,YACAhJ,KAAAksF,WACAlsF,KAAAgD,MAAAojF,UACApmF,KAAAiK,QAAA,OAyCAo/E,GAAAtD,IACA+F,eACA2E,cACAzE,aACAC,gBAEA2G,kBACAO,eACAD,iBACAD,eACAkF,oBACAnF,mBACAoF,gBAEAnQ,kBACAM,kBACAC,mBACAJ,gBACAE,kBACAb,wBACAkB,sBACAT,iBAEAlB,WACA1qB,QACAq1B,cAEAvG,aACAG,aACAL,oBACAI,kBACAuE,mBAEA8C,cACAY,kBACAtM,IAAAgN,GACA1M,IAAAiM,GACAnM,MAAA2M,GACAjM,MAAA4L,GACA9L,OAAAkM,GACApM,MAAAiM,GAEA3zF,GAAA0pF,EACAv0E,IAAA00E,EACAz4B,OACAh1C,SACAg2B,UACAg3C,UACAH,UACAJ,SACA1vE,YAKA,IAAAghE,IAAA,mBAAA/4E,KAAA,mBAAAojE,aACA2V,IAAA2L,UAGA7Q,EAAA,WACA,MAAA6Q,KACKzoF,KAAAJ,EAAAH,EAAAG,EAAAC,KAAA+3E,IAAA7sE,IAAAlL,EAAAD,QAAAg4E,KAOJ7zE,OAAArD,SAAA,W3EmzuBK,SAASb,EAAQD,KAMjB,SAASC,EAAQD,EAASH,I4E34zBhC,SAAA4F,EAAAC,GACAzF,EAAAD,QAAA0F,KAGC5C,KAAA,WAAoB,YAQrB,SAAAL,GAAAuB,EAAA2H,GACA,UAAA6xF,GAAAx5F,EAAA2H,GAgLA,QAAA8xF,GAAAx6F,GACAH,KAAA46F,gBAAAtF,UAAAn1F,GAGA,QAAA06F,GAAA16F,GACAH,KAAA46F,gBAAAE,UAAA36F,GAGA,QAAA46F,KACA/6F,KAAA63D,iBAAA,UAAAmjC,GAAA,GACAh7F,KAAA63D,iBAAA,OAAAhuB,GAAA,GAGA,QAAAA,KACA7pC,KAAA+3D,oBAAA,UAAAijC,GAAA,GACAh7F,KAAA+3D,oBAAA,OAAAluB,GAAA,GAGA,QAAAmxD,GAAA76F,GACA,KAAAA,EAAA0L,OAEA7L,KAAA46F,gBAAApuF,OA1MA,GAAAyuF,GAAAt7F,EAEAu7F,EAAA,EACAC,EAAA,IAKAT,EAAA,SAAAx5F,EAAA2H,GACA7I,KAAAkB,OACAlB,KAAA6I,WAEA7I,KAAAo7F,wBAAA,EAEAp7F,KAAAkC,KAAAhB,GAgMA,OA7LAw5F,GAAAr8D,WACAn8B,KAAA,SAAAhB,GAEAG,OAAAhD,UAAAg9F,eACAn6F,EAAA22D,iBAAA,cAAA8iC,GAAA,GACIt5F,OAAAhD,UAAAi9F,iBACJp6F,EAAA22D,iBAAA,gBAAA8iC,GAAA,GAEAz5F,EAAA22D,iBAAA,YAAA8iC,GAAA,GAIAz5F,EAAA22D,iBAAA,aAAAgjC,GAAA,GAIA,WAAA35F,EAAAwjC,SAAA,WAAAxjC,EAAAkG,MACAlG,EAAA22D,iBAAA,QAAAkjC,GAAA,GAGA75F,EAAA05F,gBAAA56F,MAGAwM,KAAA,SAAArM,EAAAiI,EAAA0B,GACA9J,KAAA6I,UACA3H,KAAAlB,KAAAkB,KACAb,SAAAF,EACAiI,IACA0B,OAIAwrF,UAAA,SAAAn1F,GACA,GAAAo7F,GAAAv7F,IAEA,KAAAA,KAAAo7F,yBAIA/yF,SAAAlI,EAAA0L,OAAA,IAAA1L,EAAA0L,OAAA,CAIA,GAAAzD,GAAAjI,EAAAwuF,QACA7kF,EAAA3J,EAAAyuF,QAGAgI,EAAAz2F,EAAAy2F,UAEA4E,EAAA,SAAAr7F,GACAA,EAAAy2F,eAIA2E,EAAA/uF,KAAArM,EAAAiI,EAAA0B,GACAiN,MAGA0kF,EAAA,SAAAt7F,GACAA,EAAAy2F,eAIA37E,KAAAmlE,IAAAjgF,EAAAwuF,QAAAvmF,IAAA8yF,GAAAjgF,KAAAmlE,IAAAjgF,EAAAyuF,QAAA9kF,IAAAoxF,IACAnkF,KAIAA,EAAA,WACAwkF,EAAAr6F,KAAA62D,oBAAA,cAAAyjC,GAAA,GACAx9F,SAAA+5D,oBAAA,gBAAA0jC,GAAA,GACAz9F,SAAA+5D,oBAAA,kBAAAhhD,GAAA,GACAwkF,EAAAr6F,KAAA62D,oBAAA,YAAAyjC,GAAA,GACAx9F,SAAA+5D,oBAAA,cAAA0jC,GAAA,GACAz9F,SAAA+5D,oBAAA,gBAAAhhD,GAAA,GACAwkF,EAAAr6F,KAAA62D,oBAAA,QAAAyjC,GAAA,GACAx9F,SAAA+5D,oBAAA,YAAA0jC,GAAA,GAGAp6F,QAAAhD,UAAAg9F,gBACAr7F,KAAAkB,KAAA22D,iBAAA,YAAA2jC,GAAA,GACAx9F,SAAA65D,iBAAA,cAAA4jC,GAAA,GACAz9F,SAAA65D,iBAAA,gBAAA9gD,GAAA,IACI1V,OAAAhD,UAAAi9F,kBACJt7F,KAAAkB,KAAA22D,iBAAA,cAAA2jC,GAAA,GACAx9F,SAAA65D,iBAAA,gBAAA4jC,GAAA,GACAz9F,SAAA65D,iBAAA,kBAAA9gD,GAAA,KAEA/W,KAAAkB,KAAA22D,iBAAA,QAAA2jC,GAAA,GACAx9F,SAAA65D,iBAAA,YAAA4jC,GAAA,IAGA3yF,WAAAiO,EAAAokF,KAGAL,UAAA,WACA,GAAAS,GAAAv7F,KAEA4wF,EAAAzwF,MAAAgwF,QAAA,GAEA/nF,EAAAwoF,EAAAjC,QACA7kF,EAAA8mF,EAAAhC,QAEA8M,EAAA9K,EAAAnmE,WAEAkxE,EAAA,SAAAx7F,GACA,GAAAywF,GAAAzwF,EAAAiwF,eAAA,EAEA,OAAAQ,GAAAnmE,aAAAixE,MACA3kF,MAIA5W,EAAAkV,iBAGAkmF,EAAAH,wBAAA,EACAnxD,aAAAsxD,EAAAK,yBAEAL,EAAAK,wBAAA9yF,WAAA,WACAyyF,EAAAH,wBAAA,GACK,KAELG,EAAA/uF,KAAArM,EAAAiI,EAAA0B,OACAiN,OAGA8kF,EAAA,SAAA17F,GACA,GAAAywF,EAEA,KAAAzwF,EAAAgwF,QAAA1rF,QAAAtE,EAAAgwF,QAAA,GAAA1lE,aAAAixE,GACA3kF,IAGA65E,EAAAzwF,EAAAgwF,QAAA,IACAl1E,KAAAmlE,IAAAwQ,EAAAjC,QAAAvmF,IAAA8yF,GAAAjgF,KAAAmlE,IAAAwQ,EAAAhC,QAAA9kF,IAAAoxF,IACAnkF,KAIAA,EAAA,WACAwkF,EAAAr6F,KAAA62D,oBAAA,WAAA4jC,GAAA,GACAt6F,OAAA02D,oBAAA,YAAA8jC,GAAA,GACAx6F,OAAA02D,oBAAA,cAAAhhD,GAAA,GAGA/W,MAAAkB,KAAA22D,iBAAA,WAAA8jC,GAAA,GACAt6F,OAAAw2D,iBAAA,YAAAgkC,GAAA,GACAx6F,OAAAw2D,iBAAA,cAAA9gD,GAAA,GAEAjO,WAAAiO,EAAAokF,IAGA9jF,SAAA,WACA,GAAAnW,GAAAlB,KAAAkB,IAEAA,GAAA62D,oBAAA,cAAA4iC,GAAA,GACAz5F,EAAA62D,oBAAA,gBAAA4iC,GAAA,GACAz5F,EAAA62D,oBAAA,YAAA4iC,GAAA,GACAz5F,EAAA62D,oBAAA,aAAA8iC,GAAA,GACA35F,EAAA62D,oBAAA,QAAAgjC,GAAA,KA6BAE","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _root = __webpack_require__(1);\n\t\n\tvar _root2 = _interopRequireDefault(_root);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t(function () {\n\t    new _root2.default(document.getElementById('app'));\n\t})();\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = function () {\n\t    'use strict';\n\t\n\t    var Ractive = __webpack_require__(2);\n\t    var template = __webpack_require__(3);\n\t    var headerComponent = __webpack_require__(4);\n\t    var EventBus = __webpack_require__(6);\n\t    __webpack_require__(72);\n\t    __webpack_require__(74);\n\t\n\t    function Root(root) {\n\t        var eb = void 0;\n\t        navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;\n\t        Ractive.DEBUG = false;\n\t        var view = new Ractive({\n\t            el: root,\n\t            template: template,\n\t            magic: true,\n\t            data: {\n\t                vibrate: {\n\t                    vibrate: false,\n\t                    speed: 500,\n\t                    recipient: \"\",\n\t                    sender: \"\"\n\t                },\n\t                signupOpen: false,\n\t                menuOpen: false,\n\t                user: \"\",\n\t                conn: false,\n\t                sending: false,\n\t                selectUser: false\n\t            },\n\t            events: {\n\t                tap: __webpack_require__(75)\n\t            },\n\t            components: {\n\t                Header: headerComponent()\n\t            },\n\t            oninit: function oninit() {\n\t                this.on({\n\t                    handleInput: function handleInput(event) {\n\t                        this.set(event.original.target.name, event.original.target.value);\n\t                    },\n\t                    hideUserForm: function hideUserForm(event) {\n\t                        if (this.get(\"user\")) {\n\t                            this.set(\"sender\", this.get(\"user\"));\n\t                            this.toggle(\"selectUser\");\n\t                            eb = this.connect();\n\t                        }\n\t                    },\n\t                    startVibrate: function startVibrate(event) {\n\t                        var model = this.get(\"vibrate\");\n\t                        model.vibrate = true;\n\t                        model.sender = this.get(\"user\");\n\t                        this.set(\"sending\", true);\n\t                        this.sendMessage(model);\n\t                    },\n\t                    endVibrate: function endVibrate(event) {\n\t                        var model = this.get(\"vibrate\");\n\t                        model.vibrate = false;\n\t                        model.sender = \"\";\n\t                        this.set(\"sending\", false);\n\t                        this.sendMessage(model);\n\t                    },\n\t                    selectSpeed: function selectSpeed(event) {\n\t                        var model = this.get(\"vibrate\");\n\t                        model.speed = event.node.value;\n\t                        this.sendMessage(model);\n\t                    },\n\t                    changeUser: function changeUser(event) {\n\t                        this.set(\"vibrate.recipient\", event.node.value);\n\t                    },\n\t                    connect: function connect(event) {\n\t                        eb = this.connect();\n\t                    }\n\t                });\n\t            },\n\t            connect: function connect() {\n\t                var eventbusUrl = \"http://\" + window.location.hostname + ':8080/eventbus';\n\t                var eb = new EventBus(eventbusUrl);\n\t\n\t                eb.onopen = function () {\n\t                    this.set(\"conn\", true);\n\t                    eb.registerHandler('chat.messageOut', function (error, msg) {\n\t                        this.set({ \"vibrate.vibrate\": msg.body.vibrate,\n\t                            \"vibrate.speed\": msg.body.speed,\n\t                            \"vibrate.sender\": msg.body.sender });\n\t                        this.msgHandler();\n\t                    }.bind(this));\n\t                    eb.send(\"chat.user\", { user: this.get(\"user\") });\n\t                }.bind(this);\n\t                eb.onclose = function () {\n\t                    this.set(\"conn\", false);\n\t                    eb.unregisterHandler('chat.messageOut');\n\t                    eb.unregisterHandler('chat.user');\n\t                }.bind(this);\n\t                return eb;\n\t            },\n\t            vibrate: function vibrate(speed) {\n\t                if (navigator.vibrate) {\n\t                    navigator.vibrate(speed);\n\t                }\n\t            },\n\t            sendMessage: function sendMessage(msg) {\n\t                eb.send(\"chat.messageIn\", msg);\n\t            },\n\t            msgHandler: function msgHandler() {\n\t                var model = this.get(\"vibrate\");\n\t                if (!model.vibrate) return;\n\t                this.vibrate(model.speed);\n\t                var start = null;\n\t                var step = function (timestamp) {\n\t                    if (!model.vibrate) {\n\t                        this.vibrate(0);\n\t                        return;\n\t                    }\n\t                    if (!start) start = timestamp;\n\t                    var progress = timestamp - start;\n\t                    if (progress <= model.speed) {\n\t                        window.requestAnimationFrame(step);\n\t                    } else {\n\t                        start = null;\n\t                        this.vibrate(model.speed);\n\t                        window.requestAnimationFrame(step);\n\t                    }\n\t                }.bind(this);\n\t                window.requestAnimationFrame(step);\n\t            }\n\t        });\n\t\n\t        return view;\n\t    }\n\t    return Root;\n\t}();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*\n\t\tRactive.js v0.8.5\n\t\tSun Nov 13 2016 17:56:27 GMT+0000 (UTC) - commit d533d91f155a4f042c1acc87136459141c2c8af9\n\t\n\t\thttp://ractivejs.org\n\t\thttp://twitter.com/RactiveJS\n\t\n\t\tReleased under the MIT License.\n\t*/\n\t\n\t\n\t(function (global, factory) {\n\t   true ? module.exports = factory() :\n\t  typeof define === 'function' && define.amd ? define(factory) :\n\t  ((function() { var current = global.Ractive; var next = factory(); next.noConflict = function() { global.Ractive = current; return next; }; return global.Ractive = next; })());\n\t}(this, function () { 'use strict';\n\t\n\t  var defaults = {\n\t  \t// render placement:\n\t  \tel:                     void 0,\n\t  \tappend:\t\t\t\t    false,\n\t\n\t  \t// template:\n\t  \ttemplate:               null,\n\t\n\t  \t// parse:\n\t  \tdelimiters:             [ '{{', '}}' ],\n\t  \ttripleDelimiters:       [ '{{{', '}}}' ],\n\t  \tstaticDelimiters:       [ '[[', ']]' ],\n\t  \tstaticTripleDelimiters: [ '[[[', ']]]' ],\n\t  \tcsp: \t\t\t\t\ttrue,\n\t  \tinterpolate:            false,\n\t  \tpreserveWhitespace:     false,\n\t  \tsanitize:               false,\n\t  \tstripComments:          true,\n\t  \tcontextLines:           0,\n\t\n\t  \t// data & binding:\n\t  \tdata:                   {},\n\t  \tcomputed:               {},\n\t  \tmagic:                  false,\n\t  \tmodifyArrays:           false,\n\t  \tadapt:                  [],\n\t  \tisolated:               false,\n\t  \ttwoway:                 true,\n\t  \tlazy:                   false,\n\t\n\t  \t// transitions:\n\t  \tnoIntro:                false,\n\t  \ttransitionsEnabled:     true,\n\t  \tcomplete:               void 0,\n\t\n\t  \t// css:\n\t  \tcss:                    null,\n\t  \tnoCssTransform:         false\n\t  };\n\t\n\t  // These are a subset of the easing equations found at\n\t  // https://raw.github.com/danro/easing-js - license info\n\t  // follows:\n\t\n\t  // --------------------------------------------------\n\t  // easing.js v0.5.4\n\t  // Generic set of easing functions with AMD support\n\t  // https://github.com/danro/easing-js\n\t  // This code may be freely distributed under the MIT license\n\t  // http://danro.mit-license.org/\n\t  // --------------------------------------------------\n\t  // All functions adapted from Thomas Fuchs & Jeremy Kahn\n\t  // Easing Equations (c) 2003 Robert Penner, BSD license\n\t  // https://raw.github.com/danro/easing-js/master/LICENSE\n\t  // --------------------------------------------------\n\t\n\t  // In that library, the functions named easeIn, easeOut, and\n\t  // easeInOut below are named easeInCubic, easeOutCubic, and\n\t  // (you guessed it) easeInOutCubic.\n\t  //\n\t  // You can add additional easing functions to this list, and they\n\t  // will be globally available.\n\t\n\t\n\t  var easing = {\n\t  \tlinear: function ( pos ) { return pos; },\n\t  \teaseIn: function ( pos ) { return Math.pow( pos, 3 ); },\n\t  \teaseOut: function ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },\n\t  \teaseInOut: function ( pos ) {\n\t  \t\tif ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }\n\t  \t\treturn ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );\n\t  \t}\n\t  };\n\t\n\t  var legacy = null;\n\t\n\t  /*global console, navigator */\n\t\n\t  var win = typeof window !== 'undefined' ? window : null;\n\t  var doc = win ? document : null;\n\t\n\t  var isClient = !!doc;\n\t  var isJsdom = ( typeof navigator !== 'undefined' && /jsDom/.test( navigator.appName ) );\n\t  var hasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );\n\t\n\t  var magicSupported;\n\t  try {\n\t  \tObject.defineProperty({}, 'test', { value: 0 });\n\t  \tmagicSupported = true;\n\t  } catch ( e ) {\n\t  \tmagicSupported = false;\n\t  }\n\t\n\t  var svg = doc ?\n\t  \tdoc.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' ) :\n\t  \tfalse;\n\t\n\t  var vendors = [ 'o', 'ms', 'moz', 'webkit' ];\n\t\n\t  var html   = 'http://www.w3.org/1999/xhtml';\n\t  var mathml = 'http://www.w3.org/1998/Math/MathML';\n\t  var svg$1    = 'http://www.w3.org/2000/svg';\n\t  var xlink  = 'http://www.w3.org/1999/xlink';\n\t  var xml    = 'http://www.w3.org/XML/1998/namespace';\n\t  var xmlns  = 'http://www.w3.org/2000/xmlns';\n\t\n\t  var namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };\n\t\n\t  var createElement;\n\t  var matches;\n\t  var div;\n\t  var methodNames;\n\t  var unprefixed;\n\t  var prefixed;\n\t  var i;\n\t  var j;\n\t  var makeFunction;\n\t  // Test for SVG support\n\t  if ( !svg ) {\n\t  \tcreateElement = function ( type, ns, extend ) {\n\t  \t\tif ( ns && ns !== html ) {\n\t  \t\t\tthrow 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n\t  \t\t}\n\t\n\t  \t\treturn extend ?\n\t  \t\t\tdoc.createElement( type, extend ) :\n\t  \t\t\tdoc.createElement( type );\n\t  \t};\n\t  } else {\n\t  \tcreateElement = function ( type, ns, extend ) {\n\t  \t\tif ( !ns || ns === html ) {\n\t  \t\t\treturn extend ?\n\t  \t\t\t\tdoc.createElement( type, extend ) :\n\t  \t\t\t\tdoc.createElement( type );\n\t  \t\t}\n\t\n\t  \t\treturn extend ?\n\t  \t\t\tdoc.createElementNS( ns, type, extend ) :\n\t  \t\t\tdoc.createElementNS( ns, type );\n\t  \t};\n\t  }\n\t\n\t  function createDocumentFragment () {\n\t  \treturn doc.createDocumentFragment();\n\t  }\n\t\n\t  function getElement ( input ) {\n\t  \tvar output;\n\t\n\t  \tif ( !input || typeof input === 'boolean' ) { return; }\n\t\n\t  \tif ( !win || !doc || !input ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// We already have a DOM node - no work to do. (Duck typing alert!)\n\t  \tif ( input.nodeType ) {\n\t  \t\treturn input;\n\t  \t}\n\t\n\t  \t// Get node from string\n\t  \tif ( typeof input === 'string' ) {\n\t  \t\t// try ID first\n\t  \t\toutput = doc.getElementById( input );\n\t\n\t  \t\t// then as selector, if possible\n\t  \t\tif ( !output && doc.querySelector ) {\n\t  \t\t\toutput = doc.querySelector( input );\n\t  \t\t}\n\t\n\t  \t\t// did it work?\n\t  \t\tif ( output && output.nodeType ) {\n\t  \t\t\treturn output;\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n\t  \tif ( input[0] && input[0].nodeType ) {\n\t  \t\treturn input[0];\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  if ( !isClient ) {\n\t  \tmatches = null;\n\t  } else {\n\t  \tdiv = createElement( 'div' );\n\t  \tmethodNames = [ 'matches', 'matchesSelector' ];\n\t\n\t  \tmakeFunction = function ( methodName ) {\n\t  \t\treturn function ( node, selector ) {\n\t  \t\t\treturn node[ methodName ]( selector );\n\t  \t\t};\n\t  \t};\n\t\n\t  \ti = methodNames.length;\n\t\n\t  \twhile ( i-- && !matches ) {\n\t  \t\tunprefixed = methodNames[i];\n\t\n\t  \t\tif ( div[ unprefixed ] ) {\n\t  \t\t\tmatches = makeFunction( unprefixed );\n\t  \t\t} else {\n\t  \t\t\tj = vendors.length;\n\t  \t\t\twhile ( j-- ) {\n\t  \t\t\t\tprefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );\n\t\n\t  \t\t\t\tif ( div[ prefixed ] ) {\n\t  \t\t\t\t\tmatches = makeFunction( prefixed );\n\t  \t\t\t\t\tbreak;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// IE8...\n\t  \tif ( !matches ) {\n\t  \t\tmatches = function ( node, selector ) {\n\t  \t\t\tvar nodes, parentNode, i;\n\t\n\t  \t\t\tparentNode = node.parentNode;\n\t\n\t  \t\t\tif ( !parentNode ) {\n\t  \t\t\t\t// empty dummy <div>\n\t  \t\t\t\tdiv.innerHTML = '';\n\t\n\t  \t\t\t\tparentNode = div;\n\t  \t\t\t\tnode = node.cloneNode();\n\t\n\t  \t\t\t\tdiv.appendChild( node );\n\t  \t\t\t}\n\t\n\t  \t\t\tnodes = parentNode.querySelectorAll( selector );\n\t\n\t  \t\t\ti = nodes.length;\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tif ( nodes[i] === node ) {\n\t  \t\t\t\t\treturn true;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\treturn false;\n\t  \t\t};\n\t  \t}\n\t  }\n\t\n\t  function detachNode ( node ) {\n\t  \tif ( node && typeof node.parentNode !== 'unknown' && node.parentNode ) {\n\t  \t\tnode.parentNode.removeChild( node );\n\t  \t}\n\t\n\t  \treturn node;\n\t  }\n\t\n\t  function safeToStringValue ( value ) {\n\t  \treturn ( value == null || !value.toString ) ? '' : '' + value;\n\t  }\n\t\n\t  function safeAttributeString ( string ) {\n\t  \treturn safeToStringValue( string )\n\t  \t\t.replace( /&/g, '&amp;' )\n\t  \t\t.replace( /\"/g, '&quot;' )\n\t  \t\t.replace( /'/g, '&#39;' );\n\t  }\n\t\n\t  var camel = /(-.)/g;\n\t  function camelize ( string ) {\n\t  \treturn string.replace( camel, function ( s ) { return s.charAt( 1 ).toUpperCase(); } );\n\t  }\n\t\n\t  var decamel = /[A-Z]/g;\n\t  function decamelize ( string ) {\n\t  \treturn string.replace( decamel, function ( s ) { return (\"-\" + (s.toLowerCase())); } );\n\t  }\n\t\n\t  var create;\n\t  var defineProperty;\n\t  var defineProperties;\n\t  try {\n\t  \tObject.defineProperty({}, 'test', { get: function() {}, set: function() {} });\n\t\n\t  \tif ( doc ) {\n\t  \t\tObject.defineProperty( createElement( 'div' ), 'test', { value: 0 });\n\t  \t}\n\t\n\t  \tdefineProperty = Object.defineProperty;\n\t  } catch ( err ) {\n\t  \t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n\t  \t// only use it with DOM objects (what were you smoking, MSFT?)\n\t  \tdefineProperty = function ( obj, prop, desc ) {\n\t  \t\tif ( desc.get ) obj[ prop ] = desc.get();\n\t  \t\telse obj[ prop ] = desc.value;\n\t  \t};\n\t  }\n\t\n\t  try {\n\t  \ttry {\n\t  \t\tObject.defineProperties({}, { test: { value: 0 } });\n\t  \t} catch ( err ) {\n\t  \t\t// TODO how do we account for this? noMagic = true;\n\t  \t\tthrow err;\n\t  \t}\n\t\n\t  \tif ( doc ) {\n\t  \t\tObject.defineProperties( createElement( 'div' ), { test: { value: 0 } });\n\t  \t}\n\t\n\t  \tdefineProperties = Object.defineProperties;\n\t  } catch ( err ) {\n\t  \tdefineProperties = function ( obj, props ) {\n\t  \t\tvar prop;\n\t\n\t  \t\tfor ( prop in props ) {\n\t  \t\t\tif ( props.hasOwnProperty( prop ) ) {\n\t  \t\t\t\tdefineProperty( obj, prop, props[ prop ] );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t  }\n\t\n\t  try {\n\t  \tObject.create( null );\n\t\n\t  \tcreate = Object.create;\n\t  } catch ( err ) {\n\t  \t// sigh\n\t  \tcreate = (function () {\n\t  \t\tvar F = function () {};\n\t\n\t  \t\treturn function ( proto, props ) {\n\t  \t\t\tvar obj;\n\t\n\t  \t\t\tif ( proto === null ) {\n\t  \t\t\t\treturn {};\n\t  \t\t\t}\n\t\n\t  \t\t\tF.prototype = proto;\n\t  \t\t\tobj = new F();\n\t\n\t  \t\t\tif ( props ) {\n\t  \t\t\t\tObject.defineProperties( obj, props );\n\t  \t\t\t}\n\t\n\t  \t\t\treturn obj;\n\t  \t\t};\n\t  \t}());\n\t  }\n\t\n\t  function extendObj ( target ) {\n\t  \tvar sources = [], len = arguments.length - 1;\n\t  \twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t  \tvar prop;\n\t\n\t  \tsources.forEach( function ( source ) {\n\t  \t\tfor ( prop in source ) {\n\t  \t\t\tif ( hasOwn.call( source, prop ) ) {\n\t  \t\t\t\ttarget[ prop ] = source[ prop ];\n\t  \t\t\t}\n\t  \t\t}\n\t  \t});\n\t\n\t  \treturn target;\n\t  }\n\t\n\t  function fillGaps ( target ) {\n\t  \tvar sources = [], len = arguments.length - 1;\n\t  \twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\t\n\t  \tsources.forEach( function ( s ) {\n\t  \t\tfor ( var key in s ) {\n\t  \t\t\tif ( hasOwn.call( s, key ) && !( key in target ) ) {\n\t  \t\t\t\ttarget[ key ] = s[ key ];\n\t  \t\t\t}\n\t  \t\t}\n\t  \t});\n\t\n\t  \treturn target;\n\t  }\n\t\n\t  var hasOwn = Object.prototype.hasOwnProperty;\n\t\n\t  var toString = Object.prototype.toString;\n\t  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n\t  function isArray ( thing ) {\n\t  \treturn toString.call( thing ) === '[object Array]';\n\t  }\n\t\n\t  function isEqual ( a, b ) {\n\t  \tif ( a === null && b === null ) {\n\t  \t\treturn true;\n\t  \t}\n\t\n\t  \tif ( typeof a === 'object' || typeof b === 'object' ) {\n\t  \t\treturn false;\n\t  \t}\n\t\n\t  \treturn a === b;\n\t  }\n\t\n\t  // http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\n\t  function isNumeric ( thing ) {\n\t  \treturn !isNaN( parseFloat( thing ) ) && isFinite( thing );\n\t  }\n\t\n\t  function isObject ( thing ) {\n\t  \treturn ( thing && toString.call( thing ) === '[object Object]' );\n\t  }\n\t\n\t  function noop () {}\n\t\n\t  var alreadyWarned = {};\n\t  var log;\n\t  var printWarning;\n\t  var welcome;\n\t  if ( hasConsole ) {\n\t  \tvar welcomeIntro = [\n\t  \t\t(\"%cRactive.js %c0.8.5 %cin debug mode, %cmore...\"),\n\t  \t\t'color: rgb(114, 157, 52); font-weight: normal;',\n\t  \t\t'color: rgb(85, 85, 85); font-weight: normal;',\n\t  \t\t'color: rgb(85, 85, 85); font-weight: normal;',\n\t  \t\t'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n\t  \t];\n\t  \tvar welcomeMessage = \"You're running Ractive 0.8.5 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\t\n\t  \twelcome = function () {\n\t  \t\tif ( Ractive.WELCOME_MESSAGE === false ) {\n\t  \t\t\twelcome = noop;\n\t  \t\t\treturn;\n\t  \t\t}\n\t  \t\tvar message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;\n\t  \t\tvar hasGroup = !!console.groupCollapsed;\n\t  \t\tif ( hasGroup ) console.groupCollapsed.apply( console, welcomeIntro );\n\t  \t\tconsole.log( message );\n\t  \t\tif ( hasGroup ) {\n\t  \t\t\tconsole.groupEnd( welcomeIntro );\n\t  \t\t}\n\t\n\t  \t\twelcome = noop;\n\t  \t};\n\t\n\t  \tprintWarning = function ( message, args ) {\n\t  \t\twelcome();\n\t\n\t  \t\t// extract information about the instance this message pertains to, if applicable\n\t  \t\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n\t  \t\t\tvar options = args.pop();\n\t  \t\t\tvar ractive = options ? options.ractive : null;\n\t\n\t  \t\t\tif ( ractive ) {\n\t  \t\t\t\t// if this is an instance of a component that we know the name of, add\n\t  \t\t\t\t// it to the message\n\t  \t\t\t\tvar name;\n\t  \t\t\t\tif ( ractive.component && ( name = ractive.component.name ) ) {\n\t  \t\t\t\t\tmessage = \"<\" + name + \"> \" + message;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tvar node;\n\t  \t\t\t\tif ( node = ( options.node || ( ractive.fragment && ractive.fragment.rendered && ractive.find( '*' ) ) ) ) {\n\t  \t\t\t\t\targs.push( node );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tconsole.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );\n\t  \t};\n\t\n\t  \tlog = function () {\n\t  \t\tconsole.log.apply( console, arguments );\n\t  \t};\n\t  } else {\n\t  \tprintWarning = log = welcome = noop;\n\t  }\n\t\n\t  function format ( message, args ) {\n\t  \treturn message.replace( /%s/g, function () { return args.shift(); } );\n\t  }\n\t\n\t  function fatal ( message ) {\n\t  \tvar args = [], len = arguments.length - 1;\n\t  \twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t  \tmessage = format( message, args );\n\t  \tthrow new Error( message );\n\t  }\n\t\n\t  function logIfDebug () {\n\t  \tif ( Ractive.DEBUG ) {\n\t  \t\tlog.apply( null, arguments );\n\t  \t}\n\t  }\n\t\n\t  function warn ( message ) {\n\t  \tvar args = [], len = arguments.length - 1;\n\t  \twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t  \tmessage = format( message, args );\n\t  \tprintWarning( message, args );\n\t  }\n\t\n\t  function warnOnce ( message ) {\n\t  \tvar args = [], len = arguments.length - 1;\n\t  \twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t  \tmessage = format( message, args );\n\t\n\t  \tif ( alreadyWarned[ message ] ) {\n\t  \t\treturn;\n\t  \t}\n\t\n\t  \talreadyWarned[ message ] = true;\n\t  \tprintWarning( message, args );\n\t  }\n\t\n\t  function warnIfDebug () {\n\t  \tif ( Ractive.DEBUG ) {\n\t  \t\twarn.apply( null, arguments );\n\t  \t}\n\t  }\n\t\n\t  function warnOnceIfDebug () {\n\t  \tif ( Ractive.DEBUG ) {\n\t  \t\twarnOnce.apply( null, arguments );\n\t  \t}\n\t  }\n\t\n\t  // Error messages that are used (or could be) in multiple places\n\t  var badArguments = 'Bad arguments';\n\t  var noRegistryFunctionReturn = 'A function was specified for \"%s\" %s, but no %s was returned';\n\t  var missingPlugin = function ( name, type ) { return (\"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#\" + type + \"s\"); };\n\t\n\t  function findInViewHierarchy ( registryName, ractive, name ) {\n\t  \tvar instance = findInstance( registryName, ractive, name );\n\t  \treturn instance ? instance[ registryName ][ name ] : null;\n\t  }\n\t\n\t  function findInstance ( registryName, ractive, name ) {\n\t  \twhile ( ractive ) {\n\t  \t\tif ( name in ractive[ registryName ] ) {\n\t  \t\t\treturn ractive;\n\t  \t\t}\n\t\n\t  \t\tif ( ractive.isolated ) {\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\tractive = ractive.parent;\n\t  \t}\n\t  }\n\t\n\t  function interpolate ( from, to, ractive, type ) {\n\t  \tif ( from === to ) return null;\n\t\n\t  \tif ( type ) {\n\t  \t\tvar interpol = findInViewHierarchy( 'interpolators', ractive, type );\n\t  \t\tif ( interpol ) return interpol( from, to ) || null;\n\t\n\t  \t\tfatal( missingPlugin( type, 'interpolator' ) );\n\t  \t}\n\t\n\t  \treturn interpolators.number( from, to ) ||\n\t  \t       interpolators.array( from, to ) ||\n\t  \t       interpolators.object( from, to ) ||\n\t  \t       null;\n\t  }\n\t\n\t  function snap ( to ) {\n\t  \treturn function () { return to; };\n\t  }\n\t\n\t  var interpolators = {\n\t  \tnumber: function ( from, to ) {\n\t  \t\tvar delta;\n\t\n\t  \t\tif ( !isNumeric( from ) || !isNumeric( to ) ) {\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\tfrom = +from;\n\t  \t\tto = +to;\n\t\n\t  \t\tdelta = to - from;\n\t\n\t  \t\tif ( !delta ) {\n\t  \t\t\treturn function () { return from; };\n\t  \t\t}\n\t\n\t  \t\treturn function ( t ) {\n\t  \t\t\treturn from + ( t * delta );\n\t  \t\t};\n\t  \t},\n\t\n\t  \tarray: function ( from, to ) {\n\t  \t\tvar intermediate, interpolators, len, i;\n\t\n\t  \t\tif ( !isArray( from ) || !isArray( to ) ) {\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\tintermediate = [];\n\t  \t\tinterpolators = [];\n\t\n\t  \t\ti = len = Math.min( from.length, to.length );\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tinterpolators[i] = interpolate( from[i], to[i] );\n\t  \t\t}\n\t\n\t  \t\t// surplus values - don't interpolate, but don't exclude them either\n\t  \t\tfor ( i=len; i<from.length; i+=1 ) {\n\t  \t\t\tintermediate[i] = from[i];\n\t  \t\t}\n\t\n\t  \t\tfor ( i=len; i<to.length; i+=1 ) {\n\t  \t\t\tintermediate[i] = to[i];\n\t  \t\t}\n\t\n\t  \t\treturn function ( t ) {\n\t  \t\t\tvar i = len;\n\t\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tintermediate[i] = interpolators[i]( t );\n\t  \t\t\t}\n\t\n\t  \t\t\treturn intermediate;\n\t  \t\t};\n\t  \t},\n\t\n\t  \tobject: function ( from, to ) {\n\t  \t\tvar properties, len, interpolators, intermediate, prop;\n\t\n\t  \t\tif ( !isObject( from ) || !isObject( to ) ) {\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\tproperties = [];\n\t  \t\tintermediate = {};\n\t  \t\tinterpolators = {};\n\t\n\t  \t\tfor ( prop in from ) {\n\t  \t\t\tif ( hasOwn.call( from, prop ) ) {\n\t  \t\t\t\tif ( hasOwn.call( to, prop ) ) {\n\t  \t\t\t\t\tproperties.push( prop );\n\t  \t\t\t\t\tinterpolators[ prop ] = interpolate( from[ prop ], to[ prop ] ) || snap( to[ prop ] );\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\telse {\n\t  \t\t\t\t\tintermediate[ prop ] = from[ prop ];\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tfor ( prop in to ) {\n\t  \t\t\tif ( hasOwn.call( to, prop ) && !hasOwn.call( from, prop ) ) {\n\t  \t\t\t\tintermediate[ prop ] = to[ prop ];\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tlen = properties.length;\n\t\n\t  \t\treturn function ( t ) {\n\t  \t\t\tvar i = len, prop;\n\t\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tprop = properties[i];\n\t\n\t  \t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\n\t  \t\t\t}\n\t\n\t  \t\t\treturn intermediate;\n\t  \t\t};\n\t  \t}\n\t  };\n\t\n\t  // TODO: deprecate in future release\n\t  var deprecations = {\n\t  \tconstruct: {\n\t  \t\tdeprecated: 'beforeInit',\n\t  \t\treplacement: 'onconstruct'\n\t  \t},\n\t  \trender: {\n\t  \t\tdeprecated: 'init',\n\t  \t\tmessage: 'The \"init\" method has been deprecated ' +\n\t  \t\t\t'and will likely be removed in a future release. ' +\n\t  \t\t\t'You can either use the \"oninit\" method which will fire ' +\n\t  \t\t\t'only once prior to, and regardless of, any eventual ractive ' +\n\t  \t\t\t'instance being rendered, or if you need to access the ' +\n\t  \t\t\t'rendered DOM, use \"onrender\" instead. ' +\n\t  \t\t\t'See http://docs.ractivejs.org/latest/migrating for more information.'\n\t  \t},\n\t  \tcomplete: {\n\t  \t\tdeprecated: 'complete',\n\t  \t\treplacement: 'oncomplete'\n\t  \t}\n\t  };\n\t\n\t  var Hook = function Hook ( event ) {\n\t  \tthis.event = event;\n\t  \tthis.method = 'on' + event;\n\t  \tthis.deprecate = deprecations[ event ];\n\t  };\n\t\n\t  Hook.prototype.call = function call ( method, ractive, arg ) {\n\t  \tif ( ractive[ method ] ) {\n\t  \t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n\t  \t\treturn true;\n\t  \t}\n\t  };\n\t\n\t  Hook.prototype.fire = function fire ( ractive, arg ) {\n\t  \tthis.call( this.method, ractive, arg );\n\t\n\t  \t// handle deprecations\n\t  \tif ( !ractive[ this.method ] && this.deprecate && this.call( this.deprecate.deprecated, ractive, arg ) ) {\n\t  \t\tif ( this.deprecate.message ) {\n\t  \t\t\twarnIfDebug( this.deprecate.message );\n\t  \t\t} else {\n\t  \t\t\twarnIfDebug( 'The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.', this.deprecate.deprecated, this.deprecate.replacement );\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// TODO should probably use internal method, in case ractive.fire was overwritten\n\t  \targ ? ractive.fire( this.event, arg ) : ractive.fire( this.event );\n\t  };\n\t\n\t  function addToArray ( array, value ) {\n\t  \tvar index = array.indexOf( value );\n\t\n\t  \tif ( index === -1 ) {\n\t  \t\tarray.push( value );\n\t  \t}\n\t  }\n\t\n\t  function arrayContains ( array, value ) {\n\t  \tfor ( var i = 0, c = array.length; i < c; i++ ) {\n\t  \t\tif ( array[i] == value ) {\n\t  \t\t\treturn true;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn false;\n\t  }\n\t\n\t  function arrayContentsMatch ( a, b ) {\n\t  \tvar i;\n\t\n\t  \tif ( !isArray( a ) || !isArray( b ) ) {\n\t  \t\treturn false;\n\t  \t}\n\t\n\t  \tif ( a.length !== b.length ) {\n\t  \t\treturn false;\n\t  \t}\n\t\n\t  \ti = a.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( a[i] !== b[i] ) {\n\t  \t\t\treturn false;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn true;\n\t  }\n\t\n\t  function ensureArray ( x ) {\n\t  \tif ( typeof x === 'string' ) {\n\t  \t\treturn [ x ];\n\t  \t}\n\t\n\t  \tif ( x === undefined ) {\n\t  \t\treturn [];\n\t  \t}\n\t\n\t  \treturn x;\n\t  }\n\t\n\t  function lastItem ( array ) {\n\t  \treturn array[ array.length - 1 ];\n\t  }\n\t\n\t  function removeFromArray ( array, member ) {\n\t  \tif ( !array ) {\n\t  \t\treturn;\n\t  \t}\n\t\n\t  \tvar index = array.indexOf( member );\n\t\n\t  \tif ( index !== -1 ) {\n\t  \t\tarray.splice( index, 1 );\n\t  \t}\n\t  }\n\t\n\t  function toArray ( arrayLike ) {\n\t  \tvar array = [], i = arrayLike.length;\n\t  \twhile ( i-- ) {\n\t  \t\tarray[i] = arrayLike[i];\n\t  \t}\n\t\n\t  \treturn array;\n\t  }\n\t\n\t  var _Promise;\n\t  var PENDING = {};\n\t  var FULFILLED = {};\n\t  var REJECTED = {};\n\t  if ( typeof Promise === 'function' ) {\n\t  \t// use native Promise\n\t  \t_Promise = Promise;\n\t  } else {\n\t  \t_Promise = function ( callback ) {\n\t  \t\tvar fulfilledHandlers = [],\n\t  \t\t\trejectedHandlers = [],\n\t  \t\t\tstate = PENDING,\n\t\n\t  \t\t\tresult,\n\t  \t\t\tdispatchHandlers,\n\t  \t\t\tmakeResolver,\n\t  \t\t\tfulfil,\n\t  \t\t\treject,\n\t\n\t  \t\t\tpromise;\n\t\n\t  \t\tmakeResolver = function ( newState ) {\n\t  \t\t\treturn function ( value ) {\n\t  \t\t\t\tif ( state !== PENDING ) {\n\t  \t\t\t\t\treturn;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tresult = value;\n\t  \t\t\t\tstate = newState;\n\t\n\t  \t\t\t\tdispatchHandlers = makeDispatcher( ( state === FULFILLED ? fulfilledHandlers : rejectedHandlers ), result );\n\t\n\t  \t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n\t  \t\t\t\twait( dispatchHandlers );\n\t  \t\t\t};\n\t  \t\t};\n\t\n\t  \t\tfulfil = makeResolver( FULFILLED );\n\t  \t\treject = makeResolver( REJECTED );\n\t\n\t  \t\ttry {\n\t  \t\t\tcallback( fulfil, reject );\n\t  \t\t} catch ( err ) {\n\t  \t\t\treject( err );\n\t  \t\t}\n\t\n\t  \t\tpromise = {\n\t  \t\t\t// `then()` returns a Promise - 2.2.7\n\t  \t\t\tthen: function ( onFulfilled, onRejected ) {\n\t  \t\t\t\tvar promise2 = new _Promise( function ( fulfil, reject ) {\n\t\n\t  \t\t\t\t\tvar processResolutionHandler = function ( handler, handlers, forward ) {\n\t\n\t  \t\t\t\t\t\t// 2.2.1.1\n\t  \t\t\t\t\t\tif ( typeof handler === 'function' ) {\n\t  \t\t\t\t\t\t\thandlers.push( function ( p1result ) {\n\t  \t\t\t\t\t\t\t\tvar x;\n\t\n\t  \t\t\t\t\t\t\t\ttry {\n\t  \t\t\t\t\t\t\t\t\tx = handler( p1result );\n\t  \t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n\t  \t\t\t\t\t\t\t\t} catch ( err ) {\n\t  \t\t\t\t\t\t\t\t\treject( err );\n\t  \t\t\t\t\t\t\t\t}\n\t  \t\t\t\t\t\t\t});\n\t  \t\t\t\t\t\t} else {\n\t  \t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n\t  \t\t\t\t\t\t\t// are not given\n\t  \t\t\t\t\t\t\thandlers.push( forward );\n\t  \t\t\t\t\t\t}\n\t  \t\t\t\t\t};\n\t\n\t  \t\t\t\t\t// 2.2\n\t  \t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n\t  \t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\t\n\t  \t\t\t\t\tif ( state !== PENDING ) {\n\t  \t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n\t  \t\t\t\t\t\twait( dispatchHandlers );\n\t  \t\t\t\t\t}\n\t\n\t  \t\t\t\t});\n\t\n\t  \t\t\t\treturn promise2;\n\t  \t\t\t}\n\t  \t\t};\n\t\n\t  \t\tpromise[ 'catch' ] = function ( onRejected ) {\n\t  \t\t\treturn this.then( null, onRejected );\n\t  \t\t};\n\t\n\t  \t\treturn promise;\n\t  \t};\n\t\n\t  \t_Promise.all = function ( promises ) {\n\t  \t\treturn new _Promise( function ( fulfil, reject ) {\n\t  \t\t\tvar result = [], pending, i, processPromise;\n\t\n\t  \t\t\tif ( !promises.length ) {\n\t  \t\t\t\tfulfil( result );\n\t  \t\t\t\treturn;\n\t  \t\t\t}\n\t\n\t  \t\t\tprocessPromise = function ( promise, i ) {\n\t  \t\t\t\tif ( promise && typeof promise.then === 'function' ) {\n\t  \t\t\t\t\tpromise.then( function ( value ) {\n\t  \t\t\t\t\t\tresult[i] = value;\n\t  \t\t\t\t\t\t--pending || fulfil( result );\n\t  \t\t\t\t\t}, reject );\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\telse {\n\t  \t\t\t\t\tresult[i] = promise;\n\t  \t\t\t\t\t--pending || fulfil( result );\n\t  \t\t\t\t}\n\t  \t\t\t};\n\t\n\t  \t\t\tpending = i = promises.length;\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tprocessPromise( promises[i], i );\n\t  \t\t\t}\n\t  \t\t});\n\t  \t};\n\t\n\t  \t_Promise.resolve = function ( value ) {\n\t  \t\treturn new _Promise( function ( fulfil ) {\n\t  \t\t\tfulfil( value );\n\t  \t\t});\n\t  \t};\n\t\n\t  \t_Promise.reject = function ( reason ) {\n\t  \t\treturn new _Promise( function ( fulfil, reject ) {\n\t  \t\t\treject( reason );\n\t  \t\t});\n\t  \t};\n\t  }\n\t\n\t  var Promise$1 = _Promise;\n\t\n\t  // TODO use MutationObservers or something to simulate setImmediate\n\t  function wait ( callback ) {\n\t  \tsetTimeout( callback, 0 );\n\t  }\n\t\n\t  function makeDispatcher ( handlers, result ) {\n\t  \treturn function () {\n\t  \t\tvar handler;\n\t\n\t  \t\twhile ( handler = handlers.shift() ) {\n\t  \t\t\thandler( result );\n\t  \t\t}\n\t  \t};\n\t  }\n\t\n\t  function resolve ( promise, x, fulfil, reject ) {\n\t  \t// Promise Resolution Procedure\n\t  \tvar then;\n\t\n\t  \t// 2.3.1\n\t  \tif ( x === promise ) {\n\t  \t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n\t  \t}\n\t\n\t  \t// 2.3.2\n\t  \tif ( x instanceof _Promise ) {\n\t  \t\tx.then( fulfil, reject );\n\t  \t}\n\t\n\t  \t// 2.3.3\n\t  \telse if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n\t  \t\ttry {\n\t  \t\t\tthen = x.then; // 2.3.3.1\n\t  \t\t} catch ( e ) {\n\t  \t\t\treject( e ); // 2.3.3.2\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\t// 2.3.3.3\n\t  \t\tif ( typeof then === 'function' ) {\n\t  \t\t\tvar called, resolvePromise, rejectPromise;\n\t\n\t  \t\t\tresolvePromise = function ( y ) {\n\t  \t\t\t\tif ( called ) {\n\t  \t\t\t\t\treturn;\n\t  \t\t\t\t}\n\t  \t\t\t\tcalled = true;\n\t  \t\t\t\tresolve( promise, y, fulfil, reject );\n\t  \t\t\t};\n\t\n\t  \t\t\trejectPromise = function ( r ) {\n\t  \t\t\t\tif ( called ) {\n\t  \t\t\t\t\treturn;\n\t  \t\t\t\t}\n\t  \t\t\t\tcalled = true;\n\t  \t\t\t\treject( r );\n\t  \t\t\t};\n\t\n\t  \t\t\ttry {\n\t  \t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n\t  \t\t\t} catch ( e ) {\n\t  \t\t\t\tif ( !called ) { // 2.3.3.3.4.1\n\t  \t\t\t\t\treject( e ); // 2.3.3.3.4.2\n\t  \t\t\t\t\tcalled = true;\n\t  \t\t\t\t\treturn;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\telse {\n\t  \t\t\tfulfil( x );\n\t  \t\t}\n\t  \t}\n\t\n\t  \telse {\n\t  \t\tfulfil( x );\n\t  \t}\n\t  }\n\t\n\t  var TransitionManager = function TransitionManager ( callback, parent ) {\n\t  \tthis.callback = callback;\n\t  \tthis.parent = parent;\n\t\n\t  \tthis.intros = [];\n\t  \tthis.outros = [];\n\t\n\t  \tthis.children = [];\n\t  \tthis.totalChildren = this.outroChildren = 0;\n\t\n\t  \tthis.detachQueue = [];\n\t  \tthis.outrosComplete = false;\n\t\n\t  \tif ( parent ) {\n\t  \t\tparent.addChild( this );\n\t  \t}\n\t  };\n\t\n\t  TransitionManager.prototype.add = function add ( transition ) {\n\t  \tvar list = transition.isIntro ? this.intros : this.outros;\n\t  \tlist.push( transition );\n\t  };\n\t\n\t  TransitionManager.prototype.addChild = function addChild ( child ) {\n\t  \tthis.children.push( child );\n\t\n\t  \tthis.totalChildren += 1;\n\t  \tthis.outroChildren += 1;\n\t  };\n\t\n\t  TransitionManager.prototype.decrementOutros = function decrementOutros () {\n\t  \tthis.outroChildren -= 1;\n\t  \tcheck( this );\n\t  };\n\t\n\t  TransitionManager.prototype.decrementTotal = function decrementTotal () {\n\t  \tthis.totalChildren -= 1;\n\t  \tcheck( this );\n\t  };\n\t\n\t  TransitionManager.prototype.detachNodes = function detachNodes () {\n\t  \tthis.detachQueue.forEach( detach );\n\t  \tthis.children.forEach( _detachNodes );\n\t  };\n\t\n\t  TransitionManager.prototype.ready = function ready () {\n\t  \tdetachImmediate( this );\n\t  };\n\t\n\t  TransitionManager.prototype.remove = function remove ( transition ) {\n\t  \tvar list = transition.isIntro ? this.intros : this.outros;\n\t  \tremoveFromArray( list, transition );\n\t  \tcheck( this );\n\t  };\n\t\n\t  TransitionManager.prototype.start = function start () {\n\t  \tthis.children.forEach( function ( c ) { return c.start(); } );\n\t  \tthis.intros.concat( this.outros ).forEach( function ( t ) { return t.start(); } );\n\t  \tthis.ready = true;\n\t  \tcheck( this );\n\t  };\n\t\n\t  function detach ( element ) {\n\t  \telement.detach();\n\t  }\n\t\n\t  function _detachNodes ( tm ) { // _ to avoid transpiler quirk\n\t  \ttm.detachNodes();\n\t  }\n\t\n\t  function check ( tm ) {\n\t  \tif ( !tm.ready || tm.outros.length || tm.outroChildren ) return;\n\t\n\t  \t// If all outros are complete, and we haven't already done this,\n\t  \t// we notify the parent if there is one, otherwise\n\t  \t// start detaching nodes\n\t  \tif ( !tm.outrosComplete ) {\n\t  \t\ttm.outrosComplete = true;\n\t\n\t  \t\tif ( tm.parent && !tm.parent.outrosComplete ) {\n\t  \t\t\ttm.parent.decrementOutros( tm );\n\t  \t\t} else {\n\t  \t\t\ttm.detachNodes();\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// Once everything is done, we can notify parent transition\n\t  \t// manager and call the callback\n\t  \tif ( !tm.intros.length && !tm.totalChildren ) {\n\t  \t\tif ( typeof tm.callback === 'function' ) {\n\t  \t\t\ttm.callback();\n\t  \t\t}\n\t\n\t  \t\tif ( tm.parent && !tm.notifiedTotal ) {\n\t  \t\t\ttm.notifiedTotal = true;\n\t  \t\t\ttm.parent.decrementTotal();\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  // check through the detach queue to see if a node is up or downstream from a\n\t  // transition and if not, go ahead and detach it\n\t  function detachImmediate ( manager ) {\n\t  \tvar queue = manager.detachQueue;\n\t  \tvar outros = collectAllOutros( manager );\n\t\n\t  \tvar i = queue.length, j = 0, node, trans;\n\t  \tstart: while ( i-- ) {\n\t  \t\tnode = queue[i].node;\n\t  \t\tj = outros.length;\n\t  \t\twhile ( j-- ) {\n\t  \t\t\ttrans = outros[j].element.node;\n\t  \t\t\t// check to see if the node is, contains, or is contained by the transitioning node\n\t  \t\t\tif ( trans === node || trans.contains( node ) || node.contains( trans ) ) continue start;\n\t  \t\t}\n\t\n\t  \t\t// no match, we can drop it\n\t  \t\tqueue[i].detach();\n\t  \t\tqueue.splice( i, 1 );\n\t  \t}\n\t  }\n\t\n\t  function collectAllOutros ( manager, list ) {\n\t  \tif ( !list ) {\n\t  \t\tlist = [];\n\t  \t\tvar parent = manager;\n\t  \t\twhile ( parent.parent ) parent = parent.parent;\n\t  \t\treturn collectAllOutros( parent, list );\n\t  \t} else {\n\t  \t\tvar i = manager.children.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tlist = collectAllOutros( manager.children[i], list );\n\t  \t\t}\n\t  \t\tlist = list.concat( manager.outros );\n\t  \t\treturn list;\n\t  \t}\n\t  }\n\t\n\t  var changeHook = new Hook( 'change' );\n\t\n\t  var batch;\n\t\n\t  var runloop = {\n\t  \tstart: function ( instance, returnPromise ) {\n\t  \t\tvar promise, fulfilPromise;\n\t\n\t  \t\tif ( returnPromise ) {\n\t  \t\t\tpromise = new Promise$1( function ( f ) { return ( fulfilPromise = f ); } );\n\t  \t\t}\n\t\n\t  \t\tbatch = {\n\t  \t\t\tpreviousBatch: batch,\n\t  \t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n\t  \t\t\tfragments: [],\n\t  \t\t\ttasks: [],\n\t  \t\t\timmediateObservers: [],\n\t  \t\t\tdeferredObservers: [],\n\t  \t\t\tractives: [],\n\t  \t\t\tinstance: instance\n\t  \t\t};\n\t\n\t  \t\treturn promise;\n\t  \t},\n\t\n\t  \tend: function () {\n\t  \t\tflushChanges();\n\t\n\t  \t\tif ( !batch.previousBatch ) batch.transitionManager.start();\n\t\n\t  \t\tbatch = batch.previousBatch;\n\t  \t},\n\t\n\t  \taddFragment: function ( fragment ) {\n\t  \t\taddToArray( batch.fragments, fragment );\n\t  \t},\n\t\n\t  \t// TODO: come up with a better way to handle fragments that trigger their own update\n\t  \taddFragmentToRoot: function ( fragment ) {\n\t  \t\tif ( !batch ) return;\n\t\n\t  \t\tvar b = batch;\n\t  \t\twhile ( b.previousBatch ) {\n\t  \t\t\tb = b.previousBatch;\n\t  \t\t}\n\t\n\t  \t\taddToArray( b.fragments, fragment );\n\t  \t},\n\t\n\t  \taddInstance: function ( instance ) {\n\t  \t\tif ( batch ) addToArray( batch.ractives, instance );\n\t  \t},\n\t\n\t  \taddObserver: function ( observer, defer ) {\n\t  \t\taddToArray( defer ? batch.deferredObservers : batch.immediateObservers, observer );\n\t  \t},\n\t\n\t  \tregisterTransition: function ( transition ) {\n\t  \t\ttransition._manager = batch.transitionManager;\n\t  \t\tbatch.transitionManager.add( transition );\n\t  \t},\n\t\n\t  \t// synchronise node detachments with transition ends\n\t  \tdetachWhenReady: function ( thing ) {\n\t  \t\tbatch.transitionManager.detachQueue.push( thing );\n\t  \t},\n\t\n\t  \tscheduleTask: function ( task, postRender ) {\n\t  \t\tvar _batch;\n\t\n\t  \t\tif ( !batch ) {\n\t  \t\t\ttask();\n\t  \t\t} else {\n\t  \t\t\t_batch = batch;\n\t  \t\t\twhile ( postRender && _batch.previousBatch ) {\n\t  \t\t\t\t// this can't happen until the DOM has been fully updated\n\t  \t\t\t\t// otherwise in some situations (with components inside elements)\n\t  \t\t\t\t// transitions and decorators will initialise prematurely\n\t  \t\t\t\t_batch = _batch.previousBatch;\n\t  \t\t\t}\n\t\n\t  \t\t\t_batch.tasks.push( task );\n\t  \t\t}\n\t  \t}\n\t  };\n\t\n\t  function dispatch ( observer ) {\n\t  \tobserver.dispatch();\n\t  }\n\t\n\t  function flushChanges () {\n\t  \tvar which = batch.immediateObservers;\n\t  \tbatch.immediateObservers = [];\n\t  \twhich.forEach( dispatch );\n\t\n\t  \t// Now that changes have been fully propagated, we can update the DOM\n\t  \t// and complete other tasks\n\t  \tvar i = batch.fragments.length;\n\t  \tvar fragment;\n\t\n\t  \twhich = batch.fragments;\n\t  \tbatch.fragments = [];\n\t  \tvar ractives = batch.ractives;\n\t  \tbatch.ractives = [];\n\t\n\t  \twhile ( i-- ) {\n\t  \t\tfragment = which[i];\n\t\n\t  \t\t// TODO deprecate this. It's annoying and serves no useful function\n\t  \t\tvar ractive = fragment.ractive;\n\t  \t\tif ( Object.keys( ractive.viewmodel.changes ).length ) {\n\t  \t\t\tchangeHook.fire( ractive, ractive.viewmodel.changes );\n\t  \t\t}\n\t  \t\tractive.viewmodel.changes = {};\n\t  \t\tremoveFromArray( ractives, ractive );\n\t\n\t  \t\tfragment.update();\n\t  \t}\n\t\n\t  \ti = ractives.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar ractive$1 = ractives[i];\n\t  \t\tchangeHook.fire( ractive$1, ractive$1.viewmodel.changes );\n\t  \t\tractive$1.viewmodel.changes = {};\n\t  \t}\n\t\n\t  \tbatch.transitionManager.ready();\n\t\n\t  \twhich = batch.deferredObservers;\n\t  \tbatch.deferredObservers = [];\n\t  \twhich.forEach( dispatch );\n\t\n\t  \tvar tasks = batch.tasks;\n\t  \tbatch.tasks = [];\n\t\n\t  \tfor ( i = 0; i < tasks.length; i += 1 ) {\n\t  \t\ttasks[i]();\n\t  \t}\n\t\n\t  \t// If updating the view caused some model blowback - e.g. a triple\n\t  \t// containing <option> elements caused the binding on the <select>\n\t  \t// to update - then we start over\n\t  \tif ( batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.ractives.length || batch.tasks.length ) return flushChanges();\n\t  }\n\t\n\t  var refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n\t  var splitPattern = /([^\\\\](?:\\\\\\\\)*)\\./;\n\t  var escapeKeyPattern = /\\\\|\\./g;\n\t  var unescapeKeyPattern = /((?:\\\\)+)\\1|\\\\(\\.)/g;\n\t\n\t  function escapeKey ( key ) {\n\t  \tif ( typeof key === 'string' ) {\n\t  \t\treturn key.replace( escapeKeyPattern, '\\\\$&' );\n\t  \t}\n\t\n\t  \treturn key;\n\t  }\n\t\n\t  function normalise ( ref ) {\n\t  \treturn ref ? ref.replace( refPattern, '.$1' ) : '';\n\t  }\n\t\n\t  function splitKeypathI ( keypath ) {\n\t  \tvar result = [],\n\t  \t\tmatch;\n\t\n\t  \tkeypath = normalise( keypath );\n\t\n\t  \twhile ( match = splitPattern.exec( keypath ) ) {\n\t  \t\tvar index = match.index + match[1].length;\n\t  \t\tresult.push( keypath.substr( 0, index ) );\n\t  \t\tkeypath = keypath.substr( index + 1 );\n\t  \t}\n\t\n\t  \tresult.push(keypath);\n\t\n\t  \treturn result;\n\t  }\n\t\n\t  function unescapeKey ( key ) {\n\t  \tif ( typeof key === 'string' ) {\n\t  \t\treturn key.replace( unescapeKeyPattern, '$1$2' );\n\t  \t}\n\t\n\t  \treturn key;\n\t  }\n\t\n\t  function bind ( fn, context ) {\n\t  \tif ( !/this/.test( fn.toString() ) ) return fn;\n\t\n\t  \tvar bound = fn.bind( context );\n\t  \tfor ( var prop in fn ) bound[ prop ] = fn[ prop ];\n\t\n\t  \treturn bound;\n\t  }\n\t\n\t  function set ( ractive, pairs ) {\n\t  \tvar promise = runloop.start( ractive, true );\n\t\n\t  \tvar i = pairs.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar ref = pairs[i], model = ref[0], value = ref[1];\n\t  \t\tif ( typeof value === 'function' ) value = bind( value, ractive );\n\t  \t\tmodel.set( value );\n\t  \t}\n\t\n\t  \trunloop.end();\n\t\n\t  \treturn promise;\n\t  }\n\t\n\t  var star = /\\*/;\n\t  function gather ( ractive, keypath, base ) {\n\t  \tif ( base === void 0 ) base = ractive.viewmodel;\n\t\n\t  \tif ( star.test( keypath ) ) {\n\t  \t\treturn base.findMatches( splitKeypathI( keypath ) );\n\t  \t} else {\n\t  \t\treturn [ base.joinAll( splitKeypathI( keypath ) ) ];\n\t  \t}\n\t  }\n\t\n\t  function build ( ractive, keypath, value ) {\n\t  \tvar sets = [];\n\t\n\t  \t// set multiple keypaths in one go\n\t  \tif ( isObject( keypath ) ) {\n\t  \t\tvar loop = function ( k ) {\n\t  \t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t  \t\t\t\tsets.push.apply( sets, gather( ractive, k ).map( function ( m ) { return [ m, keypath[k] ]; } ) );\n\t  \t\t\t}\n\t  \t\t};\n\t\n\t  \t\tfor ( var k in keypath ) loop( k );\n\t\n\t  \t}\n\t  \t// set a single keypath\n\t  \telse {\n\t  \t\tsets.push.apply( sets, gather( ractive, keypath ).map( function ( m ) { return [ m, value ]; } ) );\n\t  \t}\n\t\n\t  \treturn sets;\n\t  }\n\t\n\t  var errorMessage = 'Cannot add to a non-numeric value';\n\t\n\t  function add ( ractive, keypath, d ) {\n\t  \tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\n\t  \t\tthrow new Error( 'Bad arguments' );\n\t  \t}\n\t\n\t  \tvar sets = build( ractive, keypath, d );\n\t\n\t  \treturn set( ractive, sets.map( function ( pair ) {\n\t  \t\tvar model = pair[0], add = pair[1], value = model.get();\n\t  \t\tif ( !isNumeric( add ) || !isNumeric( value ) ) throw new Error( errorMessage );\n\t  \t\treturn [ model, value + add ];\n\t  \t}));\n\t  }\n\t\n\t  function Ractive$add ( keypath, d ) {\n\t  \treturn add( this, keypath, ( d === undefined ? 1 : +d ) );\n\t  }\n\t\n\t  var noAnimation = Promise$1.resolve();\n\t  defineProperty( noAnimation, 'stop', { value: noop });\n\t\n\t  var linear = easing.linear;\n\t\n\t  function getOptions ( options, instance ) {\n\t  \toptions = options || {};\n\t\n\t  \tvar easing;\n\t  \tif ( options.easing ) {\n\t  \t\teasing = typeof options.easing === 'function' ?\n\t  \t\t\toptions.easing :\n\t  \t\t\tinstance.easing[ options.easing ];\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\teasing: easing || linear,\n\t  \t\tduration: 'duration' in options ? options.duration : 400,\n\t  \t\tcomplete: options.complete || noop,\n\t  \t\tstep: options.step || noop\n\t  \t};\n\t  }\n\t\n\t  function protoAnimate ( ractive, model, to, options ) {\n\t  \toptions = getOptions( options, ractive );\n\t  \tvar from = model.get();\n\t\n\t  \t// don't bother animating values that stay the same\n\t  \tif ( isEqual( from, to ) ) {\n\t  \t\toptions.complete( options.to );\n\t  \t\treturn noAnimation; // TODO should this have .then and .catch methods?\n\t  \t}\n\t\n\t  \tvar interpolator = interpolate( from, to, ractive, options.interpolator );\n\t\n\t  \t// if we can't interpolate the value, set it immediately\n\t  \tif ( !interpolator ) {\n\t  \t\trunloop.start();\n\t  \t\tmodel.set( to );\n\t  \t\trunloop.end();\n\t\n\t  \t\treturn noAnimation;\n\t  \t}\n\t\n\t  \treturn model.animate( from, to, options, interpolator );\n\t  }\n\t\n\t  function Ractive$animate ( keypath, to, options ) {\n\t  \tif ( typeof keypath === 'object' ) {\n\t  \t\tvar keys = Object.keys( keypath );\n\t\n\t  \t\tthrow new Error( (\"ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  \" + (keys.map( function ( key ) { return (\"'\" + key + \"': \" + (keypath[ key ])); } ).join( '\\n  ' )) + \"\\n}, {...}), do\\n\\n\" + (keys.map( function ( key ) { return (\"ractive.animate('\" + key + \"', \" + (keypath[ key ]) + \", {...});\"); } ).join( '\\n' )) + \"\\n\") );\n\t  \t}\n\t\n\t\n\t  \treturn protoAnimate( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), to, options );\n\t  }\n\t\n\t  var detachHook = new Hook( 'detach' );\n\t\n\t  function Ractive$detach () {\n\t  \tif ( this.isDetached ) {\n\t  \t\treturn this.el;\n\t  \t}\n\t\n\t  \tif ( this.el ) {\n\t  \t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t  \t}\n\t\n\t  \tthis.el = this.fragment.detach();\n\t  \tthis.isDetached = true;\n\t\n\t  \tdetachHook.fire( this );\n\t  \treturn this.el;\n\t  }\n\t\n\t  function Ractive$find ( selector ) {\n\t  \tif ( !this.el ) throw new Error( (\"Cannot call ractive.find('\" + selector + \"') unless instance is rendered to the DOM\") );\n\t\n\t  \treturn this.fragment.find( selector );\n\t  }\n\t\n\t  function sortByDocumentPosition ( node, otherNode ) {\n\t  \tif ( node.compareDocumentPosition ) {\n\t  \t\tvar bitmask = node.compareDocumentPosition( otherNode );\n\t  \t\treturn ( bitmask & 2 ) ? 1 : -1;\n\t  \t}\n\t\n\t  \t// In old IE, we can piggy back on the mechanism for\n\t  \t// comparing component positions\n\t  \treturn sortByItemPosition( node, otherNode );\n\t  }\n\t\n\t  function sortByItemPosition ( a, b ) {\n\t  \tvar ancestryA = getAncestry( a.component || a._ractive.proxy );\n\t  \tvar ancestryB = getAncestry( b.component || b._ractive.proxy );\n\t\n\t  \tvar oldestA = lastItem( ancestryA );\n\t  \tvar oldestB = lastItem( ancestryB );\n\t  \tvar mutualAncestor;\n\t\n\t  \t// remove items from the end of both ancestries as long as they are identical\n\t  \t// - the final one removed is the closest mutual ancestor\n\t  \twhile ( oldestA && ( oldestA === oldestB ) ) {\n\t  \t\tancestryA.pop();\n\t  \t\tancestryB.pop();\n\t\n\t  \t\tmutualAncestor = oldestA;\n\t\n\t  \t\toldestA = lastItem( ancestryA );\n\t  \t\toldestB = lastItem( ancestryB );\n\t  \t}\n\t\n\t  \t// now that we have the mutual ancestor, we can find which is earliest\n\t  \toldestA = oldestA.component || oldestA;\n\t  \toldestB = oldestB.component || oldestB;\n\t\n\t  \tvar fragmentA = oldestA.parentFragment;\n\t  \tvar fragmentB = oldestB.parentFragment;\n\t\n\t  \t// if both items share a parent fragment, our job is easy\n\t  \tif ( fragmentA === fragmentB ) {\n\t  \t\tvar indexA = fragmentA.items.indexOf( oldestA );\n\t  \t\tvar indexB = fragmentB.items.indexOf( oldestB );\n\t\n\t  \t\t// if it's the same index, it means one contains the other,\n\t  \t\t// so we see which has the longest ancestry\n\t  \t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n\t  \t}\n\t\n\t  \t// if mutual ancestor is a section, we first test to see which section\n\t  \t// fragment comes first\n\t  \tvar fragments = mutualAncestor.iterations;\n\t  \tif ( fragments ) {\n\t  \t\tvar indexA$1 = fragments.indexOf( fragmentA );\n\t  \t\tvar indexB$1 = fragments.indexOf( fragmentB );\n\t\n\t  \t\treturn ( indexA$1 - indexB$1 ) || ancestryA.length - ancestryB.length;\n\t  \t}\n\t\n\t  \tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n\t  }\n\t\n\t  function getParent ( item ) {\n\t  \tvar parentFragment = item.parentFragment;\n\t\n\t  \tif ( parentFragment ) return parentFragment.owner;\n\t\n\t  \tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n\t  \t\treturn parentFragment.owner;\n\t  \t}\n\t  }\n\t\n\t  function getAncestry ( item ) {\n\t  \tvar ancestry = [ item ];\n\t  \tvar ancestor = getParent( item );\n\t\n\t  \twhile ( ancestor ) {\n\t  \t\tancestry.push( ancestor );\n\t  \t\tancestor = getParent( ancestor );\n\t  \t}\n\t\n\t  \treturn ancestry;\n\t  }\n\t\n\t\n\t  var Query = function Query ( ractive, selector, live, isComponentQuery ) {\n\t  \tthis.ractive = ractive;\n\t  \tthis.selector = selector;\n\t  \tthis.live = live;\n\t  \tthis.isComponentQuery = isComponentQuery;\n\t\n\t  \tthis.result = [];\n\t\n\t  \tthis.dirty = true;\n\t  };\n\t\n\t  Query.prototype.add = function add ( item ) {\n\t  \tthis.result.push( item );\n\t  \tthis.makeDirty();\n\t  };\n\t\n\t  Query.prototype.cancel = function cancel () {\n\t  \tvar liveQueries = this._root[ this.isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n\t  \tvar selector = this.selector;\n\t\n\t  \tvar index = liveQueries.indexOf( selector );\n\t\n\t  \tif ( index !== -1 ) {\n\t  \t\tliveQueries.splice( index, 1 );\n\t  \t\tliveQueries[ selector ] = null;\n\t  \t}\n\t  };\n\t\n\t  Query.prototype.init = function init () {\n\t  \tthis.dirty = false;\n\t  };\n\t\n\t  Query.prototype.makeDirty = function makeDirty () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( !this.dirty ) {\n\t  \t\tthis.dirty = true;\n\t\n\t  \t\t// Once the DOM has been updated, ensure the query\n\t  \t\t// is correctly ordered\n\t  \t\trunloop.scheduleTask( function () { return this$1.update(); } );\n\t  \t}\n\t  };\n\t\n\t  Query.prototype.remove = function remove ( nodeOrComponent ) {\n\t  \tvar index = this.result.indexOf( this.isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n\t  \tif ( index !== -1 ) this.result.splice( index, 1 );\n\t  };\n\t\n\t  Query.prototype.update = function update () {\n\t  \tthis.result.sort( this.isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n\t  \tthis.dirty = false;\n\t  };\n\t\n\t  Query.prototype.test = function test ( item ) {\n\t  \treturn this.isComponentQuery ?\n\t  \t\t( !this.selector || item.name === this.selector ) :\n\t  \t\t( item ? matches( item, this.selector ) : null );\n\t  };\n\t\n\t  function Ractive$findAll ( selector, options ) {\n\t  \tif ( !this.el ) throw new Error( (\"Cannot call ractive.findAll('\" + selector + \"', ...) unless instance is rendered to the DOM\") );\n\t\n\t  \toptions = options || {};\n\t  \tvar liveQueries = this._liveQueries;\n\t\n\t  \t// Shortcut: if we're maintaining a live query with this\n\t  \t// selector, we don't need to traverse the parallel DOM\n\t  \tvar query = liveQueries[ selector ];\n\t  \tif ( query ) {\n\t  \t\t// Either return the exact same query, or (if not live) a snapshot\n\t  \t\treturn ( options && options.live ) ? query : query.slice();\n\t  \t}\n\t\n\t  \tquery = new Query( this, selector, !!options.live, false );\n\t\n\t  \t// Add this to the list of live queries Ractive needs to maintain,\n\t  \t// if applicable\n\t  \tif ( query.live ) {\n\t  \t\tliveQueries.push( selector );\n\t  \t\tliveQueries[ '_' + selector ] = query;\n\t  \t}\n\t\n\t  \tthis.fragment.findAll( selector, query );\n\t\n\t  \tquery.init();\n\t  \treturn query.result;\n\t  }\n\t\n\t  function Ractive$findAllComponents ( selector, options ) {\n\t  \toptions = options || {};\n\t  \tvar liveQueries = this._liveComponentQueries;\n\t\n\t  \t// Shortcut: if we're maintaining a live query with this\n\t  \t// selector, we don't need to traverse the parallel DOM\n\t  \tvar query = liveQueries[ selector ];\n\t  \tif ( query ) {\n\t  \t\t// Either return the exact same query, or (if not live) a snapshot\n\t  \t\treturn ( options && options.live ) ? query : query.slice();\n\t  \t}\n\t\n\t  \tquery = new Query( this, selector, !!options.live, true );\n\t\n\t  \t// Add this to the list of live queries Ractive needs to maintain,\n\t  \t// if applicable\n\t  \tif ( query.live ) {\n\t  \t\tliveQueries.push( selector );\n\t  \t\tliveQueries[ '_' + selector ] = query;\n\t  \t}\n\t\n\t  \tthis.fragment.findAllComponents( selector, query );\n\t\n\t  \tquery.init();\n\t  \treturn query.result;\n\t  }\n\t\n\t  function Ractive$findComponent ( selector ) {\n\t  \treturn this.fragment.findComponent( selector );\n\t  }\n\t\n\t  function Ractive$findContainer ( selector ) {\n\t  \tif ( this.container ) {\n\t  \t\tif ( this.container.component && this.container.component.name === selector ) {\n\t  \t\t\treturn this.container;\n\t  \t\t} else {\n\t  \t\t\treturn this.container.findContainer( selector );\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  function Ractive$findParent ( selector ) {\n\t\n\t  \tif ( this.parent ) {\n\t  \t\tif ( this.parent.component && this.parent.component.name === selector ) {\n\t  \t\t\treturn this.parent;\n\t  \t\t} else {\n\t  \t\t\treturn this.parent.findParent ( selector );\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  function enqueue ( ractive, event ) {\n\t  \tif ( ractive.event ) {\n\t  \t\tractive._eventQueue.push( ractive.event );\n\t  \t}\n\t\n\t  \tractive.event = event;\n\t  }\n\t\n\t  function dequeue ( ractive ) {\n\t  \tif ( ractive._eventQueue.length ) {\n\t  \t\tractive.event = ractive._eventQueue.pop();\n\t  \t} else {\n\t  \t\tractive.event = null;\n\t  \t}\n\t  }\n\t\n\t  var starMaps = {};\n\t\n\t  // This function takes a keypath such as 'foo.bar.baz', and returns\n\t  // all the variants of that keypath that include a wildcard in place\n\t  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n\t  // These are then checked against the dependants map (ractive.viewmodel.depsMap)\n\t  // to see if any pattern observers are downstream of one or more of\n\t  // these wildcard keypaths (e.g. 'foo.bar.*.status')\n\t  function getPotentialWildcardMatches ( keypath ) {\n\t  \tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\t\n\t  \tkeys = splitKeypathI( keypath );\n\t  \tif( !( starMap = starMaps[ keys.length ]) ) {\n\t  \t\tstarMap = getStarMap( keys.length );\n\t  \t}\n\t\n\t  \tresult = [];\n\t\n\t  \tmapper = function ( star, i ) {\n\t  \t\treturn star ? '*' : keys[i];\n\t  \t};\n\t\n\t  \ti = starMap.length;\n\t  \twhile ( i-- ) {\n\t  \t\twildcardKeypath = starMap[i].map( mapper ).join( '.' );\n\t\n\t  \t\tif ( !result.hasOwnProperty( wildcardKeypath ) ) {\n\t  \t\t\tresult.push( wildcardKeypath );\n\t  \t\t\tresult[ wildcardKeypath ] = true;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn result;\n\t  }\n\t\n\t  // This function returns all the possible true/false combinations for\n\t  // a given number - e.g. for two, the possible combinations are\n\t  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n\t  // It does so by getting all the binary values between 0 and e.g. 11\n\t  function getStarMap ( num ) {\n\t  \tvar ones = '', max, binary, starMap, mapper, i, j, l, map;\n\t\n\t  \tif ( !starMaps[ num ] ) {\n\t  \t\tstarMap = [];\n\t\n\t  \t\twhile ( ones.length < num ) {\n\t  \t\t\tones += 1;\n\t  \t\t}\n\t\n\t  \t\tmax = parseInt( ones, 2 );\n\t\n\t  \t\tmapper = function ( digit ) {\n\t  \t\t\treturn digit === '1';\n\t  \t\t};\n\t\n\t  \t\tfor ( i = 0; i <= max; i += 1 ) {\n\t  \t\t\tbinary = i.toString( 2 );\n\t  \t\t\twhile ( binary.length < num ) {\n\t  \t\t\t\tbinary = '0' + binary;\n\t  \t\t\t}\n\t\n\t  \t\t\tmap = [];\n\t  \t\t\tl = binary.length;\n\t  \t\t\tfor (j = 0; j < l; j++) {\n\t  \t\t\t\tmap.push( mapper( binary[j] ) );\n\t  \t\t\t}\n\t  \t\t\tstarMap[i] = map;\n\t  \t\t}\n\t\n\t  \t\tstarMaps[ num ] = starMap;\n\t  \t}\n\t\n\t  \treturn starMaps[ num ];\n\t  }\n\t\n\t  var wildcardCache = {};\n\t\n\t  function fireEvent ( ractive, eventName, options ) {\n\t  \tif ( options === void 0 ) options = {};\n\t\n\t  \tif ( !eventName ) { return; }\n\t\n\t  \tif ( !options.event ) {\n\t  \t\toptions.event = {\n\t  \t\t\tname: eventName,\n\t  \t\t\t// until event not included as argument default\n\t  \t\t\t_noArg: true\n\t  \t\t};\n\t  \t} else {\n\t  \t\toptions.event.name = eventName;\n\t  \t}\n\t\n\t  \tvar eventNames = getWildcardNames( eventName );\n\t\n\t  \treturn fireEventAs( ractive, eventNames, options.event, options.args, true );\n\t  }\n\t\n\t  function getWildcardNames ( eventName ) {\n\t  \tif ( wildcardCache.hasOwnProperty( eventName ) ) {\n\t  \t\treturn wildcardCache[ eventName ];\n\t  \t} else {\n\t  \t\treturn wildcardCache[ eventName ] = getPotentialWildcardMatches( eventName );\n\t  \t}\n\t  }\n\t\n\t  function fireEventAs  ( ractive, eventNames, event, args, initialFire ) {\n\t\n\t  \tif ( initialFire === void 0 ) initialFire = false;\n\t\n\t  \tvar subscribers, i, bubble = true;\n\t\n\t  \tenqueue( ractive, event );\n\t\n\t  \tfor ( i = eventNames.length; i >= 0; i-- ) {\n\t  \t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\t\n\t  \t\tif ( subscribers ) {\n\t  \t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tdequeue( ractive );\n\t\n\t  \tif ( ractive.parent && bubble ) {\n\t\n\t  \t\tif ( initialFire && ractive.component ) {\n\t  \t\t\tvar fullName = ractive.component.name + '.' + eventNames[ eventNames.length-1 ];\n\t  \t\t\teventNames = getWildcardNames( fullName );\n\t\n\t  \t\t\tif( event && !event.component ) {\n\t  \t\t\t\tevent.component = ractive;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tfireEventAs( ractive.parent, eventNames, event, args );\n\t  \t}\n\t\n\t  \treturn bubble;\n\t  }\n\t\n\t  function notifySubscribers ( ractive, subscribers, event, args ) {\n\t  \tvar originalEvent = null, stopEvent = false;\n\t\n\t  \tif ( event && !event._noArg ) {\n\t  \t\targs = [ event ].concat( args );\n\t  \t}\n\t\n\t  \t// subscribers can be modified inflight, e.g. \"once\" functionality\n\t  \t// so we need to copy to make sure everyone gets called\n\t  \tsubscribers = subscribers.slice();\n\t\n\t  \tfor ( var i = 0, len = subscribers.length; i < len; i += 1 ) {\n\t  \t\tif ( !subscribers[ i ].off && subscribers[ i ].apply( ractive, args ) === false ) {\n\t  \t\t\tstopEvent = true;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n\t  \t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n\t  \t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n\t  \t}\n\t\n\t  \treturn !stopEvent;\n\t  }\n\t\n\t  function Ractive$fire ( eventName ) {\n\t  \tvar args = [], len = arguments.length - 1;\n\t  \twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t  \treturn fireEvent( this, eventName, { args: args });\n\t  }\n\t\n\t  function badReference ( key ) {\n\t  \tthrow new Error( (\"An index or key reference (\" + key + \") cannot have child properties\") );\n\t  }\n\t\n\t  function resolveAmbiguousReference ( fragment, ref ) {\n\t  \tvar localViewmodel = fragment.findContext().root;\n\t  \tvar keys = splitKeypathI( ref );\n\t  \tvar key = keys[0];\n\t\n\t  \tvar hasContextChain;\n\t  \tvar crossedComponentBoundary;\n\t  \tvar aliases;\n\t\n\t  \twhile ( fragment ) {\n\t  \t\t// repeated fragments\n\t  \t\tif ( fragment.isIteration ) {\n\t  \t\t\tif ( key === fragment.parent.keyRef ) {\n\t  \t\t\t\tif ( keys.length > 1 ) badReference( key );\n\t  \t\t\t\treturn fragment.context.getKeyModel( fragment.key );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( key === fragment.parent.indexRef ) {\n\t  \t\t\t\tif ( keys.length > 1 ) badReference( key );\n\t  \t\t\t\treturn fragment.context.getKeyModel( fragment.index );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// alias node or iteration\n\t  \t\tif ( ( ( aliases = fragment.owner.aliases ) || ( aliases = fragment.aliases ) ) && aliases.hasOwnProperty( key ) ) {\n\t  \t\t\tvar model = aliases[ key ];\n\t\n\t  \t\t\tif ( keys.length === 1 ) return model;\n\t  \t\t\telse if ( typeof model.joinAll === 'function' ) {\n\t  \t\t\t\treturn model.joinAll( keys.slice( 1 ) );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tif ( fragment.context ) {\n\t  \t\t\t// TODO better encapsulate the component check\n\t  \t\t\tif ( !fragment.isRoot || fragment.ractive.component ) hasContextChain = true;\n\t\n\t  \t\t\tif ( fragment.context.has( key ) ) {\n\t  \t\t\t\tif ( crossedComponentBoundary ) {\n\t  \t\t\t\t\treturn localViewmodel.createLink( key, fragment.context.joinKey( keys.shift() ), key ).joinAll( keys );\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\treturn fragment.context.joinAll( keys );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tif ( fragment.componentParent && !fragment.ractive.isolated ) {\n\t  \t\t\t// ascend through component boundary\n\t  \t\t\tfragment = fragment.componentParent;\n\t  \t\t\tcrossedComponentBoundary = true;\n\t  \t\t} else {\n\t  \t\t\tfragment = fragment.parent;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( !hasContextChain ) {\n\t  \t\treturn localViewmodel.joinAll( keys );\n\t  \t}\n\t  }\n\t\n\t  var stack = [];\n\t  var captureGroup;\n\t\n\t  function startCapturing () {\n\t  \tstack.push( captureGroup = [] );\n\t  }\n\t\n\t  function stopCapturing () {\n\t  \tvar dependencies = stack.pop();\n\t  \tcaptureGroup = stack[ stack.length - 1 ];\n\t  \treturn dependencies;\n\t  }\n\t\n\t  function capture ( model ) {\n\t  \tif ( captureGroup ) {\n\t  \t\tcaptureGroup.push( model );\n\t  \t}\n\t  }\n\t\n\t  var KeyModel = function KeyModel ( key, parent ) {\n\t  \tthis.value = key;\n\t  \tthis.isReadonly = this.isKey = true;\n\t  \tthis.deps = [];\n\t  \tthis.links = [];\n\t  \tthis.parent = parent;\n\t  };\n\t\n\t  KeyModel.prototype.get = function get ( shouldCapture ) {\n\t  \tif ( shouldCapture ) capture( this );\n\t  \treturn unescapeKey( this.value );\n\t  };\n\t\n\t  KeyModel.prototype.getKeypath = function getKeypath () {\n\t  \treturn unescapeKey( this.value );\n\t  };\n\t\n\t  KeyModel.prototype.rebinding = function rebinding ( next, previous ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar i = this.deps.length;\n\t  \twhile ( i-- ) this$1.deps[i].rebinding( next, previous, false );\n\t\n\t  \ti = this.links.length;\n\t  \twhile ( i-- ) this$1.links[i].rebinding( next, previous, false );\n\t  };\n\t\n\t  KeyModel.prototype.register = function register ( dependant ) {\n\t  \tthis.deps.push( dependant );\n\t  };\n\t\n\t  KeyModel.prototype.registerLink = function registerLink ( link ) {\n\t  \taddToArray( this.links, link );\n\t  };\n\t\n\t  KeyModel.prototype.unregister = function unregister ( dependant ) {\n\t  \tremoveFromArray( this.deps, dependant );\n\t  };\n\t\n\t  KeyModel.prototype.unregisterLink = function unregisterLink ( link ) {\n\t  \tremoveFromArray( this.links, link );\n\t  };\n\t\n\t  function bind$1               ( x ) { x.bind(); }\n\t  function cancel             ( x ) { x.cancel(); }\n\t  function handleChange       ( x ) { x.handleChange(); }\n\t  function mark               ( x ) { x.mark(); }\n\t  function marked             ( x ) { x.marked(); }\n\t  function notifiedUpstream   ( x ) { x.notifiedUpstream(); }\n\t  function render             ( x ) { x.render(); }\n\t  function teardown           ( x ) { x.teardown(); }\n\t  function unbind             ( x ) { x.unbind(); }\n\t  function unrender           ( x ) { x.unrender(); }\n\t  function unrenderAndDestroy ( x ) { x.unrender( true ); }\n\t  function update             ( x ) { x.update(); }\n\t  function toString$1           ( x ) { return x.toString(); }\n\t  function toEscapedString    ( x ) { return x.toString( true ); }\n\t\n\t  var KeypathModel = function KeypathModel ( parent, ractive ) {\n\t  \tthis.parent = parent;\n\t  \tthis.ractive = ractive;\n\t  \tthis.value = ractive ? parent.getKeypath( ractive ) : parent.getKeypath();\n\t  \tthis.deps = [];\n\t  \tthis.children = {};\n\t  \tthis.isReadonly = this.isKeypath = true;\n\t  };\n\t\n\t  KeypathModel.prototype.get = function get ( shouldCapture ) {\n\t  \tif ( shouldCapture ) capture( this );\n\t  \treturn this.value;\n\t  };\n\t\n\t  KeypathModel.prototype.getChild = function getChild ( ractive ) {\n\t  \tif ( !( ractive._guid in this.children ) ) {\n\t  \t\tvar model = new KeypathModel( this.parent, ractive );\n\t  \t\tthis.children[ ractive._guid ] = model;\n\t  \t\tmodel.owner = this;\n\t  \t}\n\t  \treturn this.children[ ractive._guid ];\n\t  };\n\t\n\t  KeypathModel.prototype.getKeypath = function getKeypath () {\n\t  \treturn this.value;\n\t  };\n\t\n\t  KeypathModel.prototype.handleChange = function handleChange$1 () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar keys = Object.keys( this.children );\n\t  \tvar i = keys.length;\n\t  \twhile ( i-- ) {\n\t  \t\tthis$1.children[ keys[i] ].handleChange();\n\t  \t}\n\t\n\t  \tthis.deps.forEach( handleChange );\n\t  };\n\t\n\t  KeypathModel.prototype.rebindChildren = function rebindChildren ( next ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar keys = Object.keys( this.children );\n\t  \tvar i = keys.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar child = this$1.children[keys[i]];\n\t  \t\tchild.value = next.getKeypath( child.ractive );\n\t  \t\tchild.handleChange();\n\t  \t}\n\t  };\n\t\n\t  KeypathModel.prototype.rebinding = function rebinding ( next, previous ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar model = next ? next.getKeypathModel( this.ractive ) : undefined;\n\t\n\t  \tvar keys = Object.keys( this.children );\n\t  \tvar i = keys.length;\n\t  \twhile ( i-- ) {\n\t  \t\tthis$1.children[ keys[i] ].rebinding( next, previous, false );\n\t  \t}\n\t\n\t  \ti = this.deps.length;\n\t  \twhile ( i-- ) {\n\t  \t\tthis$1.deps[i].rebinding( model, this$1, false );\n\t  \t}\n\t  };\n\t\n\t  KeypathModel.prototype.register = function register ( dep ) {\n\t  \tthis.deps.push( dep );\n\t  };\n\t\n\t  KeypathModel.prototype.removeChild = function removeChild( model ) {\n\t  \tif ( model.ractive ) delete this.children[ model.ractive._guid ];\n\t  };\n\t\n\t  KeypathModel.prototype.teardown = function teardown () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( this.owner ) this.owner.removeChild( this );\n\t\n\t  \tvar keys = Object.keys( this.children );\n\t  \tvar i = keys.length;\n\t  \twhile ( i-- ) {\n\t  \t\tthis$1.children[ keys[i] ].teardown();\n\t  \t}\n\t  };\n\t\n\t  KeypathModel.prototype.unregister = function unregister ( dep ) {\n\t  \tremoveFromArray( this.deps, dep );\n\t  \tif ( !this.deps.length ) this.teardown();\n\t  };\n\t\n\t  var hasProp = Object.prototype.hasOwnProperty;\n\t\n\t  var shuffleTasks = { early: [], mark: [] };\n\t  var registerQueue = { early: [], mark: [] };\n\t\n\t  var ModelBase = function ModelBase ( parent ) {\n\t  \tthis.deps = [];\n\t\n\t  \tthis.children = [];\n\t  \tthis.childByKey = {};\n\t  \tthis.links = [];\n\t\n\t  \tthis.keyModels = {};\n\t\n\t  \tthis.unresolved = [];\n\t  \tthis.unresolvedByKey = {};\n\t\n\t  \tthis.bindings = [];\n\t  \tthis.patternObservers = [];\n\t\n\t  \tif ( parent ) {\n\t  \t\tthis.parent = parent;\n\t  \t\tthis.root = parent.root;\n\t  \t}\n\t  };\n\t\n\t  ModelBase.prototype.addUnresolved = function addUnresolved ( key, resolver ) {\n\t  \tif ( !this.unresolvedByKey[ key ] ) {\n\t  \t\tthis.unresolved.push( key );\n\t  \t\tthis.unresolvedByKey[ key ] = [];\n\t  \t}\n\t\n\t  \tthis.unresolvedByKey[ key ].push( resolver );\n\t  };\n\t\n\t  ModelBase.prototype.addShuffleTask = function addShuffleTask ( task, stage ) { if ( stage === void 0 ) stage = 'early';\n\t\n\t  \tshuffleTasks[stage].push( task ); };\n\t  ModelBase.prototype.addShuffleRegister = function addShuffleRegister ( item, stage ) { if ( stage === void 0 ) stage = 'early';\n\t\n\t  \tregisterQueue[stage].push({ model: this, item: item }); };\n\t\n\t  ModelBase.prototype.clearUnresolveds = function clearUnresolveds ( specificKey ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar i = this.unresolved.length;\n\t\n\t  \twhile ( i-- ) {\n\t  \t\tvar key = this$1.unresolved[i];\n\t\n\t  \t\tif ( specificKey && key !== specificKey ) continue;\n\t\n\t  \t\tvar resolvers = this$1.unresolvedByKey[ key ];\n\t  \t\tvar hasKey = this$1.has( key );\n\t\n\t  \t\tvar j = resolvers.length;\n\t  \t\twhile ( j-- ) {\n\t  \t\t\tif ( hasKey ) resolvers[j].attemptResolution();\n\t  \t\t\tif ( resolvers[j].resolved ) resolvers.splice( j, 1 );\n\t  \t\t}\n\t\n\t  \t\tif ( !resolvers.length ) {\n\t  \t\t\tthis$1.unresolved.splice( i, 1 );\n\t  \t\t\tthis$1.unresolvedByKey[ key ] = null;\n\t  \t\t}\n\t  \t}\n\t  };\n\t\n\t  ModelBase.prototype.findMatches = function findMatches ( keys ) {\n\t  \tvar len = keys.length;\n\t\n\t  \tvar existingMatches = [ this ];\n\t  \tvar matches;\n\t  \tvar i;\n\t\n\t  \tvar loop = function (  ) {\n\t  \t\tvar key = keys[i];\n\t\n\t  \t\tif ( key === '*' ) {\n\t  \t\t\tmatches = [];\n\t  \t\t\texistingMatches.forEach( function ( model ) {\n\t  \t\t\t\tmatches.push.apply( matches, model.getValueChildren( model.get() ) );\n\t  \t\t\t});\n\t  \t\t} else {\n\t  \t\t\tmatches = existingMatches.map( function ( model ) { return model.joinKey( key ); } );\n\t  \t\t}\n\t\n\t  \t\texistingMatches = matches;\n\t  \t};\n\t\n\t  \t\tfor ( i = 0; i < len; i += 1 ) loop(  );\n\t\n\t  \treturn matches;\n\t  };\n\t\n\t  ModelBase.prototype.getKeyModel = function getKeyModel ( key, skip ) {\n\t  \tif ( key !== undefined && !skip ) return this.parent.getKeyModel( key, true );\n\t\n\t  \tif ( !( key in this.keyModels ) ) this.keyModels[ key ] = new KeyModel( escapeKey( key ), this );\n\t\n\t  \treturn this.keyModels[ key ];\n\t  };\n\t\n\t  ModelBase.prototype.getKeypath = function getKeypath ( ractive ) {\n\t  \tif ( ractive !== this.ractive && this._link ) return this._link.target.getKeypath( ractive );\n\t\n\t  \tif ( !this.keypath ) {\n\t  \t\tthis.keypath = this.parent.isRoot ? this.key : (\"\" + (this.parent.getKeypath( ractive )) + \".\" + (escapeKey( this.key )));\n\t  \t}\n\t\n\t  \treturn this.keypath;\n\t  };\n\t\n\t  ModelBase.prototype.getValueChildren = function getValueChildren ( value ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar children;\n\t  \tif ( isArray( value ) ) {\n\t  \t\tchildren = [];\n\t  \t\tif ( 'length' in this && this.length !== value.length ) {\n\t  \t\t\tchildren.push( this.joinKey( 'length' ) );\n\t  \t\t}\n\t  \t\tvalue.forEach( function ( m, i ) {\n\t  \t\t\tchildren.push( this$1.joinKey( i ) );\n\t  \t\t});\n\t  \t}\n\t\n\t  \telse if ( isObject( value ) || typeof value === 'function' ) {\n\t  \t\tchildren = Object.keys( value ).map( function ( key ) { return this$1.joinKey( key ); } );\n\t  \t}\n\t\n\t  \telse if ( value != null ) {\n\t  \t\treturn [];\n\t  \t}\n\t\n\t  \treturn children;\n\t  };\n\t\n\t  ModelBase.prototype.getVirtual = function getVirtual ( shouldCapture ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar value = this.get( shouldCapture, { virtual: false } );\n\t  \tif ( isObject( value ) ) {\n\t  \t\tvar result = isArray( value ) ? [] : {};\n\t\n\t  \t\tvar keys = Object.keys( value );\n\t  \t\tvar i = keys.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar child = this$1.childByKey[ keys[i] ];\n\t  \t\t\tif ( !child ) result[ keys[i] ] = value[ keys[i] ];\n\t  \t\t\telse if ( child._link ) result[ keys[i] ] = child._link.getVirtual();\n\t  \t\t\telse result[ keys[i] ] = child.getVirtual();\n\t  \t\t}\n\t\n\t  \t\ti = this.children.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar child$1 = this$1.children[i];\n\t  \t\t\tif ( !( child$1.key in result ) && child$1._link ) {\n\t  \t\t\t\tresult[ child$1.key ] = child$1._link.getVirtual();\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn result;\n\t  \t} else return value;\n\t  };\n\t\n\t  ModelBase.prototype.has = function has ( key ) {\n\t  \tif ( this._link ) return this._link.has( key );\n\t\n\t  \tvar value = this.get();\n\t  \tif ( !value ) return false;\n\t\n\t  \tkey = unescapeKey( key );\n\t  \tif ( hasProp.call( value, key ) ) return true;\n\t\n\t  \t// We climb up the constructor chain to find if one of them contains the key\n\t  \tvar constructor = value.constructor;\n\t  \twhile ( constructor !== Function && constructor !== Array && constructor !== Object ) {\n\t  \t\tif ( hasProp.call( constructor.prototype, key ) ) return true;\n\t  \t\tconstructor = constructor.constructor;\n\t  \t}\n\t\n\t  \treturn false;\n\t  };\n\t\n\t  ModelBase.prototype.joinAll = function joinAll ( keys, opts ) {\n\t  \tvar model = this;\n\t  \tfor ( var i = 0; i < keys.length; i += 1 ) {\n\t  \t\tif ( opts && opts.lastLink === false && i + 1 === keys.length && model.childByKey[keys[i]] && model.childByKey[keys[i]]._link ) return model.childByKey[keys[i]];\n\t  \t\tmodel = model.joinKey( keys[i], opts );\n\t  \t}\n\t\n\t  \treturn model;\n\t  };\n\t\n\t  ModelBase.prototype.notifyUpstream = function notifyUpstream () {\n\t  \tvar parent = this.parent, path = [ this.key ];\n\t  \twhile ( parent ) {\n\t  \t\tif ( parent.patternObservers.length ) parent.patternObservers.forEach( function ( o ) { return o.notify( path.slice() ); } );\n\t  \t\tpath.unshift( parent.key );\n\t  \t\tparent.links.forEach( notifiedUpstream );\n\t  \t\tparent.deps.forEach( handleChange );\n\t  \t\tparent = parent.parent;\n\t  \t}\n\t  };\n\t\n\t  ModelBase.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t  \t// tell the deps to move to the new target\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar i = this.deps.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( this$1.deps[i].rebinding ) this$1.deps[i].rebinding( next, previous, safe );\n\t  \t}\n\t\n\t  \ti = this.links.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar link = this$1.links[i];\n\t  \t\t// only relink the root of the link tree\n\t  \t\tif ( link.owner._link ) link.relinking( next, true, safe );\n\t  \t}\n\t\n\t  \ti = this.children.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar child = this$1.children[i];\n\t  \t\tchild.rebinding( next ? next.joinKey( child.key ) : undefined, child, safe );\n\t  \t}\n\t\n\t  \ti = this.unresolved.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar unresolved = this$1.unresolvedByKey[ this$1.unresolved[i] ];\n\t  \t\tvar c = unresolved.length;\n\t  \t\twhile ( c-- ) {\n\t  \t\t\tunresolved[c].rebinding( next, previous );\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( this.keypathModel ) this.keypathModel.rebinding( next, previous, false );\n\t\n\t  \ti = this.bindings.length;\n\t  \twhile ( i-- ) {\n\t  \t\tthis$1.bindings[i].rebinding( next, previous, safe );\n\t  \t}\n\t  };\n\t\n\t  ModelBase.prototype.register = function register ( dep ) {\n\t  \tthis.deps.push( dep );\n\t  };\n\t\n\t  ModelBase.prototype.registerChange = function registerChange ( key, value ) {\n\t  \tif ( !this.isRoot ) {\n\t  \t\tthis.root.registerChange( key, value );\n\t  \t} else {\n\t  \t\tthis.changes[ key ] = value;\n\t  \t\trunloop.addInstance( this.root.ractive );\n\t  \t}\n\t  };\n\t\n\t  ModelBase.prototype.registerLink = function registerLink ( link ) {\n\t  \taddToArray( this.links, link );\n\t  };\n\t\n\t  ModelBase.prototype.registerPatternObserver = function registerPatternObserver ( observer ) {\n\t  \tthis.patternObservers.push( observer );\n\t  \tthis.register( observer );\n\t  };\n\t\n\t  ModelBase.prototype.registerTwowayBinding = function registerTwowayBinding ( binding ) {\n\t  \tthis.bindings.push( binding );\n\t  };\n\t\n\t  ModelBase.prototype.removeUnresolved = function removeUnresolved ( key, resolver ) {\n\t  \tvar resolvers = this.unresolvedByKey[ key ];\n\t\n\t  \tif ( resolvers ) {\n\t  \t\tremoveFromArray( resolvers, resolver );\n\t  \t}\n\t  };\n\t\n\t  ModelBase.prototype.shuffled = function shuffled () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar i = this.children.length;\n\t  \twhile ( i-- ) {\n\t  \t\tthis$1.children[i].shuffled();\n\t  \t}\n\t  \tif ( this.wrapper ) {\n\t  \t\tthis.wrapper.teardown();\n\t  \t\tthis.wrapper = null;\n\t  \t\tthis.rewrap = true;\n\t  \t}\n\t  };\n\t\n\t  ModelBase.prototype.unregister = function unregister ( dependant ) {\n\t  \tremoveFromArray( this.deps, dependant );\n\t  };\n\t\n\t  ModelBase.prototype.unregisterLink = function unregisterLink ( link ) {\n\t  \tremoveFromArray( this.links, link );\n\t  };\n\t\n\t  ModelBase.prototype.unregisterPatternObserver = function unregisterPatternObserver ( observer ) {\n\t  \tremoveFromArray( this.patternObservers, observer );\n\t  \tthis.unregister( observer );\n\t  };\n\t\n\t  ModelBase.prototype.unregisterTwowayBinding = function unregisterTwowayBinding ( binding ) {\n\t  \tremoveFromArray( this.bindings, binding );\n\t  };\n\t\n\t  ModelBase.prototype.updateFromBindings = function updateFromBindings$1 ( cascade ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar i = this.bindings.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar value = this$1.bindings[i].getValue();\n\t  \t\tif ( value !== this$1.value ) this$1.set( value );\n\t  \t}\n\t\n\t  \t// check for one-way bindings if there are no two-ways\n\t  \tif ( !this.bindings.length ) {\n\t  \t\tvar oneway = findBoundValue( this.deps );\n\t  \t\tif ( oneway && oneway.value !== this.value ) this.set( oneway.value );\n\t  \t}\n\t\n\t  \tif ( cascade ) {\n\t  \t\tthis.children.forEach( updateFromBindings );\n\t  \t\tthis.links.forEach( updateFromBindings );\n\t  \t\tif ( this._link ) this._link.updateFromBindings( cascade );\n\t  \t}\n\t  };\n\t\n\t  function updateFromBindings ( model ) {\n\t  \tmodel.updateFromBindings( true );\n\t  }\n\t\n\t  function findBoundValue( list ) {\n\t  \tvar i = list.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( list[i].bound ) {\n\t  \t\t\tvar owner = list[i].owner;\n\t  \t\t\tif ( owner ) {\n\t  \t\t\t\tvar value = owner.name === 'checked' ?\n\t  \t\t\t\t\towner.node.checked :\n\t  \t\t\t\t\towner.node.value;\n\t  \t\t\t\treturn { value: value };\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  function fireShuffleTasks ( stage ) {\n\t  \tif ( !stage ) {\n\t  \t\tfireShuffleTasks( 'early' );\n\t  \t\tfireShuffleTasks( 'mark' );\n\t  \t} else {\n\t  \t\tvar tasks = shuffleTasks[stage];\n\t  \t\tshuffleTasks[stage] = [];\n\t  \t\tvar i = tasks.length;\n\t  \t\twhile ( i-- ) tasks[i]();\n\t\n\t  \t\tvar register = registerQueue[stage];\n\t  \t\tregisterQueue[stage] = [];\n\t  \t\ti = register.length;\n\t  \t\twhile ( i-- ) register[i].model.register( register[i].item );\n\t  \t}\n\t  }\n\t\n\t  KeyModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\n\t  KeyModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\n\t  KeypathModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\n\t  KeypathModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\n\t\n\t  // this is the dry method of checking to see if a rebind applies to\n\t  // a particular keypath because in some cases, a dep may be bound\n\t  // directly to a particular keypath e.g. foo.bars.0.baz and need\n\t  // to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted\n\t  function rebindMatch ( template, next, previous ) {\n\t  \tvar keypath = template.r || template;\n\t\n\t  \t// no valid keypath, go with next\n\t  \tif ( !keypath || typeof keypath !== 'string' ) return next;\n\t\n\t  \t// completely contextual ref, go with next\n\t  \tif ( keypath === '.' || keypath[0] === '@' || (next || previous).isKey || (next || previous).isKeypath ) return next;\n\t\n\t  \tvar parts = keypath.split( '/' );\n\t  \tvar keys = splitKeypathI( parts[ parts.length - 1 ] );\n\t\n\t  \t// check the keypath against the model keypath to see if it matches\n\t  \tvar model = next || previous;\n\t  \tvar i = keys.length;\n\t  \tvar match = true, shuffling = false;\n\t\n\t  \twhile ( model && i-- ) {\n\t  \t\tif ( model.shuffling ) shuffling = true;\n\t  \t\t// non-strict comparison to account for indices in keypaths\n\t  \t\tif ( keys[i] != model.key ) match = false;\n\t  \t\tmodel = model.parent;\n\t  \t}\n\t\n\t  \t// next is undefined, but keypath is shuffling and previous matches\n\t  \tif ( !next && match && shuffling ) return previous;\n\t  \t// next is defined, but doesn't match the keypath\n\t  \telse if ( next && !match && shuffling ) return previous;\n\t  \telse return next;\n\t  }\n\t\n\t  var LinkModel = (function (ModelBase) {\n\t  \tfunction LinkModel ( parent, owner, target, key ) {\n\t  \t\tModelBase.call( this, parent );\n\t\n\t  \t\tthis.owner = owner;\n\t  \t\tthis.target = target;\n\t  \t\tthis.key = key === undefined ? owner.key : key;\n\t  \t\tif ( owner.isLink ) this.sourcePath = \"\" + (owner.sourcePath) + \".\" + (this.key);\n\t\n\t  \t\ttarget.registerLink( this );\n\t\n\t  \t\tthis.isReadonly = parent.isReadonly;\n\t\n\t  \t\tthis.isLink = true;\n\t  \t}\n\t\n\t  \tLinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n\t  \tLinkModel.prototype.constructor = LinkModel;\n\t\n\t  \tLinkModel.prototype.animate = function animate ( from, to, options, interpolator ) {\n\t  \t\tthis.target.animate( from, to, options, interpolator );\n\t  \t};\n\t\n\t  \tLinkModel.prototype.applyValue = function applyValue ( value ) {\n\t  \t\tthis.target.applyValue( value );\n\t  \t};\n\t\n\t  \tLinkModel.prototype.get = function get ( shouldCapture, opts ) {\n\t  \t\tif ( shouldCapture ) {\n\t  \t\t\tcapture( this );\n\t\n\t  \t\t\t// may need to tell the target to unwrap\n\t  \t\t\topts = opts || {};\n\t  \t\t\topts.unwrap = true;\n\t  \t\t}\n\t\n\t  \t\treturn this.target.get( false, opts );\n\t  \t};\n\t\n\t  \tLinkModel.prototype.getKeypath = function getKeypath ( ractive ) {\n\t  \t\tif ( ractive && ractive !== this.root.ractive ) return this.target.getKeypath( ractive );\n\t\n\t  \t\treturn ModelBase.prototype.getKeypath.call( this, ractive );\n\t  \t};\n\t\n\t  \tLinkModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {\n\t  \t\tif ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );\n\t  \t\tif ( ractive && ractive !== this.root.ractive ) return this.keypathModel.getChild( ractive );\n\t  \t\treturn this.keypathModel;\n\t  \t};\n\t\n\t  \tLinkModel.prototype.handleChange = function handleChange$1 () {\n\t  \t\tthis.deps.forEach( handleChange );\n\t  \t\tthis.links.forEach( handleChange );\n\t  \t\tthis.notifyUpstream();\n\t  \t};\n\t\n\t  \tLinkModel.prototype.joinKey = function joinKey ( key ) {\n\t  \t\t// TODO: handle nested links\n\t  \t\tif ( key === undefined || key === '' ) return this;\n\t\n\t  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t  \t\t\tvar child = new LinkModel( this, this, this.target.joinKey( key ), key );\n\t  \t\t\tthis.children.push( child );\n\t  \t\t\tthis.childByKey[ key ] = child;\n\t  \t\t}\n\t\n\t  \t\treturn this.childByKey[ key ];\n\t  \t};\n\t\n\t  \tLinkModel.prototype.mark = function mark () {\n\t  \t\tthis.target.mark();\n\t  \t};\n\t\n\t  \tLinkModel.prototype.marked = function marked$1 () {\n\t  \t\tthis.links.forEach( marked );\n\t\n\t  \t\tthis.deps.forEach( handleChange );\n\t  \t\tthis.clearUnresolveds();\n\t  \t};\n\t\n\t  \tLinkModel.prototype.notifiedUpstream = function notifiedUpstream$1 () {\n\t  \t\tthis.links.forEach( notifiedUpstream );\n\t  \t\tthis.deps.forEach( handleChange );\n\t  \t};\n\t\n\t  \tLinkModel.prototype.relinked = function relinked () {\n\t  \t\tthis.target.registerLink( this );\n\t  \t\tthis.children.forEach( function ( c ) { return c.relinked(); } );\n\t  \t};\n\t\n\t  \tLinkModel.prototype.relinking = function relinking ( target, root, safe ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( root && this.sourcePath ) target = rebindMatch( this.sourcePath, target, this.target );\n\t  \t\tif ( !target || this.target === target ) return;\n\t\n\t  \t\tthis.target.unregisterLink( this );\n\t  \t\tif ( this.keypathModel ) this.keypathModel.rebindChildren( target );\n\t\n\t  \t\tthis.target = target;\n\t  \t\tthis.children.forEach( function ( c ) {\n\t  \t\t\tc.relinking( target.joinKey( c.key ), false, safe );\n\t  \t\t});\n\t\n\t  \t\tif ( root ) this.addShuffleTask( function () {\n\t  \t\t\tthis$1.relinked();\n\t  \t\t\tif ( !safe ) this$1.notifyUpstream();\n\t  \t\t});\n\t  \t};\n\t\n\t  \tLinkModel.prototype.set = function set ( value ) {\n\t  \t\tthis.target.set( value );\n\t  \t};\n\t\n\t  \tLinkModel.prototype.shuffle = function shuffle ( newIndices ) {\n\t  \t\t// watch for extra shuffles caused by a shuffle in a downstream link\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( this.shuffling ) return;\n\t\n\t  \t\t// let the real model handle firing off shuffles\n\t  \t\tif ( !this.target.shuffling ) {\n\t  \t\t\tthis.target.shuffle( newIndices );\n\t  \t\t} else {\n\t  \t\t\tthis.shuffling = true;\n\t\n\t  \t\t\tvar i = newIndices.length;\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tvar idx = newIndices[ i ];\n\t  \t\t\t\t// nothing is actually changing, so move in the index and roll on\n\t  \t\t\t\tif ( i === idx ) {\n\t  \t\t\t\t\tcontinue;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\t// rebind the children on i to idx\n\t  \t\t\t\tif ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );\n\t\n\t  \t\t\t\tif ( !~idx && this$1.keyModels[ i ] ) {\n\t  \t\t\t\t\tthis$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );\n\t  \t\t\t\t} else if ( ~idx && this$1.keyModels[ i ] ) {\n\t  \t\t\t\t\tif ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );\n\t  \t\t\t\t\tthis$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\tvar upstream = this.source().length !== this.source().value.length;\n\t\n\t  \t\t\tthis.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );\n\t\n\t  \t\t\ti = this.deps.length;\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tif ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.marked();\n\t\n\t  \t\t\tif ( upstream ) this.notifyUpstream();\n\t\n\t  \t\t\tthis.shuffling = false;\n\t  \t\t}\n\t\n\t  \t};\n\t\n\t  \tLinkModel.prototype.source = function source () {\n\t  \t\tif ( this.target.source ) return this.target.source();\n\t  \t\telse return this.target;\n\t  \t};\n\t\n\t  \tLinkModel.prototype.teardown = function teardown$1 () {\n\t  \t\tif ( this._link ) this._link.teardown();\n\t  \t\tthis.children.forEach( teardown );\n\t  \t};\n\t\n\t  \treturn LinkModel;\n\t  }(ModelBase));\n\t\n\t  ModelBase.prototype.link = function link ( model, keypath ) {\n\t  \tvar lnk = this._link || new LinkModel( this.parent, this, model, this.key );\n\t  \tlnk.sourcePath = keypath;\n\t  \tif ( this._link ) this._link.relinking( model, true, false );\n\t  \tthis.rebinding( lnk, this, false );\n\t  \tfireShuffleTasks();\n\t\n\t  \tvar unresolved = !this._link;\n\t  \tthis._link = lnk;\n\t  \tif ( unresolved ) this.parent.clearUnresolveds();\n\t  \tlnk.marked();\n\t  \treturn lnk;\n\t  };\n\t\n\t  ModelBase.prototype.unlink = function unlink () {\n\t  \tif ( this._link ) {\n\t  \t\tvar ln = this._link;\n\t  \t\tthis._link = undefined;\n\t  \t\tln.rebinding( this, this._link );\n\t  \t\tfireShuffleTasks();\n\t  \t\tln.teardown();\n\t  \t}\n\t  };\n\t\n\t  var requestAnimationFrame;\n\t\n\t  // If window doesn't exist, we don't need requestAnimationFrame\n\t  if ( !win ) {\n\t  \trequestAnimationFrame = null;\n\t  } else {\n\t  \t// https://gist.github.com/paulirish/1579671\n\t  \t(function(vendors, lastTime, win) {\n\t\n\t  \t\tvar x, setTimeout;\n\t\n\t  \t\tif ( win.requestAnimationFrame ) {\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tfor ( x = 0; x < vendors.length && !win.requestAnimationFrame; ++x ) {\n\t  \t\t\twin.requestAnimationFrame = win[vendors[x]+'RequestAnimationFrame'];\n\t  \t\t}\n\t\n\t  \t\tif ( !win.requestAnimationFrame ) {\n\t  \t\t\tsetTimeout = win.setTimeout;\n\t\n\t  \t\t\twin.requestAnimationFrame = function(callback) {\n\t  \t\t\t\tvar currTime, timeToCall, id;\n\t\n\t  \t\t\t\tcurrTime = Date.now();\n\t  \t\t\t\ttimeToCall = Math.max( 0, 16 - (currTime - lastTime ) );\n\t  \t\t\t\tid = setTimeout( function() { callback(currTime + timeToCall); }, timeToCall );\n\t\n\t  \t\t\t\tlastTime = currTime + timeToCall;\n\t  \t\t\t\treturn id;\n\t  \t\t\t};\n\t  \t\t}\n\t\n\t  \t}( vendors, 0, win ));\n\t\n\t  \trequestAnimationFrame = win.requestAnimationFrame;\n\t  }\n\t\n\t  var rAF = requestAnimationFrame;\n\t\n\t  var getTime = ( win && win.performance && typeof win.performance.now === 'function' ) ?\n\t  \tfunction () { return win.performance.now(); } :\n\t  \tfunction () { return Date.now(); };\n\t\n\t  // TODO what happens if a transition is aborted?\n\t\n\t  var tickers = [];\n\t  var running = false;\n\t\n\t  function tick () {\n\t  \trunloop.start();\n\t\n\t  \tvar now = getTime();\n\t\n\t  \tvar i;\n\t  \tvar ticker;\n\t\n\t  \tfor ( i = 0; i < tickers.length; i += 1 ) {\n\t  \t\tticker = tickers[i];\n\t\n\t  \t\tif ( !ticker.tick( now ) ) {\n\t  \t\t\t// ticker is complete, remove it from the stack, and decrement i so we don't miss one\n\t  \t\t\ttickers.splice( i--, 1 );\n\t  \t\t}\n\t  \t}\n\t\n\t  \trunloop.end();\n\t\n\t  \tif ( tickers.length ) {\n\t  \t\trAF( tick );\n\t  \t} else {\n\t  \t\trunning = false;\n\t  \t}\n\t  }\n\t\n\t  var Ticker = function Ticker ( options ) {\n\t  \tthis.duration = options.duration;\n\t  \tthis.step = options.step;\n\t  \tthis.complete = options.complete;\n\t  \tthis.easing = options.easing;\n\t\n\t  \tthis.start = getTime();\n\t  \tthis.end = this.start + this.duration;\n\t\n\t  \tthis.running = true;\n\t\n\t  \ttickers.push( this );\n\t  \tif ( !running ) rAF( tick );\n\t  };\n\t\n\t  Ticker.prototype.tick = function tick$1 ( now ) {\n\t  \tif ( !this.running ) return false;\n\t\n\t  \tif ( now > this.end ) {\n\t  \t\tif ( this.step ) this.step( 1 );\n\t  \t\tif ( this.complete ) this.complete( 1 );\n\t\n\t  \t\treturn false;\n\t  \t}\n\t\n\t  \tvar elapsed = now - this.start;\n\t  \tvar eased = this.easing( elapsed / this.duration );\n\t\n\t  \tif ( this.step ) this.step( eased );\n\t\n\t  \treturn true;\n\t  };\n\t\n\t  Ticker.prototype.stop = function stop () {\n\t  \tif ( this.abort ) this.abort();\n\t  \tthis.running = false;\n\t  };\n\t\n\t  var prefixers = {};\n\t\n\t  // TODO this is legacy. sooner we can replace the old adaptor API the better\n\t  function prefixKeypath ( obj, prefix ) {\n\t  \tvar prefixed = {}, key;\n\t\n\t  \tif ( !prefix ) {\n\t  \t\treturn obj;\n\t  \t}\n\t\n\t  \tprefix += '.';\n\t\n\t  \tfor ( key in obj ) {\n\t  \t\tif ( obj.hasOwnProperty( key ) ) {\n\t  \t\t\tprefixed[ prefix + key ] = obj[ key ];\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn prefixed;\n\t  }\n\t\n\t  function getPrefixer ( rootKeypath ) {\n\t  \tvar rootDot;\n\t\n\t  \tif ( !prefixers[ rootKeypath ] ) {\n\t  \t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\t\n\t  \t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n\t  \t\t\tvar obj;\n\t\n\t  \t\t\tif ( typeof relativeKeypath === 'string' ) {\n\t  \t\t\t\tobj = {};\n\t  \t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n\t  \t\t\t\treturn obj;\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( typeof relativeKeypath === 'object' ) {\n\t  \t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n\t  \t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n\t  \t\t\t}\n\t  \t\t};\n\t  \t}\n\t\n\t  \treturn prefixers[ rootKeypath ];\n\t  }\n\t\n\t  var Model = (function (ModelBase) {\n\t  \tfunction Model ( parent, key ) {\n\t  \t\tModelBase.call( this, parent );\n\t\n\t  \t\tthis.ticker = null;\n\t\n\t  \t\tif ( parent ) {\n\t  \t\t\tthis.key = unescapeKey( key );\n\t  \t\t\tthis.isReadonly = parent.isReadonly;\n\t\n\t  \t\t\tif ( parent.value ) {\n\t  \t\t\t\tthis.value = parent.value[ this.key ];\n\t  \t\t\t\tif ( isArray( this.value ) ) this.length = this.value.length;\n\t  \t\t\t\tthis.adapt();\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n\t  \tModel.prototype.constructor = Model;\n\t\n\t  \tModel.prototype.adapt = function adapt () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar adaptors = this.root.adaptors;\n\t  \t\tvar len = adaptors.length;\n\t\n\t  \t\tthis.rewrap = false;\n\t\n\t  \t\t// Exit early if no adaptors\n\t  \t\tif ( len === 0 ) return;\n\t\n\t  \t\tvar value = this.wrapper ? ( 'newWrapperValue' in this ? this.newWrapperValue : this.wrapperValue ) : this.value;\n\t\n\t  \t\t// TODO remove this legacy nonsense\n\t  \t\tvar ractive = this.root.ractive;\n\t  \t\tvar keypath = this.getKeypath();\n\t\n\t  \t\t// tear previous adaptor down if present\n\t  \t\tif ( this.wrapper ) {\n\t  \t\t\tvar shouldTeardown = this.wrapperValue === value ? false : !this.wrapper.reset || this.wrapper.reset( value ) === false;\n\t\n\t  \t\t\tif ( shouldTeardown ) {\n\t  \t\t\t\tthis.wrapper.teardown();\n\t  \t\t\t\tthis.wrapper = null;\n\t\n\t  \t\t\t\t// don't branch for undefined values\n\t  \t\t\t\tif ( this.value !== undefined ) {\n\t  \t\t\t\t\tvar parentValue = this.parent.value || this.parent.createBranch( this.key );\n\t  \t\t\t\t\tif ( parentValue[ this.key ] !== value ) parentValue[ this.key ] = value;\n\t  \t\t\t\t}\n\t  \t\t\t} else {\n\t  \t\t\t\tdelete this.newWrapperValue;\n\t  \t\t\t\tthis.wrapperValue = value;\n\t  \t\t\t\tthis.value = this.wrapper.get();\n\t  \t\t\t\treturn;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tvar i;\n\t\n\t  \t\tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\t\tvar adaptor = adaptors[i];\n\t  \t\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\n\t  \t\t\t\tthis$1.wrapper = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\n\t  \t\t\t\tthis$1.wrapperValue = value;\n\t  \t\t\t\tthis$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor\n\t\n\t  \t\t\t\tthis$1.value = this$1.wrapper.get();\n\t\n\t  \t\t\t\tbreak;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \tModel.prototype.animate = function animate ( from, to, options, interpolator ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( this.ticker ) this.ticker.stop();\n\t\n\t  \t\tvar fulfilPromise;\n\t  \t\tvar promise = new Promise$1( function ( fulfil ) { return fulfilPromise = fulfil; } );\n\t\n\t  \t\tthis.ticker = new Ticker({\n\t  \t\t\tduration: options.duration,\n\t  \t\t\teasing: options.easing,\n\t  \t\t\tstep: function ( t ) {\n\t  \t\t\t\tvar value = interpolator( t );\n\t  \t\t\t\tthis$1.applyValue( value );\n\t  \t\t\t\tif ( options.step ) options.step( t, value );\n\t  \t\t\t},\n\t  \t\t\tcomplete: function () {\n\t  \t\t\t\tthis$1.applyValue( to );\n\t  \t\t\t\tif ( options.complete ) options.complete( to );\n\t\n\t  \t\t\t\tthis$1.ticker = null;\n\t  \t\t\t\tfulfilPromise();\n\t  \t\t\t}\n\t  \t\t});\n\t\n\t  \t\tpromise.stop = this.ticker.stop;\n\t  \t\treturn promise;\n\t  \t};\n\t\n\t  \tModel.prototype.applyValue = function applyValue ( value ) {\n\t  \t\tif ( isEqual( value, this.value ) ) return;\n\t\n\t  \t\t// TODO deprecate this nonsense\n\t  \t\tthis.registerChange( this.getKeypath(), value );\n\t\n\t  \t\tif ( this.parent.wrapper && this.parent.wrapper.set ) {\n\t  \t\t\tthis.parent.wrapper.set( this.key, value );\n\t  \t\t\tthis.parent.value = this.parent.wrapper.get();\n\t\n\t  \t\t\tthis.value = this.parent.value[ this.key ];\n\t  \t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t  \t\t\tthis.adapt();\n\t  \t\t} else if ( this.wrapper ) {\n\t  \t\t\tthis.newWrapperValue = value;\n\t  \t\t\tthis.adapt();\n\t  \t\t} else {\n\t  \t\t\tvar parentValue = this.parent.value || this.parent.createBranch( this.key );\n\t  \t\t\tparentValue[ this.key ] = value;\n\t\n\t  \t\t\tthis.value = value;\n\t  \t\t\tthis.adapt();\n\t  \t\t}\n\t\n\t  \t\tthis.parent.clearUnresolveds();\n\t  \t\tthis.clearUnresolveds();\n\t\n\t  \t\t// keep track of array length\n\t  \t\tif ( isArray( value ) ) this.length = value.length;\n\t\n\t  \t\t// notify dependants\n\t  \t\tthis.links.forEach( handleChange );\n\t  \t\tthis.children.forEach( mark );\n\t  \t\tthis.deps.forEach( handleChange );\n\t\n\t  \t\tthis.notifyUpstream();\n\t\n\t  \t\tif ( this.key === 'length' && isArray( this.parent.value ) ) this.parent.length = this.parent.value.length;\n\t  \t};\n\t\n\t  \tModel.prototype.createBranch = function createBranch ( key ) {\n\t  \t\tvar branch = isNumeric( key ) ? [] : {};\n\t  \t\tthis.set( branch );\n\t\n\t  \t\treturn branch;\n\t  \t};\n\t\n\t  \tModel.prototype.get = function get ( shouldCapture, opts ) {\n\t  \t\tif ( this._link ) return this._link.get( shouldCapture, opts );\n\t  \t\tif ( shouldCapture ) capture( this );\n\t  \t\t// if capturing, this value needs to be unwrapped because it's for external use\n\t  \t\tif ( opts && opts.virtual ) return this.getVirtual( false );\n\t  \t\treturn ( shouldCapture || ( opts && opts.unwrap ) ) && this.wrapper ? this.wrapperValue : this.value;\n\t  \t};\n\t\n\t  \tModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {\n\t  \t\tif ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );\n\t  \t\treturn this.keypathModel;\n\t  \t};\n\t\n\t  \tModel.prototype.joinKey = function joinKey ( key, opts ) {\n\t  \t\tif ( this._link ) {\n\t  \t\t\tif ( opts && !opts.lastLink === false && ( key === undefined || key === '' ) ) return this;\n\t  \t\t\treturn this._link.joinKey( key );\n\t  \t\t}\n\t\n\t  \t\tif ( key === undefined || key === '' ) return this;\n\t\n\t\n\t  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t  \t\t\tvar child = new Model( this, key );\n\t  \t\t\tthis.children.push( child );\n\t  \t\t\tthis.childByKey[ key ] = child;\n\t  \t\t}\n\t\n\t  \t\tif ( this.childByKey[ key ]._link ) return this.childByKey[ key ]._link;\n\t  \t\treturn this.childByKey[ key ];\n\t  \t};\n\t\n\t  \tModel.prototype.mark = function mark$1 () {\n\t  \t\tif ( this._link ) return this._link.mark();\n\t\n\t  \t\tvar value = this.retrieve();\n\t\n\t  \t\tif ( !isEqual( value, this.value ) ) {\n\t  \t\t\tvar old = this.value;\n\t  \t\t\tthis.value = value;\n\t\n\t  \t\t\t// make sure the wrapper stays in sync\n\t  \t\t\tif ( old !== value || this.rewrap ) {\n\t  \t\t\t\tif ( this.wrapper ) this.newWrapperValue = value;\n\t  \t\t\t\tthis.adapt();\n\t  \t\t\t}\n\t\n\t  \t\t\t// keep track of array lengths\n\t  \t\t\tif ( isArray( value ) ) this.length = value.length;\n\t\n\t  \t\t\tthis.children.forEach( mark );\n\t  \t\t\tthis.links.forEach( marked );\n\t\n\t  \t\t\tthis.deps.forEach( handleChange );\n\t  \t\t\tthis.clearUnresolveds();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tModel.prototype.merge = function merge ( array, comparator ) {\n\t  \t\tvar oldArray = this.value, newArray = array;\n\t  \t\tif ( oldArray === newArray ) oldArray = recreateArray( this );\n\t  \t\tif ( comparator ) {\n\t  \t\t\toldArray = oldArray.map( comparator );\n\t  \t\t\tnewArray = newArray.map( comparator );\n\t  \t\t}\n\t\n\t  \t\tvar oldLength = oldArray.length;\n\t\n\t  \t\tvar usedIndices = {};\n\t  \t\tvar firstUnusedIndex = 0;\n\t\n\t  \t\tvar newIndices = oldArray.map( function ( item ) {\n\t  \t\t\tvar index;\n\t  \t\t\tvar start = firstUnusedIndex;\n\t\n\t  \t\t\tdo {\n\t  \t\t\t\tindex = newArray.indexOf( item, start );\n\t\n\t  \t\t\t\tif ( index === -1 ) {\n\t  \t\t\t\t\treturn -1;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tstart = index + 1;\n\t  \t\t\t} while ( ( usedIndices[ index ] === true ) && start < oldLength );\n\t\n\t  \t\t\t// keep track of the first unused index, so we don't search\n\t  \t\t\t// the whole of newArray for each item in oldArray unnecessarily\n\t  \t\t\tif ( index === firstUnusedIndex ) {\n\t  \t\t\t\tfirstUnusedIndex += 1;\n\t  \t\t\t}\n\t  \t\t\t// allow next instance of next \"equal\" to be found item\n\t  \t\t\tusedIndices[ index ] = true;\n\t  \t\t\treturn index;\n\t  \t\t});\n\t\n\t  \t\tthis.parent.value[ this.key ] = array;\n\t  \t\tthis.shuffle( newIndices );\n\t  \t};\n\t\n\t  \tModel.prototype.retrieve = function retrieve () {\n\t  \t\treturn this.parent.value ? this.parent.value[ this.key ] : undefined;\n\t  \t};\n\t\n\t  \tModel.prototype.set = function set ( value ) {\n\t  \t\tif ( this.ticker ) this.ticker.stop();\n\t  \t\tthis.applyValue( value );\n\t  \t};\n\t\n\t  \tModel.prototype.shuffle = function shuffle ( newIndices ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tthis.shuffling = true;\n\t  \t\tvar i = newIndices.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar idx = newIndices[ i ];\n\t  \t\t\t// nothing is actually changing, so move in the index and roll on\n\t  \t\t\tif ( i === idx ) {\n\t  \t\t\t\tcontinue;\n\t  \t\t\t}\n\t\n\t  \t\t\t// rebind the children on i to idx\n\t  \t\t\tif ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );\n\t\n\t  \t\t\tif ( !~idx && this$1.keyModels[ i ] ) {\n\t  \t\t\t\tthis$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );\n\t  \t\t\t} else if ( ~idx && this$1.keyModels[ i ] ) {\n\t  \t\t\t\tif ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );\n\t  \t\t\t\tthis$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tvar upstream = this.length !== this.value.length;\n\t\n\t  \t\tthis.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );\n\t  \t\tfireShuffleTasks( 'early' );\n\t\n\t  \t\ti = this.deps.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tif ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );\n\t  \t\t}\n\t\n\t  \t\tthis.mark();\n\t  \t\tfireShuffleTasks( 'mark' );\n\t\n\t  \t\tif ( upstream ) this.notifyUpstream();\n\t  \t\tthis.shuffling = false;\n\t  \t};\n\t\n\t  \tModel.prototype.teardown = function teardown$1 () {\n\t  \t\tif ( this._link ) this._link.teardown();\n\t  \t\tthis.children.forEach( teardown );\n\t  \t\tif ( this.wrapper ) this.wrapper.teardown();\n\t  \t\tif ( this.keypathModel ) this.keypathModel.teardown();\n\t  \t};\n\t\n\t  \treturn Model;\n\t  }(ModelBase));\n\t\n\t  function recreateArray( model ) {\n\t  \tvar array = [];\n\t\n\t  \tfor ( var i = 0; i < model.length; i++ ) {\n\t  \t\tarray[ i ] = (model.childByKey[i] || {}).value;\n\t  \t}\n\t\n\t  \treturn array;\n\t  }\n\t\n\t  var GlobalModel = (function (Model) {\n\t  \tfunction GlobalModel ( ) {\n\t  \t\tModel.call( this, null, '@global' );\n\t  \t\tthis.value = typeof global !== 'undefined' ? global : window;\n\t  \t\tthis.isRoot = true;\n\t  \t\tthis.root = this;\n\t  \t\tthis.adaptors = [];\n\t  \t}\n\t\n\t  \tGlobalModel.prototype = Object.create( Model && Model.prototype );\n\t  \tGlobalModel.prototype.constructor = GlobalModel;\n\t\n\t  \tGlobalModel.prototype.getKeypath = function getKeypath() {\n\t  \t\treturn '@global';\n\t  \t};\n\t\n\t  \t// global model doesn't contribute changes events because it has no instance\n\t  \tGlobalModel.prototype.registerChange = function registerChange () {};\n\t\n\t  \treturn GlobalModel;\n\t  }(Model));\n\t\n\t  var GlobalModel$1 = new GlobalModel();\n\t\n\t  var keypathExpr = /^@[^\\(]+\\(([^\\)]+)\\)/;\n\t\n\t  function resolveReference ( fragment, ref ) {\n\t  \tvar context = fragment.findContext();\n\t\n\t  \t// special references\n\t  \t// TODO does `this` become `.` at parse time?\n\t  \tif ( ref === '.' || ref === 'this' ) return context;\n\t  \tif ( ref.indexOf( '@keypath' ) === 0 ) {\n\t  \t\tvar match = keypathExpr.exec( ref );\n\t  \t\tif ( match && match[1] ) {\n\t  \t\t\tvar model = resolveReference( fragment, match[1] );\n\t  \t\t\tif ( model ) return model.getKeypathModel();\n\t  \t\t}\n\t  \t\treturn context.getKeypathModel();\n\t  \t}\n\t  \tif ( ref.indexOf( '@rootpath' ) === 0 ) {\n\t  \t\t// check to see if this is an empty component root\n\t  \t\twhile ( context.isRoot && context.ractive.component ) {\n\t  \t\t\tcontext = context.ractive.component.parentFragment.findContext();\n\t  \t\t}\n\t\n\t  \t\tvar match$1 = keypathExpr.exec( ref );\n\t  \t\tif ( match$1 && match$1[1] ) {\n\t  \t\t\tvar model$1 = resolveReference( fragment, match$1[1] );\n\t  \t\t\tif ( model$1 ) return model$1.getKeypathModel( fragment.ractive.root );\n\t  \t\t}\n\t  \t\treturn context.getKeypathModel( fragment.ractive.root );\n\t  \t}\n\t  \tif ( ref === '@index' || ref === '@key' ) {\n\t  \t\tvar repeater = fragment.findRepeatingFragment();\n\t  \t\t// make sure the found fragment is actually an iteration\n\t  \t\tif ( !repeater.isIteration ) return;\n\t  \t\treturn repeater.context.getKeyModel( repeater[ ref[1] === 'i' ? 'index' : 'key' ] );\n\t  \t}\n\t  \tif ( ref === '@this' ) {\n\t  \t\treturn fragment.ractive.viewmodel.getRactiveModel();\n\t  \t}\n\t  \tif ( ref === '@global' ) {\n\t  \t\treturn GlobalModel$1;\n\t  \t}\n\t\n\t  \t// ancestor references\n\t  \tif ( ref[0] === '~' ) return fragment.ractive.viewmodel.joinAll( splitKeypathI( ref.slice( 2 ) ) );\n\t  \tif ( ref[0] === '.' ) {\n\t  \t\tvar parts = ref.split( '/' );\n\t\n\t  \t\twhile ( parts[0] === '.' || parts[0] === '..' ) {\n\t  \t\t\tvar part = parts.shift();\n\t\n\t  \t\t\tif ( part === '..' ) {\n\t  \t\t\t\tcontext = context.parent;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tref = parts.join( '/' );\n\t\n\t  \t\t// special case - `{{.foo}}` means the same as `{{./foo}}`\n\t  \t\tif ( ref[0] === '.' ) ref = ref.slice( 1 );\n\t  \t\treturn context.joinAll( splitKeypathI( ref ) );\n\t  \t}\n\t\n\t  \treturn resolveAmbiguousReference( fragment, ref );\n\t  }\n\t\n\t  function Ractive$get ( keypath, opts ) {\n\t  \tif ( typeof keypath !== 'string' ) return this.viewmodel.get( true, keypath );\n\t\n\t  \tvar keys = splitKeypathI( keypath );\n\t  \tvar key = keys[0];\n\t\n\t  \tvar model;\n\t\n\t  \tif ( !this.viewmodel.has( key ) ) {\n\t  \t\t// if this is an inline component, we may need to create\n\t  \t\t// an implicit mapping\n\t  \t\tif ( this.component && !this.isolated ) {\n\t  \t\t\tmodel = resolveReference( this.component.parentFragment, key );\n\t\n\t  \t\t\tif ( model ) {\n\t  \t\t\t\tthis.viewmodel.map( key, model );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tmodel = this.viewmodel.joinAll( keys );\n\t  \treturn model.get( true, opts );\n\t  }\n\t\n\t  function gatherRefs( fragment ) {\n\t  \tvar key = {}, index = {};\n\t\n\t  \t// walk up the template gather refs as we go\n\t  \twhile ( fragment ) {\n\t  \t\tif ( fragment.parent && ( fragment.parent.indexRef || fragment.parent.keyRef ) ) {\n\t  \t\t\tvar ref = fragment.parent.indexRef;\n\t  \t\t\tif ( ref && !( ref in index ) ) index[ref] = fragment.index;\n\t  \t\t\tref = fragment.parent.keyRef;\n\t  \t\t\tif ( ref && !( ref in key ) ) key[ref] = fragment.key;\n\t  \t\t}\n\t\n\t  \t\tif ( fragment.componentParent && !fragment.ractive.isolated ) {\n\t  \t\t\tfragment = fragment.componentParent;\n\t  \t\t} else {\n\t  \t\t\tfragment = fragment.parent;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn { key: key, index: index };\n\t  }\n\t\n\t  // This function takes an array, the name of a mutator method, and the\n\t  // arguments to call that mutator method with, and returns an array that\n\t  // maps the old indices to their new indices.\n\t\n\t  // So if you had something like this...\n\t  //\n\t  //     array = [ 'a', 'b', 'c', 'd' ];\n\t  //     array.push( 'e' );\n\t  //\n\t  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n\t  // have changed. If you then did this...\n\t  //\n\t  //     array.unshift( 'z' );\n\t  //\n\t  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n\t  // one higher to make room for the 'z'. If you removed an item, the new index\n\t  // would be -1...\n\t  //\n\t  //     array.splice( 2, 2 );\n\t  //\n\t  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n\t  //\n\t  // This information is used to enable fast, non-destructive shuffling of list\n\t  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\t\n\t  function getNewIndices ( length, methodName, args ) {\n\t  \tvar spliceArguments, newIndices = [], removeStart, removeEnd, balance, i;\n\t\n\t  \tspliceArguments = getSpliceEquivalent( length, methodName, args );\n\t\n\t  \tif ( !spliceArguments ) {\n\t  \t\treturn null; // TODO support reverse and sort?\n\t  \t}\n\t\n\t  \tbalance = ( spliceArguments.length - 2 ) - spliceArguments[1];\n\t\n\t  \tremoveStart = Math.min( length, spliceArguments[0] );\n\t  \tremoveEnd = removeStart + spliceArguments[1];\n\t  \tnewIndices.startIndex = removeStart;\n\t\n\t  \tfor ( i = 0; i < removeStart; i += 1 ) {\n\t  \t\tnewIndices.push( i );\n\t  \t}\n\t\n\t  \tfor ( ; i < removeEnd; i += 1 ) {\n\t  \t\tnewIndices.push( -1 );\n\t  \t}\n\t\n\t  \tfor ( ; i < length; i += 1 ) {\n\t  \t\tnewIndices.push( i + balance );\n\t  \t}\n\t\n\t  \t// there is a net shift for the rest of the array starting with index + balance\n\t  \tif ( balance !== 0 ) {\n\t  \t\tnewIndices.touchedFrom = spliceArguments[0];\n\t  \t} else {\n\t  \t\tnewIndices.touchedFrom = length;\n\t  \t}\n\t\n\t  \treturn newIndices;\n\t  }\n\t\n\t\n\t  // The pop, push, shift an unshift methods can all be represented\n\t  // as an equivalent splice\n\t  function getSpliceEquivalent ( length, methodName, args ) {\n\t  \tswitch ( methodName ) {\n\t  \t\tcase 'splice':\n\t  \t\t\tif ( args[0] !== undefined && args[0] < 0 ) {\n\t  \t\t\t\targs[0] = length + Math.max( args[0], -length );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( args[0] === undefined ) args[0] = 0;\n\t\n\t  \t\t\twhile ( args.length < 2 ) {\n\t  \t\t\t\targs.push( length - args[0] );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( typeof args[1] !== 'number' ) {\n\t  \t\t\t\targs[1] = length - args[0];\n\t  \t\t\t}\n\t\n\t  \t\t\t// ensure we only remove elements that exist\n\t  \t\t\targs[1] = Math.min( args[1], length - args[0] );\n\t\n\t  \t\t\treturn args;\n\t\n\t  \t\tcase 'sort':\n\t  \t\tcase 'reverse':\n\t  \t\t\treturn null;\n\t\n\t  \t\tcase 'pop':\n\t  \t\t\tif ( length ) {\n\t  \t\t\t\treturn [ length - 1, 1 ];\n\t  \t\t\t}\n\t  \t\t\treturn [ 0, 0 ];\n\t\n\t  \t\tcase 'push':\n\t  \t\t\treturn [ length, 0 ].concat( args );\n\t\n\t  \t\tcase 'shift':\n\t  \t\t\treturn [ 0, length ? 1 : 0 ];\n\t\n\t  \t\tcase 'unshift':\n\t  \t\t\treturn [ 0, 0 ].concat( args );\n\t  \t}\n\t  }\n\t\n\t  var arrayProto = Array.prototype;\n\t\n\t  function makeArrayMethod ( methodName ) {\n\t  \tfunction path ( keypath ) {\n\t  \t\tvar args = [], len = arguments.length - 1;\n\t  \t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\t\n\t  \t\treturn model( this.viewmodel.joinAll( splitKeypathI( keypath ) ), args );\n\t  \t}\n\t\n\t  \tfunction model ( mdl, args ) {\n\t  \t\tvar array = mdl.get();\n\t\n\t  \t\tif ( !isArray( array ) ) {\n\t  \t\t\tif ( array === undefined ) {\n\t  \t\t\t\tarray = [];\n\t  \t\t\t\tvar result$1 = arrayProto[ methodName ].apply( array, args );\n\t  \t\t\t\tvar promise$1 = runloop.start( this, true ).then( function () { return result$1; } );\n\t  \t\t\t\tmdl.set( array );\n\t  \t\t\t\trunloop.end();\n\t  \t\t\t\treturn promise$1;\n\t  \t\t\t} else {\n\t  \t\t\t\tthrow new Error( (\"shuffle array method \" + methodName + \" called on non-array at \" + (mdl.getKeypath())) );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tvar newIndices = getNewIndices( array.length, methodName, args );\n\t  \t\tvar result = arrayProto[ methodName ].apply( array, args );\n\t\n\t  \t\tvar promise = runloop.start( this, true ).then( function () { return result; } );\n\t  \t\tpromise.result = result;\n\t\n\t  \t\tif ( newIndices ) {\n\t  \t\t\tmdl.shuffle( newIndices );\n\t  \t\t} else {\n\t  \t\t\tmdl.set( result );\n\t  \t\t}\n\t\n\t  \t\trunloop.end();\n\t\n\t  \t\treturn promise;\n\t  \t}\n\t\n\t  \treturn { path: path, model: model };\n\t  }\n\t\n\t  var comparators = {};\n\t\n\t  function getComparator ( option ) {\n\t  \tif ( !option ) return null; // use existing arrays\n\t  \tif ( option === true ) return JSON.stringify;\n\t  \tif ( typeof option === 'function' ) return option;\n\t\n\t  \tif ( typeof option === 'string' ) {\n\t  \t\treturn comparators[ option ] || ( comparators[ option ] = function ( thing ) { return thing[ option ]; } );\n\t  \t}\n\t\n\t  \tthrow new Error( 'If supplied, options.compare must be a string, function, or `true`' ); // TODO link to docs\n\t  }\n\t\n\t  function merge$1 ( ractive, model, array, options ) {\n\t  \tvar promise = runloop.start( ractive, true );\n\t  \tvar value = model.get();\n\t\n\t  \tif ( !isArray( value ) || !isArray( array ) ) {\n\t  \t\tthrow new Error( 'You cannot merge an array with a non-array' );\n\t  \t}\n\t\n\t  \tvar comparator = getComparator( options && options.compare );\n\t  \tmodel.merge( array, comparator );\n\t\n\t  \trunloop.end();\n\t  \treturn promise;\n\t  }\n\t\n\t  function thisRactive$merge ( keypath, array, options ) {\n\t  \treturn merge$1( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), array, options );\n\t  }\n\t\n\t  var updateHook = new Hook( 'update' );\n\t\n\t  function update$2 ( ractive, model ) {\n\t  \t// if the parent is wrapped, the adaptor will need to be updated before\n\t  \t// updating on this keypath\n\t  \tif ( model.parent && model.parent.wrapper ) {\n\t  \t\tmodel.parent.adapt();\n\t  \t}\n\t\n\t  \tvar promise = runloop.start( ractive, true );\n\t\n\t  \tmodel.mark();\n\t  \tmodel.registerChange( model.getKeypath(), model.get() );\n\t\n\t  \tif ( !model.isRoot ) {\n\t  \t\t// there may be unresolved refs that are now resolvable up the context tree\n\t  \t\tvar parent = model.parent, key = model.key;\n\t  \t\twhile ( parent && !parent.isRoot ) {\n\t  \t\t\tif ( parent.clearUnresolveds ) parent.clearUnresolveds( key );\n\t  \t\t\tkey = parent.key;\n\t  \t\t\tparent = parent.parent;\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// notify upstream of changes\n\t  \tmodel.notifyUpstream();\n\t\n\t  \trunloop.end();\n\t\n\t  \tupdateHook.fire( ractive, model );\n\t\n\t  \treturn promise;\n\t  }\n\t\n\t  function Ractive$update ( keypath ) {\n\t  \tif ( keypath ) keypath = splitKeypathI( keypath );\n\t\n\t  \treturn update$2( this, keypath ? this.viewmodel.joinAll( keypath ) : this.viewmodel );\n\t  }\n\t\n\t  var modelPush = makeArrayMethod( 'push' ).model;\n\t  var modelPop = makeArrayMethod( 'pop' ).model;\n\t  var modelShift = makeArrayMethod( 'shift' ).model;\n\t  var modelUnshift = makeArrayMethod( 'unshift' ).model;\n\t  var modelSort = makeArrayMethod( 'sort' ).model;\n\t  var modelSplice = makeArrayMethod( 'splice' ).model;\n\t  var modelReverse = makeArrayMethod( 'reverse' ).model;\n\t\n\t  // TODO: at some point perhaps this could support relative * keypaths?\n\t  function build$1 ( el, keypath, value ) {\n\t  \tvar sets = [];\n\t\n\t  \t// set multiple keypaths in one go\n\t  \tif ( isObject( keypath ) ) {\n\t  \t\tfor ( var k in keypath ) {\n\t  \t\t\tif ( keypath.hasOwnProperty( k ) ) {\n\t  \t\t\t\tsets.push( [ findModel( el, k ).model, keypath[k] ] );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t}\n\t  \t// set a single keypath\n\t  \telse {\n\t  \t\tsets.push( [ findModel( el, keypath ).model, value ] );\n\t  \t}\n\t\n\t  \treturn sets;\n\t  }\n\t\n\t  // get relative keypaths and values\n\t  function get ( keypath ) {\n\t  \tif ( !keypath ) return this._element.parentFragment.findContext().get( true );\n\t\n\t  \tvar model = resolveReference( this._element.parentFragment, keypath );\n\t\n\t  \treturn model ? model.get( true ) : undefined;\n\t  }\n\t\n\t  function resolve$1 ( path, ractive ) {\n\t  \tvar ref = findModel( this, path ), model = ref.model, instance = ref.instance;\n\t  \treturn model ? model.getKeypath( ractive || instance ) : path;\n\t  }\n\t\n\t  function findModel ( el, path ) {\n\t  \tvar frag = el._element.parentFragment;\n\t\n\t  \tif ( typeof path !== 'string' ) {\n\t  \t\treturn { model: frag.findContext(), instance: path };\n\t  \t}\n\t\n\t  \treturn { model: resolveReference( frag, path ), instance: frag.ractive };\n\t  }\n\t\n\t  // the usual mutation suspects\n\t  function add$1 ( keypath, value ) {\n\t  \tif ( value === undefined ) value = 1;\n\t  \tif ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );\n\t  \treturn set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {\n\t  \t\tvar model = pair[0], val = pair[1], value = model.get();\n\t  \t\tif ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );\n\t  \t\treturn [ model, value + val ];\n\t  \t}) );\n\t  }\n\t\n\t  function animate ( keypath, value, options ) {\n\t  \tvar model = findModel( this, keypath ).model;\n\t  \treturn protoAnimate( this.ractive, model, value, options );\n\t  }\n\t\n\t  function link ( source, dest ) {\n\t  \tvar there = findModel( this, source ).model, here = findModel( this, dest ).model;\n\t  \tvar promise = runloop.start( this.ractive, true );\n\t  \there.link( there, source );\n\t  \trunloop.end();\n\t  \treturn promise;\n\t  }\n\t\n\t  function merge ( keypath, array, options ) {\n\t  \treturn merge$1( this.ractive, findModel( this, keypath ).model, array, options );\n\t  }\n\t\n\t  function pop ( keypath ) {\n\t  \treturn modelPop( findModel( this, keypath ).model, [] );\n\t  }\n\t\n\t  function push ( keypath ) {\n\t  \tvar values = [], len = arguments.length - 1;\n\t  \twhile ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\t\n\t  \treturn modelPush( findModel( this, keypath ).model, values );\n\t  }\n\t\n\t  function reverse ( keypath ) {\n\t  \treturn modelReverse( findModel( this, keypath ).model, [] );\n\t  }\n\t\n\t  function set$1 ( keypath, value ) {\n\t  \treturn set( this.ractive, build$1( this, keypath, value ) );\n\t  }\n\t\n\t  function shift ( keypath ) {\n\t  \treturn modelShift( findModel( this, keypath ).model, [] );\n\t  }\n\t\n\t  function splice ( keypath, index, drop ) {\n\t  \tvar add = [], len = arguments.length - 3;\n\t  \twhile ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];\n\t\n\t  \tadd.unshift( index, drop );\n\t  \treturn modelSplice( findModel( this, keypath ).model, add );\n\t  }\n\t\n\t  function sort ( keypath ) {\n\t  \treturn modelSort( findModel( this, keypath ).model, [] );\n\t  }\n\t\n\t  function subtract ( keypath, value ) {\n\t  \tif ( value === undefined ) value = 1;\n\t  \tif ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );\n\t  \treturn set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {\n\t  \t\tvar model = pair[0], val = pair[1], value = model.get();\n\t  \t\tif ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );\n\t  \t\treturn [ model, value - val ];\n\t  \t}) );\n\t  }\n\t\n\t  function toggle ( keypath ) {\n\t  \tvar ref = findModel( this, keypath ), model = ref.model;\n\t  \treturn set( this.ractive, [ [ model, !model.get() ] ] );\n\t  }\n\t\n\t  function unlink ( dest ) {\n\t  \tvar here = findModel( this, dest ).model;\n\t  \tvar promise = runloop.start( this.ractive, true );\n\t  \tif ( here.owner && here.owner._link ) here.owner.unlink();\n\t  \trunloop.end();\n\t  \treturn promise;\n\t  }\n\t\n\t  function unshift ( keypath ) {\n\t  \tvar add = [], len = arguments.length - 1;\n\t  \twhile ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];\n\t\n\t  \treturn modelUnshift( findModel( this, keypath ).model, add );\n\t  }\n\t\n\t  function update$1 ( keypath ) {\n\t  \treturn update$2( this.ractive, findModel( this, keypath ).model );\n\t  }\n\t\n\t  function updateModel ( keypath, cascade ) {\n\t  \tvar ref = findModel( this, keypath ), model = ref.model;\n\t  \tvar promise = runloop.start( this.ractive, true );\n\t  \tmodel.updateFromBindings( cascade );\n\t  \trunloop.end();\n\t  \treturn promise;\n\t  }\n\t\n\t  // two-way binding related helpers\n\t  function isBound () {\n\t  \tvar ref = getBindingModel( this ), model = ref.model;\n\t  \treturn !!model;\n\t  }\n\t\n\t  function getBindingPath ( ractive ) {\n\t  \tvar ref = getBindingModel( this ), model = ref.model, instance = ref.instance;\n\t  \tif ( model ) return model.getKeypath( ractive || instance );\n\t  }\n\t\n\t  function getBinding () {\n\t  \tvar ref = getBindingModel( this ), model = ref.model;\n\t  \tif ( model ) return model.get( true );\n\t  }\n\t\n\t  function getBindingModel ( ctx ) {\n\t  \tvar el = ctx._element;\n\t  \treturn { model: el.binding && el.binding.model, instance: el.parentFragment.ractive };\n\t  }\n\t\n\t  function setBinding ( value ) {\n\t  \tvar ref = getBindingModel( this ), model = ref.model;\n\t  \treturn set( this.ractive, [ [ model, value ] ] );\n\t  }\n\t\n\t  // deprecated getters\n\t  function keypath () {\n\t  \twarnOnceIfDebug( (\"Object property keypath is deprecated, please use resolve() instead.\") );\n\t  \treturn this.resolve();\n\t  }\n\t\n\t  function rootpath () {\n\t  \twarnOnceIfDebug( (\"Object property rootpath is deprecated, please use resolve( ractive.root ) instead.\") );\n\t  \treturn this.resolve( this.ractive.root );\n\t  }\n\t\n\t  function context () {\n\t  \twarnOnceIfDebug( (\"Object property context is deprecated, please use get() instead.\") );\n\t  \treturn this.get();\n\t  }\n\t\n\t  function index () {\n\t  \twarnOnceIfDebug( (\"Object property index is deprecated, you can use get( \\\"indexName\\\" ) instead.\") );\n\t  \treturn gatherRefs( this._element.parentFragment ).index;\n\t  }\n\t\n\t  function key () {\n\t  \twarnOnceIfDebug( (\"Object property key is deprecated, you can use get( \\\"keyName\\\" ) instead.\") );\n\t  \treturn gatherRefs( this._element.parentFragment ).key;\n\t  }\n\t\n\t  function addHelpers ( obj, element ) {\n\t  \tdefineProperties( obj, {\n\t  \t\t_element: { value: element },\n\t  \t\tractive: { value: element.parentFragment.ractive },\n\t  \t\tresolve: { value: resolve$1 },\n\t  \t\tget: { value: get },\n\t\n\t  \t\tadd: { value: add$1 },\n\t  \t\tanimate: { value: animate },\n\t  \t\tlink: { value: link },\n\t  \t\tmerge: { value: merge },\n\t  \t\tpop: { value: pop },\n\t  \t\tpush: { value: push },\n\t  \t\treverse: { value: reverse },\n\t  \t\tset: { value: set$1 },\n\t  \t\tshift: { value: shift },\n\t  \t\tsort: { value: sort },\n\t  \t\tsplice: { value: splice },\n\t  \t\tsubtract: { value: subtract },\n\t  \t\ttoggle: { value: toggle },\n\t  \t\tunlink: { value: unlink },\n\t  \t\tunshift: { value: unshift },\n\t  \t\tupdate: { value: update$1 },\n\t  \t\tupdateModel: { value: updateModel },\n\t\n\t  \t\tisBound: { value: isBound },\n\t  \t\tgetBindingPath: { value: getBindingPath },\n\t  \t\tgetBinding: { value: getBinding },\n\t  \t\tsetBinding: { value: setBinding },\n\t\n\t  \t\tkeypath: { get: keypath },\n\t  \t\trootpath: { get: rootpath },\n\t  \t\tcontext: { get: context },\n\t  \t\tindex: { get: index },\n\t  \t\tkey: { get: key }\n\t  \t});\n\t\n\t  \treturn obj;\n\t  }\n\t\n\t  var query = doc && doc.querySelector;\n\t\n\t  function staticInfo( node ) {\n\t  \tif ( typeof node === 'string' && query ) {\n\t  \t\tnode = query.call( document, node );\n\t  \t}\n\t\n\t  \tif ( !node || !node._ractive ) return {};\n\t\n\t  \tvar storage = node._ractive;\n\t\n\t  \treturn addHelpers( {}, storage.proxy );\n\t  }\n\t\n\t  function getNodeInfo( node ) {\n\t  \tif ( typeof node === 'string' ) {\n\t  \t\tnode = this.find( node );\n\t  \t}\n\t\n\t  \treturn staticInfo( node );\n\t  }\n\t\n\t  var insertHook = new Hook( 'insert' );\n\t\n\t  function Ractive$insert ( target, anchor ) {\n\t  \tif ( !this.fragment.rendered ) {\n\t  \t\t// TODO create, and link to, documentation explaining this\n\t  \t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n\t  \t}\n\t\n\t  \ttarget = getElement( target );\n\t  \tanchor = getElement( anchor ) || null;\n\t\n\t  \tif ( !target ) {\n\t  \t\tthrow new Error( 'You must specify a valid target to insert into' );\n\t  \t}\n\t\n\t  \ttarget.insertBefore( this.detach(), anchor );\n\t  \tthis.el = target;\n\t\n\t  \t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n\t  \tthis.isDetached = false;\n\t\n\t  \tfireInsertHook( this );\n\t  }\n\t\n\t  function fireInsertHook( ractive ) {\n\t  \tinsertHook.fire( ractive );\n\t\n\t  \tractive.findAllComponents('*').forEach( function ( child ) {\n\t  \t\tfireInsertHook( child.instance );\n\t  \t});\n\t  }\n\t\n\t  function link$1( there, here ) {\n\t  \tif ( here === there || (there + '.').indexOf( here + '.' ) === 0 || (here + '.').indexOf( there + '.' ) === 0 ) {\n\t  \t\tthrow new Error( 'A keypath cannot be linked to itself.' );\n\t  \t}\n\t\n\t  \tvar promise = runloop.start();\n\t  \tvar model;\n\t\n\t  \t// may need to allow a mapping to resolve implicitly\n\t  \tvar sourcePath = splitKeypathI( there );\n\t  \tif ( !this.viewmodel.has( sourcePath[0] ) && this.component ) {\n\t  \t\tmodel = resolveReference( this.component.parentFragment, sourcePath[0] );\n\t  \t\tmodel = model.joinAll( sourcePath.slice( 1 ) );\n\t  \t}\n\t\n\t  \tthis.viewmodel.joinAll( splitKeypathI( here ) ).link( model || this.viewmodel.joinAll( sourcePath ), there );\n\t\n\t  \trunloop.end();\n\t\n\t  \treturn promise;\n\t  }\n\t\n\t  var ReferenceResolver = function ReferenceResolver ( fragment, reference, callback ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.fragment = fragment;\n\t  \tthis.reference = normalise( reference );\n\t  \tthis.callback = callback;\n\t\n\t  \tthis.keys = splitKeypathI( reference );\n\t  \tthis.resolved = false;\n\t\n\t  \tthis.contexts = [];\n\t\n\t  \t// TODO the consumer should take care of addUnresolved\n\t  \t// we attach to all the contexts between here and the root\n\t  \t// - whenever their values change, they can quickly\n\t  \t// check to see if we can resolve\n\t  \twhile ( fragment ) {\n\t  \t\tif ( fragment.context ) {\n\t  \t\t\tfragment.context.addUnresolved( this$1.keys[0], this$1 );\n\t  \t\t\tthis$1.contexts.push( fragment.context );\n\t  \t\t}\n\t\n\t  \t\tfragment = fragment.componentParent || fragment.parent;\n\t  \t}\n\t  };\n\t\n\t  ReferenceResolver.prototype.attemptResolution = function attemptResolution () {\n\t  \tif ( this.resolved ) return;\n\t\n\t  \tvar model = resolveAmbiguousReference( this.fragment, this.reference );\n\t\n\t  \tif ( model ) {\n\t  \t\tthis.resolved = true;\n\t  \t\tthis.callback( model );\n\t  \t}\n\t  };\n\t\n\t  ReferenceResolver.prototype.forceResolution = function forceResolution () {\n\t  \tif ( this.resolved ) return;\n\t\n\t  \tvar model = this.fragment.findContext().joinAll( this.keys );\n\t  \tthis.callback( model );\n\t  \tthis.resolved = true;\n\t  };\n\t\n\t  ReferenceResolver.prototype.rebinding = function rebinding ( next, previous ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( previous ) previous.removeUnresolved( this.keys[0], this );\n\t  \tif ( next ) runloop.scheduleTask( function () { return next.addUnresolved( this$1.keys[0], this$1 ); } );\n\t  };\n\t\n\t  ReferenceResolver.prototype.unbind = function unbind () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( this.fragment ) removeFromArray( this.fragment.unresolved, this );\n\t\n\t  \tif ( this.resolved ) return;\n\t\n\t  \tthis.contexts.forEach( function ( c ) { return c.removeUnresolved( this$1.keys[0], this$1 ); } );\n\t  };\n\t\n\t  function observe ( keypath, callback, options ) {\n\t  \tvar this$1 = this;\n\t\n\t  \tvar observers = [];\n\t  \tvar map;\n\t\n\t  \tif ( isObject( keypath ) ) {\n\t  \t\tmap = keypath;\n\t  \t\toptions = callback || {};\n\t\n\t  \t\tObject.keys( map ).forEach( function ( keypath ) {\n\t  \t\t\tvar callback = map[ keypath ];\n\t\n\t  \t\t\tvar keypaths = keypath.split( ' ' );\n\t  \t\t\tif ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );\n\t\n\t  \t\t\tkeypaths.forEach( function ( keypath ) {\n\t  \t\t\t\tobservers.push( createObserver( this$1, keypath, callback, options ) );\n\t  \t\t\t});\n\t  \t\t});\n\t  \t}\n\t\n\t  \telse {\n\t  \t\tvar keypaths;\n\t\n\t  \t\tif ( typeof keypath === 'function' ) {\n\t  \t\t\toptions = callback;\n\t  \t\t\tcallback = keypath;\n\t  \t\t\tkeypaths = [ '' ];\n\t  \t\t} else {\n\t  \t\t\tkeypaths = keypath.split( ' ' );\n\t  \t\t}\n\t\n\t  \t\tif ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );\n\t\n\t  \t\tkeypaths.forEach( function ( keypath ) {\n\t  \t\t\tobservers.push( createObserver( this$1, keypath, callback, options || {} ) );\n\t  \t\t});\n\t  \t}\n\t\n\t  \t// add observers to the Ractive instance, so they can be\n\t  \t// cancelled on ractive.teardown()\n\t  \tthis._observers.push.apply( this._observers, observers );\n\t\n\t  \treturn {\n\t  \t\tcancel: function () {\n\t  \t\t\tobservers.forEach( function ( observer ) {\n\t  \t\t\t\tremoveFromArray ( this$1._observers, observer );\n\t  \t\t\t\tobserver.cancel();\n\t  \t\t\t} );\n\t  \t\t}\n\t  \t};\n\t  }\n\t\n\t  function createObserver ( ractive, keypath, callback, options ) {\n\t  \tvar viewmodel = ractive.viewmodel;\n\t\n\t  \tvar keys = splitKeypathI( keypath );\n\t  \tvar wildcardIndex = keys.indexOf( '*' );\n\t  \toptions.keypath = keypath;\n\t\n\t  \t// normal keypath - no wildcards\n\t  \tif ( !~wildcardIndex ) {\n\t  \t\tvar key = keys[0];\n\t  \t\tvar model;\n\t\n\t  \t\t// if not the root model itself, check if viewmodel has key.\n\t  \t\tif ( key !== '' && !viewmodel.has( key ) ) {\n\t  \t\t\t// if this is an inline component, we may need to create an implicit mapping\n\t  \t\t\tif ( ractive.component && !ractive.isolated ) {\n\t  \t\t\t\tmodel = resolveReference( ractive.component.parentFragment, key );\n\t  \t\t\t\tif ( model ) {\n\t  \t\t\t\t\tviewmodel.map( key, model );\n\t  \t\t\t\t\tmodel = viewmodel.joinAll( keys );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t} else {\n\t  \t\t\tmodel = viewmodel.joinAll( keys );\n\t  \t\t}\n\t\n\t  \t\treturn new Observer( ractive, model, callback, options );\n\t  \t}\n\t\n\t  \t// pattern observers - more complex case\n\t  \tvar baseModel = wildcardIndex === 0 ?\n\t  \t\tviewmodel :\n\t  \t\tviewmodel.joinAll( keys.slice( 0, wildcardIndex ) );\n\t\n\t  \treturn new PatternObserver( ractive, baseModel, keys.splice( wildcardIndex ), callback, options );\n\t  }\n\t\n\t  var Observer = function Observer ( ractive, model, callback, options ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.context = options.context || ractive;\n\t  \tthis.callback = callback;\n\t  \tthis.ractive = ractive;\n\t\n\t  \tif ( model ) this.resolved( model );\n\t  \telse {\n\t  \t\tthis.keypath = options.keypath;\n\t  \t\tthis.resolver = new ReferenceResolver( ractive.fragment, options.keypath, function ( model ) {\n\t  \t\t\tthis$1.resolved( model );\n\t  \t\t});\n\t  \t}\n\t\n\t  \tif ( options.init !== false ) {\n\t  \t\tthis.dirty = true;\n\t  \t\tthis.dispatch();\n\t  \t} else {\n\t  \t\tthis.oldValue = this.newValue;\n\t  \t}\n\t\n\t  \tthis.defer = options.defer;\n\t  \tthis.once = options.once;\n\t  \tthis.strict = options.strict;\n\t\n\t  \tthis.dirty = false;\n\t  };\n\t\n\t  Observer.prototype.cancel = function cancel () {\n\t  \tthis.cancelled = true;\n\t  \tif ( this.model ) {\n\t  \t\tthis.model.unregister( this );\n\t  \t} else {\n\t  \t\tthis.resolver.unbind();\n\t  \t}\n\t  };\n\t\n\t  Observer.prototype.dispatch = function dispatch () {\n\t  \tif ( !this.cancelled ) {\n\t  \t\tthis.callback.call( this.context, this.newValue, this.oldValue, this.keypath );\n\t  \t\tthis.oldValue = this.model ? this.model.get() : this.newValue;\n\t  \t\tthis.dirty = false;\n\t  \t}\n\t  };\n\t\n\t  Observer.prototype.handleChange = function handleChange () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( !this.dirty ) {\n\t  \t\tvar newValue = this.model.get();\n\t  \t\tif ( isEqual( newValue, this.oldValue ) ) return;\n\t\n\t  \t\tthis.newValue = newValue;\n\t\n\t  \t\tif ( this.strict && this.newValue === this.oldValue ) return;\n\t\n\t  \t\trunloop.addObserver( this, this.defer );\n\t  \t\tthis.dirty = true;\n\t\n\t  \t\tif ( this.once ) runloop.scheduleTask( function () { return this$1.cancel(); } );\n\t  \t}\n\t  };\n\t\n\t  Observer.prototype.rebinding = function rebinding ( next, previous ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tnext = rebindMatch( this.keypath, next, previous );\n\t  \t// TODO: set up a resolver if next is undefined?\n\t  \tif ( next === this.model ) return false;\n\t\n\t  \tif ( this.model ) this.model.unregister( this );\n\t  \tif ( next ) next.addShuffleTask( function () { return this$1.resolved( next ); } );\n\t  };\n\t\n\t  Observer.prototype.resolved = function resolved ( model ) {\n\t  \tthis.model = model;\n\t  \tthis.keypath = model.getKeypath( this.ractive );\n\t\n\t  \tthis.oldValue = undefined;\n\t  \tthis.newValue = model.get();\n\t\n\t  \tmodel.register( this );\n\t  };\n\t\n\t  var PatternObserver = function PatternObserver ( ractive, baseModel, keys, callback, options ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.context = options.context || ractive;\n\t  \tthis.ractive = ractive;\n\t  \tthis.baseModel = baseModel;\n\t  \tthis.keys = keys;\n\t  \tthis.callback = callback;\n\t\n\t  \tvar pattern = keys.join( '\\\\.' ).replace( /\\*/g, '(.+)' );\n\t  \tvar baseKeypath = baseModel.getKeypath( ractive );\n\t  \tthis.pattern = new RegExp( (\"^\" + (baseKeypath ? baseKeypath + '\\\\.' : '') + \"\" + pattern + \"$\") );\n\t\n\t  \tthis.oldValues = {};\n\t  \tthis.newValues = {};\n\t\n\t  \tthis.defer = options.defer;\n\t  \tthis.once = options.once;\n\t  \tthis.strict = options.strict;\n\t\n\t  \tthis.dirty = false;\n\t  \tthis.changed = [];\n\t  \tthis.partial = false;\n\t\n\t  \tvar models = baseModel.findMatches( this.keys );\n\t\n\t  \tmodels.forEach( function ( model ) {\n\t  \t\tthis$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();\n\t  \t});\n\t\n\t  \tif ( options.init !== false ) {\n\t  \t\tthis.dispatch();\n\t  \t} else {\n\t  \t\tthis.oldValues = this.newValues;\n\t  \t}\n\t\n\t  \tbaseModel.registerPatternObserver( this );\n\t  };\n\t\n\t  PatternObserver.prototype.cancel = function cancel () {\n\t  \tthis.baseModel.unregisterPatternObserver( this );\n\t  };\n\t\n\t  PatternObserver.prototype.dispatch = function dispatch () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tObject.keys( this.newValues ).forEach( function ( keypath ) {\n\t  \t\tif ( this$1.newKeys && !this$1.newKeys[ keypath ] ) return;\n\t\n\t  \t\tvar newValue = this$1.newValues[ keypath ];\n\t  \t\tvar oldValue = this$1.oldValues[ keypath ];\n\t\n\t  \t\tif ( this$1.strict && newValue === oldValue ) return;\n\t  \t\tif ( isEqual( newValue, oldValue ) ) return;\n\t\n\t  \t\tvar args = [ newValue, oldValue, keypath ];\n\t  \t\tif ( keypath ) {\n\t  \t\t\tvar wildcards = this$1.pattern.exec( keypath );\n\t  \t\t\tif ( wildcards ) {\n\t  \t\t\t\targs = args.concat( wildcards.slice( 1 ) );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tthis$1.callback.apply( this$1.context, args );\n\t  \t});\n\t\n\t  \tif ( this.partial ) {\n\t  \t\tfor ( var k in this.newValues ) {\n\t  \t\t\tthis.oldValues[k] = this.newValues[k];\n\t  \t\t}\n\t  \t} else {\n\t  \t\tthis.oldValues = this.newValues;\n\t  \t}\n\t\n\t  \tthis.newKeys = null;\n\t  \tthis.dirty = false;\n\t  };\n\t\n\t  PatternObserver.prototype.notify = function notify ( key ) {\n\t  \tthis.changed.push( key );\n\t  };\n\t\n\t  PatternObserver.prototype.shuffle = function shuffle ( newIndices ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( !isArray( this.baseModel.value ) ) return;\n\t\n\t  \tvar base = this.baseModel.getKeypath( this.ractive );\n\t  \tvar max = this.baseModel.value.length;\n\t  \tvar suffix = this.keys.length > 1 ? '.' + this.keys.slice( 1 ).join( '.' ) : '';\n\t\n\t  \tthis.newKeys = {};\n\t  \tfor ( var i = 0; i < newIndices.length; i++ ) {\n\t  \t\tif ( newIndices[ i ] === -1 || newIndices[ i ] === i ) continue;\n\t  \t\tthis$1.newKeys[ (\"\" + base + \".\" + i + \"\" + suffix) ] = true;\n\t  \t}\n\t\n\t  \tfor ( var i$1 = newIndices.touchedFrom; i$1 < max; i$1++ ) {\n\t  \t\tthis$1.newKeys[ (\"\" + base + \".\" + i$1 + \"\" + suffix) ] = true;\n\t  \t}\n\t  };\n\t\n\t  PatternObserver.prototype.handleChange = function handleChange () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( !this.dirty || this.changed.length ) {\n\t  \t\tif ( !this.dirty ) this.newValues = {};\n\t\n\t  \t\t// handle case where previously extant keypath no longer exists -\n\t  \t\t// observer should still fire, with undefined as new value\n\t  \t\t// TODO huh. according to the test suite that's not the case...\n\t  \t\t// NOTE: I don't think this will work with partial updates\n\t  \t\t// Object.keys( this.oldValues ).forEach( keypath => {\n\t  \t\t// this.newValues[ keypath ] = undefined;\n\t  \t\t// });\n\t\n\t  \t\tif ( !this.changed.length ) {\n\t  \t\t\tthis.baseModel.findMatches( this.keys ).forEach( function ( model ) {\n\t  \t\t\t\tvar keypath = model.getKeypath( this$1.ractive );\n\t  \t\t\t\tthis$1.newValues[ keypath ] = model.get();\n\t  \t\t\t});\n\t  \t\t\tthis.partial = false;\n\t  \t\t} else {\n\t  \t\t\tvar count = 0;\n\t  \t\t\tvar ok = this.baseModel.isRoot ?\n\t  \t\t\t\tthis.changed.map( function ( keys ) { return keys.map( escapeKey ).join( '.' ); } ) :\n\t  \t\t\t\tthis.changed.map( function ( keys ) { return this$1.baseModel.getKeypath( this$1.ractive ) + '.' + keys.map( escapeKey ).join( '.' ); } );\n\t\n\t  \t\t\tthis.baseModel.findMatches( this.keys ).forEach( function ( model ) {\n\t  \t\t\t\tvar keypath = model.getKeypath( this$1.ractive );\n\t  \t\t\t\t// is this model on a changed keypath?\n\t  \t\t\t\tif ( ok.filter( function ( k ) { return keypath.indexOf( k ) === 0 || k.indexOf( keypath ) === 0; } ).length ) {\n\t  \t\t\t\t\tcount++;\n\t  \t\t\t\t\tthis$1.newValues[ keypath ] = model.get();\n\t  \t\t\t\t}\n\t  \t\t\t});\n\t\n\t  \t\t\t// no valid change triggered, so bail to avoid breakage\n\t  \t\t\tif ( !count ) return;\n\t\n\t  \t\t\tthis.partial = true;\n\t  \t\t}\n\t\n\t  \t\trunloop.addObserver( this, this.defer );\n\t  \t\tthis.dirty = true;\n\t  \t\tthis.changed.length = 0;\n\t\n\t  \t\tif ( this.once ) this.cancel();\n\t  \t}\n\t  };\n\t\n\t  function observeList ( keypath, callback, options ) {\n\t  \tif ( typeof keypath !== 'string' ) {\n\t  \t\tthrow new Error( 'ractive.observeList() must be passed a string as its first argument' );\n\t  \t}\n\t\n\t  \tvar model = this.viewmodel.joinAll( splitKeypathI( keypath ) );\n\t  \tvar observer = new ListObserver( this, model, callback, options || {} );\n\t\n\t  \t// add observer to the Ractive instance, so it can be\n\t  \t// cancelled on ractive.teardown()\n\t  \tthis._observers.push( observer );\n\t\n\t  \treturn {\n\t  \t\tcancel: function () {\n\t  \t\t\tobserver.cancel();\n\t  \t\t}\n\t  \t};\n\t  }\n\t\n\t  function negativeOne () {\n\t  \treturn -1;\n\t  }\n\t\n\t  var ListObserver = function ListObserver ( context, model, callback, options ) {\n\t  \tthis.context = context;\n\t  \tthis.model = model;\n\t  \tthis.keypath = model.getKeypath();\n\t  \tthis.callback = callback;\n\t\n\t  \tthis.pending = null;\n\t\n\t  \tmodel.register( this );\n\t\n\t  \tif ( options.init !== false ) {\n\t  \t\tthis.sliced = [];\n\t  \t\tthis.shuffle([]);\n\t  \t\tthis.handleChange();\n\t  \t} else {\n\t  \t\tthis.sliced = this.slice();\n\t  \t}\n\t  };\n\t\n\t  ListObserver.prototype.handleChange = function handleChange () {\n\t  \tif ( this.pending ) {\n\t  \t\t// post-shuffle\n\t  \t\tthis.callback( this.pending );\n\t  \t\tthis.pending = null;\n\t  \t}\n\t\n\t  \telse {\n\t  \t\t// entire array changed\n\t  \t\tthis.shuffle( this.sliced.map( negativeOne ) );\n\t  \t\tthis.handleChange();\n\t  \t}\n\t  };\n\t\n\t  ListObserver.prototype.shuffle = function shuffle ( newIndices ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar newValue = this.slice();\n\t\n\t  \tvar inserted = [];\n\t  \tvar deleted = [];\n\t  \tvar start;\n\t\n\t  \tvar hadIndex = {};\n\t\n\t  \tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t  \t\thadIndex[ newIndex ] = true;\n\t\n\t  \t\tif ( newIndex !== oldIndex && start === undefined ) {\n\t  \t\t\tstart = oldIndex;\n\t  \t\t}\n\t\n\t  \t\tif ( newIndex === -1 ) {\n\t  \t\t\tdeleted.push( this$1.sliced[ oldIndex ] );\n\t  \t\t}\n\t  \t});\n\t\n\t  \tif ( start === undefined ) start = newIndices.length;\n\t\n\t  \tvar len = newValue.length;\n\t  \tfor ( var i = 0; i < len; i += 1 ) {\n\t  \t\tif ( !hadIndex[i] ) inserted.push( newValue[i] );\n\t  \t}\n\t\n\t  \tthis.pending = { inserted: inserted, deleted: deleted, start: start };\n\t  \tthis.sliced = newValue;\n\t  };\n\t\n\t  ListObserver.prototype.slice = function slice () {\n\t  \tvar value = this.model.get();\n\t  \treturn isArray( value ) ? value.slice() : [];\n\t  };\n\t\n\t  var onceOptions = { init: false, once: true };\n\t\n\t  function observeOnce ( keypath, callback, options ) {\n\t  \tif ( isObject( keypath ) || typeof keypath === 'function' ) {\n\t  \t\toptions = extendObj( callback || {}, onceOptions );\n\t  \t\treturn this.observe( keypath, options );\n\t  \t}\n\t\n\t  \toptions = extendObj( options || {}, onceOptions );\n\t  \treturn this.observe( keypath, callback, options );\n\t  }\n\t\n\t  function trim ( str ) { return str.trim(); };\n\t\n\t  function notEmptyString ( str ) { return str !== ''; };\n\t\n\t  function Ractive$off ( eventName, callback ) {\n\t  \t// if no arguments specified, remove all callbacks\n\t  \tvar this$1 = this;\n\t\n\t  \tif ( !eventName ) {\n\t  \t\t// TODO use this code instead, once the following issue has been resolved\n\t  \t\t// in PhantomJS (tests are unpassable otherwise!)\n\t  \t\t// https://github.com/ariya/phantomjs/issues/11856\n\t  \t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n\t  \t\tfor ( eventName in this._subs ) {\n\t  \t\t\tdelete this._subs[ eventName ];\n\t  \t\t}\n\t  \t}\n\t\n\t  \telse {\n\t  \t\t// Handle multiple space-separated event names\n\t  \t\tvar eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\n\t  \t\teventNames.forEach( function ( eventName ) {\n\t  \t\t\tvar subscribers = this$1._subs[ eventName ];\n\t\n\t  \t\t\t// If we have subscribers for this event...\n\t  \t\t\tif ( subscribers ) {\n\t  \t\t\t\t// ...if a callback was specified, only remove that\n\t  \t\t\t\tif ( callback ) {\n\t  \t\t\t\t\t// flag this callback as off so that any in-flight firings don't call\n\t  \t\t\t\t\t// a cancelled handler - this is _slightly_ hacky\n\t  \t\t\t\t\tcallback.off = true;\n\t  \t\t\t\t\tvar index = subscribers.indexOf( callback );\n\t  \t\t\t\t\tif ( index !== -1 ) {\n\t  \t\t\t\t\t\tsubscribers.splice( index, 1 );\n\t  \t\t\t\t\t}\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\t// ...otherwise remove all callbacks\n\t  \t\t\t\telse {\n\t  \t\t\t\t\tthis$1._subs[ eventName ] = [];\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t});\n\t  \t}\n\t\n\t  \treturn this;\n\t  }\n\t\n\t  function Ractive$on ( eventName, callback ) {\n\t  \t// allow multiple listeners to be bound in one go\n\t  \tvar this$1 = this;\n\t\n\t  \tif ( typeof eventName === 'object' ) {\n\t  \t\tvar listeners = [];\n\t  \t\tvar n;\n\t\n\t  \t\tfor ( n in eventName ) {\n\t  \t\t\tif ( eventName.hasOwnProperty( n ) ) {\n\t  \t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn {\n\t  \t\t\tcancel: function () {\n\t  \t\t\t\tvar listener;\n\t  \t\t\t\twhile ( listener = listeners.pop() ) listener.cancel();\n\t  \t\t\t}\n\t  \t\t};\n\t  \t}\n\t\n\t  \t// Handle multiple space-separated event names\n\t  \tvar eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\t\n\t  \teventNames.forEach( function ( eventName ) {\n\t  \t\t( this$1._subs[ eventName ] || ( this$1._subs[ eventName ] = [] ) ).push( callback );\n\t  \t});\n\t\n\t  \treturn {\n\t  \t\tcancel: function () { return this$1.off( eventName, callback ); }\n\t  \t};\n\t  }\n\t\n\t  function Ractive$once ( eventName, handler ) {\n\t  \tvar listener = this.on( eventName, function () {\n\t  \t\thandler.apply( this, arguments );\n\t  \t\tlistener.cancel();\n\t  \t});\n\t\n\t  \t// so we can still do listener.cancel() manually\n\t  \treturn listener;\n\t  }\n\t\n\t  var pop$1 = makeArrayMethod( 'pop' ).path;\n\t\n\t  var push$1 = makeArrayMethod( 'push' ).path;\n\t\n\t  var PREFIX = '/* Ractive.js component styles */';\n\t\n\t  // Holds current definitions of styles.\n\t  var styleDefinitions = [];\n\t\n\t  // Flag to tell if we need to update the CSS\n\t  var isDirty = false;\n\t\n\t  // These only make sense on the browser. See additional setup below.\n\t  var styleElement = null;\n\t  var useCssText = null;\n\t\n\t  function addCSS( styleDefinition ) {\n\t  \tstyleDefinitions.push( styleDefinition );\n\t  \tisDirty = true;\n\t  }\n\t\n\t  function applyCSS() {\n\t\n\t  \t// Apply only seems to make sense when we're in the DOM. Server-side renders\n\t  \t// can call toCSS to get the updated CSS.\n\t  \tif ( !doc || !isDirty ) return;\n\t\n\t  \tif ( useCssText ) {\n\t  \t\tstyleElement.styleSheet.cssText = getCSS( null );\n\t  \t} else {\n\t  \t\tstyleElement.innerHTML = getCSS( null );\n\t  \t}\n\t\n\t  \tisDirty = false;\n\t  }\n\t\n\t  function getCSS( cssIds ) {\n\t\n\t  \tvar filteredStyleDefinitions = cssIds ? styleDefinitions.filter( function ( style ) { return ~cssIds.indexOf( style.id ); } ) : styleDefinitions;\n\t\n\t  \treturn filteredStyleDefinitions.reduce( function ( styles, style ) { return (\"\" + styles + \"\\n\\n/* {\" + (style.id) + \"} */\\n\" + (style.styles)); }, PREFIX );\n\t\n\t  }\n\t\n\t  // If we're on the browser, additional setup needed.\n\t  if ( doc && ( !styleElement || !styleElement.parentNode ) ) {\n\t\n\t  \tstyleElement = doc.createElement( 'style' );\n\t  \tstyleElement.type = 'text/css';\n\t\n\t  \tdoc.getElementsByTagName( 'head' )[ 0 ].appendChild( styleElement );\n\t\n\t  \tuseCssText = !!styleElement.styleSheet;\n\t  }\n\t\n\t  var renderHook = new Hook( 'render' );\n\t  var completeHook = new Hook( 'complete' );\n\t\n\t  function render$1 ( ractive, target, anchor, occupants ) {\n\t  \t// if `noIntro` is `true`, temporarily disable transitions\n\t  \tvar transitionsEnabled = ractive.transitionsEnabled;\n\t  \tif ( ractive.noIntro ) ractive.transitionsEnabled = false;\n\t\n\t  \tvar promise = runloop.start( ractive, true );\n\t  \trunloop.scheduleTask( function () { return renderHook.fire( ractive ); }, true );\n\t\n\t  \tif ( ractive.fragment.rendered ) {\n\t  \t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n\t  \t}\n\t\n\t  \tanchor = getElement( anchor ) || ractive.anchor;\n\t\n\t  \tractive.el = target;\n\t  \tractive.anchor = anchor;\n\t\n\t  \t// ensure encapsulated CSS is up-to-date\n\t  \tif ( ractive.cssId ) applyCSS();\n\t\n\t  \tif ( target ) {\n\t  \t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( ractive );\n\t\n\t  \t\tif ( anchor ) {\n\t  \t\t\tvar docFrag = doc.createDocumentFragment();\n\t  \t\t\tractive.fragment.render( docFrag );\n\t  \t\t\ttarget.insertBefore( docFrag, anchor );\n\t  \t\t} else {\n\t  \t\t\tractive.fragment.render( target, occupants );\n\t  \t\t}\n\t  \t}\n\t\n\t  \trunloop.end();\n\t  \tractive.transitionsEnabled = transitionsEnabled;\n\t\n\t  \treturn promise.then( function () { return completeHook.fire( ractive ); } );\n\t  }\n\t\n\t  function Ractive$render ( target, anchor ) {\n\t  \tif ( this.torndown ) {\n\t  \t\twarnIfDebug( 'ractive.render() was called on a Ractive instance that was already torn down' );\n\t  \t\treturn Promise.resolve();\n\t  \t}\n\t\n\t  \ttarget = getElement( target ) || this.el;\n\t\n\t  \tif ( !this.append && target ) {\n\t  \t\t// Teardown any existing instances *before* trying to set up the new one -\n\t  \t\t// avoids certain weird bugs\n\t  \t\tvar others = target.__ractive_instances__;\n\t  \t\tif ( others ) others.forEach( teardown );\n\t\n\t  \t\t// make sure we are the only occupants\n\t  \t\tif ( !this.enhance ) {\n\t  \t\t\ttarget.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n\t  \t\t}\n\t  \t}\n\t\n\t  \tvar occupants = this.enhance ? toArray( target.childNodes ) : null;\n\t  \tvar promise = render$1( this, target, anchor, occupants );\n\t\n\t  \tif ( occupants ) {\n\t  \t\twhile ( occupants.length ) target.removeChild( occupants.pop() );\n\t  \t}\n\t\n\t  \treturn promise;\n\t  }\n\t\n\t  var adaptConfigurator = {\n\t  \textend: function ( Parent, proto, options ) {\n\t  \t\tproto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );\n\t  \t},\n\t\n\t  \tinit: function () {}\n\t  };\n\t\n\t  function combine ( a, b ) {\n\t  \tvar c = a.slice();\n\t  \tvar i = b.length;\n\t\n\t  \twhile ( i-- ) {\n\t  \t\tif ( !~c.indexOf( b[i] ) ) {\n\t  \t\t\tc.push( b[i] );\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn c;\n\t  }\n\t\n\t  var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g;\n\t  var commentsPattern = /\\/\\*[\\s\\S]*?\\*\\//g;\n\t  var selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g;\n\t  var excludePattern = /^(?:@|\\d+%)/;\n\t  var dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\t\n\t  function trim$1 ( str ) {\n\t  \treturn str.trim();\n\t  }\n\t\n\t  function extractString ( unit ) {\n\t  \treturn unit.str;\n\t  }\n\t\n\t  function transformSelector ( selector, parent ) {\n\t  \tvar selectorUnits = [];\n\t  \tvar match;\n\t\n\t  \twhile ( match = selectorUnitPattern.exec( selector ) ) {\n\t  \t\tselectorUnits.push({\n\t  \t\t\tstr: match[0],\n\t  \t\t\tbase: match[1],\n\t  \t\t\tmodifiers: match[2]\n\t  \t\t});\n\t  \t}\n\t\n\t  \t// For each simple selector within the selector, we need to create a version\n\t  \t// that a) combines with the id, and b) is inside the id\n\t  \tvar base = selectorUnits.map( extractString );\n\t\n\t  \tvar transformed = [];\n\t  \tvar i = selectorUnits.length;\n\t\n\t  \twhile ( i-- ) {\n\t  \t\tvar appended = base.slice();\n\t\n\t  \t\t// Pseudo-selectors should go after the attribute selector\n\t  \t\tvar unit = selectorUnits[i];\n\t  \t\tappended[i] = unit.base + parent + unit.modifiers || '';\n\t\n\t  \t\tvar prepended = base.slice();\n\t  \t\tprepended[i] = parent + ' ' + prepended[i];\n\t\n\t  \t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n\t  \t}\n\t\n\t  \treturn transformed.join( ', ' );\n\t  }\n\t\n\t  function transformCss ( css, id ) {\n\t  \tvar dataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\t\n\t  \tvar transformed;\n\t\n\t  \tif ( dataRvcGuidPattern.test( css ) ) {\n\t  \t\ttransformed = css.replace( dataRvcGuidPattern, dataAttr );\n\t  \t} else {\n\t  \t\ttransformed = css\n\t  \t\t.replace( commentsPattern, '' )\n\t  \t\t.replace( selectorsPattern, function ( match, $1 ) {\n\t  \t\t\t// don't transform at-rules and keyframe declarations\n\t  \t\t\tif ( excludePattern.test( $1 ) ) return match;\n\t\n\t  \t\t\tvar selectors = $1.split( ',' ).map( trim$1 );\n\t  \t\t\tvar transformed = selectors\n\t  \t\t\t\t.map( function ( selector ) { return transformSelector( selector, dataAttr ); } )\n\t  \t\t\t\t.join( ', ' ) + ' ';\n\t\n\t  \t\t\treturn match.replace( $1, transformed );\n\t  \t\t});\n\t  \t}\n\t\n\t  \treturn transformed;\n\t  }\n\t\n\t  function s4() {\n\t  \treturn Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n\t  }\n\t\n\t  function uuid() {\n\t  \treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n\t  }\n\t\n\t  var cssConfigurator = {\n\t  \tname: 'css',\n\t\n\t  \t// Called when creating a new component definition\n\t  \textend: function ( Parent, proto, options ) {\n\t  \t\tif ( !options.css ) return;\n\t\n\t  \t\tvar id = uuid();\n\t  \t\tvar styles = options.noCssTransform ? options.css : transformCss( options.css, id );\n\t\n\t  \t\tproto.cssId = id;\n\t\n\t  \t\taddCSS( { id: id, styles: styles } );\n\t\n\t  \t},\n\t\n\t  \t// Called when creating a new component instance\n\t  \tinit: function ( Parent, target, options ) {\n\t  \t\tif ( !options.css ) return;\n\t\n\t  \t\twarnIfDebug( (\"\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\\t...\\n\\tcss: '/* your css */',\\n\\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\\t\\t\") );\n\t  \t}\n\t\n\t  };\n\t\n\t  function validate ( data ) {\n\t  \t// Warn if userOptions.data is a non-POJO\n\t  \tif ( data && data.constructor !== Object ) {\n\t  \t\tif ( typeof data === 'function' ) {\n\t  \t\t\t// TODO do we need to support this in the new Ractive() case?\n\t  \t\t} else if ( typeof data !== 'object' ) {\n\t  \t\t\tfatal( (\"data option must be an object or a function, `\" + data + \"` is not valid\") );\n\t  \t\t} else {\n\t  \t\t\twarnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var dataConfigurator = {\n\t  \tname: 'data',\n\t\n\t  \textend: function ( Parent, proto, options ) {\n\t  \t\tvar key;\n\t  \t\tvar value;\n\t\n\t  \t\t// check for non-primitives, which could cause mutation-related bugs\n\t  \t\tif ( options.data && isObject( options.data ) ) {\n\t  \t\t\tfor ( key in options.data ) {\n\t  \t\t\t\tvalue = options.data[ key ];\n\t\n\t  \t\t\t\tif ( value && typeof value === 'object' ) {\n\t  \t\t\t\t\tif ( isObject( value ) || isArray( value ) ) {\n\t  \t\t\t\t\t\twarnIfDebug( (\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\") );\n\t  \t\t\t\t\t}\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tproto.data = combine$1( proto.data, options.data );\n\t  \t},\n\t\n\t  \tinit: function ( Parent, ractive, options ) {\n\t  \t\tvar result = combine$1( Parent.prototype.data, options.data );\n\t\n\t  \t\tif ( typeof result === 'function' ) result = result.call( ractive );\n\t\n\t  \t\t// bind functions to the ractive instance at the top level,\n\t  \t\t// unless it's a non-POJO (in which case alarm bells should ring)\n\t  \t\tif ( result && result.constructor === Object ) {\n\t  \t\t\tfor ( var prop in result ) {\n\t  \t\t\t\tif ( typeof result[ prop ] === 'function' ) result[ prop ] = bind( result[ prop ], ractive );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn result || {};\n\t  \t},\n\t\n\t  \treset: function ( ractive ) {\n\t  \t\tvar result = this.init( ractive.constructor, ractive, ractive.viewmodel );\n\t  \t\tractive.viewmodel.root.set( result );\n\t  \t\treturn true;\n\t  \t}\n\t  };\n\t\n\t  function combine$1 ( parentValue, childValue ) {\n\t  \tvalidate( childValue );\n\t\n\t  \tvar parentIsFn = typeof parentValue === 'function';\n\t  \tvar childIsFn = typeof childValue === 'function';\n\t\n\t  \t// Very important, otherwise child instance can become\n\t  \t// the default data object on Ractive or a component.\n\t  \t// then ractive.set() ends up setting on the prototype!\n\t  \tif ( !childValue && !parentIsFn ) {\n\t  \t\tchildValue = {};\n\t  \t}\n\t\n\t  \t// Fast path, where we just need to copy properties from\n\t  \t// parent to child\n\t  \tif ( !parentIsFn && !childIsFn ) {\n\t  \t\treturn fromProperties( childValue, parentValue );\n\t  \t}\n\t\n\t  \treturn function () {\n\t  \t\tvar child = childIsFn ? callDataFunction( childValue, this ) : childValue;\n\t  \t\tvar parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;\n\t\n\t  \t\treturn fromProperties( child, parent );\n\t  \t};\n\t  }\n\t\n\t  function callDataFunction ( fn, context ) {\n\t  \tvar data = fn.call( context );\n\t\n\t  \tif ( !data ) return;\n\t\n\t  \tif ( typeof data !== 'object' ) {\n\t  \t\tfatal( 'Data function must return an object' );\n\t  \t}\n\t\n\t  \tif ( data.constructor !== Object ) {\n\t  \t\twarnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );\n\t  \t}\n\t\n\t  \treturn data;\n\t  }\n\t\n\t  function fromProperties ( primary, secondary ) {\n\t  \tif ( primary && secondary ) {\n\t  \t\tfor ( var key in secondary ) {\n\t  \t\t\tif ( !( key in primary ) ) {\n\t  \t\t\t\tprimary[ key ] = secondary[ key ];\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn primary;\n\t  \t}\n\t\n\t  \treturn primary || secondary;\n\t  }\n\t\n\t  var TEMPLATE_VERSION = 4;\n\t\n\t  var pattern = /\\$\\{([^\\}]+)\\}/g;\n\t\n\t  function fromExpression ( body, length ) {\n\t  \tif ( length === void 0 ) length = 0;\n\t\n\t  \tvar args = new Array( length );\n\t\n\t  \twhile ( length-- ) {\n\t  \t\targs[length] = \"_\" + length;\n\t  \t}\n\t\n\t  \t// Functions created directly with new Function() look like this:\n\t  \t//     function anonymous (_0 /**/) { return _0*2 }\n\t  \t//\n\t  \t// With this workaround, we get a little more compact:\n\t  \t//     function (_0){return _0*2}\n\t  \treturn new Function( [], (\"return function (\" + (args.join(',')) + \"){return(\" + body + \");};\") )();\n\t  }\n\t\n\t  function fromComputationString ( str, bindTo ) {\n\t  \tvar hasThis;\n\t\n\t  \tvar functionBody = 'return (' + str.replace( pattern, function ( match, keypath ) {\n\t  \t\thasThis = true;\n\t  \t\treturn (\"__ractive.get(\\\"\" + keypath + \"\\\")\");\n\t  \t}) + ');';\n\t\n\t  \tif ( hasThis ) functionBody = \"var __ractive = this; \" + functionBody;\n\t  \tvar fn = new Function( functionBody );\n\t  \treturn hasThis ? fn.bind( bindTo ) : fn;\n\t  }\n\t\n\t  var functions = create( null );\n\t\n\t  function getFunction ( str, i ) {\n\t  \tif ( functions[ str ] ) return functions[ str ];\n\t  \treturn functions[ str ] = createFunction( str, i );\n\t  }\n\t\n\t  function addFunctions( template ) {\n\t  \tif ( !template ) return;\n\t\n\t  \tvar exp = template.e;\n\t\n\t  \tif ( !exp ) return;\n\t\n\t  \tObject.keys( exp ).forEach( function ( str ) {\n\t  \t\tif ( functions[ str ] ) return;\n\t  \t\tfunctions[ str ] = exp[ str ];\n\t  \t});\n\t  }\n\t\n\t  var Parser;\n\t  var ParseError;\n\t  var leadingWhitespace = /^\\s+/;\n\t  ParseError = function ( message ) {\n\t  \tthis.name = 'ParseError';\n\t  \tthis.message = message;\n\t  \ttry {\n\t  \t\tthrow new Error(message);\n\t  \t} catch (e) {\n\t  \t\tthis.stack = e.stack;\n\t  \t}\n\t  };\n\t\n\t  ParseError.prototype = Error.prototype;\n\t\n\t  Parser = function ( str, options ) {\n\t  \tvar this$1 = this;\n\t\n\t  \tvar items, item, lineStart = 0;\n\t\n\t  \tthis.str = str;\n\t  \tthis.options = options || {};\n\t  \tthis.pos = 0;\n\t\n\t  \tthis.lines = this.str.split( '\\n' );\n\t  \tthis.lineEnds = this.lines.map( function ( line ) {\n\t  \t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\t\n\t  \t\tlineStart = lineEnd;\n\t  \t\treturn lineEnd;\n\t  \t}, 0 );\n\t\n\t  \t// Custom init logic\n\t  \tif ( this.init ) this.init( str, options );\n\t\n\t  \titems = [];\n\t\n\t  \twhile ( ( this$1.pos < this$1.str.length ) && ( item = this$1.read() ) ) {\n\t  \t\titems.push( item );\n\t  \t}\n\t\n\t  \tthis.leftover = this.remaining();\n\t  \tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n\t  };\n\t\n\t  Parser.prototype = {\n\t  \tread: function ( converters ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar pos, i, len, item;\n\t\n\t  \t\tif ( !converters ) converters = this.converters;\n\t\n\t  \t\tpos = this.pos;\n\t\n\t  \t\tlen = converters.length;\n\t  \t\tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\t\tthis$1.pos = pos; // reset for each attempt\n\t\n\t  \t\t\tif ( item = converters[i]( this$1 ) ) {\n\t  \t\t\t\treturn item;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn null;\n\t  \t},\n\t\n\t  \tgetContextMessage: function ( pos, message ) {\n\t  \t\tvar ref = this.getLinePos( pos ), lineNum = ref[0], columnNum = ref[1];\n\t  \t\tif ( this.options.contextLines === -1 ) {\n\t  \t\t\treturn [ lineNum, columnNum, (\"\" + message + \" at line \" + lineNum + \" character \" + columnNum) ];\n\t  \t\t}\n\t\n\t  \t\tvar line = this.lines[ lineNum - 1 ];\n\t\n\t  \t\tvar contextUp = '';\n\t  \t\tvar contextDown = '';\n\t  \t\tif ( this.options.contextLines ) {\n\t  \t\t\tvar start = lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;\n\t  \t\t\tcontextUp = this.lines.slice( start, lineNum - 1 - start ).join( '\\n' ).replace( /\\t/g, '  ' );\n\t  \t\t\tcontextDown = this.lines.slice( lineNum, lineNum + this.options.contextLines ).join( '\\n' ).replace( /\\t/g, '  ' );\n\t  \t\t\tif ( contextUp ) {\n\t  \t\t\t\tcontextUp += '\\n';\n\t  \t\t\t}\n\t  \t\t\tif ( contextDown ) {\n\t  \t\t\t\tcontextDown = '\\n' + contextDown;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tvar numTabs = 0;\n\t  \t\tvar annotation = contextUp + line.replace( /\\t/g, function ( match, char ) {\n\t  \t\t\tif ( char < columnNum ) {\n\t  \t\t\t\tnumTabs += 1;\n\t  \t\t\t}\n\t\n\t  \t\t\treturn '  ';\n\t  \t\t}) + '\\n' + new Array( columnNum + numTabs ).join( ' ' ) + '^----' + contextDown;\n\t\n\t  \t\treturn [ lineNum, columnNum, (\"\" + message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation) ];\n\t  \t},\n\t\n\t  \tgetLinePos: function ( char ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar lineNum = 0, lineStart = 0, columnNum;\n\t\n\t  \t\twhile ( char >= this$1.lineEnds[ lineNum ] ) {\n\t  \t\t\tlineStart = this$1.lineEnds[ lineNum ];\n\t  \t\t\tlineNum += 1;\n\t  \t\t}\n\t\n\t  \t\tcolumnNum = char - lineStart;\n\t  \t\treturn [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!\n\t  \t},\n\t\n\t  \terror: function ( message ) {\n\t  \t\tvar ref = this.getContextMessage( this.pos, message ), lineNum = ref[0], columnNum = ref[1], msg = ref[2];\n\t\n\t  \t\tvar error = new ParseError( msg );\n\t\n\t  \t\terror.line = lineNum;\n\t  \t\terror.character = columnNum;\n\t  \t\terror.shortMessage = message;\n\t\n\t  \t\tthrow error;\n\t  \t},\n\t\n\t  \tmatchString: function ( string ) {\n\t  \t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n\t  \t\t\tthis.pos += string.length;\n\t  \t\t\treturn string;\n\t  \t\t}\n\t  \t},\n\t\n\t  \tmatchPattern: function ( pattern ) {\n\t  \t\tvar match;\n\t\n\t  \t\tif ( match = pattern.exec( this.remaining() ) ) {\n\t  \t\t\tthis.pos += match[0].length;\n\t  \t\t\treturn match[1] || match[0];\n\t  \t\t}\n\t  \t},\n\t\n\t  \tallowWhitespace: function () {\n\t  \t\tthis.matchPattern( leadingWhitespace );\n\t  \t},\n\t\n\t  \tremaining: function () {\n\t  \t\treturn this.str.substring( this.pos );\n\t  \t},\n\t\n\t  \tnextChar: function () {\n\t  \t\treturn this.str.charAt( this.pos );\n\t  \t}\n\t  };\n\t\n\t  Parser.extend = function ( proto ) {\n\t  \tvar Parent = this, Child, key;\n\t\n\t  \tChild = function ( str, options ) {\n\t  \t\tParser.call( this, str, options );\n\t  \t};\n\t\n\t  \tChild.prototype = create( Parent.prototype );\n\t\n\t  \tfor ( key in proto ) {\n\t  \t\tif ( hasOwn.call( proto, key ) ) {\n\t  \t\t\tChild.prototype[ key ] = proto[ key ];\n\t  \t\t}\n\t  \t}\n\t\n\t  \tChild.extend = Parser.extend;\n\t  \treturn Child;\n\t  };\n\t\n\t  var Parser$1 = Parser;\n\t\n\t  var TEXT              = 1;\n\t  var INTERPOLATOR      = 2;\n\t  var TRIPLE            = 3;\n\t  var SECTION           = 4;\n\t  var INVERTED          = 5;\n\t  var CLOSING           = 6;\n\t  var ELEMENT           = 7;\n\t  var PARTIAL           = 8;\n\t  var COMMENT           = 9;\n\t  var DELIMCHANGE       = 10;\n\t  var ATTRIBUTE         = 13;\n\t  var CLOSING_TAG       = 14;\n\t  var COMPONENT         = 15;\n\t  var YIELDER           = 16;\n\t  var INLINE_PARTIAL    = 17;\n\t  var DOCTYPE           = 18;\n\t  var ALIAS             = 19;\n\t\n\t  var NUMBER_LITERAL    = 20;\n\t  var STRING_LITERAL    = 21;\n\t  var ARRAY_LITERAL     = 22;\n\t  var OBJECT_LITERAL    = 23;\n\t  var BOOLEAN_LITERAL   = 24;\n\t  var REGEXP_LITERAL    = 25;\n\t\n\t  var GLOBAL            = 26;\n\t  var KEY_VALUE_PAIR    = 27;\n\t\n\t\n\t  var REFERENCE         = 30;\n\t  var REFINEMENT        = 31;\n\t  var MEMBER            = 32;\n\t  var PREFIX_OPERATOR   = 33;\n\t  var BRACKETED         = 34;\n\t  var CONDITIONAL       = 35;\n\t  var INFIX_OPERATOR    = 36;\n\t\n\t  var INVOCATION        = 40;\n\t\n\t  var SECTION_IF        = 50;\n\t  var SECTION_UNLESS    = 51;\n\t  var SECTION_EACH      = 52;\n\t  var SECTION_WITH      = 53;\n\t  var SECTION_IF_WITH   = 54;\n\t\n\t  var ELSE              = 60;\n\t  var ELSEIF            = 61;\n\t\n\t  var EVENT             = 70;\n\t  var DECORATOR         = 71;\n\t  var TRANSITION        = 72;\n\t  var BINDING_FLAG      = 73;\n\t\n\t  var delimiterChangePattern = /^[^\\s=]+/;\n\t  var whitespacePattern = /^\\s+/;\n\t  function readDelimiterChange ( parser ) {\n\t  \tvar start, opening, closing;\n\t\n\t  \tif ( !parser.matchString( '=' ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \t// allow whitespace before new opening delimiter\n\t  \tparser.allowWhitespace();\n\t\n\t  \topening = parser.matchPattern( delimiterChangePattern );\n\t  \tif ( !opening ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// allow whitespace (in fact, it's necessary...)\n\t  \tif ( !parser.matchPattern( whitespacePattern ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tclosing = parser.matchPattern( delimiterChangePattern );\n\t  \tif ( !closing ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// allow whitespace before closing '='\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( '=' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \treturn [ opening, closing ];\n\t  }\n\t\n\t  var regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\t\n\t  function readNumberLiteral ( parser ) {\n\t  \tvar result;\n\t\n\t  \tif ( result = parser.matchPattern( regexpPattern ) ) {\n\t  \t\treturn {\n\t  \t\t\tt: REGEXP_LITERAL,\n\t  \t\t\tv: result\n\t  \t\t};\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  var pattern$1 = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\t\n\t  function escapeRegExp ( str ) {\n\t  \treturn str.replace( pattern$1, '\\\\$&' );\n\t  }\n\t\n\t  var regExpCache = {};\n\t\n\t  function getLowestIndex ( haystack, needles ) {\n\t  \treturn haystack.search( regExpCache[needles.join()] || ( regExpCache[needles.join()] = new RegExp( needles.map( escapeRegExp ).join( '|' ) ) ) );\n\t  }\n\t\n\t  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n\t  var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n\t  var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\t\n\t  var htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830\t};\n\t  var controlCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];\n\t  var entityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n\t  var codePointSupport = typeof String.fromCodePoint === 'function';\n\t  var codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;\n\t\n\t  function decodeCharacterReferences ( html ) {\n\t  \treturn html.replace( entityPattern, function ( match, entity ) {\n\t  \t\tvar code;\n\t\n\t  \t\t// Handle named entities\n\t  \t\tif ( entity[0] !== '#' ) {\n\t  \t\t\tcode = htmlEntities[ entity ];\n\t  \t\t} else if ( entity[1] === 'x' ) {\n\t  \t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n\t  \t\t} else {\n\t  \t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n\t  \t\t}\n\t\n\t  \t\tif ( !code ) {\n\t  \t\t\treturn match;\n\t  \t\t}\n\t\n\t  \t\treturn codeToChar( validateCode( code ) );\n\t  \t});\n\t  }\n\t\n\t  var lessThan = /</g;\n\t  var greaterThan = />/g;\n\t  var amp = /&/g;\n\t  var invalid = 65533;\n\t\n\t  function escapeHtml ( str ) {\n\t  \treturn str\n\t  \t\t.replace( amp, '&amp;' )\n\t  \t\t.replace( lessThan, '&lt;' )\n\t  \t\t.replace( greaterThan, '&gt;' );\n\t  }\n\t\n\t  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n\t  // code points with alternatives in some cases - since we're bypassing that mechanism, we need\n\t  // to replace them ourselves\n\t  //\n\t  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n\t  function validateCode ( code ) {\n\t  \tif ( !code ) {\n\t  \t\treturn invalid;\n\t  \t}\n\t\n\t  \t// line feed becomes generic whitespace\n\t  \tif ( code === 10 ) {\n\t  \t\treturn 32;\n\t  \t}\n\t\n\t  \t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n\t  \tif ( code < 128 ) {\n\t  \t\treturn code;\n\t  \t}\n\t\n\t  \t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n\t  \t// to correct the mistake or we'll end up with missing € signs and so on\n\t  \tif ( code <= 159 ) {\n\t  \t\treturn controlCharacters[ code - 128 ];\n\t  \t}\n\t\n\t  \t// basic multilingual plane\n\t  \tif ( code < 55296 ) {\n\t  \t\treturn code;\n\t  \t}\n\t\n\t  \t// UTF-16 surrogate halves\n\t  \tif ( code <= 57343 ) {\n\t  \t\treturn invalid;\n\t  \t}\n\t\n\t  \t// rest of the basic multilingual plane\n\t  \tif ( code <= 65535 ) {\n\t  \t\treturn code;\n\t  \t} else if ( !codePointSupport ) {\n\t  \t\treturn invalid;\n\t  \t}\n\t\n\t  \t// supplementary multilingual plane 0x10000 - 0x1ffff\n\t  \tif ( code >= 65536 && code <= 131071 ) {\n\t  \t\treturn code;\n\t  \t}\n\t\n\t  \t// supplementary ideographic plane 0x20000 - 0x2ffff\n\t  \tif ( code >= 131072 && code <= 196607 ) {\n\t  \t\treturn code;\n\t  \t}\n\t\n\t  \treturn invalid;\n\t  }\n\t\n\t  var expectedExpression = 'Expected a JavaScript expression';\n\t  var expectedParen = 'Expected closing paren';\n\t\n\t  // bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\n\t  var numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t\n\t  function readNumberLiteral$1 ( parser ) {\n\t  \tvar result;\n\t\n\t  \tif ( result = parser.matchPattern( numberPattern ) ) {\n\t  \t\treturn {\n\t  \t\t\tt: NUMBER_LITERAL,\n\t  \t\t\tv: result\n\t  \t\t};\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  function readBooleanLiteral ( parser ) {\n\t  \tvar remaining = parser.remaining();\n\t\n\t  \tif ( remaining.substr( 0, 4 ) === 'true' ) {\n\t  \t\tparser.pos += 4;\n\t  \t\treturn {\n\t  \t\t\tt: BOOLEAN_LITERAL,\n\t  \t\t\tv: 'true'\n\t  \t\t};\n\t  \t}\n\t\n\t  \tif ( remaining.substr( 0, 5 ) === 'false' ) {\n\t  \t\tparser.pos += 5;\n\t  \t\treturn {\n\t  \t\t\tt: BOOLEAN_LITERAL,\n\t  \t\t\tv: 'false'\n\t  \t\t};\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  var stringMiddlePattern;\n\t  var escapeSequencePattern;\n\t  var lineContinuationPattern;\n\t  // Match one or more characters until: \", ', \\, or EOL/EOF.\n\t  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n\t  stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\t\n\t  // Match one escape sequence, including the backslash.\n\t  escapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\t\n\t  // Match one ES5 line continuation (backslash + line terminator).\n\t  lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\t\n\t  // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n\t  function makeQuotedStringMatcher ( okQuote ) {\n\t  \treturn function ( parser ) {\n\t  \t\tvar literal = '\"';\n\t  \t\tvar done = false;\n\t  \t\tvar next;\n\t\n\t  \t\twhile ( !done ) {\n\t  \t\t\tnext = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||\n\t  \t\t\t\tparser.matchString( okQuote ) );\n\t  \t\t\tif ( next ) {\n\t  \t\t\t\tif ( next === (\"\\\"\") ) {\n\t  \t\t\t\t\tliteral += \"\\\\\\\"\";\n\t  \t\t\t\t} else if ( next === (\"\\\\'\") ) {\n\t  \t\t\t\t\tliteral += \"'\";\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\tliteral += next;\n\t  \t\t\t\t}\n\t  \t\t\t} else {\n\t  \t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n\t  \t\t\t\tif ( next ) {\n\t  \t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n\t  \t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\tdone = true;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tliteral += '\"';\n\t\n\t  \t\t// use JSON.parse to interpret escapes\n\t  \t\treturn JSON.parse( literal );\n\t  \t};\n\t  }\n\t\n\t  var getSingleQuotedString = makeQuotedStringMatcher( (\"\\\"\") );\n\t  var getDoubleQuotedString = makeQuotedStringMatcher( (\"'\") );\n\t\n\t  function readStringLiteral ( parser ) {\n\t  \tvar start, string;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tif ( parser.matchString( '\"' ) ) {\n\t  \t\tstring = getDoubleQuotedString( parser );\n\t\n\t  \t\tif ( !parser.matchString( '\"' ) ) {\n\t  \t\t\tparser.pos = start;\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\treturn {\n\t  \t\t\tt: STRING_LITERAL,\n\t  \t\t\tv: string\n\t  \t\t};\n\t  \t}\n\t\n\t  \tif ( parser.matchString( (\"'\") ) ) {\n\t  \t\tstring = getSingleQuotedString( parser );\n\t\n\t  \t\tif ( !parser.matchString( (\"'\") ) ) {\n\t  \t\t\tparser.pos = start;\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\treturn {\n\t  \t\t\tt: STRING_LITERAL,\n\t  \t\t\tv: string\n\t  \t\t};\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  var namePattern = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\t\n\t  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\t\n\t  // http://mathiasbynens.be/notes/javascript-properties\n\t  // can be any name, string literal, or number literal\n\t  function readKey ( parser ) {\n\t  \tvar token;\n\t\n\t  \tif ( token = readStringLiteral( parser ) ) {\n\t  \t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n\t  \t}\n\t\n\t  \tif ( token = readNumberLiteral$1( parser ) ) {\n\t  \t\treturn token.v;\n\t  \t}\n\t\n\t  \tif ( token = parser.matchPattern( namePattern ) ) {\n\t  \t\treturn token;\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  function readKeyValuePair ( parser ) {\n\t  \tvar start, key, value;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \t// allow whitespace between '{' and key\n\t  \tparser.allowWhitespace();\n\t\n\t  \tvar refKey = parser.nextChar() !== '\\'' && parser.nextChar() !== '\"';\n\t\n\t  \tkey = readKey( parser );\n\t  \tif ( key === null ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// allow whitespace between key and ':'\n\t  \tparser.allowWhitespace();\n\t\n\t  \t// es2015 shorthand property\n\t  \tif ( refKey && ( parser.nextChar() === ',' || parser.nextChar() === '}' ) ) {\n\t  \t\tif ( !namePattern.test( key ) ) {\n\t  \t\t\tparser.error( (\"Expected a valid reference, but found '\" + key + \"' instead.\") );\n\t  \t\t}\n\t\n\t  \t\treturn {\n\t  \t\t\tt: KEY_VALUE_PAIR,\n\t  \t\t\tk: key,\n\t  \t\t\tv: {\n\t  \t\t\t\tt: REFERENCE,\n\t  \t\t\t\tn: key\n\t  \t\t\t}\n\t  \t\t};\n\t  \t}\n\t\n\t  \t// next character must be ':'\n\t  \tif ( !parser.matchString( ':' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// allow whitespace between ':' and value\n\t  \tparser.allowWhitespace();\n\t\n\t  \t// next expression must be a, well... expression\n\t  \tvalue = readExpression( parser );\n\t  \tif ( value === null ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tt: KEY_VALUE_PAIR,\n\t  \t\tk: key,\n\t  \t\tv: value\n\t  \t};\n\t  }\n\t\n\t  function readKeyValuePairs ( parser ) {\n\t  \tvar start, pairs, pair, keyValuePairs;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tpair = readKeyValuePair( parser );\n\t  \tif ( pair === null ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tpairs = [ pair ];\n\t\n\t  \tif ( parser.matchString( ',' ) ) {\n\t  \t\tkeyValuePairs = readKeyValuePairs( parser );\n\t\n\t  \t\tif ( !keyValuePairs ) {\n\t  \t\t\tparser.pos = start;\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\treturn pairs.concat( keyValuePairs );\n\t  \t}\n\t\n\t  \treturn pairs;\n\t  }\n\t\n\t  function readObjectLiteral ( parser ) {\n\t  \tvar start, keyValuePairs;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \t// allow whitespace\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( '{' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tkeyValuePairs = readKeyValuePairs( parser );\n\t\n\t  \t// allow whitespace between final value and '}'\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( '}' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tt: OBJECT_LITERAL,\n\t  \t\tm: keyValuePairs\n\t  \t};\n\t  }\n\t\n\t  function readExpressionList ( parser ) {\n\t  \tparser.allowWhitespace();\n\t\n\t  \tvar expr = readExpression( parser );\n\t\n\t  \tif ( expr === null ) return null;\n\t\n\t  \tvar expressions = [ expr ];\n\t\n\t  \t// allow whitespace between expression and ','\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( parser.matchString( ',' ) ) {\n\t  \t\tvar next = readExpressionList( parser );\n\t  \t\tif ( next === null ) parser.error( expectedExpression );\n\t\n\t  \t\texpressions.push.apply( expressions, next );\n\t  \t}\n\t\n\t  \treturn expressions;\n\t  }\n\t\n\t  function readArrayLiteral ( parser ) {\n\t  \tvar start, expressionList;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \t// allow whitespace before '['\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( '[' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \texpressionList = readExpressionList( parser );\n\t\n\t  \tif ( !parser.matchString( ']' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tt: ARRAY_LITERAL,\n\t  \t\tm: expressionList\n\t  \t};\n\t  }\n\t\n\t  function readLiteral ( parser ) {\n\t  \treturn readNumberLiteral$1( parser )  ||\n\t  \t       readBooleanLiteral( parser ) ||\n\t  \t       readStringLiteral( parser )  ||\n\t  \t       readObjectLiteral( parser )  ||\n\t  \t       readArrayLiteral( parser )   ||\n\t  \t       readNumberLiteral( parser );\n\t  }\n\t\n\t  var prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/;\n\t  var globals;\n\t  var keywords;\n\t  // if a reference is a browser global, we don't deference it later, so it needs special treatment\n\t  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/;\n\t\n\t  // keywords are not valid references, with the exception of `this`\n\t  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\t\n\t  var legalReference = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\n\t  var relaxedName = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*/;\n\t  var specials = /^@(?:keypath|rootpath|index|key|this|global)/;\n\t  var specialCall = /^\\s*\\(/;\n\t  var spreadPattern = /^\\s*\\.{3}/;\n\t\n\t  function readReference ( parser ) {\n\t  \tvar startPos, prefix, name, global, reference, fullLength, lastDotIndex, spread;\n\t\n\t  \tstartPos = parser.pos;\n\t\n\t  \tname = parser.matchPattern( specials );\n\t\n\t  \tif ( name === '@keypath' || name === '@rootpath' ) {\n\t  \t\tif ( parser.matchPattern( specialCall ) ) {\n\t  \t\t\tvar ref = readReference( parser );\n\t  \t\t\tif ( !ref ) parser.error( (\"Expected a valid reference for a keypath expression\") );\n\t\n\t  \t\t\tparser.allowWhitespace();\n\t\n\t  \t\t\tif ( !parser.matchString( ')' ) ) parser.error( (\"Unclosed keypath expression\") );\n\t  \t\t\tname += \"(\" + (ref.n) + \")\";\n\t  \t\t}\n\t  \t}\n\t\n\t  \tspread = !name && parser.spreadArgs && parser.matchPattern( spreadPattern );\n\t\n\t  \tif ( !name ) {\n\t  \t\tprefix = parser.matchPattern( prefixPattern ) || '';\n\t  \t\tname = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||\n\t  \t\t       parser.matchPattern( legalReference );\n\t\n\t  \t\tif ( !name && prefix === '.' ) {\n\t  \t\t\tprefix = '';\n\t  \t\t\tname = '.';\n\t  \t\t} else if ( !name && prefix ) {\n\t  \t\t\tname = prefix;\n\t  \t\t\tprefix = '';\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( !name ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n\t  \tif ( !prefix && !parser.relaxedNames && keywords.test( name ) ) {\n\t  \t\tparser.pos = startPos;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// if this is a browser global, stop here\n\t  \tif ( !prefix && globals.test( name ) ) {\n\t  \t\tglobal = globals.exec( name )[0];\n\t  \t\tparser.pos = startPos + global.length;\n\t\n\t  \t\treturn {\n\t  \t\t\tt: GLOBAL,\n\t  \t\t\tv: ( spread ? '...' : '' ) + global\n\t  \t\t};\n\t  \t}\n\t\n\t  \tfullLength = ( spread ? 3 : 0 ) + ( prefix || '' ).length + name.length;\n\t  \treference = ( prefix || '' ) + normalise( name );\n\t\n\t  \tif ( parser.matchString( '(' ) ) {\n\t  \t\t// if this is a method invocation (as opposed to a function) we need\n\t  \t\t// to strip the method name from the reference combo, else the context\n\t  \t\t// will be wrong\n\t  \t\t// but only if the reference was actually a member and not a refinement\n\t  \t\tlastDotIndex = reference.lastIndexOf( '.' );\n\t  \t\tif ( lastDotIndex !== -1 && name[ name.length - 1 ] !== ']' ) {\n\t  \t\t\tvar refLength = reference.length;\n\t  \t\t\treference = reference.substr( 0, lastDotIndex );\n\t  \t\t\tparser.pos = startPos + (fullLength - ( refLength - lastDotIndex ) );\n\t  \t\t} else {\n\t  \t\t\tparser.pos -= 1;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tt: REFERENCE,\n\t  \t\tn: ( spread ? '...' : '' ) + reference.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n\t  \t};\n\t  }\n\t\n\t  function readBracketedExpression ( parser ) {\n\t  \tif ( !parser.matchString( '(' ) ) return null;\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tvar expr = readExpression( parser );\n\t\n\t  \tif ( !expr ) parser.error( expectedExpression );\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( ')' ) ) parser.error( expectedParen );\n\t\n\t  \treturn {\n\t  \t\tt: BRACKETED,\n\t  \t\tx: expr\n\t  \t};\n\t  }\n\t\n\t  function readPrimary ( parser ) {\n\t  \treturn readLiteral( parser )\n\t  \t\t|| readReference( parser )\n\t  \t\t|| readBracketedExpression( parser );\n\t  }\n\t\n\t  function readRefinement ( parser ) {\n\t  \t// some things call for strict refinement (partial names), meaning no space between reference and refinement\n\t  \tif ( !parser.strictRefinement ) {\n\t  \t\tparser.allowWhitespace();\n\t  \t}\n\t\n\t  \t// \".\" name\n\t  \tif ( parser.matchString( '.' ) ) {\n\t  \t\tparser.allowWhitespace();\n\t\n\t  \t\tvar name = parser.matchPattern( namePattern );\n\t  \t\tif ( name ) {\n\t  \t\t\treturn {\n\t  \t\t\t\tt: REFINEMENT,\n\t  \t\t\t\tn: name\n\t  \t\t\t};\n\t  \t\t}\n\t\n\t  \t\tparser.error( 'Expected a property name' );\n\t  \t}\n\t\n\t  \t// \"[\" expression \"]\"\n\t  \tif ( parser.matchString( '[' ) ) {\n\t  \t\tparser.allowWhitespace();\n\t\n\t  \t\tvar expr = readExpression( parser );\n\t  \t\tif ( !expr ) parser.error( expectedExpression );\n\t\n\t  \t\tparser.allowWhitespace();\n\t\n\t  \t\tif ( !parser.matchString( ']' ) ) parser.error( (\"Expected ']'\") );\n\t\n\t  \t\treturn {\n\t  \t\t\tt: REFINEMENT,\n\t  \t\t\tx: expr\n\t  \t\t};\n\t  \t}\n\t\n\t  \treturn null;\n\t  }\n\t\n\t  function readMemberOrInvocation ( parser ) {\n\t  \tvar expression = readPrimary( parser );\n\t\n\t  \tif ( !expression ) return null;\n\t\n\t  \twhile ( expression ) {\n\t  \t\tvar refinement = readRefinement( parser );\n\t  \t\tif ( refinement ) {\n\t  \t\t\texpression = {\n\t  \t\t\t\tt: MEMBER,\n\t  \t\t\t\tx: expression,\n\t  \t\t\t\tr: refinement\n\t  \t\t\t};\n\t  \t\t}\n\t\n\t  \t\telse if ( parser.matchString( '(' ) ) {\n\t  \t\t\tparser.allowWhitespace();\n\t  \t\t\tvar start = parser.spreadArgs;\n\t  \t\t\tparser.spreadArgs = true;\n\t  \t\t\tvar expressionList = readExpressionList( parser );\n\t  \t\t\tparser.spreadArgs = start;\n\t\n\t  \t\t\tparser.allowWhitespace();\n\t\n\t  \t\t\tif ( !parser.matchString( ')' ) ) {\n\t  \t\t\t\tparser.error( expectedParen );\n\t  \t\t\t}\n\t\n\t  \t\t\texpression = {\n\t  \t\t\t\tt: INVOCATION,\n\t  \t\t\t\tx: expression\n\t  \t\t\t};\n\t\n\t  \t\t\tif ( expressionList ) expression.o = expressionList;\n\t  \t\t}\n\t\n\t  \t\telse {\n\t  \t\t\tbreak;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn expression;\n\t  }\n\t\n\t  var readTypeOf;\n\t  var makePrefixSequenceMatcher;\n\t  makePrefixSequenceMatcher = function ( symbol, fallthrough ) {\n\t  \treturn function ( parser ) {\n\t  \t\tvar expression;\n\t\n\t  \t\tif ( expression = fallthrough( parser ) ) {\n\t  \t\t\treturn expression;\n\t  \t\t}\n\t\n\t  \t\tif ( !parser.matchString( symbol ) ) {\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\tparser.allowWhitespace();\n\t\n\t  \t\texpression = readExpression( parser );\n\t  \t\tif ( !expression ) {\n\t  \t\t\tparser.error( expectedExpression );\n\t  \t\t}\n\t\n\t  \t\treturn {\n\t  \t\t\ts: symbol,\n\t  \t\t\to: expression,\n\t  \t\t\tt: PREFIX_OPERATOR\n\t  \t\t};\n\t  \t};\n\t  };\n\t\n\t  // create all prefix sequence matchers, return readTypeOf\n\t  (function() {\n\t  \tvar i, len, matcher, prefixOperators, fallthrough;\n\t\n\t  \tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\t\n\t  \tfallthrough = readMemberOrInvocation;\n\t  \tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n\t  \t\tmatcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );\n\t  \t\tfallthrough = matcher;\n\t  \t}\n\t\n\t  \t// typeof operator is higher precedence than multiplication, so provides the\n\t  \t// fallthrough for the multiplication sequence matcher we're about to create\n\t  \t// (we're skipping void and delete)\n\t  \treadTypeOf = fallthrough;\n\t  }());\n\t\n\t  var readTypeof = readTypeOf;\n\t\n\t  var readLogicalOr;\n\t  var makeInfixSequenceMatcher;\n\t  makeInfixSequenceMatcher = function ( symbol, fallthrough ) {\n\t  \treturn function ( parser ) {\n\t  \t\tvar start, left, right;\n\t\n\t  \t\tleft = fallthrough( parser );\n\t  \t\tif ( !left ) {\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n\t  \t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n\t  \t\t// to parse `left` because that would be infinite regress.\n\t  \t\twhile ( true ) {\n\t  \t\t\tstart = parser.pos;\n\t\n\t  \t\t\tparser.allowWhitespace();\n\t\n\t  \t\t\tif ( !parser.matchString( symbol ) ) {\n\t  \t\t\t\tparser.pos = start;\n\t  \t\t\t\treturn left;\n\t  \t\t\t}\n\t\n\t  \t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n\t  \t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n\t  \t\t\t\tparser.pos = start;\n\t  \t\t\t\treturn left;\n\t  \t\t\t}\n\t\n\t  \t\t\tparser.allowWhitespace();\n\t\n\t  \t\t\t// right operand must also consist of only higher-precedence operators\n\t  \t\t\tright = fallthrough( parser );\n\t  \t\t\tif ( !right ) {\n\t  \t\t\t\tparser.pos = start;\n\t  \t\t\t\treturn left;\n\t  \t\t\t}\n\t\n\t  \t\t\tleft = {\n\t  \t\t\t\tt: INFIX_OPERATOR,\n\t  \t\t\t\ts: symbol,\n\t  \t\t\t\to: [ left, right ]\n\t  \t\t\t};\n\t\n\t  \t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n\t  \t\t\t// we'll return left.\n\t  \t\t}\n\t  \t};\n\t  };\n\t\n\t  // create all infix sequence matchers, and return readLogicalOr\n\t  (function() {\n\t  \tvar i, len, matcher, infixOperators, fallthrough;\n\t\n\t  \t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n\t  \t// Each sequence matcher will initially fall through to its higher precedence\n\t  \t// neighbour, and only attempt to match if one of the higher precedence operators\n\t  \t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n\t  \tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\t\n\t  \t// A typeof operator is higher precedence than multiplication\n\t  \tfallthrough = readTypeof;\n\t  \tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n\t  \t\tmatcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );\n\t  \t\tfallthrough = matcher;\n\t  \t}\n\t\n\t  \t// Logical OR is the fallthrough for the conditional matcher\n\t  \treadLogicalOr = fallthrough;\n\t  }());\n\t\n\t  var readLogicalOr$1 = readLogicalOr;\n\t\n\t  // The conditional operator is the lowest precedence operator, so we start here\n\t  function getConditional ( parser ) {\n\t  \tvar start, expression, ifTrue, ifFalse;\n\t\n\t  \texpression = readLogicalOr$1( parser );\n\t  \tif ( !expression ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( '?' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn expression;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tifTrue = readExpression( parser );\n\t  \tif ( !ifTrue ) {\n\t  \t\tparser.error( expectedExpression );\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( ':' ) ) {\n\t  \t\tparser.error( 'Expected \":\"' );\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tifFalse = readExpression( parser );\n\t  \tif ( !ifFalse ) {\n\t  \t\tparser.error( expectedExpression );\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tt: CONDITIONAL,\n\t  \t\to: [ expression, ifTrue, ifFalse ]\n\t  \t};\n\t  }\n\t\n\t  function readExpression ( parser ) {\n\t  \t// The conditional operator is the lowest precedence operator (except yield,\n\t  \t// assignment operators, and commas, none of which are supported), so we\n\t  \t// start there. If it doesn't match, it 'falls through' to progressively\n\t  \t// higher precedence operators, until it eventually matches (or fails to\n\t  \t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n\t  \t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n\t  \treturn getConditional( parser );\n\t  }\n\t\n\t  function flattenExpression ( expression ) {\n\t  \tvar refs, count = 0, stringified;\n\t\n\t  \textractRefs( expression, refs = [] );\n\t  \tstringified = stringify( expression );\n\t\n\t  \trefs = refs.map( function ( r ) { return r.indexOf( '...' ) === 0 ? r.substr( 3 ) : r; } );\n\t\n\t  \treturn {\n\t  \t\tr: refs,\n\t  \t\ts: getVars(stringified)\n\t  \t};\n\t\n\t  \tfunction getVars(expr) {\n\t  \t\tvar vars = [];\n\t  \t\tfor ( var i = count - 1; i >= 0; i-- ) {\n\t  \t\t\tvars.push( (\"spread$\" + i) );\n\t  \t\t}\n\t  \t\treturn vars.length ? (\"(function(){var \" + (vars.join(',')) + \";return(\" + expr + \");})()\") : expr;\n\t  \t}\n\t\n\t  \tfunction stringify ( node ) {\n\t  \t\tswitch ( node.t ) {\n\t  \t\t\tcase BOOLEAN_LITERAL:\n\t  \t\t\tcase GLOBAL:\n\t  \t\t\tcase NUMBER_LITERAL:\n\t  \t\t\tcase REGEXP_LITERAL:\n\t  \t\t\t\treturn node.v;\n\t\n\t  \t\t\tcase STRING_LITERAL:\n\t  \t\t\t\treturn JSON.stringify( String( node.v ) );\n\t\n\t  \t\t\tcase ARRAY_LITERAL:\n\t  \t\t\t\treturn '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + ']';\n\t\n\t  \t\t\tcase OBJECT_LITERAL:\n\t  \t\t\t\treturn '{' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + '}';\n\t\n\t  \t\t\tcase KEY_VALUE_PAIR:\n\t  \t\t\t\treturn node.k + ':' + stringify( node.v );\n\t\n\t  \t\t\tcase PREFIX_OPERATOR:\n\t  \t\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );\n\t\n\t  \t\t\tcase INFIX_OPERATOR:\n\t  \t\t\t\treturn stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );\n\t\n\t  \t\t\tcase INVOCATION:\n\t  \t\t\t\tif ( node.spread ) {\n\t  \t\t\t\t\tvar id = count++;\n\t  \t\t\t\t\treturn (\"(spread$\" + id + \" = \" + (stringify(node.x)) + \").apply(spread$\" + id + \", [].concat(\" + (node.o ? node.o.map( function ( a ) { return a.n && a.n.indexOf( '...' ) === 0 ? stringify( a ) : '[' + stringify(a) + ']'; } ).join( ',' ) : '') + \") )\");\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\treturn stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : '' ) + ')';\n\t  \t\t\t\t}\n\t\n\t  \t\t\tcase BRACKETED:\n\t  \t\t\t\treturn '(' + stringify( node.x ) + ')';\n\t\n\t  \t\t\tcase MEMBER:\n\t  \t\t\t\treturn stringify( node.x ) + stringify( node.r );\n\t\n\t  \t\t\tcase REFINEMENT:\n\t  \t\t\t\treturn ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );\n\t\n\t  \t\t\tcase CONDITIONAL:\n\t  \t\t\t\treturn stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );\n\t\n\t  \t\t\tcase REFERENCE:\n\t  \t\t\t\treturn '_' + refs.indexOf( node.n );\n\t\n\t  \t\t\tdefault:\n\t  \t\t\t\tthrow new Error( 'Expected legal JavaScript' );\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  // TODO maybe refactor this?\n\t  function extractRefs ( node, refs ) {\n\t  \tvar i, list;\n\t\n\t  \tif ( node.t === REFERENCE ) {\n\t  \t\tif ( refs.indexOf( node.n ) === -1 ) {\n\t  \t\t\trefs.unshift( node.n );\n\t  \t\t}\n\t  \t}\n\t\n\t  \tlist = node.o || node.m;\n\t  \tif ( list ) {\n\t  \t\tif ( isObject( list ) ) {\n\t  \t\t\textractRefs( list, refs );\n\t  \t\t} else {\n\t  \t\t\ti = list.length;\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tif ( list[i].n && list[i].n.indexOf('...') === 0 ) {\n\t  \t\t\t\t\tnode.spread = true;\n\t  \t\t\t\t}\n\t  \t\t\t\textractRefs( list[i], refs );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( node.x ) {\n\t  \t\textractRefs( node.x, refs );\n\t  \t}\n\t\n\t  \tif ( node.r ) {\n\t  \t\textractRefs( node.r, refs );\n\t  \t}\n\t\n\t  \tif ( node.v ) {\n\t  \t\textractRefs( node.v, refs );\n\t  \t}\n\t  }\n\t\n\t  // simple JSON parser, without the restrictions of JSON parse\n\t  // (i.e. having to double-quote keys).\n\t  //\n\t  // If passed a hash of values as the second argument, ${placeholders}\n\t  // will be replaced with those values\n\t\n\t  var specials$1 = {\n\t  \t'true': true,\n\t  \t'false': false,\n\t  \t'null': null,\n\t  \tundefined: undefined\n\t  };\n\t\n\t  var specialsPattern = new RegExp( '^(?:' + Object.keys( specials$1 ).join( '|' ) + ')' );\n\t  var numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\t  var placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n\t  var placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n\t  var onlyWhitespace = /^\\s*$/;\n\t\n\t  var JsonParser = Parser$1.extend({\n\t  \tinit: function ( str, options ) {\n\t  \t\tthis.values = options.values;\n\t  \t\tthis.allowWhitespace();\n\t  \t},\n\t\n\t  \tpostProcess: function ( result ) {\n\t  \t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\treturn { value: result[0].v };\n\t  \t},\n\t\n\t  \tconverters: [\n\t  \t\tfunction getPlaceholder ( parser ) {\n\t  \t\t\tif ( !parser.values ) return null;\n\t\n\t  \t\t\tvar placeholder = parser.matchPattern( placeholderAtStartPattern );\n\t\n\t  \t\t\tif ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {\n\t  \t\t\t\treturn { v: parser.values[ placeholder ] };\n\t  \t\t\t}\n\t  \t\t},\n\t\n\t  \t\tfunction getSpecial ( parser ) {\n\t  \t\t\tvar special = parser.matchPattern( specialsPattern );\n\t  \t\t\tif ( special ) return { v: specials$1[ special ] };\n\t  \t\t},\n\t\n\t  \t\tfunction getNumber ( parser ) {\n\t  \t\t\tvar number = parser.matchPattern( numberPattern$1 );\n\t  \t\t\tif ( number ) return { v: +number };\n\t  \t\t},\n\t\n\t  \t\tfunction getString ( parser ) {\n\t  \t\t\tvar stringLiteral = readStringLiteral( parser );\n\t  \t\t\tvar values = parser.values;\n\t\n\t  \t\t\tif ( stringLiteral && values ) {\n\t  \t\t\t\treturn {\n\t  \t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) { return ( $1 in values ? values[ $1 ] : $1 ); } )\n\t  \t\t\t\t};\n\t  \t\t\t}\n\t\n\t  \t\t\treturn stringLiteral;\n\t  \t\t},\n\t\n\t  \t\tfunction getObject ( parser ) {\n\t  \t\t\tif ( !parser.matchString( '{' ) ) return null;\n\t\n\t  \t\t\tvar result = {};\n\t\n\t  \t\t\tparser.allowWhitespace();\n\t\n\t  \t\t\tif ( parser.matchString( '}' ) ) {\n\t  \t\t\t\treturn { v: result };\n\t  \t\t\t}\n\t\n\t  \t\t\tvar pair;\n\t  \t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n\t  \t\t\t\tresult[ pair.key ] = pair.value;\n\t\n\t  \t\t\t\tparser.allowWhitespace();\n\t\n\t  \t\t\t\tif ( parser.matchString( '}' ) ) {\n\t  \t\t\t\t\treturn { v: result };\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t  \t\t\t\t\treturn null;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\treturn null;\n\t  \t\t},\n\t\n\t  \t\tfunction getArray ( parser ) {\n\t  \t\t\tif ( !parser.matchString( '[' ) ) return null;\n\t\n\t  \t\t\tvar result = [];\n\t\n\t  \t\t\tparser.allowWhitespace();\n\t\n\t  \t\t\tif ( parser.matchString( ']' ) ) {\n\t  \t\t\t\treturn { v: result };\n\t  \t\t\t}\n\t\n\t  \t\t\tvar valueToken;\n\t  \t\t\twhile ( valueToken = parser.read() ) {\n\t  \t\t\t\tresult.push( valueToken.v );\n\t\n\t  \t\t\t\tparser.allowWhitespace();\n\t\n\t  \t\t\t\tif ( parser.matchString( ']' ) ) {\n\t  \t\t\t\t\treturn { v: result };\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tif ( !parser.matchString( ',' ) ) {\n\t  \t\t\t\t\treturn null;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tparser.allowWhitespace();\n\t  \t\t\t}\n\t\n\t  \t\t\treturn null;\n\t  \t\t}\n\t  \t]\n\t  });\n\t\n\t  function getKeyValuePair ( parser ) {\n\t  \tparser.allowWhitespace();\n\t\n\t  \tvar key = readKey( parser );\n\t\n\t  \tif ( !key ) return null;\n\t\n\t  \tvar pair = { key: key };\n\t\n\t  \tparser.allowWhitespace();\n\t  \tif ( !parser.matchString( ':' ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t  \tparser.allowWhitespace();\n\t\n\t  \tvar valueToken = parser.read();\n\t\n\t  \tif ( !valueToken ) return null;\n\t\n\t  \tpair.value = valueToken.v;\n\t  \treturn pair;\n\t  }\n\t\n\t  function parseJSON ( str, values ) {\n\t  \tvar parser = new JsonParser( str, { values: values });\n\t  \treturn parser.result;\n\t  }\n\t\n\t  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*\\)\\s*$/;\n\t  var ExpressionParser;\n\t  ExpressionParser = Parser$1.extend({\n\t  \tconverters: [ readExpression ],\n\t  \tspreadArgs: true\n\t  });\n\t\n\t  // TODO clean this up, it's shocking\n\t  function processDirective ( tokens, parentParser, type ) {\n\t  \tvar result,\n\t  \t\tmatch,\n\t  \t\ttoken,\n\t  \t\tcolonIndex,\n\t  \t\tdirectiveName,\n\t  \t\tdirectiveArgs,\n\t  \t\tparsed;\n\t\n\t  \tif ( typeof tokens === 'string' ) {\n\t  \t\tvar pos = parentParser.pos - tokens.length;\n\t  \t\tif ( type === DECORATOR || type === TRANSITION ) {\n\t  \t\t\tvar parser = new ExpressionParser( (\"[\" + tokens + \"]\") );\n\t  \t\t\treturn { a: flattenExpression( parser.result[0] ) };\n\t  \t\t}\n\t\n\t  \t\tif ( type === EVENT && ( match = methodCallPattern.exec( tokens ) ) ) {\n\t  \t\t\twarnIfDebug( parentParser.getContextMessage( pos, (\"Unqualified method events are deprecated. Prefix methods with '@this.' to call methods on the current Ractive instance.\") )[2] );\n\t  \t\t\ttokens = \"@this.\" + (match[1]) + \"\" + (tokens.substr(match[1].length));\n\t  \t\t}\n\t\n\t  \t\tif ( type === EVENT && ~tokens.indexOf( '(' ) ) {\n\t  \t\t\tvar parser$1 = new ExpressionParser( '[' + tokens + ']' );\n\t  \t\t\tif ( parser$1.result && parser$1.result[0] ) {\n\t  \t\t\t\tif ( parser$1.remaining().length ) {\n\t  \t\t\t\t\tparentParser.pos = pos + tokens.length - parser$1.remaining().length;\n\t  \t\t\t\t\tparentParser.error( (\"Invalid input after event expression '\" + (parser$1.remaining()) + \"'\") );\n\t  \t\t\t\t}\n\t  \t\t\t\treturn { x: flattenExpression( parser$1.result[0] ) };\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( tokens.indexOf( ':' ) > tokens.indexOf( '(' ) || !~tokens.indexOf( ':' ) ) {\n\t  \t\t\t\tparentParser.pos = pos;\n\t  \t\t\t\tparentParser.error( (\"Invalid input in event expression '\" + tokens + \"'\") );\n\t  \t\t\t}\n\t\n\t  \t\t}\n\t\n\t  \t\tif ( tokens.indexOf( ':' ) === -1 ) {\n\t  \t\t\treturn tokens.trim();\n\t  \t\t}\n\t\n\t  \t\ttokens = [ tokens ];\n\t  \t}\n\t\n\t  \tresult = {};\n\t\n\t  \tdirectiveName = [];\n\t  \tdirectiveArgs = [];\n\t\n\t  \tif ( tokens ) {\n\t  \t\twhile ( tokens.length ) {\n\t  \t\t\ttoken = tokens.shift();\n\t\n\t  \t\t\tif ( typeof token === 'string' ) {\n\t  \t\t\t\tcolonIndex = token.indexOf( ':' );\n\t\n\t  \t\t\t\tif ( colonIndex === -1 ) {\n\t  \t\t\t\t\tdirectiveName.push( token );\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\t// is the colon the first character?\n\t  \t\t\t\t\tif ( colonIndex ) {\n\t  \t\t\t\t\t\t// no\n\t  \t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n\t  \t\t\t\t\t}\n\t\n\t  \t\t\t\t\t// if there is anything after the colon in this token, treat\n\t  \t\t\t\t\t// it as the first token of the directiveArgs fragment\n\t  \t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n\t  \t\t\t\t\t\tdirectiveArgs[0] = token.substring( colonIndex + 1 );\n\t  \t\t\t\t\t}\n\t\n\t  \t\t\t\t\tbreak;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\telse {\n\t  \t\t\t\tdirectiveName.push( token );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tdirectiveArgs = directiveArgs.concat( tokens );\n\t  \t}\n\t\n\t  \tif ( !directiveName.length ) {\n\t  \t\tresult = '';\n\t  \t} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {\n\t  \t\tresult = {\n\t  \t\t\t// TODO is this really necessary? just use the array\n\t  \t\t\tn: ( directiveName.length === 1 && typeof directiveName[0] === 'string' ? directiveName[0] : directiveName )\n\t  \t\t};\n\t\n\t  \t\tif ( directiveArgs.length === 1 && typeof directiveArgs[0] === 'string' ) {\n\t  \t\t\tparsed = parseJSON( '[' + directiveArgs[0] + ']' );\n\t  \t\t\tresult.a = parsed ? parsed.value : [ directiveArgs[0].trim() ];\n\t  \t\t}\n\t\n\t  \t\telse {\n\t  \t\t\tresult.d = directiveArgs;\n\t  \t\t}\n\t  \t} else {\n\t  \t\tresult = directiveName;\n\t  \t}\n\t\n\t  \tif ( directiveArgs.length && type ) {\n\t  \t\twarnIfDebug( parentParser.getContextMessage( parentParser.pos, (\"Proxy events with arguments are deprecated. You can fire events with arguments using \\\"@this.fire('eventName', arg1, arg2, ...)\\\".\") )[2] );\n\t  \t}\n\t\n\t  \treturn result;\n\t  }\n\t\n\t  var attributeNamePattern = /^[^\\s\"'>\\/=]+/;\n\t  var onPattern = /^on/;\n\t  var proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/;\n\t  var reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/;\n\t  var decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;\n\t  var transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;\n\t  var directives = {\n\t  \t\t\t\t   'intro-outro': { t: TRANSITION, v: 't0' },\n\t  \t\t\t\t   intro: { t: TRANSITION, v: 't1' },\n\t  \t\t\t\t   outro: { t: TRANSITION, v: 't2' },\n\t  \t\t\t\t   lazy: { t: BINDING_FLAG, v: 'l' },\n\t  \t\t\t\t   twoway: { t: BINDING_FLAG, v: 't' },\n\t  \t\t\t\t   decorator: { t: DECORATOR }\n\t  \t\t\t\t };\n\t  var unquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n\t  function readAttribute ( parser ) {\n\t  \tvar attr, name, value, i, nearest, idx;\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tname = parser.matchPattern( attributeNamePattern );\n\t  \tif ( !name ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />\n\t  \tnearest = name.length;\n\t  \tfor ( i = 0; i < parser.tags.length; i++ ) {\n\t  \t\tif ( ~( idx = name.indexOf( parser.tags[ i ].open ) ) ) {\n\t  \t\t\tif ( idx < nearest ) nearest = idx;\n\t  \t\t}\n\t  \t}\n\t  \tif ( nearest < name.length ) {\n\t  \t\tparser.pos -= name.length - nearest;\n\t  \t\tname = name.substr( 0, nearest );\n\t  \t\treturn { n: name };\n\t  \t}\n\t\n\t  \tattr = { n: name };\n\t\n\t  \tvalue = readAttributeValue( parser );\n\t  \tif ( value != null ) { // not null/undefined\n\t  \t\tattr.f = value;\n\t  \t}\n\t\n\t  \treturn attr;\n\t  }\n\t\n\t  function readAttributeValue ( parser ) {\n\t  \tvar start, valueStart, startDepth, value;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \t// next character must be `=`, `/`, `>` or whitespace\n\t  \tif ( !/[=\\/>\\s]/.test( parser.nextChar() ) ) {\n\t  \t\tparser.error( 'Expected `=`, `/`, `>` or whitespace' );\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( '=' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tvalueStart = parser.pos;\n\t  \tstartDepth = parser.sectionDepth;\n\t\n\t  \tvalue = readQuotedAttributeValue( parser, (\"'\") ) ||\n\t  \t\t\treadQuotedAttributeValue( parser, (\"\\\"\") ) ||\n\t  \t\t\treadUnquotedAttributeValue( parser );\n\t\n\t  \tif ( value === null ) {\n\t  \t\tparser.error( 'Expected valid attribute value' );\n\t  \t}\n\t\n\t  \tif ( parser.sectionDepth !== startDepth ) {\n\t  \t\tparser.pos = valueStart;\n\t  \t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n\t  \t}\n\t\n\t  \tif ( !value.length ) {\n\t  \t\treturn '';\n\t  \t}\n\t\n\t  \tif ( value.length === 1 && typeof value[0] === 'string' ) {\n\t  \t\treturn decodeCharacterReferences( value[0] );\n\t  \t}\n\t\n\t  \treturn value;\n\t  }\n\t\n\t  function readUnquotedAttributeValueToken ( parser ) {\n\t  \tvar start, text, haystack, needles, index;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\t\n\t  \tif ( !text ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \thaystack = text;\n\t  \tneedles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well\n\t\n\t  \tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n\t  \t\ttext = text.substr( 0, index );\n\t  \t\tparser.pos = start + text.length;\n\t  \t}\n\t\n\t  \treturn text;\n\t  }\n\t\n\t  function readUnquotedAttributeValue ( parser ) {\n\t  \tvar tokens, token;\n\t\n\t  \tparser.inAttribute = true;\n\t\n\t  \ttokens = [];\n\t\n\t  \ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\t  \twhile ( token ) {\n\t  \t\ttokens.push( token );\n\t  \t\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n\t  \t}\n\t\n\t  \tif ( !tokens.length ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.inAttribute = false;\n\t  \treturn tokens;\n\t  }\n\t\n\t  function readQuotedAttributeValue ( parser, quoteMark ) {\n\t  \tvar start, tokens, token;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tif ( !parser.matchString( quoteMark ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.inAttribute = quoteMark;\n\t\n\t  \ttokens = [];\n\t\n\t  \ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\t  \twhile ( token !== null ) {\n\t  \t\ttokens.push( token );\n\t  \t\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n\t  \t}\n\t\n\t  \tif ( !parser.matchString( quoteMark ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.inAttribute = false;\n\t\n\t  \treturn tokens;\n\t  }\n\t\n\t  function readQuotedStringToken ( parser, quoteMark ) {\n\t  \tvar haystack = parser.remaining();\n\t\n\t  \tvar needles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well\n\t  \tneedles.push( quoteMark );\n\t\n\t  \tvar index = getLowestIndex( haystack, needles );\n\t\n\t  \tif ( index === -1 ) {\n\t  \t\tparser.error( 'Quoted attribute value must have a closing quote' );\n\t  \t}\n\t\n\t  \tif ( !index ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.pos += index;\n\t  \treturn haystack.substr( 0, index );\n\t  }\n\t\n\t  function readAttributeOrDirective ( parser ) {\n\t  \t\tvar match,\n\t  \t\t\tattribute,\n\t  \t\t    directive;\n\t\n\t  \t\tattribute = readAttribute( parser );\n\t\n\t  \t\tif ( !attribute ) return null;\n\t\n\t  \t\t// intro, outro, decorator\n\t  \t\tif ( directive = directives[ attribute.n ] ) {\n\t  \t\t\tattribute.t = directive.t;\n\t  \t\t\tif ( directive.v ) attribute.v = directive.v;\n\t  \t\t\tdelete attribute.n; // no name necessary\n\t\n\t  \t\t\tif ( directive.t === TRANSITION || directive.t === DECORATOR ) attribute.f = processDirective( attribute.f, parser );\n\t\n\t  \t\t\tif ( directive.t === TRANSITION ) {\n\t  \t\t\t\twarnOnceIfDebug( (\"\" + (directive.v === 't0' ? 'intro-outro' : directive.v === 't1' ? 'intro' : 'outro') + \" is deprecated. To specify tranisitions, use the transition name suffixed with '-in', '-out', or '-in-out' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.\") );\n\t  \t\t\t} else if ( directive.t === DECORATOR ) {\n\t  \t\t\t\twarnOnceIfDebug( (\"decorator is deprecated. To specify decorators, use the decorator name prefixed with 'as-' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.\") );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// decorators\n\t  \t\telse if ( match = decoratorPattern.exec( attribute.n ) ) {\n\t  \t\t\tdelete attribute.n;\n\t  \t\t\tattribute.t = DECORATOR;\n\t  \t\t\tattribute.f = processDirective( attribute.f, parser, DECORATOR );\n\t  \t\t\tif ( typeof attribute.f === 'object' ) attribute.f.n = match[1];\n\t  \t\t\telse attribute.f = match[1];\n\t  \t\t}\n\t\n\t  \t\t// transitions\n\t  \t\telse if ( match = transitionPattern.exec( attribute.n ) ) {\n\t  \t\t\tdelete attribute.n;\n\t  \t\t\tattribute.t = TRANSITION;\n\t  \t\t\tattribute.f = processDirective( attribute.f, parser, TRANSITION );\n\t  \t\t\tif ( typeof attribute.f === 'object' ) attribute.f.n = match[1];\n\t  \t\t\telse attribute.f = match[1];\n\t  \t\t\tattribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';\n\t  \t\t}\n\t\n\t  \t\t// on-click etc\n\t  \t\telse if ( match = proxyEventPattern.exec( attribute.n ) ) {\n\t  \t\t\tattribute.n = match[1];\n\t  \t\t\tattribute.t = EVENT;\n\t  \t\t\tattribute.f = processDirective( attribute.f, parser, EVENT );\n\t\n\t  \t\t\tif ( reservedEventNames.test( attribute.f.n || attribute.f ) ) {\n\t  \t\t\t\tparser.pos -= ( attribute.f.n || attribute.f ).length;\n\t  \t\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\telse {\n\t  \t\t\tif ( parser.sanitizeEventAttributes && onPattern.test( attribute.n ) ) {\n\t  \t\t\t\treturn { exclude: true };\n\t  \t\t\t} else {\n\t  \t\t\t\tattribute.f = attribute.f || ( attribute.f === '' ? '' : 0 );\n\t  \t\t\t\tattribute.t = ATTRIBUTE;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn attribute;\n\t  }\n\t\n\t  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\t\n\t  function readMustache ( parser ) {\n\t  \tvar mustache, i;\n\t\n\t  \t// If we're inside a <script> or <style> tag, and we're not\n\t  \t// interpolating, bug out\n\t  \tif ( parser.interpolate[ parser.inside ] === false ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tfor ( i = 0; i < parser.tags.length; i += 1 ) {\n\t  \t\tif ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {\n\t  \t\t\treturn mustache;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( parser.inTag && !parser.inAttribute ) {\n\t  \t\tmustache = readAttributeOrDirective( parser );\n\t  \t\tif ( mustache ) {\n\t  \t\t\tparser.allowWhitespace();\n\t  \t\t\treturn mustache;\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  function readMustacheOfType ( parser, tag ) {\n\t  \tvar start, mustache, reader, i;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tif ( parser.matchString( '\\\\' + tag.open ) ) {\n\t  \t\tif ( start === 0 || parser.str[ start - 1 ] !== '\\\\' ) {\n\t  \t\t\treturn tag.open;\n\t  \t\t}\n\t  \t} else if ( !parser.matchString( tag.open ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// delimiter change?\n\t  \tif ( mustache = readDelimiterChange( parser ) ) {\n\t  \t\t// find closing delimiter or abort...\n\t  \t\tif ( !parser.matchString( tag.close ) ) {\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\t// ...then make the switch\n\t  \t\ttag.open = mustache[0];\n\t  \t\ttag.close = mustache[1];\n\t  \t\tparser.sortMustacheTags();\n\t\n\t  \t\treturn delimiterChangeToken;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \t// illegal section closer\n\t  \tif ( parser.matchString( '/' ) ) {\n\t  \t\tparser.pos -= 1;\n\t  \t\tvar rewind = parser.pos;\n\t  \t\tif ( !readNumberLiteral( parser ) ) {\n\t  \t\t\tparser.pos = rewind - ( tag.close.length );\n\t  \t\t\tif ( parser.inAttribute ) {\n\t  \t\t\t\tparser.pos = start;\n\t  \t\t\t\treturn null;\n\t  \t\t\t} else {\n\t  \t\t\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n\t  \t\t\t}\n\t  \t\t} else {\n\t  \t\t\tparser.pos = rewind;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tfor ( i = 0; i < tag.readers.length; i += 1 ) {\n\t  \t\treader = tag.readers[i];\n\t\n\t  \t\tif ( mustache = reader( parser, tag ) ) {\n\t  \t\t\tif ( tag.isStatic ) {\n\t  \t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( parser.includeLinePositions ) {\n\t  \t\t\t\tmustache.p = parser.getLinePos( start );\n\t  \t\t\t}\n\t\n\t  \t\t\treturn mustache;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tparser.pos = start;\n\t  \treturn null;\n\t  }\n\t\n\t  function refineExpression ( expression, mustache ) {\n\t  \tvar referenceExpression;\n\t\n\t  \tif ( expression ) {\n\t  \t\twhile ( expression.t === BRACKETED && expression.x ) {\n\t  \t\t\texpression = expression.x;\n\t  \t\t}\n\t\n\t  \t\tif ( expression.t === REFERENCE ) {\n\t  \t\t\tmustache.r = expression.n;\n\t  \t\t} else {\n\t  \t\t\tif ( referenceExpression = getReferenceExpression( expression ) ) {\n\t  \t\t\t\tmustache.rx = referenceExpression;\n\t  \t\t\t} else {\n\t  \t\t\t\tmustache.x = flattenExpression( expression );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn mustache;\n\t  \t}\n\t  }\n\t\n\t  // TODO refactor this! it's bewildering\n\t  function getReferenceExpression ( expression ) {\n\t  \tvar members = [], refinement;\n\t\n\t  \twhile ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {\n\t  \t\trefinement = expression.r;\n\t\n\t  \t\tif ( refinement.x ) {\n\t  \t\t\tif ( refinement.x.t === REFERENCE ) {\n\t  \t\t\t\tmembers.unshift( refinement.x );\n\t  \t\t\t} else {\n\t  \t\t\t\tmembers.unshift( flattenExpression( refinement.x ) );\n\t  \t\t\t}\n\t  \t\t} else {\n\t  \t\t\tmembers.unshift( refinement.n );\n\t  \t\t}\n\t\n\t  \t\texpression = expression.x;\n\t  \t}\n\t\n\t  \tif ( expression.t !== REFERENCE ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tr: expression.n,\n\t  \t\tm: members\n\t  \t};\n\t  }\n\t\n\t  function readTriple ( parser, tag ) {\n\t  \tvar expression = readExpression( parser ), triple;\n\t\n\t  \tif ( !expression ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( !parser.matchString( tag.close ) ) {\n\t  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t  \t}\n\t\n\t  \ttriple = { t: TRIPLE };\n\t  \trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\t\n\t  \treturn triple;\n\t  }\n\t\n\t  function readUnescaped ( parser, tag ) {\n\t  \tvar expression, triple;\n\t\n\t  \tif ( !parser.matchString( '&' ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \texpression = readExpression( parser );\n\t\n\t  \tif ( !expression ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( !parser.matchString( tag.close ) ) {\n\t  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t  \t}\n\t\n\t  \ttriple = { t: TRIPLE };\n\t  \trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\t\n\t  \treturn triple;\n\t  }\n\t\n\t  var legalAlias = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\n\t  var asRE = /^as/i;\n\t\n\t  function readAliases( parser ) {\n\t  \tvar aliases = [], alias, start = parser.pos;\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \talias = readAlias( parser );\n\t\n\t  \tif ( alias ) {\n\t  \t\talias.x = refineExpression( alias.x, {} );\n\t  \t\taliases.push( alias );\n\t\n\t  \t\tparser.allowWhitespace();\n\t\n\t  \t\twhile ( parser.matchString(',') ) {\n\t  \t\t\talias = readAlias( parser );\n\t\n\t  \t\t\tif ( !alias ) {\n\t  \t\t\t\tparser.error( 'Expected another alias.' );\n\t  \t\t\t}\n\t\n\t  \t\t\talias.x = refineExpression( alias.x, {} );\n\t  \t\t\taliases.push( alias );\n\t\n\t  \t\t\tparser.allowWhitespace();\n\t  \t\t}\n\t\n\t  \t\treturn aliases;\n\t  \t}\n\t\n\t  \tparser.pos = start;\n\t  \treturn null;\n\t  }\n\t\n\t  function readAlias( parser ) {\n\t  \tvar expr, alias, start = parser.pos;\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \texpr = readExpression( parser, [] );\n\t\n\t  \tif ( !expr ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchPattern( asRE ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \talias = parser.matchPattern( legalAlias );\n\t\n\t  \tif ( !alias ) {\n\t  \t\tparser.error( 'Expected a legal alias name.' );\n\t  \t}\n\t\n\t  \treturn { n: alias, x: expr };\n\t  }\n\t\n\t  function readPartial ( parser, tag ) {\n\t  \tif ( !parser.matchString( '>' ) ) return null;\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \t// Partial names can include hyphens, so we can't use readExpression\n\t  \t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n\t  \t// `foo-bar` should be read as a single name, rather than 'subtract\n\t  \t// bar from foo'\n\t  \tparser.relaxedNames = parser.strictRefinement = true;\n\t  \tvar expression = readExpression( parser );\n\t  \tparser.relaxedNames = parser.strictRefinement = false;\n\t\n\t  \tif ( !expression ) return null;\n\t\n\t  \tvar partial = { t: PARTIAL };\n\t  \trefineExpression( expression, partial ); // TODO...\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \t// check for alias context e.g. `{{>foo bar as bat, bip as bop}}` then\n\t  \t// turn it into `{{#with bar as bat, bip as bop}}{{>foo}}{{/with}}`\n\t  \tvar aliases = readAliases( parser );\n\t  \tif ( aliases ) {\n\t  \t\tpartial = {\n\t  \t\t\tt: ALIAS,\n\t  \t\t\tz: aliases,\n\t  \t\t\tf: [ partial ]\n\t  \t\t};\n\t  \t}\n\t\n\t  \t// otherwise check for literal context e.g. `{{>foo bar}}` then\n\t  \t// turn it into `{{#with bar}}{{>foo}}{{/with}}`\n\t  \telse {\n\t  \t\tvar context = readExpression( parser );\n\t  \t\tif ( context) {\n\t  \t\t\tpartial = {\n\t  \t\t\t\tt: SECTION,\n\t  \t\t\t\tn: SECTION_WITH,\n\t  \t\t\t\tf: [ partial ]\n\t  \t\t\t};\n\t\n\t  \t\t\trefineExpression( context, partial );\n\t  \t\t}\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( tag.close ) ) {\n\t  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t  \t}\n\t\n\t  \treturn partial;\n\t  }\n\t\n\t  function readComment ( parser, tag ) {\n\t  \tvar index;\n\t\n\t  \tif ( !parser.matchString( '!' ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tindex = parser.remaining().indexOf( tag.close );\n\t\n\t  \tif ( index !== -1 ) {\n\t  \t\tparser.pos += index + tag.close.length;\n\t  \t\treturn { t: COMMENT };\n\t  \t}\n\t  }\n\t\n\t  function readExpressionOrReference ( parser, expectedFollowers ) {\n\t  \tvar start, expression, i;\n\t\n\t  \tstart = parser.pos;\n\t  \texpression = readExpression( parser );\n\t\n\t  \tif ( !expression ) {\n\t  \t\t// valid reference but invalid expression e.g. `{{new}}`?\n\t  \t\tvar ref = parser.matchPattern( /^(\\w+)/ );\n\t  \t\tif ( ref ) {\n\t  \t\t\treturn {\n\t  \t\t\t\tt: REFERENCE,\n\t  \t\t\t\tn: ref\n\t  \t\t\t};\n\t  \t\t}\n\t\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tfor ( i = 0; i < expectedFollowers.length; i += 1 ) {\n\t  \t\tif ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {\n\t  \t\t\treturn expression;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tparser.pos = start;\n\t  \treturn readReference( parser );\n\t  }\n\t\n\t  function readInterpolator ( parser, tag ) {\n\t  \tvar start, expression, interpolator, err;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \t// TODO would be good for perf if we could do away with the try-catch\n\t  \ttry {\n\t  \t\texpression = readExpressionOrReference( parser, [ tag.close ]);\n\t  \t} catch ( e ) {\n\t  \t\terr = e;\n\t  \t}\n\t\n\t  \tif ( !expression ) {\n\t  \t\tif ( parser.str.charAt( start ) === '!' ) {\n\t  \t\t\t// special case - comment\n\t  \t\t\tparser.pos = start;\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\tif ( err ) {\n\t  \t\t\tthrow err;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( !parser.matchString( tag.close ) ) {\n\t  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"' after reference\") );\n\t\n\t  \t\tif ( !expression ) {\n\t  \t\t\t// special case - comment\n\t  \t\t\tif ( parser.nextChar() === '!' ) {\n\t  \t\t\t\treturn null;\n\t  \t\t\t}\n\t\n\t  \t\t\tparser.error( (\"Expected expression or legal reference\") );\n\t  \t\t}\n\t  \t}\n\t\n\t  \tinterpolator = { t: INTERPOLATOR };\n\t  \trefineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious\n\t\n\t  \treturn interpolator;\n\t  }\n\t\n\t  var yieldPattern = /^yield\\s*/;\n\t\n\t  function readYielder ( parser, tag ) {\n\t  \tif ( !parser.matchPattern( yieldPattern ) ) return null;\n\t\n\t  \tvar name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/ );\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( tag.close ) ) {\n\t  \t\tparser.error( (\"expected legal partial name\") );\n\t  \t}\n\t\n\t  \tvar yielder = { t: YIELDER };\n\t  \tif ( name ) yielder.n = name;\n\t\n\t  \treturn yielder;\n\t  }\n\t\n\t  function readClosing ( parser, tag ) {\n\t  \tvar start, remaining, index, closing;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tif ( !parser.matchString( tag.open ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( '/' ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tremaining = parser.remaining();\n\t  \tindex = remaining.indexOf( tag.close );\n\t\n\t  \tif ( index !== -1 ) {\n\t  \t\tclosing = {\n\t  \t\t\tt: CLOSING,\n\t  \t\t\tr: remaining.substr( 0, index ).split( ' ' )[0]\n\t  \t\t};\n\t\n\t  \t\tparser.pos += index;\n\t\n\t  \t\tif ( !parser.matchString( tag.close ) ) {\n\t  \t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t  \t\t}\n\t\n\t  \t\treturn closing;\n\t  \t}\n\t\n\t  \tparser.pos = start;\n\t  \treturn null;\n\t  }\n\t\n\t  var elsePattern = /^\\s*else\\s*/;\n\t\n\t  function readElse ( parser, tag ) {\n\t  \tvar start = parser.pos;\n\t\n\t  \tif ( !parser.matchString( tag.open ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( !parser.matchPattern( elsePattern ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( !parser.matchString( tag.close ) ) {\n\t  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tt: ELSE\n\t  \t};\n\t  }\n\t\n\t  var elsePattern$1 = /^\\s*elseif\\s+/;\n\t\n\t  function readElseIf ( parser, tag ) {\n\t  \tvar start = parser.pos;\n\t\n\t  \tif ( !parser.matchString( tag.open ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( !parser.matchPattern( elsePattern$1 ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tvar expression = readExpression( parser );\n\t\n\t  \tif ( !parser.matchString( tag.close ) ) {\n\t  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tt: ELSEIF,\n\t  \t\tx: expression\n\t  \t};\n\t  }\n\t\n\t  var handlebarsBlockCodes = {\n\t  \t'each':    SECTION_EACH,\n\t  \t'if':      SECTION_IF,\n\t  \t'with':    SECTION_IF_WITH,\n\t  \t'unless':  SECTION_UNLESS\n\t  };\n\t\n\t  var indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\n\t  var keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\n\t  var handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' );\n\t  function readSection ( parser, tag ) {\n\t  \tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose, aliasOnly = false;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tif ( parser.matchString( '^' ) ) {\n\t  \t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n\t  \t} else if ( parser.matchString( '#' ) ) {\n\t  \t\tsection = { t: SECTION, f: [] };\n\t\n\t  \t\tif ( parser.matchString( 'partial' ) ) {\n\t  \t\t\tparser.pos = start - parser.standardDelimiters[0].length;\n\t  \t\t\tparser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );\n\t  \t\t}\n\t\n\t  \t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n\t  \t\t\texpectedClose = block;\n\t  \t\t\tsection.n = handlebarsBlockCodes[ block ];\n\t  \t\t}\n\t  \t} else {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( block === 'with' ) {\n\t  \t\tvar aliases = readAliases( parser );\n\t  \t\tif ( aliases ) {\n\t  \t\t\taliasOnly = true;\n\t  \t\t\tsection.z = aliases;\n\t  \t\t\tsection.t = ALIAS;\n\t  \t\t}\n\t  \t} else if ( block === 'each' ) {\n\t  \t\tvar alias = readAlias( parser );\n\t  \t\tif ( alias ) {\n\t  \t\t\tsection.z = [ { n: alias.n, x: { r: '.' } } ];\n\t  \t\t\texpression = alias.x;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( !aliasOnly ) {\n\t  \t\tif ( !expression ) expression = readExpression( parser );\n\t\n\t  \t\tif ( !expression ) {\n\t  \t\t\tparser.error( 'Expected expression' );\n\t  \t\t}\n\t\n\t  \t\t// optional index and key references\n\t  \t\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n\t  \t\t\tvar extra;\n\t\n\t  \t\t\tif ( extra = parser.matchPattern( keyIndexRefPattern ) ) {\n\t  \t\t\t\tsection.i = i + ',' + extra;\n\t  \t\t\t} else {\n\t  \t\t\t\tsection.i = i;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tif ( !parser.matchString( tag.close ) ) {\n\t  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n\t  \t}\n\t\n\t  \tparser.sectionDepth += 1;\n\t  \tchildren = section.f;\n\t\n\t  \tconditions = [];\n\t\n\t  \tvar pos;\n\t  \tdo {\n\t  \t\tpos = parser.pos;\n\t  \t\tif ( child = readClosing( parser, tag ) ) {\n\t  \t\t\tif ( expectedClose && child.r !== expectedClose ) {\n\t  \t\t\t\tparser.pos = pos;\n\t  \t\t\t\tparser.error( (\"Expected \" + (tag.open) + \"/\" + expectedClose + \"\" + (tag.close)) );\n\t  \t\t\t}\n\t\n\t  \t\t\tparser.sectionDepth -= 1;\n\t  \t\t\tclosed = true;\n\t  \t\t}\n\t\n\t  \t\telse if ( !aliasOnly && ( child = readElseIf( parser, tag ) ) ) {\n\t  \t\t\tif ( section.n === SECTION_UNLESS ) {\n\t  \t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( hasElse ) {\n\t  \t\t\t\tparser.error( 'illegal {{elseif...}} after {{else}}' );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( !unlessBlock ) {\n\t  \t\t\t\tunlessBlock = [];\n\t  \t\t\t}\n\t\n\t  \t\t\tvar mustache = {\n\t  \t\t\t\tt: SECTION,\n\t  \t\t\t\tn: SECTION_IF,\n\t  \t\t\t\tf: children = []\n\t  \t\t\t};\n\t  \t\t\trefineExpression( child.x, mustache );\n\t\n\t  \t\t\tunlessBlock.push( mustache );\n\t  \t\t}\n\t\n\t  \t\telse if ( !aliasOnly && ( child = readElse( parser, tag ) ) ) {\n\t  \t\t\tif ( section.n === SECTION_UNLESS ) {\n\t  \t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( hasElse ) {\n\t  \t\t\t\tparser.error( 'there can only be one {{else}} block, at the end of a section' );\n\t  \t\t\t}\n\t\n\t  \t\t\thasElse = true;\n\t\n\t  \t\t\t// use an unless block if there's no elseif\n\t  \t\t\tif ( !unlessBlock ) {\n\t  \t\t\t\tunlessBlock = [];\n\t  \t\t\t}\n\t\n\t  \t\t\tunlessBlock.push({\n\t  \t\t\t\tt: SECTION,\n\t  \t\t\t\tn: SECTION_UNLESS,\n\t  \t\t\t\tf: children = []\n\t  \t\t\t});\n\t  \t\t}\n\t\n\t  \t\telse {\n\t  \t\t\tchild = parser.read( READERS );\n\t\n\t  \t\t\tif ( !child ) {\n\t  \t\t\t\tbreak;\n\t  \t\t\t}\n\t\n\t  \t\t\tchildren.push( child );\n\t  \t\t}\n\t  \t} while ( !closed );\n\t\n\t  \tif ( unlessBlock ) {\n\t  \t\tsection.l = unlessBlock;\n\t  \t}\n\t\n\t  \tif ( !aliasOnly ) {\n\t  \t\trefineExpression( expression, section );\n\t  \t}\n\t\n\t  \t// TODO if a section is empty it should be discarded. Don't do\n\t  \t// that here though - we need to clean everything up first, as\n\t  \t// it may contain removeable whitespace. As a temporary measure,\n\t  \t// to pass the existing tests, remove empty `f` arrays\n\t  \tif ( !section.f.length ) {\n\t  \t\tdelete section.f;\n\t  \t}\n\t\n\t  \treturn section;\n\t  }\n\t\n\t  var OPEN_COMMENT = '<!--';\n\t  var CLOSE_COMMENT = '-->';\n\t  function readHtmlComment ( parser ) {\n\t  \tvar start, content, remaining, endIndex, comment;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tif ( parser.textOnlyMode || !parser.matchString( OPEN_COMMENT ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tremaining = parser.remaining();\n\t  \tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\t\n\t  \tif ( endIndex === -1 ) {\n\t  \t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n\t  \t}\n\t\n\t  \tcontent = remaining.substr( 0, endIndex );\n\t  \tparser.pos += endIndex + 3;\n\t\n\t  \tcomment = {\n\t  \t\tt: COMMENT,\n\t  \t\tc: content\n\t  \t};\n\t\n\t  \tif ( parser.includeLinePositions ) {\n\t  \t\tcomment.p = parser.getLinePos( start );\n\t  \t}\n\t\n\t  \treturn comment;\n\t  }\n\t\n\t  var leadingLinebreak = /^[ \\t\\f\\r\\n]*\\r?\\n/;\n\t  var trailingLinebreak = /\\r?\\n[ \\t\\f\\r\\n]*$/;\n\t  function stripStandalones ( items ) {\n\t  \tvar i, current, backOne, backTwo, lastSectionItem;\n\t\n\t  \tfor ( i=1; i<items.length; i+=1 ) {\n\t  \t\tcurrent = items[i];\n\t  \t\tbackOne = items[i-1];\n\t  \t\tbackTwo = items[i-2];\n\t\n\t  \t\t// if we're at the end of a [text][comment][text] sequence...\n\t  \t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\t\n\t  \t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n\t  \t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\t\n\t  \t\t\t\t// ... then we want to remove the whitespace after the first line break\n\t  \t\t\t\titems[i-2] = backTwo.replace( trailingLinebreak, '\\n' );\n\t\n\t  \t\t\t\t// and the leading line break of the second text token\n\t  \t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// if the current item is a section, and it is preceded by a linebreak, and\n\t  \t\t// its first item is a linebreak...\n\t  \t\tif ( isSection( current ) && isString( backOne ) ) {\n\t  \t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {\n\t  \t\t\t\titems[i-1] = backOne.replace( trailingLinebreak, '\\n' );\n\t  \t\t\t\tcurrent.f[0] = current.f[0].replace( leadingLinebreak, '' );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// if the last item was a section, and it is followed by a linebreak, and\n\t  \t\t// its last item is a linebreak...\n\t  \t\tif ( isString( current ) && isSection( backOne ) ) {\n\t  \t\t\tlastSectionItem = lastItem( backOne.f );\n\t\n\t  \t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n\t  \t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n\t  \t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn items;\n\t  }\n\t\n\t  function isString ( item ) {\n\t  \treturn typeof item === 'string';\n\t  }\n\t\n\t  function isComment ( item ) {\n\t  \treturn item.t === COMMENT || item.t === DELIMCHANGE;\n\t  }\n\t\n\t  function isSection ( item ) {\n\t  \treturn ( item.t === SECTION || item.t === INVERTED ) && item.f;\n\t  }\n\t\n\t  function trimWhitespace ( items, leadingPattern, trailingPattern ) {\n\t  \tvar item;\n\t\n\t  \tif ( leadingPattern ) {\n\t  \t\titem = items[0];\n\t  \t\tif ( typeof item === 'string' ) {\n\t  \t\t\titem = item.replace( leadingPattern, '' );\n\t\n\t  \t\t\tif ( !item ) {\n\t  \t\t\t\titems.shift();\n\t  \t\t\t} else {\n\t  \t\t\t\titems[0] = item;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( trailingPattern ) {\n\t  \t\titem = lastItem( items );\n\t  \t\tif ( typeof item === 'string' ) {\n\t  \t\t\titem = item.replace( trailingPattern, '' );\n\t\n\t  \t\t\tif ( !item ) {\n\t  \t\t\t\titems.pop();\n\t  \t\t\t} else {\n\t  \t\t\t\titems[ items.length - 1 ] = item;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n\t  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n\t  var leadingWhitespace$1 = /^[ \\t\\f\\r\\n]+/;\n\t  var trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n\t  var leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\n\t  var trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n\t\n\t  function cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {\n\t  \tif ( typeof items === 'string' ) return;\n\t\n\t  \tvar i,\n\t  \t\titem,\n\t  \t\tpreviousItem,\n\t  \t\tnextItem,\n\t  \t\tpreserveWhitespaceInsideFragment,\n\t  \t\tremoveLeadingWhitespaceInsideFragment,\n\t  \t\tremoveTrailingWhitespaceInsideFragment,\n\t  \t\tkey;\n\t\n\t  \t// First pass - remove standalones and comments etc\n\t  \tstripStandalones( items );\n\t\n\t  \ti = items.length;\n\t  \twhile ( i-- ) {\n\t  \t\titem = items[i];\n\t\n\t  \t\t// Remove delimiter changes, unsafe elements etc\n\t  \t\tif ( item.exclude ) {\n\t  \t\t\titems.splice( i, 1 );\n\t  \t\t}\n\t\n\t  \t\t// Remove comments, unless we want to keep them\n\t  \t\telse if ( stripComments && item.t === COMMENT ) {\n\t  \t\t\titems.splice( i, 1 );\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// If necessary, remove leading and trailing whitespace\n\t  \ttrimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null );\n\t\n\t  \ti = items.length;\n\t  \twhile ( i-- ) {\n\t  \t\titem = items[i];\n\t\n\t  \t\t// Recurse\n\t  \t\tif ( item.f ) {\n\t  \t\t\tvar isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test( item.e );\n\t  \t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\t\n\t  \t\t\tif ( !preserveWhitespace && isPreserveWhitespaceElement ) {\n\t  \t\t\t\ttrimWhitespace( item.f, leadingNewLine, trailingNewLine );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( !preserveWhitespaceInsideFragment ) {\n\t  \t\t\t\tpreviousItem = items[ i - 1 ];\n\t  \t\t\t\tnextItem = items[ i + 1 ];\n\t\n\t  \t\t\t\t// if the previous item was a text item with trailing whitespace,\n\t  \t\t\t\t// remove leading whitespace inside the fragment\n\t  \t\t\t\tif ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {\n\t  \t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\t// and vice versa\n\t  \t\t\t\tif ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace$1.test( nextItem ) ) ) {\n\t  \t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\n\t  \t\t\t// clean up name templates (events, decorators, etc)\n\t  \t\t\tif ( isArray( item.f.n ) ) {\n\t  \t\t\t\tcleanup( item.f.n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );\n\t  \t\t\t}\n\t\n\t  \t\t\t// clean up arg templates (events, decorators, etc)\n\t  \t\t\tif ( isArray( item.f.d ) ) {\n\t  \t\t\t\tcleanup( item.f.d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// Split if-else blocks into two (an if, and an unless)\n\t  \t\tif ( item.l ) {\n\t  \t\t\tcleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t\n\t  \t\t\titem.l.forEach( function ( s ) { return s.l = 1; } );\n\t  \t\t\titem.l.unshift( i + 1, 0 );\n\t  \t\t\titems.splice.apply( items, item.l );\n\t  \t\t\tdelete item.l; // TODO would be nice if there was a way around this\n\t  \t\t}\n\t\n\t  \t\t// Clean up element attributes\n\t  \t\tif ( item.a ) {\n\t  \t\t\tfor ( key in item.a ) {\n\t  \t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n\t  \t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t  \t\t// Clean up conditional attributes\n\t  \t\tif ( item.m ) {\n\t  \t\t\tcleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\t  \t\t\tif ( item.m.length < 1 ) delete item.m;\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// final pass - fuse text nodes together\n\t  \ti = items.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( typeof items[i] === 'string' ) {\n\t  \t\t\tif ( typeof items[i+1] === 'string' ) {\n\t  \t\t\t\titems[i] = items[i] + items[i+1];\n\t  \t\t\t\titems.splice( i + 1, 1 );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( !preserveWhitespace ) {\n\t  \t\t\t\titems[i] = items[i].replace( contiguousWhitespace, ' ' );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( items[i] === '' ) {\n\t  \t\t\t\titems.splice( i, 1 );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\t\n\t  function readClosingTag ( parser ) {\n\t  \tvar start, tag;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \t// are we looking at a closing tag?\n\t  \tif ( !parser.matchString( '</' ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n\t  \t\tif ( parser.inside && tag !== parser.inside ) {\n\t  \t\t\tparser.pos = start;\n\t  \t\t\treturn null;\n\t  \t\t}\n\t\n\t  \t\treturn {\n\t  \t\t\tt: CLOSING_TAG,\n\t  \t\t\te: tag\n\t  \t\t};\n\t  \t}\n\t\n\t  \t// We have an illegal closing tag, report it\n\t  \tparser.pos -= 2;\n\t  \tparser.error( 'Illegal closing tag' );\n\t  }\n\t\n\t  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\n\t  var validTagNameFollower = /^[\\s\\n\\/>]/;\n\t  var exclude = { exclude: true };\n\t  var disallowedContents;\n\t  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n\t  disallowedContents = {\n\t  \tli: [ 'li' ],\n\t  \tdt: [ 'dt', 'dd' ],\n\t  \tdd: [ 'dt', 'dd' ],\n\t  \tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n\t  \trt: [ 'rt', 'rp' ],\n\t  \trp: [ 'rt', 'rp' ],\n\t  \toptgroup: [ 'optgroup' ],\n\t  \toption: [ 'option', 'optgroup' ],\n\t  \tthead: [ 'tbody', 'tfoot' ],\n\t  \ttbody: [ 'tbody', 'tfoot' ],\n\t  \ttfoot: [ 'tbody' ],\n\t  \ttr: [ 'tr', 'tbody' ],\n\t  \ttd: [ 'td', 'th', 'tr' ],\n\t  \tth: [ 'td', 'th', 'tr' ]\n\t  };\n\t\n\t  function readElement ( parser ) {\n\t  \tvar start,\n\t  \t\telement,\n\t  \t\tattribute,\n\t  \t\tselfClosing,\n\t  \t\tchildren,\n\t  \t\tpartials,\n\t  \t\thasPartials,\n\t  \t\tchild,\n\t  \t\tclosed,\n\t  \t\tpos,\n\t  \t\tremaining,\n\t  \t\tclosingTag;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tif ( parser.inside || parser.inAttribute || parser.textOnlyMode ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( !parser.matchString( '<' ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// if this is a closing tag, abort straight away\n\t  \tif ( parser.nextChar() === '/' ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \telement = {};\n\t  \tif ( parser.includeLinePositions ) {\n\t  \t\telement.p = parser.getLinePos( start );\n\t  \t}\n\t\n\t  \tif ( parser.matchString( '!' ) ) {\n\t  \t\telement.t = DOCTYPE;\n\t  \t\tif ( !parser.matchPattern( /^doctype/i ) ) {\n\t  \t\t\tparser.error( 'Expected DOCTYPE declaration' );\n\t  \t\t}\n\t\n\t  \t\telement.a = parser.matchPattern( /^(.+?)>/ );\n\t  \t\treturn element;\n\t  \t}\n\t\n\t  \telement.t = ELEMENT;\n\t\n\t  \t// element name\n\t  \telement.e = parser.matchPattern( tagNamePattern );\n\t  \tif ( !element.e ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// next character must be whitespace, closing solidus or '>'\n\t  \tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n\t  \t\tparser.error( 'Illegal tag name' );\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t\n\t  \tparser.inTag = true;\n\t\n\t  \t// directives and attributes\n\t  \twhile ( attribute = readMustache( parser ) ) {\n\t  \t\tif ( attribute !== false ) {\n\t  \t\t\tif ( !element.m ) element.m = [];\n\t  \t\t\telement.m.push( attribute );\n\t  \t\t}\n\t\n\t  \t\tparser.allowWhitespace();\n\t  \t}\n\t\n\t  \tparser.inTag = false;\n\t\n\t  \t// allow whitespace before closing solidus\n\t  \tparser.allowWhitespace();\n\t\n\t  \t// self-closing solidus?\n\t  \tif ( parser.matchString( '/' ) ) {\n\t  \t\tselfClosing = true;\n\t  \t}\n\t\n\t  \t// closing angle bracket\n\t  \tif ( !parser.matchString( '>' ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tvar lowerCaseName = element.e.toLowerCase();\n\t  \tvar preserveWhitespace = parser.preserveWhitespace;\n\t\n\t  \tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n\t  \t\tparser.elementStack.push( lowerCaseName );\n\t\n\t  \t\t// Special case - if we open a script element, further tags should\n\t  \t\t// be ignored unless they're a closing script element\n\t  \t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' || lowerCaseName === 'textarea' ) {\n\t  \t\t\tparser.inside = lowerCaseName;\n\t  \t\t}\n\t\n\t  \t\tchildren = [];\n\t  \t\tpartials = create( null );\n\t\n\t  \t\tdo {\n\t  \t\t\tpos = parser.pos;\n\t  \t\t\tremaining = parser.remaining();\n\t\n\t  \t\t\tif ( !remaining ) {\n\t  \t\t\t\tparser.error( (\"Missing end \" + (parser.elementStack.length > 1 ? 'tags' : 'tag') + \" (\" + (parser.elementStack.reverse().map( function ( x ) { return (\"</\" + x + \">\"); } ).join( '' )) + \")\") );\n\t  \t\t\t}\n\t\n\t  \t\t\t// if for example we're in an <li> element, and we see another\n\t  \t\t\t// <li> tag, close the first so they become siblings\n\t  \t\t\tif ( !canContain( lowerCaseName, remaining ) ) {\n\t  \t\t\t\tclosed = true;\n\t  \t\t\t}\n\t\n\t  \t\t\t// closing tag\n\t  \t\t\telse if ( closingTag = readClosingTag( parser ) ) {\n\t  \t\t\t\tclosed = true;\n\t\n\t  \t\t\t\tvar closingTagName = closingTag.e.toLowerCase();\n\t\n\t  \t\t\t\t// if this *isn't* the closing tag for the current element...\n\t  \t\t\t\tif ( closingTagName !== lowerCaseName ) {\n\t  \t\t\t\t\t// rewind parser\n\t  \t\t\t\t\tparser.pos = pos;\n\t\n\t  \t\t\t\t\t// if it doesn't close a parent tag, error\n\t  \t\t\t\t\tif ( !~parser.elementStack.indexOf( closingTagName ) ) {\n\t  \t\t\t\t\t\tvar errorMessage = 'Unexpected closing tag';\n\t\n\t  \t\t\t\t\t\t// add additional help for void elements, since component names\n\t  \t\t\t\t\t\t// might clash with them\n\t  \t\t\t\t\t\tif ( voidElementNames.test( closingTagName ) ) {\n\t  \t\t\t\t\t\t\terrorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n\t  \t\t\t\t\t\t}\n\t\n\t  \t\t\t\t\t\tparser.error( errorMessage );\n\t  \t\t\t\t\t}\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\t// implicit close by closing section tag. TODO clean this up\n\t  \t\t\telse if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {\n\t  \t\t\t\tclosed = true;\n\t  \t\t\t\tparser.pos = pos;\n\t  \t\t\t}\n\t\n\t  \t\t\telse {\n\t  \t\t\t\tif ( child = parser.read( PARTIAL_READERS ) ) {\n\t  \t\t\t\t\tif ( partials[ child.n ] ) {\n\t  \t\t\t\t\t\tparser.pos = pos;\n\t  \t\t\t\t\t\tparser.error( 'Duplicate partial definition' );\n\t  \t\t\t\t\t}\n\t\n\t  \t\t\t\t\tcleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\t\n\t  \t\t\t\t\tpartials[ child.n ] = child.f;\n\t  \t\t\t\t\thasPartials = true;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\telse {\n\t  \t\t\t\t\tif ( child = parser.read( READERS ) ) {\n\t  \t\t\t\t\t\tchildren.push( child );\n\t  \t\t\t\t\t} else {\n\t  \t\t\t\t\t\tclosed = true;\n\t  \t\t\t\t\t}\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t} while ( !closed );\n\t\n\t  \t\tif ( children.length ) {\n\t  \t\t\telement.f = children;\n\t  \t\t}\n\t\n\t  \t\tif ( hasPartials ) {\n\t  \t\t\telement.p = partials;\n\t  \t\t}\n\t\n\t  \t\tparser.elementStack.pop();\n\t  \t}\n\t\n\t  \tparser.inside = null;\n\t\n\t  \tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n\t  \t\treturn exclude;\n\t  \t}\n\t\n\t  \treturn element;\n\t  }\n\t\n\t  function canContain ( name, remaining ) {\n\t  \tvar match, disallowed;\n\t\n\t  \tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n\t  \tdisallowed = disallowedContents[ name ];\n\t\n\t  \tif ( !match || !disallowed ) {\n\t  \t\treturn true;\n\t  \t}\n\t\n\t  \treturn !~disallowed.indexOf( match[1].toLowerCase() );\n\t  }\n\t\n\t  function readText ( parser ) {\n\t  \tvar index, remaining, disallowed, barrier;\n\t\n\t  \tremaining = parser.remaining();\n\t\n\t  \tif ( parser.textOnlyMode ) {\n\t  \t\tdisallowed = parser.tags.map( function ( t ) { return t.open; } );\n\t  \t\tdisallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\\\' + t.open; } ) );\n\t\n\t  \t\tindex = getLowestIndex( remaining, disallowed );\n\t  \t} else {\n\t  \t\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\t\n\t  \t\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n\t  \t\t\tindex = remaining.indexOf( barrier );\n\t  \t\t} else {\n\t  \t\t\tdisallowed = parser.tags.map( function ( t ) { return t.open; } );\n\t  \t\t\tdisallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\\\' + t.open; } ) );\n\t\n\t  \t\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n\t  \t\t\tif ( parser.inAttribute === true ) {\n\t  \t\t\t\t// we're inside an unquoted attribute value\n\t  \t\t\t\tdisallowed.push( (\"\\\"\"), (\"'\"), (\"=\"), (\"<\"), (\">\"), '`' );\n\t  \t\t\t} else if ( parser.inAttribute ) {\n\t  \t\t\t\t// quoted attribute value\n\t  \t\t\t\tdisallowed.push( parser.inAttribute );\n\t  \t\t\t} else {\n\t  \t\t\t\tdisallowed.push( barrier );\n\t  \t\t\t}\n\t\n\t  \t\t\tindex = getLowestIndex( remaining, disallowed );\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( !index ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( index === -1 ) {\n\t  \t\tindex = remaining.length;\n\t  \t}\n\t\n\t  \tparser.pos += index;\n\t\n\t  \tif ( ( parser.inside && parser.inside !== 'textarea' ) || parser.textOnlyMode ) {\n\t  \t\treturn remaining.substr( 0, index );\n\t  \t} else {\n\t  \t\treturn decodeCharacterReferences( remaining.substr( 0, index ) );\n\t  \t}\n\t  }\n\t\n\t  var startPattern = /^<!--\\s*/;\n\t  var namePattern$1 = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/;\n\t  var finishPattern = /\\s*-->/;\n\t\n\t  function readPartialDefinitionComment ( parser ) {\n\t  \tvar start = parser.pos;\n\t  \tvar open = parser.standardDelimiters[0];\n\t  \tvar close = parser.standardDelimiters[1];\n\t\n\t  \tif ( !parser.matchPattern( startPattern ) || !parser.matchString( open ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tvar name = parser.matchPattern( namePattern$1 );\n\t\n\t  \twarnOnceIfDebug( (\"Inline partial comments are deprecated.\\nUse this...\\n  {{#partial \" + name + \"}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>\" + name + \"}} --> ... <!-- {{/\" + name + \"}} -->'\") );\n\t\n\t  \t// make sure the rest of the comment is in the correct place\n\t  \tif ( !parser.matchString( close ) || !parser.matchPattern( finishPattern ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tvar content = [];\n\t  \tvar closed;\n\t\n\t  \tvar endPattern = new RegExp('^<!--\\\\s*' + escapeRegExp( open ) + '\\\\s*\\\\/\\\\s*' + name + '\\\\s*' + escapeRegExp( close ) + '\\\\s*-->');\n\t\n\t  \tdo {\n\t  \t\tif ( parser.matchPattern( endPattern ) ) {\n\t  \t\t\tclosed = true;\n\t  \t\t}\n\t\n\t  \t\telse {\n\t  \t\t\tvar child = parser.read( READERS );\n\t  \t\t\tif ( !child ) {\n\t  \t\t\t\tparser.error( (\"expected closing comment ('<!-- \" + open + \"/\" + name + \"\" + close + \" -->')\") );\n\t  \t\t\t}\n\t\n\t  \t\t\tcontent.push( child );\n\t  \t\t}\n\t  \t} while ( !closed );\n\t\n\t  \treturn {\n\t  \t\tt: INLINE_PARTIAL,\n\t  \t\tf: content,\n\t  \t\tn: name\n\t  \t};\n\t  }\n\t\n\t  var partialDefinitionSectionPattern = /^\\s*#\\s*partial\\s+/;\n\t\n\t  function readPartialDefinitionSection ( parser ) {\n\t  \tvar start, name, content, child, closed;\n\t\n\t  \tstart = parser.pos;\n\t\n\t  \tvar delimiters = parser.standardDelimiters;\n\t\n\t  \tif ( !parser.matchString( delimiters[0] ) ) {\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {\n\t  \t\tparser.pos = start;\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tname = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/ );\n\t\n\t  \tif ( !name ) {\n\t  \t\tparser.error( 'expected legal partial name' );\n\t  \t}\n\t\n\t  \tparser.allowWhitespace();\n\t  \tif ( !parser.matchString( delimiters[1] ) ) {\n\t  \t\tparser.error( (\"Expected closing delimiter '\" + (delimiters[1]) + \"'\") );\n\t  \t}\n\t\n\t  \tcontent = [];\n\t\n\t  \tdo {\n\t  \t\t// TODO clean this up\n\t  \t\tif ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] }) ) {\n\t  \t\t\tif ( !child.r === 'partial' ) {\n\t  \t\t\t\tparser.error( (\"Expected \" + (delimiters[0]) + \"/partial\" + (delimiters[1])) );\n\t  \t\t\t}\n\t\n\t  \t\t\tclosed = true;\n\t  \t\t}\n\t\n\t  \t\telse {\n\t  \t\t\tchild = parser.read( READERS );\n\t\n\t  \t\t\tif ( !child ) {\n\t  \t\t\t\tparser.error( (\"Expected \" + (delimiters[0]) + \"/partial\" + (delimiters[1])) );\n\t  \t\t\t}\n\t\n\t  \t\t\tcontent.push( child );\n\t  \t\t}\n\t  \t} while ( !closed );\n\t\n\t  \treturn {\n\t  \t\tt: INLINE_PARTIAL,\n\t  \t\tn: name,\n\t  \t\tf: content\n\t  \t};\n\t  }\n\t\n\t  function readTemplate ( parser ) {\n\t  \tvar fragment = [];\n\t  \tvar partials = create( null );\n\t  \tvar hasPartials = false;\n\t\n\t  \tvar preserveWhitespace = parser.preserveWhitespace;\n\t\n\t  \twhile ( parser.pos < parser.str.length ) {\n\t  \t\tvar pos = parser.pos, item, partial;\n\t\n\t  \t\tif ( partial = parser.read( PARTIAL_READERS ) ) {\n\t  \t\t\tif ( partials[ partial.n ] ) {\n\t  \t\t\t\tparser.pos = pos;\n\t  \t\t\t\tparser.error( 'Duplicated partial definition' );\n\t  \t\t\t}\n\t\n\t  \t\t\tcleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\t\n\t  \t\t\tpartials[ partial.n ] = partial.f;\n\t  \t\t\thasPartials = true;\n\t  \t\t} else if ( item = parser.read( READERS ) ) {\n\t  \t\t\tfragment.push( item );\n\t  \t\t} else  {\n\t  \t\t\tparser.error( 'Unexpected template content' );\n\t  \t\t}\n\t  \t}\n\t\n\t  \tvar result = {\n\t  \t\tv: TEMPLATE_VERSION,\n\t  \t\tt: fragment\n\t  \t};\n\t\n\t  \tif ( hasPartials ) {\n\t  \t\tresult.p = partials;\n\t  \t}\n\t\n\t  \treturn result;\n\t  }\n\t\n\t  function insertExpressions ( obj, expr ) {\n\t\n\t  \tObject.keys( obj ).forEach( function ( key ) {\n\t  \t\tif  ( isExpression( key, obj ) ) return addTo( obj, expr );\n\t\n\t  \t\tvar ref = obj[ key ];\n\t  \t\tif ( hasChildren( ref ) ) insertExpressions( ref, expr );\n\t   \t});\n\t  }\n\t\n\t  function isExpression( key, obj ) {\n\t  \treturn key === 's' && isArray( obj.r );\n\t  }\n\t\n\t  function addTo( obj, expr ) {\n\t  \tvar s = obj.s, r = obj.r;\n\t  \tif ( !expr[ s ] ) expr[ s ] = fromExpression( s, r.length );\n\t  }\n\t\n\t  function hasChildren( ref ) {\n\t  \treturn isArray( ref ) || isObject( ref );\n\t  }\n\t\n\t  // See https://github.com/ractivejs/template-spec for information\n\t  // about the Ractive template specification\n\t\n\t  var STANDARD_READERS = [ readPartial, readUnescaped, readSection, readYielder, readInterpolator, readComment ];\n\t  var TRIPLE_READERS = [ readTriple ];\n\t  var STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?\n\t\n\t  var StandardParser;\n\t\n\t  function parse ( template, options ) {\n\t  \treturn new StandardParser( template, options || {} ).result;\n\t  }\n\t\n\t  parse.computedStrings = function( computed ) {\n\t  \tif ( !computed ) return [];\n\t\n\t  \tObject.keys( computed ).forEach( function ( key ) {\n\t  \t\tvar value = computed[ key ];\n\t  \t\tif ( typeof value === 'string' ) {\n\t  \t\t\tcomputed[ key ] = fromComputationString( value );\n\t  \t\t}\n\t  \t});\n\t  };\n\t\n\t\n\t  var READERS = [ readMustache, readHtmlComment, readElement, readText ];\n\t  var PARTIAL_READERS = [ readPartialDefinitionComment, readPartialDefinitionSection ];\n\t\n\t  StandardParser = Parser$1.extend({\n\t  \tinit: function ( str, options ) {\n\t  \t\tvar tripleDelimiters = options.tripleDelimiters || [ '{{{', '}}}' ],\n\t  \t\t\tstaticDelimiters = options.staticDelimiters || [ '[[', ']]' ],\n\t  \t\t\tstaticTripleDelimiters = options.staticTripleDelimiters || [ '[[[', ']]]' ];\n\t\n\t  \t\tthis.standardDelimiters = options.delimiters || [ '{{', '}}' ];\n\t\n\t  \t\tthis.tags = [\n\t  \t\t\t{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },\n\t  \t\t\t{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },\n\t  \t\t\t{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },\n\t  \t\t\t{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }\n\t  \t\t];\n\t\n\t  \t\tthis.contextLines = options.contextLines || 0;\n\t\n\t  \t\tthis.sortMustacheTags();\n\t\n\t  \t\tthis.sectionDepth = 0;\n\t  \t\tthis.elementStack = [];\n\t\n\t  \t\tthis.interpolate = {\n\t  \t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n\t  \t\t\tstyle: !options.interpolate || options.interpolate.style !== false,\n\t  \t\t\ttextarea: true\n\t  \t\t};\n\t\n\t  \t\tif ( options.sanitize === true ) {\n\t  \t\t\toptions.sanitize = {\n\t  \t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n\t  \t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n\t  \t\t\t\teventAttributes: true\n\t  \t\t\t};\n\t  \t\t}\n\t\n\t  \t\tthis.stripComments = options.stripComments !== false;\n\t  \t\tthis.preserveWhitespace = options.preserveWhitespace;\n\t  \t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n\t  \t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n\t  \t\tthis.includeLinePositions = options.includeLinePositions;\n\t  \t\tthis.textOnlyMode = options.textOnlyMode;\n\t  \t\tthis.csp = options.csp;\n\t  \t},\n\t\n\t  \tpostProcess: function ( result ) {\n\t  \t\t// special case - empty string\n\t  \t\tif ( !result.length ) {\n\t  \t\t\treturn { t: [], v: TEMPLATE_VERSION };\n\t  \t\t}\n\t\n\t  \t\tif ( this.sectionDepth > 0 ) {\n\t  \t\t\tthis.error( 'A section was left open' );\n\t  \t\t}\n\t\n\t  \t\tcleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );\n\t\n\t  \t\tif ( this.csp !== false ) {\n\t  \t\t\tvar expr = {};\n\t  \t\t\tinsertExpressions( result[0].t, expr );\n\t  \t\t\tif ( Object.keys( expr ).length ) result[0].e = expr;\n\t  \t\t}\n\t\n\t  \t\treturn result[0];\n\t  \t},\n\t\n\t  \tconverters: [\n\t  \t\treadTemplate\n\t  \t],\n\t\n\t  \tsortMustacheTags: function () {\n\t  \t\t// Sort in order of descending opening delimiter length (longer first),\n\t  \t\t// to protect against opening delimiters being substrings of each other\n\t  \t\tthis.tags.sort( function ( a, b ) {\n\t  \t\t\treturn b.open.length - a.open.length;\n\t  \t\t});\n\t  \t}\n\t  });\n\t\n\t  var parseOptions = [\n\t  \t'delimiters',\n\t  \t'tripleDelimiters',\n\t  \t'staticDelimiters',\n\t  \t'staticTripleDelimiters',\n\t  \t'csp',\n\t  \t'interpolate',\n\t  \t'preserveWhitespace',\n\t  \t'sanitize',\n\t  \t'stripComments',\n\t  \t'contextLines'\n\t  ];\n\t\n\t  var TEMPLATE_INSTRUCTIONS = \"Either preparse or use a ractive runtime source that includes the parser. \";\n\t\n\t  var COMPUTATION_INSTRUCTIONS = \"Either use:\\n\\n\\tRactive.parse.computedStrings( component.computed )\\n\\nat build time to pre-convert the strings to functions, or use functions instead of strings in computed properties.\";\n\t\n\t\n\t  function throwNoParse ( method, error, instructions ) {\n\t  \tif ( !method ) {\n\t  \t\tfatal( (\"Missing Ractive.parse - cannot parse \" + error + \". \" + instructions) );\n\t  \t}\n\t  }\n\t\n\t  function createFunction ( body, length ) {\n\t  \tthrowNoParse( fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS );\n\t  \treturn fromExpression( body, length );\n\t  }\n\t\n\t  function createFunctionFromString ( str, bindTo ) {\n\t  \tthrowNoParse( fromComputationString, 'compution string \"${str}\"', COMPUTATION_INSTRUCTIONS );\n\t  \treturn fromComputationString( str, bindTo );\n\t  }\n\t\n\t  var parser = {\n\t\n\t  \tfromId: function ( id, options ) {\n\t  \t\tif ( !doc ) {\n\t  \t\t\tif ( options && options.noThrow ) { return; }\n\t  \t\t\tthrow new Error( (\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\") );\n\t  \t\t}\n\t\n\t  \t\tif ( id ) id = id.replace( /^#/, '' );\n\t\n\t  \t\tvar template;\n\t\n\t  \t\tif ( !( template = doc.getElementById( id ) )) {\n\t  \t\t\tif ( options && options.noThrow ) { return; }\n\t  \t\t\tthrow new Error( (\"Could not find template element with id #\" + id) );\n\t  \t\t}\n\t\n\t  \t\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n\t  \t\t\tif ( options && options.noThrow ) { return; }\n\t  \t\t\tthrow new Error( (\"Template element with id #\" + id + \", must be a <script> element\") );\n\t  \t\t}\n\t\n\t  \t\treturn ( 'textContent' in template ? template.textContent : template.innerHTML );\n\t\n\t  \t},\n\t\n\t  \tisParsed: function ( template) {\n\t  \t\treturn !( typeof template === 'string' );\n\t  \t},\n\t\n\t  \tgetParseOptions: function ( ractive ) {\n\t  \t\t// Could be Ractive or a Component\n\t  \t\tif ( ractive.defaults ) { ractive = ractive.defaults; }\n\t\n\t  \t\treturn parseOptions.reduce( function ( val, key ) {\n\t  \t\t\tval[ key ] = ractive[ key ];\n\t  \t\t\treturn val;\n\t  \t\t}, {});\n\t  \t},\n\t\n\t  \tparse: function ( template, options ) {\n\t  \t\tthrowNoParse( parse, 'template', TEMPLATE_INSTRUCTIONS );\n\t  \t\tvar parsed = parse( template, options );\n\t  \t\taddFunctions( parsed );\n\t  \t\treturn parsed;\n\t  \t},\n\t\n\t  \tparseFor: function( template, ractive ) {\n\t  \t\treturn this.parse( template, this.getParseOptions( ractive ) );\n\t  \t}\n\t  };\n\t\n\t  var templateConfigurator = {\n\t  \tname: 'template',\n\t\n\t  \textend: function ( Parent, proto, options ) {\n\t  \t\t// only assign if exists\n\t  \t\tif ( 'template' in options ) {\n\t  \t\t\tvar template = options.template;\n\t\n\t  \t\t\tif ( typeof template === 'function' ) {\n\t  \t\t\t\tproto.template = template;\n\t  \t\t\t} else {\n\t  \t\t\t\tproto.template = parseTemplate( template, proto );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t},\n\t\n\t  \tinit: function ( Parent, ractive, options ) {\n\t  \t\t// TODO because of prototypal inheritance, we might just be able to use\n\t  \t\t// ractive.template, and not bother passing through the Parent object.\n\t  \t\t// At present that breaks the test mocks' expectations\n\t  \t\tvar template = 'template' in options ? options.template : Parent.prototype.template;\n\t  \t\ttemplate = template || { v: TEMPLATE_VERSION, t: [] };\n\t\n\t  \t\tif ( typeof template === 'function' ) {\n\t  \t\t\tvar fn = template;\n\t  \t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\t\n\t  \t\t\tractive._config.template = {\n\t  \t\t\t\tfn: fn,\n\t  \t\t\t\tresult: template\n\t  \t\t\t};\n\t  \t\t}\n\t\n\t  \t\ttemplate = parseTemplate( template, ractive );\n\t\n\t  \t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n\t  \t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n\t  \t\t// it's unnecessary, because the developer never needs to access\n\t  \t\t// ractive.template\n\t  \t\tractive.template = template.t;\n\t\n\t  \t\tif ( template.p ) {\n\t  \t\t\textendPartials( ractive.partials, template.p );\n\t  \t\t}\n\t  \t},\n\t\n\t  \treset: function ( ractive ) {\n\t  \t\tvar result = resetValue( ractive );\n\t\n\t  \t\tif ( result ) {\n\t  \t\t\tvar parsed = parseTemplate( result, ractive );\n\t\n\t  \t\t\tractive.template = parsed.t;\n\t  \t\t\textendPartials( ractive.partials, parsed.p, true );\n\t\n\t  \t\t\treturn true;\n\t  \t\t}\n\t  \t}\n\t  };\n\t\n\t  function resetValue ( ractive ) {\n\t  \tvar initial = ractive._config.template;\n\t\n\t  \t// If this isn't a dynamic template, there's nothing to do\n\t  \tif ( !initial || !initial.fn ) {\n\t  \t\treturn;\n\t  \t}\n\t\n\t  \tvar result = getDynamicTemplate( ractive, initial.fn );\n\t\n\t  \t// TODO deep equality check to prevent unnecessary re-rendering\n\t  \t// in the case of already-parsed templates\n\t  \tif ( result !== initial.result ) {\n\t  \t\tinitial.result = result;\n\t  \t\treturn result;\n\t  \t}\n\t  }\n\t\n\t  function getDynamicTemplate ( ractive, fn ) {\n\t  \treturn fn.call( ractive, {\n\t  \t\tfromId: parser.fromId,\n\t  \t\tisParsed: parser.isParsed,\n\t  \t\tparse: function ( template, options ) {\n\t  \t\t\tif ( options === void 0 ) options = parser.getParseOptions( ractive );\n\t\n\t  \t\t\treturn parser.parse( template, options );\n\t  \t\t}\n\t  \t});\n\t  }\n\t\n\t  function parseTemplate ( template, ractive ) {\n\t  \tif ( typeof template === 'string' ) {\n\t  \t\t// parse will validate and add expression functions\n\t  \t\ttemplate = parseAsString( template, ractive );\n\t  \t}\n\t  \telse {\n\t  \t\t// need to validate and add exp for already parsed template\n\t  \t\tvalidate$1( template );\n\t  \t\taddFunctions( template );\n\t  \t}\n\t\n\t  \treturn template;\n\t  }\n\t\n\t  function parseAsString ( template, ractive ) {\n\t  \t// ID of an element containing the template?\n\t  \tif ( template[0] === '#' ) {\n\t  \t\ttemplate = parser.fromId( template );\n\t  \t}\n\t\n\t  \treturn parser.parseFor( template, ractive );\n\t  }\n\t\n\t  function validate$1( template ) {\n\t\n\t  \t// Check that the template even exists\n\t  \tif ( template == undefined ) {\n\t  \t\tthrow new Error( (\"The template cannot be \" + template + \".\") );\n\t  \t}\n\t\n\t  \t// Check the parsed template has a version at all\n\t  \telse if ( typeof template.v !== 'number' ) {\n\t  \t\tthrow new Error( 'The template parser was passed a non-string template, but the template doesn\\'t have a version.  Make sure you\\'re passing in the template you think you are.' );\n\t  \t}\n\t\n\t  \t// Check we're using the correct version\n\t  \telse if ( template.v !== TEMPLATE_VERSION ) {\n\t  \t\tthrow new Error( (\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + (template.v) + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\") );\n\t  \t}\n\t  }\n\t\n\t  function extendPartials ( existingPartials, newPartials, overwrite ) {\n\t  \tif ( !newPartials ) return;\n\t\n\t  \t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n\t  \t// case, but not initially...\n\t\n\t  \tfor ( var key in newPartials ) {\n\t  \t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n\t  \t\t\texistingPartials[ key ] = newPartials[ key ];\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var registryNames = [\n\t  \t'adaptors',\n\t  \t'components',\n\t  \t'computed',\n\t  \t'decorators',\n\t  \t'easing',\n\t  \t'events',\n\t  \t'interpolators',\n\t  \t'partials',\n\t  \t'transitions'\n\t  ];\n\t\n\t  var Registry = function Registry ( name, useDefaults ) {\n\t  \tthis.name = name;\n\t  \tthis.useDefaults = useDefaults;\n\t  };\n\t\n\t  Registry.prototype.extend = function extend ( Parent, proto, options ) {\n\t  \tthis.configure(\n\t  \t\tthis.useDefaults ? Parent.defaults : Parent,\n\t  \t\tthis.useDefaults ? proto : proto.constructor,\n\t  \t\toptions );\n\t  };\n\t\n\t  Registry.prototype.init = function init () {\n\t  \t// noop\n\t  };\n\t\n\t  Registry.prototype.configure = function configure ( Parent, target, options ) {\n\t  \tvar name = this.name;\n\t  \tvar option = options[ name ];\n\t\n\t  \tvar registry = create( Parent[name] );\n\t\n\t  \tfor ( var key in option ) {\n\t  \t\tregistry[ key ] = option[ key ];\n\t  \t}\n\t\n\t  \ttarget[ name ] = registry;\n\t  };\n\t\n\t  Registry.prototype.reset = function reset ( ractive ) {\n\t  \tvar registry = ractive[ this.name ];\n\t  \tvar changed = false;\n\t\n\t  \tObject.keys( registry ).forEach( function ( key ) {\n\t  \t\tvar item = registry[ key ];\n\t  \t\t\t\n\t  \t\tif ( item._fn ) {\n\t  \t\t\tif ( item._fn.isOwner ) {\n\t  \t\t\t\tregistry[key] = item._fn;\n\t  \t\t\t} else {\n\t  \t\t\t\tdelete registry[key];\n\t  \t\t\t}\n\t  \t\t\tchanged = true;\n\t  \t\t}\n\t  \t});\n\t\n\t  \treturn changed;\n\t  };\n\t\n\t  var registries = registryNames.map( function ( name ) { return new Registry( name, name === 'computed' ); } );\n\t\n\t  function wrap ( parent, name, method ) {\n\t  \tif ( !/_super/.test( method ) ) return method;\n\t\n\t  \tfunction wrapper () {\n\t  \t\tvar superMethod = getSuperMethod( wrapper._parent, name );\n\t  \t\tvar hasSuper = '_super' in this;\n\t  \t\tvar oldSuper = this._super;\n\t\n\t  \t\tthis._super = superMethod;\n\t\n\t  \t\tvar result = method.apply( this, arguments );\n\t\n\t  \t\tif ( hasSuper ) {\n\t  \t\t\tthis._super = oldSuper;\n\t  \t\t} else {\n\t  \t\t\tdelete this._super;\n\t  \t\t}\n\t\n\t  \t\treturn result;\n\t  \t}\n\t\n\t  \twrapper._parent = parent;\n\t  \twrapper._method = method;\n\t\n\t  \treturn wrapper;\n\t  }\n\t\n\t  function getSuperMethod ( parent, name ) {\n\t  \tif ( name in parent ) {\n\t  \t\tvar value = parent[ name ];\n\t\n\t  \t\treturn typeof value === 'function' ?\n\t  \t\t\tvalue :\n\t  \t\t\tfunction () { return value; };\n\t  \t}\n\t\n\t  \treturn noop;\n\t  }\n\t\n\t  function getMessage( deprecated, correct, isError ) {\n\t  \treturn \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\"\n\t  \t\t+ ( isError ? (\" You cannot specify both options, please use options.\" + correct + \".\") : '' );\n\t  }\n\t\n\t  function deprecateOption ( options, deprecatedOption, correct ) {\n\t  \tif ( deprecatedOption in options ) {\n\t  \t\tif( !( correct in options ) ) {\n\t  \t\t\twarnIfDebug( getMessage( deprecatedOption, correct ) );\n\t  \t\t\toptions[ correct ] = options[ deprecatedOption ];\n\t  \t\t} else {\n\t  \t\t\tthrow new Error( getMessage( deprecatedOption, correct, true ) );\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  function deprecate ( options ) {\n\t  \tdeprecateOption( options, 'beforeInit', 'onconstruct' );\n\t  \tdeprecateOption( options, 'init', 'onrender' );\n\t  \tdeprecateOption( options, 'complete', 'oncomplete' );\n\t  \tdeprecateOption( options, 'eventDefinitions', 'events' );\n\t\n\t  \t// Using extend with Component instead of options,\n\t  \t// like Human.extend( Spider ) means adaptors as a registry\n\t  \t// gets copied to options. So we have to check if actually an array\n\t  \tif ( isArray( options.adaptors ) ) {\n\t  \t\tdeprecateOption( options, 'adaptors', 'adapt' );\n\t  \t}\n\t  }\n\t\n\t  var custom = {\n\t  \tadapt: adaptConfigurator,\n\t  \tcss: cssConfigurator,\n\t  \tdata: dataConfigurator,\n\t  \ttemplate: templateConfigurator\n\t  };\n\t\n\t  var defaultKeys = Object.keys( defaults );\n\t\n\t  var isStandardKey = makeObj( defaultKeys.filter( function ( key ) { return !custom[ key ]; } ) );\n\t\n\t  // blacklisted keys that we don't double extend\n\t  var isBlacklisted = makeObj( defaultKeys.concat( registries.map( function ( r ) { return r.name; } ) ) );\n\t\n\t  var order = [].concat(\n\t  \tdefaultKeys.filter( function ( key ) { return !registries[ key ] && !custom[ key ]; } ),\n\t  \tregistries,\n\t  \t//custom.data,\n\t  \tcustom.template,\n\t  \tcustom.css\n\t  );\n\t\n\t  var config = {\n\t  \textend: function ( Parent, proto, options ) { return configure( 'extend', Parent, proto, options ); },\n\t\n\t  \tinit: function ( Parent, ractive, options ) { return configure( 'init', Parent, ractive, options ); },\n\t\n\t  \treset: function ( ractive ) {\n\t  \t\treturn order.filter( function ( c ) {\n\t  \t\t\treturn c.reset && c.reset( ractive );\n\t  \t\t}).map( function ( c ) { return c.name; } );\n\t  \t},\n\t\n\t  \t// this defines the order. TODO this isn't used anywhere in the codebase,\n\t  \t// only in the test suite - should get rid of it\n\t  \torder: order\n\t  };\n\t\n\t  function configure ( method, Parent, target, options ) {\n\t  \tdeprecate( options );\n\t\n\t  \tfor ( var key in options ) {\n\t  \t\tif ( isStandardKey.hasOwnProperty( key ) ) {\n\t  \t\t\tvar value = options[ key ];\n\t\n\t  \t\t\t// warn the developer if they passed a function and ignore its value\n\t\n\t  \t\t\t// NOTE: we allow some functions on \"el\" because we duck type element lists\n\t  \t\t\t// and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n\t  \t\t\t// function object as the result of querySelector methods\n\t  \t\t\tif ( key !== 'el' && typeof value === 'function' ) {\n\t  \t\t\t\twarnIfDebug( (\"\" + key + \" is a Ractive option that does not expect a function and will be ignored\"),\n\t  \t\t\t\t\tmethod === 'init' ? target : null );\n\t  \t\t\t}\n\t  \t\t\telse {\n\t  \t\t\t\ttarget[ key ] = value;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// disallow combination of `append` and `enhance`\n\t  \tif ( options.append && options.enhance ) {\n\t  \t\tthrow new Error( 'Cannot use append and enhance at the same time' );\n\t  \t}\n\t\n\t  \tregistries.forEach( function ( registry ) {\n\t  \t\tregistry[ method ]( Parent, target, options );\n\t  \t});\n\t\n\t  \tadaptConfigurator[ method ]( Parent, target, options );\n\t  \ttemplateConfigurator[ method ]( Parent, target, options );\n\t  \tcssConfigurator[ method ]( Parent, target, options );\n\t\n\t  \textendOtherMethods( Parent.prototype, target, options );\n\t  }\n\t\n\t  function extendOtherMethods ( parent, target, options ) {\n\t  \tfor ( var key in options ) {\n\t  \t\tif ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {\n\t  \t\t\tvar member = options[ key ];\n\t\n\t  \t\t\t// if this is a method that overwrites a method, wrap it:\n\t  \t\t\tif ( typeof member === 'function' ) {\n\t  \t\t\t\tmember = wrap( parent, key, member );\n\t  \t\t\t}\n\t\n\t  \t\t\ttarget[ key ] = member;\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  function makeObj ( array ) {\n\t  \tvar obj = {};\n\t  \tarray.forEach( function ( x ) { return obj[x] = true; } );\n\t  \treturn obj;\n\t  }\n\t\n\t  var shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ];\n\t\n\t  var completeHook$1 = new Hook( 'complete' );\n\t  var resetHook = new Hook( 'reset' );\n\t  var renderHook$1 = new Hook( 'render' );\n\t  var unrenderHook = new Hook( 'unrender' );\n\t\n\t  function Ractive$reset ( data ) {\n\t  \tdata = data || {};\n\t\n\t  \tif ( typeof data !== 'object' ) {\n\t  \t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n\t  \t}\n\t\n\t  \t// TEMP need to tidy this up\n\t  \tdata = dataConfigurator.init( this.constructor, this, { data: data });\n\t\n\t  \tvar promise = runloop.start( this, true );\n\t\n\t  \t// If the root object is wrapped, try and use the wrapper's reset value\n\t  \tvar wrapper = this.viewmodel.wrapper;\n\t  \tif ( wrapper && wrapper.reset ) {\n\t  \t\tif ( wrapper.reset( data ) === false ) {\n\t  \t\t\t// reset was rejected, we need to replace the object\n\t  \t\t\tthis.viewmodel.set( data );\n\t  \t\t}\n\t  \t} else {\n\t  \t\tthis.viewmodel.set( data );\n\t  \t}\n\t\n\t  \t// reset config items and track if need to rerender\n\t  \tvar changes = config.reset( this );\n\t  \tvar rerender;\n\t\n\t  \tvar i = changes.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n\t  \t\t\trerender = true;\n\t  \t\t\tbreak;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( rerender ) {\n\t  \t\tunrenderHook.fire( this );\n\t  \t\tthis.fragment.resetTemplate( this.template );\n\t  \t\trenderHook$1.fire( this );\n\t  \t\tcompleteHook$1.fire( this );\n\t  \t}\n\t\n\t  \trunloop.end();\n\t\n\t  \tresetHook.fire( this, data );\n\t\n\t  \treturn promise;\n\t  }\n\t\n\t  function collect( source, name, attr, dest ) {\n\t  \tsource.forEach( function ( item ) {\n\t  \t\t// queue to rerender if the item is a partial and the current name matches\n\t  \t\tif ( item.type === PARTIAL && ( item.refName ===  name || item.name === name ) ) {\n\t  \t\t\titem.inAttribute = attr;\n\t  \t\t\tdest.push( item );\n\t  \t\t\treturn; // go no further\n\t  \t\t}\n\t\n\t  \t\t// if it has a fragment, process its items\n\t  \t\tif ( item.fragment ) {\n\t  \t\t\tcollect( item.fragment.iterations || item.fragment.items, name, attr, dest );\n\t  \t\t}\n\t\n\t  \t\t// or if it is itself a fragment, process its items\n\t  \t\telse if ( isArray( item.items ) ) {\n\t  \t\t\tcollect( item.items, name, attr, dest );\n\t  \t\t}\n\t\n\t  \t\t// or if it is a component, step in and process its items\n\t  \t\telse if ( item.type === COMPONENT && item.instance ) {\n\t  \t\t\t// ...unless the partial is shadowed\n\t  \t\t\tif ( item.instance.partials[ name ] ) return;\n\t  \t\t\tcollect( item.instance.fragment.items, name, attr, dest );\n\t  \t\t}\n\t\n\t  \t\t// if the item is an element, process its attributes too\n\t  \t\tif ( item.type === ELEMENT ) {\n\t  \t\t\tif ( isArray( item.attributes ) ) {\n\t  \t\t\t\tcollect( item.attributes, name, true, dest );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t});\n\t  }\n\t\n\t  function forceResetTemplate ( partial ) {\n\t  \tpartial.forceResetTemplate();\n\t  }\n\t\n\t  function resetPartial ( name, partial ) {\n\t  \tvar collection = [];\n\t  \tcollect( this.fragment.items, name, false, collection );\n\t\n\t  \tvar promise = runloop.start( this, true );\n\t\n\t  \tthis.partials[ name ] = partial;\n\t  \tcollection.forEach( forceResetTemplate );\n\t\n\t  \trunloop.end();\n\t\n\t  \treturn promise;\n\t  }\n\t\n\t  var Item = function Item ( options ) {\n\t  \tthis.parentFragment = options.parentFragment;\n\t  \tthis.ractive = options.parentFragment.ractive;\n\t\n\t  \tthis.template = options.template;\n\t  \tthis.index = options.index;\n\t  \tthis.type = options.template.t;\n\t\n\t  \tthis.dirty = false;\n\t  };\n\t\n\t  Item.prototype.bubble = function bubble () {\n\t  \tif ( !this.dirty ) {\n\t  \t\tthis.dirty = true;\n\t  \t\tthis.parentFragment.bubble();\n\t  \t}\n\t  };\n\t\n\t  Item.prototype.destroyed = function destroyed () {\n\t  \tif ( this.fragment ) this.fragment.destroyed();\n\t  };\n\t\n\t  Item.prototype.find = function find () {\n\t  \treturn null;\n\t  };\n\t\n\t  Item.prototype.findAll = function findAll () {\n\t  \t// noop\n\t  };\n\t\n\t  Item.prototype.findComponent = function findComponent () {\n\t  \treturn null;\n\t  };\n\t\n\t  Item.prototype.findAllComponents = function findAllComponents () {\n\t  \t// noop;\n\t  };\n\t\n\t  Item.prototype.findNextNode = function findNextNode () {\n\t  \treturn this.parentFragment.findNextNode( this );\n\t  };\n\t\n\t  Item.prototype.shuffled = function shuffled () {\n\t  \tif ( this.fragment ) this.fragment.shuffled();\n\t  };\n\t\n\t  Item.prototype.valueOf = function valueOf () {\n\t  \treturn this.toString();\n\t  };\n\t\n\t  var ComputationChild = (function (Model) {\n\t  \tfunction ComputationChild () {\n\t  \t\tModel.apply(this, arguments);\n\t  \t}\n\t\n\t  \tComputationChild.prototype = Object.create( Model && Model.prototype );\n\t  \tComputationChild.prototype.constructor = ComputationChild;\n\t\n\t  \tComputationChild.prototype.get = function get ( shouldCapture ) {\n\t  \t\tif ( shouldCapture ) capture( this );\n\t\n\t  \t\tvar parentValue = this.parent.get();\n\t  \t\treturn parentValue ? parentValue[ this.key ] : undefined;\n\t  \t};\n\t\n\t  \tComputationChild.prototype.handleChange = function handleChange$1 () {\n\t  \t\tthis.dirty = true;\n\t\n\t  \t\tthis.links.forEach( marked );\n\t  \t\tthis.deps.forEach( handleChange );\n\t  \t\tthis.children.forEach( handleChange );\n\t  \t\tthis.clearUnresolveds(); // TODO is this necessary?\n\t  \t};\n\t\n\t  \tComputationChild.prototype.joinKey = function joinKey ( key ) {\n\t  \t\tif ( key === undefined || key === '' ) return this;\n\t\n\t  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t  \t\t\tvar child = new ComputationChild( this, key );\n\t  \t\t\tthis.children.push( child );\n\t  \t\t\tthis.childByKey[ key ] = child;\n\t  \t\t}\n\t\n\t  \t\treturn this.childByKey[ key ];\n\t  \t};\n\t\n\t  \treturn ComputationChild;\n\t  }(Model));\n\t\n\t  function createResolver ( proxy, ref, index ) {\n\t  \tvar resolver = proxy.fragment.resolve( ref, function ( model ) {\n\t  \t\tremoveFromArray( proxy.resolvers, resolver );\n\t  \t\tproxy.models[ index ] = model;\n\t  \t\tproxy.bubble();\n\t  \t});\n\t\n\t  \tproxy.resolvers.push( resolver );\n\t  }\n\t\n\t  var ExpressionProxy = (function (Model) {\n\t  \tfunction ExpressionProxy ( fragment, template ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tModel.call( this, fragment.ractive.viewmodel, null );\n\t\n\t  \t\tthis.fragment = fragment;\n\t  \t\tthis.template = template;\n\t\n\t  \t\tthis.isReadonly = true;\n\t  \t\tthis.dirty = true;\n\t\n\t  \t\tthis.fn = getFunction( template.s, template.r.length );\n\t\n\t  \t\tthis.resolvers = [];\n\t  \t\tthis.models = this.template.r.map( function ( ref, index ) {\n\t  \t\t\tvar model = resolveReference( this$1.fragment, ref );\n\t\n\t  \t\t\tif ( !model ) {\n\t  \t\t\t\tcreateResolver( this$1, ref, index );\n\t  \t\t\t}\n\t\n\t  \t\t\treturn model;\n\t  \t\t});\n\t  \t\tthis.dependencies = [];\n\t\n\t  \t\tthis.shuffle = undefined;\n\t\n\t  \t\tthis.bubble();\n\t  \t}\n\t\n\t  \tExpressionProxy.prototype = Object.create( Model && Model.prototype );\n\t  \tExpressionProxy.prototype.constructor = ExpressionProxy;\n\t\n\t  \tExpressionProxy.prototype.bubble = function bubble ( actuallyChanged ) {\n\t  \t\t// refresh the keypath\n\t  \t\tif ( actuallyChanged === void 0 ) actuallyChanged = true;\n\t\n\t  \t\tif ( this.registered ) delete this.root.expressions[ this.keypath ];\n\t  \t\tthis.keypath = undefined;\n\t\n\t  \t\tif ( actuallyChanged ) {\n\t  \t\t\tthis.dirty = true;\n\t  \t\t\tthis.handleChange();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.get = function get ( shouldCapture ) {\n\t  \t\tif ( shouldCapture ) capture( this );\n\t\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t  \t\t\tthis.value = this.getValue();\n\t  \t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t  \t\t\tthis.adapt();\n\t  \t\t}\n\t\n\t  \t\treturn shouldCapture && this.wrapper ? this.wrapperValue : this.value;\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.getKeypath = function getKeypath () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( !this.template ) return '@undefined';\n\t  \t\tif ( !this.keypath ) {\n\t  \t\t\tthis.keypath = '@' + this.template.s.replace( /_(\\d+)/g, function ( match, i ) {\n\t  \t\t\t\tif ( i >= this$1.models.length ) return match;\n\t\n\t  \t\t\t\tvar model = this$1.models[i];\n\t  \t\t\t\treturn model ? model.getKeypath() : '@undefined';\n\t  \t\t\t});\n\t\n\t  \t\t\tthis.root.expressions[ this.keypath ] = this;\n\t  \t\t\tthis.registered = true;\n\t  \t\t}\n\t\n\t  \t\treturn this.keypath;\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.getValue = function getValue () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tstartCapturing();\n\t  \t\tvar result;\n\t\n\t  \t\ttry {\n\t  \t\t\tvar params = this.models.map( function ( m ) { return m ? m.get( true ) : undefined; } );\n\t  \t\t\tresult = this.fn.apply( this.fragment.ractive, params );\n\t  \t\t} catch ( err ) {\n\t  \t\t\twarnIfDebug( (\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)) );\n\t  \t\t}\n\t\n\t  \t\tvar dependencies = stopCapturing();\n\t  \t\t// remove missing deps\n\t  \t\tthis.dependencies.filter( function ( d ) { return !~dependencies.indexOf( d ); } ).forEach( function ( d ) {\n\t  \t\t\td.unregister( this$1 );\n\t  \t\t\tremoveFromArray( this$1.dependencies, d );\n\t  \t\t});\n\t  \t\t// register new deps\n\t  \t\tdependencies.filter( function ( d ) { return !~this$1.dependencies.indexOf( d ); } ).forEach( function ( d ) {\n\t  \t\t\td.register( this$1 );\n\t  \t\t\tthis$1.dependencies.push( d );\n\t  \t\t});\n\t\n\t  \t\treturn result;\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.handleChange = function handleChange$1 () {\n\t  \t\tthis.dirty = true;\n\t\n\t  \t\tthis.links.forEach( marked );\n\t  \t\tthis.deps.forEach( handleChange );\n\t  \t\tthis.children.forEach( handleChange );\n\t\n\t  \t\tthis.clearUnresolveds();\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.joinKey = function joinKey ( key ) {\n\t  \t\tif ( key === undefined || key === '' ) return this;\n\t\n\t  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t  \t\t\tvar child = new ComputationChild( this, key );\n\t  \t\t\tthis.children.push( child );\n\t  \t\t\tthis.childByKey[ key ] = child;\n\t  \t\t}\n\t\n\t  \t\treturn this.childByKey[ key ];\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.mark = function mark () {\n\t  \t\tthis.handleChange();\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t  \t\tvar idx = this.models.indexOf( previous );\n\t\n\t  \t\tif ( ~idx ) {\n\t  \t\t\tnext = rebindMatch( this.template.r[idx], next, previous );\n\t  \t\t\tif ( next !== previous ) {\n\t  \t\t\t\tprevious.unregister( this );\n\t  \t\t\t\tthis.models.splice( idx, 1, next );\n\t  \t\t\t\t// TODO: set up a resolver if there is no next?\n\t  \t\t\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t\tthis.bubble( !safe );\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.retrieve = function retrieve () {\n\t  \t\treturn this.get();\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.teardown = function teardown () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tthis.unbind();\n\t  \t\tthis.fragment = undefined;\n\t  \t\tif ( this.dependencies ) this.dependencies.forEach( function ( d ) { return d.unregister( this$1 ); } );\n\t  \t\tModel.prototype.teardown.call(this);\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.unregister = function unregister( dep ) {\n\t  \t\tModel.prototype.unregister.call( this, dep );\n\t  \t\tif ( !this.deps.length ) this.teardown();\n\t  \t};\n\t\n\t  \tExpressionProxy.prototype.unbind = function unbind$1 () {\n\t  \t\tthis.resolvers.forEach( unbind );\n\t  \t};\n\t\n\t  \treturn ExpressionProxy;\n\t  }(Model));\n\t\n\t  var ReferenceExpressionChild = (function (Model) {\n\t  \tfunction ReferenceExpressionChild ( parent, key ) {\n\t  \t\tModel.call ( this, parent, key );\n\t  \t}\n\t\n\t  \tReferenceExpressionChild.prototype = Object.create( Model && Model.prototype );\n\t  \tReferenceExpressionChild.prototype.constructor = ReferenceExpressionChild;\n\t\n\t  \tReferenceExpressionChild.prototype.applyValue = function applyValue ( value ) {\n\t  \t\tif ( isEqual( value, this.value ) ) return;\n\t\n\t  \t\tvar parent = this.parent, keys = [ this.key ];\n\t  \t\twhile ( parent ) {\n\t  \t\t\tif ( parent.base ) {\n\t  \t\t\t\tvar target = parent.model.joinAll( keys );\n\t  \t\t\t\ttarget.applyValue( value );\n\t  \t\t\t\tbreak;\n\t  \t\t\t}\n\t\n\t  \t\t\tkeys.unshift( parent.key );\n\t\n\t  \t\t\tparent = parent.parent;\n\t  \t\t}\n\t  \t};\n\t\n\t  \tReferenceExpressionChild.prototype.joinKey = function joinKey ( key ) {\n\t  \t\tif ( key === undefined || key === '' ) return this;\n\t\n\t  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t  \t\t\tvar child = new ReferenceExpressionChild( this, key );\n\t  \t\t\tthis.children.push( child );\n\t  \t\t\tthis.childByKey[ key ] = child;\n\t  \t\t}\n\t\n\t  \t\treturn this.childByKey[ key ];\n\t  \t};\n\t\n\t  \tReferenceExpressionChild.prototype.retrieve = function retrieve () {\n\t  \t\tvar parent = this.parent.get();\n\t  \t\treturn parent && this.key in parent ? parent[ this.key ] : undefined;\n\t  \t};\n\t\n\t  \treturn ReferenceExpressionChild;\n\t  }(Model));\n\t\n\t  var ReferenceExpressionProxy = (function (Model) {\n\t  \tfunction ReferenceExpressionProxy ( fragment, template ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tModel.call( this, null, null );\n\t  \t\tthis.dirty = true;\n\t  \t\tthis.root = fragment.ractive.viewmodel;\n\t  \t\tthis.template = template;\n\t\n\t  \t\tthis.resolvers = [];\n\t\n\t  \t\tthis.base = resolve$2( fragment, template );\n\t  \t\tvar baseResolver;\n\t\n\t  \t\tif ( !this.base ) {\n\t  \t\t\tbaseResolver = fragment.resolve( template.r, function ( model ) {\n\t  \t\t\t\tthis$1.base = model;\n\t  \t\t\t\tthis$1.bubble();\n\t\n\t  \t\t\t\tremoveFromArray( this$1.resolvers, baseResolver );\n\t  \t\t\t});\n\t\n\t  \t\t\tthis.resolvers.push( baseResolver );\n\t  \t\t}\n\t\n\t  \t\tvar intermediary = this.intermediary = {\n\t  \t\t\thandleChange: function () { return this$1.handleChange(); },\n\t  \t\t\trebinding: function ( next, previous ) {\n\t  \t\t\t\tif ( previous === this$1.base ) {\n\t  \t\t\t\t\tnext = rebindMatch( template, next, previous );\n\t  \t\t\t\t\tif ( next !== this$1.base ) {\n\t  \t\t\t\t\t\tthis$1.base.unregister( intermediary );\n\t  \t\t\t\t\t\tthis$1.base = next;\n\t  \t\t\t\t\t\t// TODO: if there is no next, set up a resolver?\n\t  \t\t\t\t\t}\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\tvar idx = this$1.members.indexOf( previous );\n\t  \t\t\t\t\tif ( ~idx ) {\n\t  \t\t\t\t\t\t// only direct references will rebind... expressions handle themselves\n\t  \t\t\t\t\t\tnext = rebindMatch( template.m[idx].n, next, previous );\n\t  \t\t\t\t\t\tif ( next !== this$1.members[idx] ) {\n\t  \t\t\t\t\t\t\tthis$1.members.splice( idx, 1, next );\n\t  \t\t\t\t\t\t\t// TODO: if there is no next, set up a resolver?\n\t  \t\t\t\t\t\t}\n\t  \t\t\t\t\t}\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tif ( next !== previous ) previous.unregister( intermediary );\n\t  \t\t\t\tif ( next ) next.addShuffleTask( function () { return next.register( intermediary ); } );\n\t\n\t  \t\t\t\tthis$1.bubble();\n\t  \t\t\t}\n\t  \t\t};\n\t\n\t  \t\tthis.members = template.m.map( function ( template, i ) {\n\t  \t\t\tif ( typeof template === 'string' ) {\n\t  \t\t\t\treturn { get: function () { return template; } };\n\t  \t\t\t}\n\t\n\t  \t\t\tvar model;\n\t  \t\t\tvar resolver;\n\t\n\t  \t\t\tif ( template.t === REFERENCE ) {\n\t  \t\t\t\tmodel = resolveReference( fragment, template.n );\n\t\n\t  \t\t\t\tif ( model ) {\n\t  \t\t\t\t\tmodel.register( intermediary );\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\tresolver = fragment.resolve( template.n, function ( model ) {\n\t  \t\t\t\t\t\tthis$1.members[i] = model;\n\t\n\t  \t\t\t\t\t\tmodel.register( intermediary );\n\t  \t\t\t\t\t\tthis$1.handleChange();\n\t\n\t  \t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t  \t\t\t\t\t});\n\t\n\t  \t\t\t\t\tthis$1.resolvers.push( resolver );\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\treturn model;\n\t  \t\t\t}\n\t\n\t  \t\t\tmodel = new ExpressionProxy( fragment, template );\n\t  \t\t\tmodel.register( intermediary );\n\t  \t\t\treturn model;\n\t  \t\t});\n\t\n\t  \t\tthis.isUnresolved = true;\n\t  \t\tthis.bubble();\n\t  \t}\n\t\n\t  \tReferenceExpressionProxy.prototype = Object.create( Model && Model.prototype );\n\t  \tReferenceExpressionProxy.prototype.constructor = ReferenceExpressionProxy;\n\t\n\t  \tReferenceExpressionProxy.prototype.bubble = function bubble () {\n\t  \t\tif ( !this.base ) return;\n\t  \t\tif ( !this.dirty ) this.handleChange();\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.forceResolution = function forceResolution () {\n\t  \t\tthis.resolvers.forEach( function ( resolver ) { return resolver.forceResolution(); } );\n\t  \t\tthis.dirty = true;\n\t  \t\tthis.bubble();\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.get = function get ( shouldCapture ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.bubble();\n\t\n\t  \t\t\tvar i = this.members.length, resolved = true;\n\t  \t\t\twhile ( resolved && i-- ) {\n\t  \t\t\t\tif ( !this$1.members[i] ) resolved = false;\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( this.base && resolved ) {\n\t  \t\t\t\tvar keys = this.members.map( function ( m ) { return escapeKey( String( m.get() ) ); } );\n\t  \t\t\t\tvar model = this.base.joinAll( keys );\n\t\n\t  \t\t\t\tif ( model !== this.model ) {\n\t  \t\t\t\t\tif ( this.model ) {\n\t  \t\t\t\t\t\tthis.model.unregister( this );\n\t  \t\t\t\t\t\tthis.model.unregisterTwowayBinding( this );\n\t  \t\t\t\t\t}\n\t\n\t  \t\t\t\t\tthis.model = model;\n\t  \t\t\t\t\tthis.parent = model.parent;\n\t  \t\t\t\t\tthis.model.register( this );\n\t  \t\t\t\t\tthis.model.registerTwowayBinding( this );\n\t\n\t  \t\t\t\t\tif ( this.keypathModel ) this.keypathModel.handleChange();\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.value = this.model ? this.model.get( shouldCapture ) : undefined;\n\t  \t\t\tthis.dirty = false;\n\t  \t\t\tthis.mark();\n\t  \t\t\treturn this.value;\n\t  \t\t} else {\n\t  \t\t\treturn this.model ? this.model.get( shouldCapture ) : undefined;\n\t  \t\t}\n\t  \t};\n\t\n\t  \t// indirect two-way bindings\n\t  \tReferenceExpressionProxy.prototype.getValue = function getValue () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tthis.value = this.model ? this.model.get() : undefined;\n\t\n\t  \t\tvar i = this.bindings.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar value = this$1.bindings[i].getValue();\n\t  \t\t\tif ( value !== this$1.value ) return value;\n\t  \t\t}\n\t\n\t  \t\t// check one-way bindings\n\t  \t\tvar oneway = findBoundValue( this.deps );\n\t  \t\tif ( oneway ) return oneway.value;\n\t\n\t  \t\treturn this.value;\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.getKeypath = function getKeypath () {\n\t  \t\treturn this.model ? this.model.getKeypath() : '@undefined';\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.handleChange = function handleChange$1 () {\n\t  \t\tthis.dirty = true;\n\t  \t\tthis.mark();\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.joinKey = function joinKey ( key ) {\n\t  \t\tif ( key === undefined || key === '' ) return this;\n\t\n\t  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t  \t\t\tvar child = new ReferenceExpressionChild( this, key );\n\t  \t\t\tthis.children.push( child );\n\t  \t\t\tthis.childByKey[ key ] = child;\n\t  \t\t}\n\t\n\t  \t\treturn this.childByKey[ key ];\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.mark = function mark$1 () {\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.deps.forEach( handleChange );\n\t  \t\t}\n\t\n\t  \t\tthis.links.forEach( marked );\n\t  \t\tthis.children.forEach( mark );\n\t  \t\tthis.clearUnresolveds();\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.retrieve = function retrieve () {\n\t  \t\treturn this.value;\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.rebinding = function rebinding () { }; // NOOP\n\t\n\t  \tReferenceExpressionProxy.prototype.set = function set ( value ) {\n\t  \t\tif ( !this.model ) throw new Error( 'Unresolved reference expression. This should not happen!' );\n\t  \t\tthis.model.set( value );\n\t  \t};\n\t\n\t  \tReferenceExpressionProxy.prototype.unbind = function unbind$1 () {\n\t  \t\tthis.resolvers.forEach( unbind );\n\t  \t\tif ( this.model ) {\n\t  \t\t\tthis.model.unregister( this );\n\t  \t\t\tthis.model.unregisterTwowayBinding( this );\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn ReferenceExpressionProxy;\n\t  }(Model));\n\t\n\t  function resolve$2 ( fragment, template ) {\n\t  \tif ( template.r ) {\n\t  \t\treturn resolveReference( fragment, template.r );\n\t  \t}\n\t\n\t  \telse if ( template.x ) {\n\t  \t\treturn new ExpressionProxy( fragment, template.x );\n\t  \t}\n\t\n\t  \telse if ( template.rx ) {\n\t  \t\treturn new ReferenceExpressionProxy( fragment, template.rx );\n\t  \t}\n\t  }\n\t\n\t  function resolveAliases( section ) {\n\t  \tif ( section.template.z ) {\n\t  \t\tsection.aliases = {};\n\t\n\t  \t\tvar refs = section.template.z;\n\t  \t\tfor ( var i = 0; i < refs.length; i++ ) {\n\t  \t\t\tsection.aliases[ refs[i].n ] = resolve$2( section.parentFragment, refs[i].x );\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var Alias = (function (Item) {\n\t  \tfunction Alias ( options ) {\n\t  \t\tItem.call( this, options );\n\t\n\t  \t\tthis.fragment = null;\n\t  \t}\n\t\n\t  \tAlias.prototype = Object.create( Item && Item.prototype );\n\t  \tAlias.prototype.constructor = Alias;\n\t\n\t  \tAlias.prototype.bind = function bind () {\n\t  \t\tresolveAliases( this );\n\t\n\t  \t\tthis.fragment = new Fragment({\n\t  \t\t\towner: this,\n\t  \t\t\ttemplate: this.template.f\n\t  \t\t}).bind();\n\t  \t};\n\t\n\t  \tAlias.prototype.detach = function detach () {\n\t  \t\treturn this.fragment ? this.fragment.detach() : createDocumentFragment();\n\t  \t};\n\t\n\t  \tAlias.prototype.find = function find ( selector ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\treturn this.fragment.find( selector );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tAlias.prototype.findAll = function findAll ( selector, query ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tthis.fragment.findAll( selector, query );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tAlias.prototype.findComponent = function findComponent ( name ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\treturn this.fragment.findComponent( name );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tAlias.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tthis.fragment.findAllComponents( name, query );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tAlias.prototype.firstNode = function firstNode ( skipParent ) {\n\t  \t\treturn this.fragment && this.fragment.firstNode( skipParent );\n\t  \t};\n\t\n\t  \tAlias.prototype.rebinding = function rebinding () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( this.locked ) return;\n\t  \t\tthis.locked = true;\n\t  \t\trunloop.scheduleTask( function () {\n\t  \t\t\tthis$1.locked = false;\n\t  \t\t\tresolveAliases( this$1 );\n\t  \t\t});\n\t  \t};\n\t\n\t  \tAlias.prototype.render = function render ( target ) {\n\t  \t\tthis.rendered = true;\n\t  \t\tif ( this.fragment ) this.fragment.render( target );\n\t  \t};\n\t\n\t  \tAlias.prototype.toString = function toString ( escape ) {\n\t  \t\treturn this.fragment ? this.fragment.toString( escape ) : '';\n\t  \t};\n\t\n\t  \tAlias.prototype.unbind = function unbind () {\n\t  \t\tthis.aliases = {};\n\t  \t\tif ( this.fragment ) this.fragment.unbind();\n\t  \t};\n\t\n\t  \tAlias.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \t\tif ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );\n\t  \t\tthis.rendered = false;\n\t  \t};\n\t\n\t  \tAlias.prototype.update = function update () {\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t  \t\t\tthis.fragment.update();\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Alias;\n\t  }(Item));\n\t\n\t  function findElement( start, orComponent, name ) {\n\t  \tif ( orComponent === void 0 ) orComponent = true;\n\t\n\t  \twhile ( start && ( start.type !== ELEMENT || ( name && start.name !== name ) ) && ( !orComponent || start.type !== COMPONENT ) ) {\n\t  \t\t// start is a fragment - look at the owner\n\t  \t\tif ( start.owner ) start = start.owner;\n\t  \t\t// start is a component or yielder - look at the container\n\t  \t\telse if ( start.component ) start = start.containerFragment || start.component.parentFragment;\n\t  \t\t// start is an item - look at the parent\n\t  \t\telse if ( start.parent ) start = start.parent;\n\t  \t\t// start is an item without a parent - look at the parent fragment\n\t  \t\telse if ( start.parentFragment ) start = start.parentFragment;\n\t\n\t  \t\telse start = undefined;\n\t  \t}\n\t\n\t  \treturn start;\n\t  }\n\t\n\t  function camelCase ( hyphenatedStr ) {\n\t  \treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n\t  \t\treturn $1.toUpperCase();\n\t  \t});\n\t  }\n\t\n\t  var space = /\\s+/;\n\t  var specials$2 = { 'float': 'cssFloat' };\n\t  var remove = /\\/\\*(?:[\\s\\S]*?)\\*\\//g;\n\t  var escape = /url\\(\\s*(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\2/gi;\n\t  var value = /\\0(\\d+)/g;\n\t\n\t  function readStyle ( css ) {\n\t      var values = [];\n\t\n\t      if ( typeof css !== 'string' ) return {};\n\t\n\t      return css.replace( escape, function ( match ) { return (\"\\u0000\" + (values.push( match ) - 1)); })\n\t          .replace( remove, '' )\n\t          .split( ';' )\n\t          .filter( function ( rule ) { return !!rule.trim(); } )\n\t          .map( function ( rule ) { return rule.replace( value, function ( match, n ) { return values[ n ]; } ); } )\n\t          .reduce(function ( rules, rule ) {\n\t              var i = rule.indexOf(':');\n\t              var name = camelCase( rule.substr( 0, i ).trim() );\n\t              rules[ specials$2[ name ] || name ] = rule.substr( i + 1 ).trim();\n\t              return rules;\n\t          }, {});\n\t  }\n\t\n\t  function readClass ( str ) {\n\t    var list = str.split( space );\n\t\n\t    // remove any empty entries\n\t    var i = list.length;\n\t    while ( i-- ) {\n\t      if ( !list[i] ) list.splice( i, 1 );\n\t    }\n\t\n\t    return list;\n\t  }\n\t\n\t  var textTypes = [ undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit' ];\n\t\n\t  function getUpdateDelegate ( attribute ) {\n\t  \tvar element = attribute.element, name = attribute.name;\n\t\n\t  \tif ( name === 'id' ) return updateId;\n\t\n\t  \tif ( name === 'value' ) {\n\t  \t\tif ( attribute.interpolator ) attribute.interpolator.bound = true;\n\t\n\t  \t\t// special case - selects\n\t  \t\tif ( element.name === 'select' && name === 'value' ) {\n\t  \t\t\treturn element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n\t  \t\t}\n\t\n\t  \t\tif ( element.name === 'textarea' ) return updateStringValue;\n\t\n\t  \t\t// special case - contenteditable\n\t  \t\tif ( element.getAttribute( 'contenteditable' ) != null ) return updateContentEditableValue;\n\t\n\t  \t\t// special case - <input>\n\t  \t\tif ( element.name === 'input' ) {\n\t  \t\t\tvar type = element.getAttribute( 'type' );\n\t\n\t  \t\t\t// type='file' value='{{fileList}}'>\n\t  \t\t\tif ( type === 'file' ) return noop; // read-only\n\t\n\t  \t\t\t// type='radio' name='{{twoway}}'\n\t  \t\t\tif ( type === 'radio' && element.binding && element.binding.attribute.name === 'name' ) return updateRadioValue;\n\t\n\t  \t\t\tif ( ~textTypes.indexOf( type ) ) return updateStringValue;\n\t  \t\t}\n\t\n\t  \t\treturn updateValue;\n\t  \t}\n\t\n\t  \tvar node = element.node;\n\t\n\t  \t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n\t  \tif ( attribute.isTwoway && name === 'name' ) {\n\t  \t\tif ( node.type === 'radio' ) return updateRadioName;\n\t  \t\tif ( node.type === 'checkbox' ) return updateCheckboxName;\n\t  \t}\n\t\n\t  \tif ( name === 'style' ) return updateStyleAttribute;\n\t\n\t  \tif ( name.indexOf( 'style-' ) === 0 ) return updateInlineStyle;\n\t\n\t  \t// special case - class names. IE fucks things up, again\n\t  \tif ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === html ) ) return updateClassName;\n\t\n\t  \tif ( name.indexOf( 'class-' ) === 0 ) return updateInlineClass;\n\t\n\t  \tif ( attribute.isBoolean ) {\n\t  \t\tvar type$1 = element.getAttribute( 'type' );\n\t  \t\tif ( attribute.interpolator && name === 'checked' && ( type$1 === 'checkbox' || type$1 === 'radio' ) ) attribute.interpolator.bound = true;\n\t  \t\treturn updateBoolean;\n\t  \t}\n\t\n\t  \tif ( attribute.namespace && attribute.namespace !== attribute.node.namespaceURI ) return updateNamespacedAttribute;\n\t\n\t  \treturn updateAttribute;\n\t  }\n\t\n\t  function updateId ( reset ) {\n\t  \tvar ref = this, node = ref.node;\n\t  \tvar value = this.getValue();\n\t\n\t  \t// remove the mapping to this node if it hasn't already been replaced\n\t  \tif ( this.ractive.nodes[ node.id ] === node ) delete this.ractive.nodes[ node.id ];\n\t  \tif ( reset ) return node.removeAttribute( 'id' );\n\t\n\t  \tthis.ractive.nodes[ value ] = node;\n\t\n\t  \tnode.id = value;\n\t  }\n\t\n\t  function updateMultipleSelectValue ( reset ) {\n\t  \tvar value = this.getValue();\n\t\n\t  \tif ( !isArray( value ) ) value = [ value ];\n\t\n\t  \tvar options = this.node.options;\n\t  \tvar i = options.length;\n\t\n\t  \tif ( reset ) {\n\t  \t\twhile ( i-- ) options[i].selected = false;\n\t  \t} else {\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar option = options[i];\n\t  \t\t\tvar optionValue = option._ractive ?\n\t  \t\t\t\toption._ractive.value :\n\t  \t\t\t\toption.value; // options inserted via a triple don't have _ractive\n\t\n\t  \t\t\toption.selected = arrayContains( value, optionValue );\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  function updateSelectValue ( reset ) {\n\t  \tvar value = this.getValue();\n\t\n\t  \tif ( !this.locked ) { // TODO is locked still a thing?\n\t  \t\tthis.node._ractive.value = value;\n\t\n\t  \t\tvar options = this.node.options;\n\t  \t\tvar i = options.length;\n\t  \t\tvar wasSelected = false;\n\t\n\t  \t\tif ( reset ) {\n\t  \t\t\twhile ( i-- ) options[i].selected = false;\n\t  \t\t} else {\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tvar option = options[i];\n\t  \t\t\t\tvar optionValue = option._ractive ?\n\t  \t\t\t\t\toption._ractive.value :\n\t  \t\t\t\t\toption.value; // options inserted via a triple don't have _ractive\n\t  \t\t\t\tif ( option.disabled && option.selected ) wasSelected = true;\n\t\n\t  \t\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n\t  \t\t\t\t\toption.selected = true;\n\t  \t\t\t\t\treturn;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tif ( !wasSelected ) this.node.selectedIndex = -1;\n\t  \t}\n\t  }\n\t\n\t\n\t  function updateContentEditableValue ( reset ) {\n\t  \tvar value = this.getValue();\n\t\n\t  \tif ( !this.locked ) {\n\t  \t\tif ( reset ) this.node.innerHTML = '';\n\t  \t\telse this.node.innerHTML = value === undefined ? '' : value;\n\t  \t}\n\t  }\n\t\n\t  function updateRadioValue ( reset ) {\n\t  \tvar node = this.node;\n\t  \tvar wasChecked = node.checked;\n\t\n\t  \tvar value = this.getValue();\n\t\n\t  \tif ( reset ) return node.checked = false;\n\t\n\t  \t//node.value = this.element.getAttribute( 'value' );\n\t  \tnode.value = this.node._ractive.value = value;\n\t  \tnode.checked = value === this.element.getAttribute( 'name' );\n\t\n\t  \t// This is a special case - if the input was checked, and the value\n\t  \t// changed so that it's no longer checked, the twoway binding is\n\t  \t// most likely out of date. To fix it we have to jump through some\n\t  \t// hoops... this is a little kludgy but it works\n\t  \tif ( wasChecked && !node.checked && this.element.binding && this.element.binding.rendered ) {\n\t  \t\tthis.element.binding.group.model.set( this.element.binding.group.getValue() );\n\t  \t}\n\t  }\n\t\n\t  function updateValue ( reset ) {\n\t  \tif ( !this.locked ) {\n\t  \t\tif ( reset ) {\n\t  \t\t\tthis.node.removeAttribute( 'value' );\n\t  \t\t\tthis.node.value = this.node._ractive.value = null;\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tvar value = this.getValue();\n\t\n\t  \t\tthis.node.value = this.node._ractive.value = value;\n\t  \t\tthis.node.setAttribute( 'value', value );\n\t  \t}\n\t  }\n\t\n\t  function updateStringValue ( reset ) {\n\t  \tif ( !this.locked ) {\n\t  \t\tif ( reset ) {\n\t  \t\t\tthis.node._ractive.value = '';\n\t  \t\t\tthis.node.removeAttribute( 'value' );\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tvar value = this.getValue();\n\t\n\t  \t\tthis.node._ractive.value = value;\n\t\n\t  \t\tthis.node.value = safeToStringValue( value );\n\t  \t\tthis.node.setAttribute( 'value', safeToStringValue( value ) );\n\t  \t}\n\t  }\n\t\n\t  function updateRadioName ( reset ) {\n\t  \tif ( reset ) this.node.checked = false;\n\t  \telse this.node.checked = ( this.getValue() == this.node._ractive.value );\n\t  }\n\t\n\t  function updateCheckboxName ( reset ) {\n\t  \tvar ref = this, element = ref.element, node = ref.node;\n\t  \tvar binding = element.binding;\n\t\n\t  \tvar value = this.getValue();\n\t  \tvar valueAttribute = element.getAttribute( 'value' );\n\t\n\t  \tif ( reset ) {\n\t  \t\t// TODO: WAT?\n\t  \t}\n\t\n\t  \tif ( !isArray( value ) ) {\n\t  \t\tbinding.isChecked = node.checked = ( value == valueAttribute );\n\t  \t} else {\n\t  \t\tvar i = value.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tif ( valueAttribute == value[i] ) {\n\t  \t\t\t\tbinding.isChecked = node.checked = true;\n\t  \t\t\t\treturn;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t\tbinding.isChecked = node.checked = false;\n\t  \t}\n\t  }\n\t\n\t  function updateStyleAttribute ( reset ) {\n\t  \tvar props = reset ? {} : readStyle( this.getValue() || '' );\n\t  \tvar style = this.node.style;\n\t  \tvar keys = Object.keys( props );\n\t  \tvar prev = this.previous || [];\n\t\n\t  \tvar i = 0;\n\t  \twhile ( i < keys.length ) {\n\t  \t\tif ( keys[i] in style ) style[ keys[i] ] = props[ keys[i] ];\n\t  \t\ti++;\n\t  \t}\n\t\n\t  \t// remove now-missing attrs\n\t  \ti = prev.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( !~keys.indexOf( prev[i] ) && prev[i] in style ) style[ prev[i] ] = '';\n\t  \t}\n\t\n\t  \tthis.previous = keys;\n\t  }\n\t\n\t  function updateInlineStyle ( reset ) {\n\t  \tif ( !this.styleName ) {\n\t  \t\tthis.styleName = camelize( this.name.substr( 6 ) );\n\t  \t}\n\t\n\t  \tthis.node.style[ this.styleName ] = reset ? '' : this.getValue();\n\t  }\n\t\n\t  function updateClassName ( reset ) {\n\t  \tvar value = reset ? [] : readClass( safeToStringValue( this.getValue() ) );\n\t  \tvar attr = readClass( this.node.className );\n\t  \tvar prev = this.previous || attr.slice( 0 );\n\t\n\t  \tvar i = 0;\n\t  \twhile ( i < value.length ) {\n\t  \t\tif ( !~attr.indexOf( value[i] ) ) attr.push( value[i] );\n\t  \t\ti++;\n\t  \t}\n\t\n\t  \t// remove now-missing classes\n\t  \ti = prev.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( !~value.indexOf( prev[i] ) ) {\n\t  \t\t\tvar idx = attr.indexOf( prev[i] );\n\t  \t\t\tif ( ~idx ) attr.splice( idx, 1 );\n\t  \t\t}\n\t  \t}\n\t\n\t  \tvar className = attr.join( ' ' );\n\t\n\t  \tif ( className !== this.node.className ) {\n\t  \t\tthis.node.className = className;\n\t  \t}\n\t\n\t  \tthis.previous = value;\n\t  }\n\t\n\t  function updateInlineClass ( reset ) {\n\t  \tvar name = this.name.substr( 6 );\n\t  \tvar attr = readClass( this.node.className );\n\t  \tvar value = reset ? false : this.getValue();\n\t\n\t  \tif ( !this.inlineClass ) this.inlineClass = name;\n\t\n\t  \tif ( value && !~attr.indexOf( name ) ) attr.push( name );\n\t  \telse if ( !value && ~attr.indexOf( name ) ) attr.splice( attr.indexOf( name ), 1 );\n\t\n\t  \tthis.node.className = attr.join( ' ' );\n\t  }\n\t\n\t  function updateBoolean ( reset ) {\n\t  \t// with two-way binding, only update if the change wasn't initiated by the user\n\t  \t// otherwise the cursor will often be sent to the wrong place\n\t  \tif ( !this.locked ) {\n\t  \t\tif ( reset ) {\n\t  \t\t\tif ( this.useProperty ) this.node[ this.propertyName ] = false;\n\t  \t\t\tthis.node.removeAttribute( this.propertyName );\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tif ( this.useProperty ) {\n\t  \t\t\tthis.node[ this.propertyName ] = this.getValue();\n\t  \t\t} else {\n\t  \t\t\tif ( this.getValue() ) {\n\t  \t\t\t\tthis.node.setAttribute( this.propertyName, '' );\n\t  \t\t\t} else {\n\t  \t\t\t\tthis.node.removeAttribute( this.propertyName );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  function updateAttribute ( reset ) {\n\t  \tif ( reset ) this.node.removeAttribute( this.name );\n\t  \telse this.node.setAttribute( this.name, safeToStringValue( this.getString() ) );\n\t  }\n\t\n\t  function updateNamespacedAttribute ( reset ) {\n\t  \tif ( reset ) this.node.removeAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ) );\n\t  \telse this.node.setAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ), safeToStringValue( this.getString() ) );\n\t  }\n\t\n\t  var propertyNames = {\n\t  \t'accept-charset': 'acceptCharset',\n\t  \taccesskey: 'accessKey',\n\t  \tbgcolor: 'bgColor',\n\t  \t'class': 'className',\n\t  \tcodebase: 'codeBase',\n\t  \tcolspan: 'colSpan',\n\t  \tcontenteditable: 'contentEditable',\n\t  \tdatetime: 'dateTime',\n\t  \tdirname: 'dirName',\n\t  \t'for': 'htmlFor',\n\t  \t'http-equiv': 'httpEquiv',\n\t  \tismap: 'isMap',\n\t  \tmaxlength: 'maxLength',\n\t  \tnovalidate: 'noValidate',\n\t  \tpubdate: 'pubDate',\n\t  \treadonly: 'readOnly',\n\t  \trowspan: 'rowSpan',\n\t  \ttabindex: 'tabIndex',\n\t  \tusemap: 'useMap'\n\t  };\n\t\n\t  function lookupNamespace ( node, prefix ) {\n\t  \tvar qualified = \"xmlns:\" + prefix;\n\t\n\t  \twhile ( node ) {\n\t  \t\tif ( node.hasAttribute && node.hasAttribute( qualified ) ) return node.getAttribute( qualified );\n\t  \t\tnode = node.parentNode;\n\t  \t}\n\t\n\t  \treturn namespaces[ prefix ];\n\t  }\n\t\n\t  var Attribute = (function (Item) {\n\t  \tfunction Attribute ( options ) {\n\t  \t\tItem.call( this, options );\n\t\n\t  \t\tthis.name = options.template.n;\n\t  \t\tthis.namespace = null;\n\t\n\t  \t\tthis.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );\n\t  \t\tthis.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );\n\t  \t\tthis.parentFragment = options.parentFragment; // shared\n\t  \t\tthis.ractive = this.parentFragment.ractive;\n\t\n\t  \t\tthis.rendered = false;\n\t  \t\tthis.updateDelegate = null;\n\t  \t\tthis.fragment = null;\n\t\n\t  \t\tthis.element.attributeByName[ this.name ] = this;\n\t\n\t  \t\tif ( !isArray( options.template.f ) ) {\n\t  \t\t\tthis.value = options.template.f;\n\t  \t\t\tif ( this.value === 0 ) {\n\t  \t\t\t\tthis.value = '';\n\t  \t\t\t}\n\t  \t\t} else {\n\t  \t\t\tthis.fragment = new Fragment({\n\t  \t\t\t\towner: this,\n\t  \t\t\t\ttemplate: options.template.f\n\t  \t\t\t});\n\t  \t\t}\n\t\n\t  \t\tthis.interpolator = this.fragment &&\n\t  \t\t\tthis.fragment.items.length === 1 &&\n\t  \t\t\tthis.fragment.items[0].type === INTERPOLATOR &&\n\t  \t\t\tthis.fragment.items[0];\n\t\n\t  \t\tif ( this.interpolator ) this.interpolator.owner = this;\n\t  \t}\n\t\n\t  \tAttribute.prototype = Object.create( Item && Item.prototype );\n\t  \tAttribute.prototype.constructor = Attribute;\n\t\n\t  \tAttribute.prototype.bind = function bind () {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tthis.fragment.bind();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tAttribute.prototype.bubble = function bubble () {\n\t  \t\tif ( !this.dirty ) {\n\t  \t\t\tthis.parentFragment.bubble();\n\t  \t\t\tthis.element.bubble();\n\t  \t\t\tthis.dirty = true;\n\t  \t\t}\n\t  \t};\n\t\n\t  \tAttribute.prototype.destroyed = function destroyed () {\n\t  \t\tthis.updateDelegate( true );\n\t  \t};\n\t\n\t  \tAttribute.prototype.getString = function getString () {\n\t  \t\treturn this.fragment ?\n\t  \t\t\tthis.fragment.toString() :\n\t  \t\t\tthis.value != null ? '' + this.value : '';\n\t  \t};\n\t\n\t  \t// TODO could getValue ever be called for a static attribute,\n\t  \t// or can we assume that this.fragment exists?\n\t  \tAttribute.prototype.getValue = function getValue () {\n\t  \t\treturn this.fragment ? this.fragment.valueOf() : booleanAttributes.test( this.name ) ? true : this.value;\n\t  \t};\n\t\n\t  \tAttribute.prototype.render = function render () {\n\t  \t\tvar node = this.element.node;\n\t  \t\tthis.node = node;\n\t\n\t  \t\t// should we use direct property access, or setAttribute?\n\t  \t\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n\t  \t\t\tthis.propertyName = propertyNames[ this.name ] || this.name;\n\t\n\t  \t\t\tif ( node[ this.propertyName ] !== undefined ) {\n\t  \t\t\t\tthis.useProperty = true;\n\t  \t\t\t}\n\t\n\t  \t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n\t  \t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n\t  \t\t\tif ( booleanAttributes.test( this.name ) || this.isTwoway ) {\n\t  \t\t\t\tthis.isBoolean = true;\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( this.propertyName === 'value' ) {\n\t  \t\t\t\tnode._ractive.value = this.value;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tif ( node.namespaceURI ) {\n\t  \t\t\tvar index = this.name.indexOf( ':' );\n\t  \t\t\tif ( index !== -1 ) {\n\t  \t\t\t\tthis.namespace = lookupNamespace( node, this.name.slice( 0, index ) );\n\t  \t\t\t} else {\n\t  \t\t\t\tthis.namespace = node.namespaceURI;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tthis.rendered = true;\n\t  \t\tthis.updateDelegate = getUpdateDelegate( this );\n\t  \t\tthis.updateDelegate();\n\t  \t};\n\t\n\t  \tAttribute.prototype.toString = function toString () {\n\t  \t\tvar value = this.getValue();\n\t\n\t  \t\t// Special case - select and textarea values (should not be stringified)\n\t  \t\tif ( this.name === 'value' && ( this.element.getAttribute( 'contenteditable' ) !== undefined || ( this.element.name === 'select' || this.element.name === 'textarea' ) ) ) {\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\t// Special case – bound radio `name` attributes\n\t  \t\tif ( this.name === 'name' && this.element.name === 'input' && this.interpolator && this.element.getAttribute( 'type' ) === 'radio' ) {\n\t  \t\t\treturn (\"name=\\\"{{\" + (this.interpolator.model.getKeypath()) + \"}}\\\"\");\n\t  \t\t}\n\t\n\t  \t\t// Special case - style and class attributes and directives\n\t  \t\tif ( this.owner === this.element && ( this.name === 'style' || this.name === 'class' || this.styleName || this.inlineClass ) ) {\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tif ( !this.rendered && this.owner === this.element && ( !this.name.indexOf( 'style-' ) || !this.name.indexOf( 'class-' ) ) ) {\n\t  \t\t\tif ( !this.name.indexOf( 'style-' ) ) {\n\t  \t\t\t\tthis.styleName = camelize( this.name.substr( 6 ) );\n\t  \t\t\t} else {\n\t  \t\t\t\tthis.inlineClass = this.name.substr( 6 );\n\t  \t\t\t}\n\t\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tif ( booleanAttributes.test( this.name ) ) return value ? this.name : '';\n\t  \t\tif ( value == null ) return '';\n\t\n\t  \t\tvar str = safeAttributeString( this.getString() );\n\t  \t\treturn str ?\n\t  \t\t\t(\"\" + (this.name) + \"=\\\"\" + str + \"\\\"\") :\n\t  \t\t\tthis.name;\n\t  \t};\n\t\n\t  \tAttribute.prototype.unbind = function unbind () {\n\t  \t\tif ( this.fragment ) this.fragment.unbind();\n\t  \t};\n\t\n\t  \tAttribute.prototype.unrender = function unrender () {\n\t  \t\tthis.updateDelegate( true );\n\t\n\t  \t\tthis.rendered = false;\n\t  \t};\n\t\n\t  \tAttribute.prototype.update = function update () {\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t  \t\t\tif ( this.fragment ) this.fragment.update();\n\t  \t\t\tif ( this.rendered ) this.updateDelegate();\n\t  \t\t\tif ( this.isTwoway && !this.locked ) {\n\t  \t\t\t\tthis.interpolator.twowayBinding.lastVal( true, this.interpolator.model.get() );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Attribute;\n\t  }(Item));\n\t\n\t  var BindingFlag = (function (Item) {\n\t  \tfunction BindingFlag ( options ) {\n\t  \t\tItem.call( this, options );\n\t\n\t  \t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t  \t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t  \t\tthis.flag = options.template.v === 'l' ? 'lazy' : 'twoway';\n\t\n\t  \t\tif ( this.element.type === ELEMENT ) {\n\t  \t\t\tif ( isArray( options.template.f ) ) {\n\t  \t\t\t\tthis.fragment = new Fragment({\n\t  \t\t\t\t\towner: this,\n\t  \t\t\t\t\ttemplate: options.template.f\n\t  \t\t\t\t});\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.interpolator = this.fragment &&\n\t  \t\t\t\t\t\t\t\tthis.fragment.items.length === 1 &&\n\t  \t\t\t\t\t\t\t\tthis.fragment.items[0].type === INTERPOLATOR &&\n\t  \t\t\t\t\t\t\t\tthis.fragment.items[0];\n\t  \t\t}\n\t  \t}\n\t\n\t  \tBindingFlag.prototype = Object.create( Item && Item.prototype );\n\t  \tBindingFlag.prototype.constructor = BindingFlag;\n\t\n\t  \tBindingFlag.prototype.bind = function bind () {\n\t  \t\tif ( this.fragment ) this.fragment.bind();\n\t  \t\tset$2( this, this.getValue(), true );\n\t  \t};\n\t\n\t  \tBindingFlag.prototype.bubble = function bubble () {\n\t  \t\tif ( !this.dirty ) {\n\t  \t\t\tthis.element.bubble();\n\t  \t\t\tthis.dirty = true;\n\t  \t\t}\n\t  \t};\n\t\n\t  \tBindingFlag.prototype.getValue = function getValue () {\n\t  \t\tif ( this.fragment ) return this.fragment.valueOf();\n\t  \t\telse if ( 'value' in this ) return this.value;\n\t  \t\telse if ( 'f' in this.template ) return this.template.f;\n\t  \t\telse return true;\n\t  \t};\n\t\n\t  \tBindingFlag.prototype.render = function render () {\n\t  \t\tset$2( this, this.getValue(), true );\n\t  \t};\n\t\n\t  \tBindingFlag.prototype.toString = function toString () { return ''; };\n\t\n\t  \tBindingFlag.prototype.unbind = function unbind () {\n\t  \t\tif ( this.fragment ) this.fragment.unbind();\n\t\n\t  \t\tdelete this.element[ this.flag ];\n\t  \t};\n\t\n\t  \tBindingFlag.prototype.unrender = function unrender () {\n\t  \t\tif ( this.element.rendered ) this.element.recreateTwowayBinding();\n\t  \t};\n\t\n\t  \tBindingFlag.prototype.update = function update () {\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tif ( this.fragment ) this.fragment.update();\n\t  \t\t\tset$2( this, this.getValue(), true );\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn BindingFlag;\n\t  }(Item));\n\t\n\t  function set$2 ( flag, value, update ) {\n\t  \tif ( value === 0 ) {\n\t  \t\tflag.value = true;\n\t  \t} else if ( value === 'true' ) {\n\t  \t\tflag.value = true;\n\t  \t} else if ( value === 'false' || value === '0' ) {\n\t  \t\tflag.value = false;\n\t  \t} else {\n\t  \t\tflag.value = value;\n\t  \t}\n\t\n\t  \tvar current = flag.element[ flag.flag ];\n\t  \tflag.element[ flag.flag ] = flag.value;\n\t  \tif ( update && !flag.element.attributes.binding && current !== flag.value ) {\n\t  \t\tflag.element.recreateTwowayBinding();\n\t  \t}\n\t\n\t  \treturn flag.value;\n\t  }\n\t\n\t  var div$1 = doc ? createElement( 'div' ) : null;\n\t\n\t  var attributes = false;\n\t  function inAttributes() { return attributes; }\n\t  function doInAttributes( fn ) {\n\t  \tattributes = true;\n\t  \tfn();\n\t  \tattributes = false;\n\t  }\n\t\n\t  var ConditionalAttribute = (function (Item) {\n\t  \tfunction ConditionalAttribute ( options ) {\n\t  \t\tItem.call( this, options );\n\t\n\t  \t\tthis.attributes = [];\n\t\n\t  \t\tthis.owner = options.owner;\n\t\n\t  \t\tthis.fragment = new Fragment({\n\t  \t\t\tractive: this.ractive,\n\t  \t\t\towner: this,\n\t  \t\t\ttemplate: this.template\n\t  \t\t});\n\t  \t\t// this fragment can't participate in node-y things\n\t  \t\tthis.fragment.findNextNode = noop;\n\t\n\t  \t\tthis.dirty = false;\n\t  \t}\n\t\n\t  \tConditionalAttribute.prototype = Object.create( Item && Item.prototype );\n\t  \tConditionalAttribute.prototype.constructor = ConditionalAttribute;\n\t\n\t  \tConditionalAttribute.prototype.bind = function bind () {\n\t  \t\tthis.fragment.bind();\n\t  \t};\n\t\n\t  \tConditionalAttribute.prototype.bubble = function bubble () {\n\t  \t\tif ( !this.dirty ) {\n\t  \t\t\tthis.dirty = true;\n\t  \t\t\tthis.owner.bubble();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tConditionalAttribute.prototype.render = function render () {\n\t  \t\tthis.node = this.owner.node;\n\t  \t\tif ( this.node ) {\n\t  \t\t\tthis.isSvg = this.node.namespaceURI === svg$1;\n\t  \t\t}\n\t\n\t  \t\tattributes = true;\n\t  \t\tif ( !this.rendered ) this.fragment.render();\n\t  \t\tattributes = false;\n\t\n\t  \t\tthis.rendered = true;\n\t  \t\tthis.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js\n\t  \t\tthis.update();\n\t  \t};\n\t\n\t  \tConditionalAttribute.prototype.toString = function toString () {\n\t  \t\treturn this.fragment.toString();\n\t  \t};\n\t\n\t  \tConditionalAttribute.prototype.unbind = function unbind () {\n\t  \t\tthis.fragment.unbind();\n\t  \t};\n\t\n\t  \tConditionalAttribute.prototype.unrender = function unrender () {\n\t  \t\tthis.rendered = false;\n\t  \t\tthis.fragment.unrender();\n\t  \t};\n\t\n\t  \tConditionalAttribute.prototype.update = function update () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar str;\n\t  \t\tvar attrs;\n\t\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t\n\t  \t\t\tattributes = true;\n\t  \t\t\tthis.fragment.update();\n\t  \t\t\tattributes = false;\n\t\n\t  \t\t\tif ( this.rendered && this.node ) {\n\t  \t\t\t\tstr = this.fragment.toString();\n\t  \t\t\t\tattrs = parseAttributes( str, this.isSvg );\n\t\n\t  \t\t\t\t// any attributes that previously existed but no longer do\n\t  \t\t\t\t// must be removed\n\t  \t\t\t\tthis.attributes.filter( function ( a ) { return notIn( attrs, a ); } ).forEach( function ( a ) {\n\t  \t\t\t\t\tthis$1.node.removeAttribute( a.name );\n\t  \t\t\t\t});\n\t\n\t  \t\t\t\tattrs.forEach( function ( a ) {\n\t  \t\t\t\t\tthis$1.node.setAttribute( a.name, a.value );\n\t  \t\t\t\t});\n\t\n\t  \t\t\t\tthis.attributes = attrs;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn ConditionalAttribute;\n\t  }(Item));\n\t\n\t  function parseAttributes ( str, isSvg ) {\n\t  \tvar tagName = isSvg ? 'svg' : 'div';\n\t  \treturn str\n\t  \t\t? (div$1.innerHTML = \"<\" + tagName + \" \" + str + \"></\" + tagName + \">\") &&\n\t  \t\t\ttoArray(div$1.childNodes[0].attributes)\n\t  \t\t: [];\n\t  }\n\t\n\t  function notIn ( haystack, needle ) {\n\t  \tvar i = haystack.length;\n\t\n\t  \twhile ( i-- ) {\n\t  \t\tif ( haystack[i].name === needle.name ) {\n\t  \t\t\treturn false;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn true;\n\t  }\n\t\n\t  function processWrapper ( wrapper, array, methodName, newIndices ) {\n\t  \tvar __model = wrapper.__model;\n\t\n\t  \tif ( newIndices ) {\n\t  \t\t__model.shuffle( newIndices );\n\t  \t} else {\n\t  \t\t// If this is a sort or reverse, we just do root.set()...\n\t  \t\t// TODO use merge logic?\n\t  \t\t//root.viewmodel.mark( keypath );\n\t  \t}\n\t  }\n\t\n\t  var mutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ];\n\t  var patchedArrayProto = [];\n\t\n\t  mutatorMethods.forEach( function ( methodName ) {\n\t  \tvar method = function () {\n\t  \t\tvar this$1 = this;\n\t  \t\tvar args = [], len = arguments.length;\n\t  \t\twhile ( len-- ) args[ len ] = arguments[ len ];\n\t\n\t  \t\tvar newIndices = getNewIndices( this.length, methodName, args );\n\t\n\t  \t\t// lock any magic array wrappers, so that things don't get fudged\n\t  \t\tthis._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = true; } );\n\t\n\t  \t\t// apply the underlying method\n\t  \t\tvar result = Array.prototype[ methodName ].apply( this, arguments );\n\t\n\t  \t\t// trigger changes\n\t  \t\trunloop.start();\n\t\n\t  \t\tthis._ractive.setting = true;\n\t  \t\tvar i = this._ractive.wrappers.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tprocessWrapper( this$1._ractive.wrappers[i], this$1, methodName, newIndices );\n\t  \t\t}\n\t\n\t  \t\trunloop.end();\n\t\n\t  \t\tthis._ractive.setting = false;\n\t\n\t  \t\t// unlock the magic arrays... magic... bah\n\t  \t\tthis._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = false; } );\n\t\n\t  \t\treturn result;\n\t  \t};\n\t\n\t  \tdefineProperty( patchedArrayProto, methodName, {\n\t  \t\tvalue: method,\n\t  \t\tconfigurable: true\n\t  \t});\n\t  });\n\t\n\t  var patchArrayMethods;\n\t  var unpatchArrayMethods;\n\t\n\t  // can we use prototype chain injection?\n\t  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n\t  if ( ({}).__proto__ ) {\n\t  \t// yes, we can\n\t  \tpatchArrayMethods = function ( array ) { return array.__proto__ = patchedArrayProto; };\n\t  \tunpatchArrayMethods = function ( array ) { return array.__proto__ = Array.prototype; };\n\t  }\n\t\n\t  else {\n\t  \t// no, we can't\n\t  \tpatchArrayMethods = function ( array ) {\n\t  \t\tvar i = mutatorMethods.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar methodName = mutatorMethods[i];\n\t  \t\t\tdefineProperty( array, methodName, {\n\t  \t\t\t\tvalue: patchedArrayProto[ methodName ],\n\t  \t\t\t\tconfigurable: true\n\t  \t\t\t});\n\t  \t\t}\n\t  \t};\n\t\n\t  \tunpatchArrayMethods = function ( array ) {\n\t  \t\tvar i = mutatorMethods.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tdelete array[ mutatorMethods[i] ];\n\t  \t\t}\n\t  \t};\n\t  }\n\t\n\t  patchArrayMethods.unpatch = unpatchArrayMethods; // TODO export separately?\n\t  var patch = patchArrayMethods;\n\t\n\t  var errorMessage$1 = 'Something went wrong in a rather interesting way';\n\t\n\t  var arrayAdaptor = {\n\t  \tfilter: function ( object ) {\n\t  \t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n\t  \t\t// or the array didn't trigger the get() itself\n\t  \t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n\t  \t},\n\t  \twrap: function ( ractive, array, keypath ) {\n\t  \t\treturn new ArrayWrapper( ractive, array, keypath );\n\t  \t}\n\t  };\n\t\n\t  var ArrayWrapper = function ArrayWrapper ( ractive, array ) {\n\t  \tthis.root = ractive;\n\t  \tthis.value = array;\n\t  \tthis.__model = null; // filled in later\n\t\n\t  \t// if this array hasn't already been ractified, ractify it\n\t  \tif ( !array._ractive ) {\n\t  \t\t// define a non-enumerable _ractive property to store the wrappers\n\t  \t\tdefineProperty( array, '_ractive', {\n\t  \t\t\tvalue: {\n\t  \t\t\t\twrappers: [],\n\t  \t\t\t\tinstances: [],\n\t  \t\t\t\tsetting: false\n\t  \t\t\t},\n\t  \t\t\tconfigurable: true\n\t  \t\t});\n\t\n\t  \t\tpatch( array );\n\t  \t}\n\t\n\t  \t// store the ractive instance, so we can handle transitions later\n\t  \tif ( !array._ractive.instances[ ractive._guid ] ) {\n\t  \t\tarray._ractive.instances[ ractive._guid ] = 0;\n\t  \t\tarray._ractive.instances.push( ractive );\n\t  \t}\n\t\n\t  \tarray._ractive.instances[ ractive._guid ] += 1;\n\t  \tarray._ractive.wrappers.push( this );\n\t  };\n\t\n\t  ArrayWrapper.prototype.get = function get () {\n\t  \treturn this.value;\n\t  };\n\t\n\t  ArrayWrapper.prototype.reset = function reset ( value ) {\n\t  \treturn this.value === value;\n\t  };\n\t\n\t  ArrayWrapper.prototype.teardown = function teardown () {\n\t  \tvar array, storage, wrappers, instances, index;\n\t\n\t  \tarray = this.value;\n\t  \tstorage = array._ractive;\n\t  \twrappers = storage.wrappers;\n\t  \tinstances = storage.instances;\n\t\n\t  \t// if teardown() was invoked because we're clearing the cache as a result of\n\t  \t// a change that the array itself triggered, we can save ourselves the teardown\n\t  \t// and immediate setup\n\t  \tif ( storage.setting ) {\n\t  \t\treturn false; // so that we don't remove it from cached wrappers\n\t  \t}\n\t\n\t  \tindex = wrappers.indexOf( this );\n\t  \tif ( index === -1 ) {\n\t  \t\tthrow new Error( errorMessage$1 );\n\t  \t}\n\t\n\t  \twrappers.splice( index, 1 );\n\t\n\t  \t// if nothing else depends on this array, we can revert it to its\n\t  \t// natural state\n\t  \tif ( !wrappers.length ) {\n\t  \t\tdelete array._ractive;\n\t  \t\tpatch.unpatch( this.value );\n\t  \t}\n\t\n\t  \telse {\n\t  \t\t// remove ractive instance if possible\n\t  \t\tinstances[ this.root._guid ] -= 1;\n\t  \t\tif ( !instances[ this.root._guid ] ) {\n\t  \t\t\tindex = instances.indexOf( this.root );\n\t\n\t  \t\t\tif ( index === -1 ) {\n\t  \t\t\t\tthrow new Error( errorMessage$1 );\n\t  \t\t\t}\n\t\n\t  \t\t\tinstances.splice( index, 1 );\n\t  \t\t}\n\t  \t}\n\t  };\n\t\n\t  var magicAdaptor;\n\t\n\t  try {\n\t  \tObject.defineProperty({}, 'test', { get: function() {}, set: function() {} });\n\t\n\t  \tmagicAdaptor = {\n\t  \t\tfilter: function ( value ) {\n\t  \t\t\treturn value && typeof value === 'object';\n\t  \t\t},\n\t  \t\twrap: function ( ractive, value, keypath ) {\n\t  \t\t\treturn new MagicWrapper( ractive, value, keypath );\n\t  \t\t}\n\t  \t};\n\t  } catch ( err ) {\n\t  \tmagicAdaptor = false;\n\t  }\n\t\n\t  var magicAdaptor$1 = magicAdaptor;\n\t\n\t  function createOrWrapDescriptor ( originalDescriptor, ractive, keypath, wrapper ) {\n\t  \tif ( originalDescriptor.set && originalDescriptor.set.__magic ) {\n\t  \t\toriginalDescriptor.set.__magic.dependants.push({ ractive: ractive, keypath: keypath });\n\t  \t\treturn originalDescriptor;\n\t  \t}\n\t\n\t  \tvar setting;\n\t\n\t  \tvar dependants = [{ ractive: ractive, keypath: keypath }];\n\t\n\t  \tvar descriptor = {\n\t  \t\tget: function () {\n\t  \t\t\treturn 'value' in originalDescriptor ? originalDescriptor.value : originalDescriptor.get.call( this );\n\t  \t\t},\n\t  \t\tset: function (value) {\n\t  \t\t\tif ( setting ) return;\n\t\n\t  \t\t\tif ( 'value' in originalDescriptor ) {\n\t  \t\t\t\toriginalDescriptor.value = value;\n\t  \t\t\t} else {\n\t  \t\t\t\toriginalDescriptor.set.call( this, value );\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( wrapper.locked ) return;\n\t  \t\t\tsetting = true;\n\t  \t\t\tdependants.forEach( function (ref) {\n\t  \t\t\t\tvar ractive = ref.ractive;\n\t  \t\t\t\tvar keypath = ref.keypath;\n\t\n\t  \t\t\t\tractive.set( keypath, value );\n\t  \t\t\t});\n\t  \t\t\tsetting = false;\n\t  \t\t},\n\t  \t\tenumerable: true\n\t  \t};\n\t\n\t  \tdescriptor.set.__magic = { dependants: dependants, originalDescriptor: originalDescriptor };\n\t\n\t  \treturn descriptor;\n\t  }\n\t\n\t  function revert ( descriptor, ractive, keypath ) {\n\t  \tif ( !descriptor.set || !descriptor.set.__magic ) return true;\n\t\n\t  \tvar dependants = descriptor.set.__magic;\n\t  \tvar i = dependants.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar dependant = dependants[i];\n\t  \t\tif ( dependant.ractive === ractive && dependant.keypath === keypath ) {\n\t  \t\t\tdependants.splice( i, 1 );\n\t  \t\t\treturn false;\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var MagicWrapper = function MagicWrapper ( ractive, value, keypath ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.ractive = ractive;\n\t  \tthis.value = value;\n\t  \tthis.keypath = keypath;\n\t\n\t  \tthis.originalDescriptors = {};\n\t\n\t  \t// wrap all properties with getters\n\t  \tObject.keys( value ).forEach( function ( key ) {\n\t  \t\tvar originalDescriptor = Object.getOwnPropertyDescriptor( this$1.value, key );\n\t  \t\tthis$1.originalDescriptors[ key ] = originalDescriptor;\n\t\n\t  \t\tvar childKeypath = keypath ? (\"\" + keypath + \".\" + (escapeKey( key ))) : escapeKey( key );\n\t\n\t  \t\tvar descriptor = createOrWrapDescriptor( originalDescriptor, ractive, childKeypath, this$1 );\n\t\n\t\n\t\n\t  \t\tObject.defineProperty( this$1.value, key, descriptor );\n\t  \t});\n\t  };\n\t\n\t  MagicWrapper.prototype.get = function get () {\n\t  \treturn this.value;\n\t  };\n\t\n\t  MagicWrapper.prototype.reset = function reset ( value ) {\n\t  \treturn this.value === value;\n\t  };\n\t\n\t  MagicWrapper.prototype.set = function set ( key, value ) {\n\t  \tthis.value[ key ] = value;\n\t  };\n\t\n\t  MagicWrapper.prototype.teardown = function teardown () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tObject.keys( this.value ).forEach( function ( key ) {\n\t  \t\tvar descriptor = Object.getOwnPropertyDescriptor( this$1.value, key );\n\t  \t\tif ( !descriptor.set || !descriptor.set.__magic ) return;\n\t\n\t  \t\trevert( descriptor );\n\t\n\t  \t\tif ( descriptor.set.__magic.dependants.length === 1 ) {\n\t  \t\t\tObject.defineProperty( this$1.value, key, descriptor.set.__magic.originalDescriptor );\n\t  \t\t}\n\t  \t});\n\t  };\n\t\n\t  var MagicArrayWrapper = function MagicArrayWrapper ( ractive, array, keypath ) {\n\t  \tthis.value = array;\n\t\n\t  \tthis.magic = true;\n\t\n\t  \tthis.magicWrapper = magicAdaptor$1.wrap( ractive, array, keypath );\n\t  \tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n\t  \tthis.arrayWrapper.magic = this.magicWrapper;\n\t\n\t  \t// ugh, this really is a terrible hack\n\t  \tObject.defineProperty( this, '__model', {\n\t  \t\tget: function () {\n\t  \t\t\treturn this.arrayWrapper.__model;\n\t  \t\t},\n\t  \t\tset: function ( model ) {\n\t  \t\t\tthis.arrayWrapper.__model = model;\n\t  \t\t}\n\t  \t});\n\t  };\n\t\n\t  MagicArrayWrapper.prototype.get = function get () {\n\t  \treturn this.value;\n\t  };\n\t\n\t  MagicArrayWrapper.prototype.teardown = function teardown () {\n\t  \tthis.arrayWrapper.teardown();\n\t  \tthis.magicWrapper.teardown();\n\t  };\n\t\n\t  MagicArrayWrapper.prototype.reset = function reset ( value ) {\n\t  \treturn this.arrayWrapper.reset( value ) && this.magicWrapper.reset( value );\n\t  };\n\t\n\t  var magicArrayAdaptor = {\n\t  \tfilter: function ( object, keypath, ractive ) {\n\t  \t\treturn magicAdaptor$1.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n\t  \t},\n\t\n\t  \twrap: function ( ractive, array, keypath ) {\n\t  \t\treturn new MagicArrayWrapper( ractive, array, keypath );\n\t  \t}\n\t  };\n\t\n\t  // TODO this is probably a bit anal, maybe we should leave it out\n\t  function prettify ( fnBody ) {\n\t  \tvar lines = fnBody\n\t  \t\t.replace( /^\\t+/gm, function ( tabs ) { return tabs.split( '\\t' ).join( '  ' ); } )\n\t  \t\t.split( '\\n' );\n\t\n\t  \tvar minIndent = lines.length < 2 ? 0 :\n\t  \t\tlines.slice( 1 ).reduce( function ( prev, line ) {\n\t  \t\t\treturn Math.min( prev, /^\\s*/.exec( line )[0].length );\n\t  \t\t}, Infinity );\n\t\n\t  \treturn lines.map( function ( line, i ) {\n\t  \t\treturn '    ' + ( i ? line.substring( minIndent ) : line );\n\t  \t}).join( '\\n' );\n\t  }\n\t\n\t  // Ditto. This function truncates the stack to only include app code\n\t  function truncateStack ( stack ) {\n\t  \tif ( !stack ) return '';\n\t\n\t  \tvar lines = stack.split( '\\n' );\n\t  \tvar name = Computation.name + '.getValue';\n\t\n\t  \tvar truncated = [];\n\t\n\t  \tvar len = lines.length;\n\t  \tfor ( var i = 1; i < len; i += 1 ) {\n\t  \t\tvar line = lines[i];\n\t\n\t  \t\tif ( ~line.indexOf( name ) ) {\n\t  \t\t\treturn truncated.join( '\\n' );\n\t  \t\t} else {\n\t  \t\t\ttruncated.push( line );\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var Computation = (function (Model) {\n\t  \tfunction Computation ( viewmodel, signature, key ) {\n\t  \t\tModel.call( this, null, null );\n\t\n\t  \t\tthis.root = this.parent = viewmodel;\n\t  \t\tthis.signature = signature;\n\t\n\t  \t\tthis.key = key; // not actually used, but helps with debugging\n\t  \t\tthis.isExpression = key && key[0] === '@';\n\t\n\t  \t\tthis.isReadonly = !this.signature.setter;\n\t\n\t  \t\tthis.context = viewmodel.computationContext;\n\t\n\t  \t\tthis.dependencies = [];\n\t\n\t  \t\tthis.children = [];\n\t  \t\tthis.childByKey = {};\n\t\n\t  \t\tthis.deps = [];\n\t\n\t  \t\tthis.dirty = true;\n\t\n\t  \t\t// TODO: is there a less hackish way to do this?\n\t  \t\tthis.shuffle = undefined;\n\t  \t}\n\t\n\t  \tComputation.prototype = Object.create( Model && Model.prototype );\n\t  \tComputation.prototype.constructor = Computation;\n\t\n\t  \tComputation.prototype.get = function get ( shouldCapture ) {\n\t  \t\tif ( shouldCapture ) capture( this );\n\t\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t  \t\t\tthis.value = this.getValue();\n\t  \t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n\t  \t\t\tthis.adapt();\n\t  \t\t}\n\t\n\t  \t\t// if capturing, this value needs to be unwrapped because it's for external use\n\t  \t\treturn shouldCapture && this.wrapper ? this.wrapperValue : this.value;\n\t  \t};\n\t\n\t  \tComputation.prototype.getValue = function getValue () {\n\t  \t\tstartCapturing();\n\t  \t\tvar result;\n\t\n\t  \t\ttry {\n\t  \t\t\tresult = this.signature.getter.call( this.context );\n\t  \t\t} catch ( err ) {\n\t  \t\t\twarnIfDebug( (\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)) );\n\t\n\t  \t\t\t// TODO this is all well and good in Chrome, but...\n\t  \t\t\t// ...also, should encapsulate this stuff better, and only\n\t  \t\t\t// show it if Ractive.DEBUG\n\t  \t\t\tif ( hasConsole ) {\n\t  \t\t\t\tif ( console.groupCollapsed ) console.groupCollapsed( '%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;' );\n\t  \t\t\t\tvar functionBody = prettify( this.signature.getterString );\n\t  \t\t\t\tvar stack = this.signature.getterUseStack ? '\\n\\n' + truncateStack( err.stack ) : '';\n\t  \t\t\t\tconsole.error( (\"\" + (err.name) + \": \" + (err.message) + \"\\n\\n\" + functionBody + \"\" + stack) );\n\t  \t\t\t\tif ( console.groupCollapsed ) console.groupEnd();\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tvar dependencies = stopCapturing();\n\t  \t\tthis.setDependencies( dependencies );\n\t\n\t  \t\t// if not the first computation and the value is not the same,\n\t  \t\t// register the change for change events\n\t  \t\tif ( 'value' in this && result !== this.value ) {\n\t  \t\t\tthis.registerChange( this.getKeypath(), result );\n\t  \t\t}\n\t\n\t  \t\treturn result;\n\t  \t};\n\t\n\t  \tComputation.prototype.handleChange = function handleChange$1 () {\n\t  \t\tthis.dirty = true;\n\t\n\t  \t\tthis.links.forEach( marked );\n\t  \t\tthis.deps.forEach( handleChange );\n\t  \t\tthis.children.forEach( handleChange );\n\t  \t\tthis.clearUnresolveds(); // TODO same question as on Model - necessary for primitives?\n\t  \t};\n\t\n\t  \tComputation.prototype.joinKey = function joinKey ( key ) {\n\t  \t\tif ( key === undefined || key === '' ) return this;\n\t\n\t  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n\t  \t\t\tvar child = new ComputationChild( this, key );\n\t  \t\t\tthis.children.push( child );\n\t  \t\t\tthis.childByKey[ key ] = child;\n\t  \t\t}\n\t\n\t  \t\treturn this.childByKey[ key ];\n\t  \t};\n\t\n\t  \tComputation.prototype.mark = function mark () {\n\t  \t\tthis.handleChange();\n\t  \t};\n\t\n\t  \tComputation.prototype.rebinding = function rebinding ( next, previous ) {\n\t  \t\t// computations will grab all of their deps again automagically\n\t  \t\tif ( next !== previous ) this.handleChange();\n\t  \t};\n\t\n\t  \tComputation.prototype.set = function set ( value ) {\n\t  \t\tif ( !this.signature.setter ) {\n\t  \t\t\tthrow new Error( (\"Cannot set read-only computed value '\" + (this.key) + \"'\") );\n\t  \t\t}\n\t\n\t  \t\tthis.signature.setter( value );\n\t  \t\tthis.mark();\n\t  \t};\n\t\n\t  \tComputation.prototype.setDependencies = function setDependencies ( dependencies ) {\n\t  \t\t// unregister any soft dependencies we no longer have\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar i = this.dependencies.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar model = this$1.dependencies[i];\n\t  \t\t\tif ( !~dependencies.indexOf( model ) ) model.unregister( this$1 );\n\t  \t\t}\n\t\n\t  \t\t// and add any new ones\n\t  \t\ti = dependencies.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar model$1 = dependencies[i];\n\t  \t\t\tif ( !~this$1.dependencies.indexOf( model$1 ) ) model$1.register( this$1 );\n\t  \t\t}\n\t\n\t  \t\tthis.dependencies = dependencies;\n\t  \t};\n\t\n\t  \tComputation.prototype.teardown = function teardown () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar i = this.dependencies.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tif ( this$1.dependencies[i] ) this$1.dependencies[i].unregister( this$1 );\n\t  \t\t}\n\t  \t\tif ( this.root.computations[this.key] === this ) delete this.root.computations[this.key];\n\t  \t\tModel.prototype.teardown.call(this);\n\t  \t};\n\t\n\t  \tComputation.prototype.unregister = function unregister ( dependent ) {\n\t  \t\tModel.prototype.unregister.call( this, dependent );\n\t  \t\t// tear down expressions with no deps, because they will be replaced when needed\n\t  \t\tif ( this.isExpression && this.deps.length === 0 ) this.teardown();\n\t  \t};\n\t\n\t  \treturn Computation;\n\t  }(Model));\n\t\n\t  var RactiveModel = (function (Model) {\n\t  \tfunction RactiveModel ( ractive ) {\n\t  \t\tModel.call( this, null, '' );\n\t  \t\tthis.value = ractive;\n\t  \t\tthis.isRoot = true;\n\t  \t\tthis.root = this;\n\t  \t\tthis.adaptors = [];\n\t  \t\tthis.ractive = ractive;\n\t  \t\tthis.changes = {};\n\t  \t}\n\t\n\t  \tRactiveModel.prototype = Object.create( Model && Model.prototype );\n\t  \tRactiveModel.prototype.constructor = RactiveModel;\n\t\n\t  \tRactiveModel.prototype.getKeypath = function getKeypath() {\n\t  \t\treturn '@this';\n\t  \t};\n\t\n\t  \treturn RactiveModel;\n\t  }(Model));\n\t\n\t  var hasProp$1 = Object.prototype.hasOwnProperty;\n\t\n\t  var RootModel = (function (Model) {\n\t  \tfunction RootModel ( options ) {\n\t  \t\tModel.call( this, null, null );\n\t\n\t  \t\t// TODO deprecate this\n\t  \t\tthis.changes = {};\n\t\n\t  \t\tthis.isRoot = true;\n\t  \t\tthis.root = this;\n\t  \t\tthis.ractive = options.ractive; // TODO sever this link\n\t\n\t  \t\tthis.value = options.data;\n\t  \t\tthis.adaptors = options.adapt;\n\t  \t\tthis.adapt();\n\t\n\t  \t\tthis.computationContext = options.ractive;\n\t  \t\tthis.computations = {};\n\t\n\t  \t\t// TODO this is only for deprecation of using expression keypaths\n\t  \t\tthis.expressions = {};\n\t  \t}\n\t\n\t  \tRootModel.prototype = Object.create( Model && Model.prototype );\n\t  \tRootModel.prototype.constructor = RootModel;\n\t\n\t  \tRootModel.prototype.applyChanges = function applyChanges () {\n\t  \t\tthis._changeHash = {};\n\t  \t\tthis.flush();\n\t\n\t  \t\treturn this._changeHash;\n\t  \t};\n\t\n\t  \tRootModel.prototype.compute = function compute ( key, signature ) {\n\t  \t\tvar computation = new Computation( this, signature, key );\n\t  \t\tthis.computations[ key ] = computation;\n\t\n\t  \t\treturn computation;\n\t  \t};\n\t\n\t  \tRootModel.prototype.createLink = function createLink ( keypath, target, targetPath ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar keys = splitKeypathI( keypath );\n\t\n\t  \t\tvar model = this;\n\t  \t\twhile ( keys.length ) {\n\t  \t\t\tvar key = keys.shift();\n\t  \t\t\tmodel = this$1.childByKey[ key ] || this$1.joinKey( key );\n\t  \t\t}\n\t\n\t  \t\treturn model.link( target, targetPath );\n\t  \t};\n\t\n\t  \tRootModel.prototype.get = function get ( shouldCapture, options ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( shouldCapture ) capture( this );\n\t\n\t  \t\tif ( !options || options.virtual !== false ) {\n\t  \t\t\tvar result = this.getVirtual();\n\t  \t\t\tvar keys = Object.keys( this.computations );\n\t  \t\t\tvar i = keys.length;\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tvar computation = this$1.computations[ keys[i] ];\n\t  \t\t\t\t// exclude template expressions\n\t  \t\t\t\tif ( !computation.isExpression ) {\n\t  \t\t\t\t\tresult[ keys[i] ] = computation.get();\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\treturn result;\n\t  \t\t} else {\n\t  \t\t\treturn this.value;\n\t  \t\t}\n\t  \t};\n\t\n\t  \tRootModel.prototype.getKeypath = function getKeypath () {\n\t  \t\treturn '';\n\t  \t};\n\t\n\t  \tRootModel.prototype.getRactiveModel = function getRactiveModel() {\n\t  \t\treturn this.ractiveModel || ( this.ractiveModel = new RactiveModel( this.ractive ) );\n\t  \t};\n\t\n\t  \tRootModel.prototype.getValueChildren = function getValueChildren () {\n\t  \t\tvar children = Model.prototype.getValueChildren.call( this, this.value );\n\t\n\t  \t\tthis.children.forEach( function ( child ) {\n\t  \t\t\tif ( child._link ) {\n\t  \t\t\t\tvar idx = children.indexOf( child );\n\t  \t\t\t\tif ( ~idx ) children.splice( idx, 1, child._link );\n\t  \t\t\t\telse children.push( child._link );\n\t  \t\t\t}\n\t  \t\t});\n\t\n\t  \t\tfor ( var k in this.computations ) {\n\t  \t\t\tchildren.push( this.computations[k] );\n\t  \t\t}\n\t\n\t  \t\treturn children;\n\t  \t};\n\t\n\t  \tRootModel.prototype.handleChange = function handleChange$1 () {\n\t  \t\tthis.deps.forEach( handleChange );\n\t  \t};\n\t\n\t  \tRootModel.prototype.has = function has ( key ) {\n\t  \t\tvar value = this.value;\n\t\n\t  \t\tkey = unescapeKey( key );\n\t  \t\tif ( hasProp$1.call( value, key ) ) return true;\n\t\n\t  \t\t// mappings/links and computations\n\t  \t\tif ( key in this.computations || this.childByKey[key] && this.childByKey[key]._link ) return true;\n\t  \t\t// TODO remove this after deprecation is done\n\t  \t\tif ( key in this.expressions ) return true;\n\t\n\t  \t\t// We climb up the constructor chain to find if one of them contains the key\n\t  \t\tvar constructor = value.constructor;\n\t  \t\twhile ( constructor !== Function && constructor !== Array && constructor !== Object ) {\n\t  \t\t\tif ( hasProp$1.call( constructor.prototype, key ) ) return true;\n\t  \t\t\tconstructor = constructor.constructor;\n\t  \t\t}\n\t\n\t  \t\treturn false;\n\t  \t};\n\t\n\t  \tRootModel.prototype.joinKey = function joinKey ( key, opts ) {\n\t  \t\tif ( key === '@global' ) return GlobalModel$1;\n\t  \t\tif ( key === '@this' ) return this.getRactiveModel();\n\t\n\t  \t\tif ( this.expressions.hasOwnProperty( key ) ) {\n\t  \t\t\twarnIfDebug( (\"Accessing expression keypaths (\" + (key.substr(1)) + \") from the instance is deprecated. You can used a getNodeInfo or event object to access keypaths with expression context.\") );\n\t  \t\t\treturn this.expressions[ key ];\n\t  \t\t}\n\t\n\t  \t\treturn this.computations.hasOwnProperty( key ) ? this.computations[ key ] :\n\t  \t\t       Model.prototype.joinKey.call( this, key, opts );\n\t  \t};\n\t\n\t  \tRootModel.prototype.map = function map ( localKey, origin ) {\n\t  \t\tvar local = this.joinKey( localKey );\n\t  \t\tlocal.link( origin );\n\t  \t};\n\t\n\t  \tRootModel.prototype.rebinding = function rebinding () {\n\t  \t};\n\t\n\t  \tRootModel.prototype.set = function set ( value ) {\n\t  \t\t// TODO wrapping root node is a baaaad idea. We should prevent this\n\t  \t\tvar wrapper = this.wrapper;\n\t  \t\tif ( wrapper ) {\n\t  \t\t\tvar shouldTeardown = !wrapper.reset || wrapper.reset( value ) === false;\n\t\n\t  \t\t\tif ( shouldTeardown ) {\n\t  \t\t\t\twrapper.teardown();\n\t  \t\t\t\tthis.wrapper = null;\n\t  \t\t\t\tthis.value = value;\n\t  \t\t\t\tthis.adapt();\n\t  \t\t\t}\n\t  \t\t} else {\n\t  \t\t\tthis.value = value;\n\t  \t\t\tthis.adapt();\n\t  \t\t}\n\t\n\t  \t\tthis.deps.forEach( handleChange );\n\t  \t\tthis.children.forEach( mark );\n\t  \t\tthis.clearUnresolveds(); // TODO do we need to do this with primitive values? if not, what about e.g. unresolved `length` property of null -> string?\n\t  \t};\n\t\n\t  \tRootModel.prototype.retrieve = function retrieve () {\n\t  \t\treturn this.wrapper ? this.wrapper.get() : this.value;\n\t  \t};\n\t\n\t  \tRootModel.prototype.update = function update () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \treturn RootModel;\n\t  }(Model));\n\t\n\t  function getComputationSignature ( ractive, key, signature ) {\n\t  \tvar getter;\n\t  \tvar setter;\n\t\n\t  \t// useful for debugging\n\t  \tvar getterString;\n\t  \tvar getterUseStack;\n\t  \tvar setterString;\n\t\n\t  \tif ( typeof signature === 'function' ) {\n\t  \t\tgetter = bind( signature, ractive );\n\t  \t\tgetterString = signature.toString();\n\t  \t\tgetterUseStack = true;\n\t  \t}\n\t\n\t  \tif ( typeof signature === 'string' ) {\n\t  \t\tgetter = createFunctionFromString( signature, ractive );\n\t  \t\tgetterString = signature;\n\t  \t}\n\t\n\t  \tif ( typeof signature === 'object' ) {\n\t  \t\tif ( typeof signature.get === 'string' ) {\n\t  \t\t\tgetter = createFunctionFromString( signature.get, ractive );\n\t  \t\t\tgetterString = signature.get;\n\t  \t\t} else if ( typeof signature.get === 'function' ) {\n\t  \t\t\tgetter = bind( signature.get, ractive );\n\t  \t\t\tgetterString = signature.get.toString();\n\t  \t\t\tgetterUseStack = true;\n\t  \t\t} else {\n\t  \t\t\tfatal( '`%s` computation must have a `get()` method', key );\n\t  \t\t}\n\t\n\t  \t\tif ( typeof signature.set === 'function' ) {\n\t  \t\t\tsetter = bind( signature.set, ractive );\n\t  \t\t\tsetterString = signature.set.toString();\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn {\n\t  \t\tgetter: getter,\n\t  \t\tsetter: setter,\n\t  \t\tgetterString: getterString,\n\t  \t\tsetterString: setterString,\n\t  \t\tgetterUseStack: getterUseStack\n\t  \t};\n\t  }\n\t\n\t  var constructHook = new Hook( 'construct' );\n\t\n\t  var registryNames$1 = [\n\t  \t'adaptors',\n\t  \t'components',\n\t  \t'decorators',\n\t  \t'easing',\n\t  \t'events',\n\t  \t'interpolators',\n\t  \t'partials',\n\t  \t'transitions'\n\t  ];\n\t\n\t  var uid = 0;\n\t\n\t  function construct ( ractive, options ) {\n\t  \tif ( Ractive.DEBUG ) welcome();\n\t\n\t  \tinitialiseProperties( ractive );\n\t\n\t  \t// TODO remove this, eventually\n\t  \tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\t\n\t  \t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n\t  \tconstructHook.fire( ractive, options );\n\t\n\t  \t// Add registries\n\t  \tregistryNames$1.forEach( function ( name ) {\n\t  \t\tractive[ name ] = extendObj( create( ractive.constructor[ name ] || null ), options[ name ] );\n\t  \t});\n\t\n\t  \t// Create a viewmodel\n\t  \tvar viewmodel = new RootModel({\n\t  \t\tadapt: getAdaptors( ractive, ractive.adapt, options ),\n\t  \t\tdata: dataConfigurator.init( ractive.constructor, ractive, options ),\n\t  \t\tractive: ractive\n\t  \t});\n\t\n\t  \tractive.viewmodel = viewmodel;\n\t\n\t  \t// Add computed properties\n\t  \tvar computed = extendObj( create( ractive.constructor.prototype.computed ), options.computed );\n\t\n\t  \tfor ( var key in computed ) {\n\t  \t\tvar signature = getComputationSignature( ractive, key, computed[ key ] );\n\t  \t\tviewmodel.compute( key, signature );\n\t  \t}\n\t  }\n\t\n\t  function combine$2 ( arrays ) {\n\t  \tvar res = [];\n\t  \tvar args = res.concat.apply( res, arrays );\n\t\n\t  \tvar i = args.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( !~res.indexOf( args[i] ) ) {\n\t  \t\t\tres.unshift( args[i] );\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn res;\n\t  }\n\t\n\t  function getAdaptors ( ractive, protoAdapt, options ) {\n\t  \tprotoAdapt = protoAdapt.map( lookup );\n\t  \tvar adapt = ensureArray( options.adapt ).map( lookup );\n\t\n\t  \tvar builtins = [];\n\t  \tvar srcs = [ protoAdapt, adapt ];\n\t  \tif ( ractive.parent && !ractive.isolated ) {\n\t  \t\tsrcs.push( ractive.parent.viewmodel.adaptors );\n\t  \t}\n\t  \tsrcs.push( builtins );\n\t\n\t  \tvar magic = 'magic' in options ? options.magic : ractive.magic;\n\t  \tvar modifyArrays = 'modifyArrays' in options ? options.modifyArrays : ractive.modifyArrays;\n\t\n\t  \tif ( magic ) {\n\t  \t\tif ( !magicSupported ) {\n\t  \t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n\t  \t\t}\n\t\n\t  \t\tif ( modifyArrays ) {\n\t  \t\t\tbuiltins.push( magicArrayAdaptor );\n\t  \t\t}\n\t\n\t  \t\tbuiltins.push( magicAdaptor$1 );\n\t  \t}\n\t\n\t  \tif ( modifyArrays ) {\n\t  \t\tbuiltins.push( arrayAdaptor );\n\t  \t}\n\t\n\t  \treturn combine$2( srcs );\n\t\n\t\n\t  \tfunction lookup ( adaptor ) {\n\t  \t\tif ( typeof adaptor === 'string' ) {\n\t  \t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\t\n\t  \t\t\tif ( !adaptor ) {\n\t  \t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn adaptor;\n\t  \t}\n\t  }\n\t\n\t  function initialiseProperties ( ractive ) {\n\t  \t// Generate a unique identifier, for places where you'd use a weak map if it\n\t  \t// existed\n\t  \tractive._guid = 'r-' + uid++;\n\t\n\t  \t// events\n\t  \tractive._subs = create( null );\n\t\n\t  \t// storage for item configuration from instantiation to reset,\n\t  \t// like dynamic functions or original values\n\t  \tractive._config = {};\n\t\n\t  \t// nodes registry\n\t  \tractive.nodes = {};\n\t\n\t  \t// events\n\t  \tractive.event = null;\n\t  \tractive._eventQueue = [];\n\t\n\t  \t// live queries\n\t  \tractive._liveQueries = [];\n\t  \tractive._liveComponentQueries = [];\n\t\n\t  \t// observers\n\t  \tractive._observers = [];\n\t\n\t  \tif(!ractive.component){\n\t  \t\tractive.root = ractive;\n\t  \t\tractive.parent = ractive.container = null; // TODO container still applicable?\n\t  \t}\n\t\n\t  }\n\t\n\t  function deprecateRactiveData () {\n\t  \tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n\t  }\n\t\n\t  function getChildQueue ( queue, ractive ) {\n\t  \treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n\t  }\n\t\n\t  function fire ( hookQueue, ractive ) {\n\t  \tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\t\n\t  \thookQueue.hook.fire( ractive );\n\t\n\t  \t// queue is \"live\" because components can end up being\n\t  \t// added while hooks fire on parents that modify data values.\n\t  \twhile ( childQueue.length ) {\n\t  \t\tfire( hookQueue, childQueue.shift() );\n\t  \t}\n\t\n\t  \tdelete hookQueue.queue[ ractive._guid ];\n\t  }\n\t\n\t  var HookQueue = function HookQueue ( event ) {\n\t  \tthis.hook = new Hook( event );\n\t  \tthis.inProcess = {};\n\t  \tthis.queue = {};\n\t  };\n\t\n\t  HookQueue.prototype.begin = function begin ( ractive ) {\n\t  \tthis.inProcess[ ractive._guid ] = true;\n\t  };\n\t\n\t  HookQueue.prototype.end = function end ( ractive ) {\n\t  \tvar parent = ractive.parent;\n\t\n\t  \t// If this is *isn't* a child of a component that's in process,\n\t  \t// it should call methods or fire at this point\n\t  \tif ( !parent || !this.inProcess[ parent._guid ] ) {\n\t  \t\tfire( this, ractive );\n\t  \t}\n\t  \t// elsewise, handoff to parent to fire when ready\n\t  \telse {\n\t  \t\tgetChildQueue( this.queue, parent ).push( ractive );\n\t  \t}\n\t\n\t  \tdelete this.inProcess[ ractive._guid ];\n\t  };\n\t\n\t  var configHook = new Hook( 'config' );\n\t  var initHook = new HookQueue( 'init' );\n\t\n\t  function initialise ( ractive, userOptions, options ) {\n\t  \tObject.keys( ractive.viewmodel.computations ).forEach( function ( key ) {\n\t  \t\tvar computation = ractive.viewmodel.computations[ key ];\n\t\n\t  \t\tif ( ractive.viewmodel.value.hasOwnProperty( key ) ) {\n\t  \t\t\tcomputation.set( ractive.viewmodel.value[ key ] );\n\t  \t\t}\n\t  \t});\n\t\n\t  \t// init config from Parent and options\n\t  \tconfig.init( ractive.constructor, ractive, userOptions );\n\t\n\t  \tconfigHook.fire( ractive );\n\t  \tinitHook.begin( ractive );\n\t\n\t  \tvar fragment;\n\t\n\t  \t// Render virtual DOM\n\t  \tif ( ractive.template ) {\n\t  \t\tvar cssIds;\n\t\n\t  \t\tif ( options.cssIds || ractive.cssId ) {\n\t  \t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\t\n\t  \t\t\tif ( ractive.cssId ) {\n\t  \t\t\t\tcssIds.push( ractive.cssId );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tractive.fragment = fragment = new Fragment({\n\t  \t\t\towner: ractive,\n\t  \t\t\ttemplate: ractive.template,\n\t  \t\t\tcssIds: cssIds\n\t  \t\t}).bind( ractive.viewmodel );\n\t  \t}\n\t\n\t  \tinitHook.end( ractive );\n\t\n\t  \tif ( fragment ) {\n\t  \t\t// render automatically ( if `el` is specified )\n\t  \t\tvar el = getElement( ractive.el );\n\t  \t\tif ( el ) {\n\t  \t\t\tvar promise = ractive.render( el, ractive.append );\n\t\n\t  \t\t\tif ( Ractive.DEBUG_PROMISES ) {\n\t  \t\t\t\tpromise['catch']( function ( err ) {\n\t  \t\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n\t  \t\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive: ractive });\n\t  \t\t\t\t\tlogIfDebug( err );\n\t\n\t  \t\t\t\t\tthrow err;\n\t  \t\t\t\t});\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var DOMEvent = function DOMEvent ( name, owner ) {\n\t  \tif ( name.indexOf( '*' ) !== -1 ) {\n\t  \t\tfatal( (\"Only component proxy-events may contain \\\"*\\\" wildcards, <\" + (owner.name) + \" on-\" + name + \"=\\\"...\\\"/> is not valid\") );\n\t  \t}\n\t\n\t  \tthis.name = name;\n\t  \tthis.owner = owner;\n\t  \tthis.node = null;\n\t  \tthis.handler = null;\n\t  };\n\t\n\t  DOMEvent.prototype.listen = function listen ( directive ) {\n\t  \tvar node = this.node = this.owner.node;\n\t  \tvar name = this.name;\n\t\n\t  \tif ( !( (\"on\" + name) in node ) ) {\n\t  \t\twarnOnce( missingPlugin( name, 'events' ) );\n\t  \t\t}\n\t\n\t  \t\tnode.addEventListener( name, this.handler = function( event ) {\n\t  \t\tdirective.fire({\n\t  \t\t\t\tnode: node,\n\t  \t\t\toriginal: event\n\t  \t\t\t});\n\t  \t\t}, false );\n\t  };\n\t\n\t  DOMEvent.prototype.unlisten = function unlisten () {\n\t  \tthis.node.removeEventListener( this.name, this.handler, false );\n\t  };\n\t\n\t  var CustomEvent = function CustomEvent ( eventPlugin, owner ) {\n\t  \tthis.eventPlugin = eventPlugin;\n\t  \tthis.owner = owner;\n\t  \tthis.handler = null;\n\t  };\n\t\n\t  CustomEvent.prototype.listen = function listen ( directive ) {\n\t  \tvar node = this.owner.node;\n\t\n\t  \tthis.handler = this.eventPlugin( node, function ( event ) {\n\t  \t\tif ( event === void 0 ) event = {};\n\t\n\t  \t\t\tevent.node = event.node || node;\n\t  \t\tdirective.fire( event );\n\t  \t});\n\t  };\n\t\n\t  CustomEvent.prototype.unlisten = function unlisten () {\n\t  \tthis.handler.teardown();\n\t  };\n\t\n\t  var RactiveEvent = function RactiveEvent ( ractive, name ) {\n\t  \tthis.ractive = ractive;\n\t  \tthis.name = name;\n\t  \tthis.handler = null;\n\t  };\n\t\n\t  RactiveEvent.prototype.listen = function listen ( directive ) {\n\t  \tvar ractive = this.ractive;\n\t\n\t  \tthis.handler = ractive.on( this.name, function () {\n\t  \t\tvar event;\n\t\n\t  \t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n\t  \t\tif ( arguments.length && arguments[0] && arguments[0].node ) {\n\t  \t\t\tevent = Array.prototype.shift.call( arguments );\n\t  \t\t\tevent.component = ractive;\n\t  \t\t}\n\t\n\t  \t\tvar args = Array.prototype.slice.call( arguments );\n\t  \t\tdirective.fire( event, args );\n\t\n\t  \t\t// cancel bubbling\n\t  \t\treturn false;\n\t  \t});\n\t  };\n\t\n\t  RactiveEvent.prototype.unlisten = function unlisten () {\n\t  \tthis.handler.cancel();\n\t  };\n\t\n\t  var specialPattern = /^(event|arguments)(\\..+)?$/;\n\t  var dollarArgsPattern = /^\\$(\\d+)(\\..+)?$/;\n\t\n\t  var EventDirective = function EventDirective ( options ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t  \tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t  \tthis.template = options.template;\n\t  \tthis.parentFragment = options.parentFragment;\n\t  \tthis.ractive = options.parentFragment.ractive;\n\t\n\t  \tthis.events = [];\n\t\n\t  \tif ( this.element.type === COMPONENT ) {\n\t  \t\tthis.template.n.split( '-' ).forEach( function ( n ) {\n\t  \t\t\tthis$1.events.push( new RactiveEvent( this$1.element.instance, n ) );\n\t  \t\t});\n\t  \t} else {\n\t  \t\tthis.template.n.split( '-' ).forEach( function ( n ) {\n\t  \t\t\tvar fn = findInViewHierarchy( 'events', this$1.ractive, n );\n\t  \t\t\t// we need to pass in \"this\" in order to get\n\t  \t\t\t// access to node when it is created.\n\t  \t\t\tthis$1.events.push(fn ? new CustomEvent( fn, this$1.element ) : new DOMEvent( n, this$1.element ));\n\t  \t\t});\n\t  \t}\n\t\n\t  \tthis.context = null;\n\t\n\t  \t// method calls\n\t  \tthis.resolvers = null;\n\t  \tthis.models = null;\n\t\n\t  \t// handler directive\n\t  \tthis.action = null;\n\t  \tthis.args = null;\n\t  };\n\t\n\t  EventDirective.prototype.bind = function bind () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.context = this.parentFragment.findContext();\n\t\n\t  \tvar template = this.template.f;\n\t\n\t  \tif ( template.x ) {\n\t  \t\tthis.fn = getFunction( template.x.s, template.x.r.length );\n\t  \t\tthis.resolvers = [];\n\t  \t\tthis.models = template.x.r.map( function ( ref, i ) {\n\t  \t\t\tvar specialMatch = specialPattern.exec( ref );\n\t  \t\t\tif ( specialMatch ) {\n\t  \t\t\t\t// on-click=\"foo(event.node)\"\n\t  \t\t\t\treturn {\n\t  \t\t\t\t\tspecial: specialMatch[1],\n\t  \t\t\t\t\tkeys: specialMatch[2] ? splitKeypathI( specialMatch[2].substr(1) ) : []\n\t  \t\t\t\t};\n\t  \t\t\t}\n\t\n\t  \t\t\tvar dollarMatch = dollarArgsPattern.exec( ref );\n\t  \t\t\tif ( dollarMatch ) {\n\t  \t\t\t\t// on-click=\"foo($1)\"\n\t  \t\t\t\treturn {\n\t  \t\t\t\t\tspecial: 'arguments',\n\t  \t\t\t\t\tkeys: [ dollarMatch[1] - 1 ].concat( dollarMatch[2] ? splitKeypathI( dollarMatch[2].substr( 1 ) ) : [] )\n\t  \t\t\t\t};\n\t  \t\t\t}\n\t\n\t  \t\t\tvar resolver;\n\t\n\t  \t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t  \t\t\tif ( !model ) {\n\t  \t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t  \t\t\t\t\tthis$1.models[i] = model;\n\t  \t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t  \t\t\t\t\tmodel.register( this$1 );\n\t  \t\t\t\t});\n\t\n\t  \t\t\t\tthis$1.resolvers.push( resolver );\n\t  \t\t\t} else model.register( this$1 );\n\t\n\t  \t\t\treturn model;\n\t  \t\t});\n\t  \t}\n\t\n\t  \telse {\n\t  \t\t// TODO deprecate this style of directive\n\t  \t\tthis.action = typeof template === 'string' ? // on-click='foo'\n\t  \t\t\ttemplate :\n\t  \t\t\ttypeof template.n === 'string' ? // on-click='{{dynamic}}'\n\t  \t\t\t\ttemplate.n :\n\t  \t\t\t\tnew Fragment({\n\t  \t\t\t\t\towner: this,\n\t  \t\t\t\t\ttemplate: template.n\n\t  \t\t\t\t});\n\t\n\t  \t\tthis.args = template.a ? // static arguments\n\t  \t\t\t( typeof template.a === 'string' ? [ template.a ] : template.a ) :\n\t  \t\t\ttemplate.d ? // dynamic arguments\n\t  \t\t\t\tnew Fragment({\n\t  \t\t\t\t\towner: this,\n\t  \t\t\t\t\ttemplate: template.d\n\t  \t\t\t\t}) :\n\t  \t\t\t\t[]; // no arguments\n\t  \t}\n\t\n\t  \tif ( this.action && typeof this.action !== 'string' ) this.action.bind();\n\t  \tif ( this.args && template.d ) this.args.bind();\n\t  };\n\t\n\t  EventDirective.prototype.bubble = function bubble () {\n\t  \tif ( !this.dirty ) {\n\t  \t\tthis.dirty = true;\n\t  \t\tthis.owner.bubble();\n\t  \t}\n\t  };\n\t\n\t  EventDirective.prototype.destroyed = function destroyed () {\n\t  \tthis.events.forEach( function ( e ) { return e.unlisten(); } );\n\t  };\n\t\n\t  EventDirective.prototype.fire = function fire ( event, passedArgs ) {\n\t\n\t  \t// augment event object\n\t  \tif ( passedArgs === void 0 ) passedArgs = [];\n\t\n\t  \t\tif ( event && !event.hasOwnProperty( '_element' ) ) {\n\t  \t\t   addHelpers( event, this.owner );\n\t  \t}\n\t\n\t  \tif ( this.fn ) {\n\t  \t\tvar values = [];\n\t\n\t  \t\tif ( event ) passedArgs.unshift( event );\n\t\n\t  \t\tif ( this.models ) {\n\t  \t\t\tthis.models.forEach( function ( model ) {\n\t  \t\t\t\tif ( !model ) return values.push( undefined );\n\t\n\t  \t\t\t\tif ( model.special ) {\n\t  \t\t\t\t\tvar obj = model.special === 'event' ? event : passedArgs;\n\t  \t\t\t\t\tvar keys = model.keys.slice();\n\t\n\t  \t\t\t\t\twhile ( keys.length ) obj = obj[ keys.shift() ];\n\t  \t\t\t\t\treturn values.push( obj );\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tif ( model.wrapper ) {\n\t  \t\t\t\t\treturn values.push( model.wrapperValue );\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tvalues.push( model.get() );\n\t  \t\t\t});\n\t  \t\t}\n\t\n\t  \t\t// make event available as `this.event`\n\t  \t\tvar ractive = this.ractive;\n\t  \t\tvar oldEvent = ractive.event;\n\t\n\t  \t\tractive.event = event;\n\t  \t\tvar result = this.fn.apply( ractive, values ).pop();\n\t\n\t  \t\t// Auto prevent and stop if return is explicitly false\n\t  \t\tif ( result === false ) {\n\t  \t\t\tvar original = event ? event.original : undefined;\n\t  \t\t\tif ( original ) {\n\t  \t\t\t\toriginal.preventDefault && original.preventDefault();\n\t  \t\t\t\toriginal.stopPropagation && original.stopPropagation();\n\t  \t\t\t} else {\n\t  \t\t\t\twarnOnceIfDebug( (\"handler '\" + (this.template.n) + \"' returned false, but there is no event available to cancel\") );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tractive.event = oldEvent;\n\t  \t}\n\t\n\t  \telse {\n\t  \t\tvar action = this.action.toString();\n\t  \t\tvar args = this.template.f.d ? this.args.getArgsList() : this.args;\n\t\n\t  \t\tif ( passedArgs.length ) args = args.concat( passedArgs );\n\t\n\t  \t\tif ( event ) event.name = action;\n\t\n\t  \t\tfireEvent( this.ractive, action, {\n\t  \t\t\tevent: event,\n\t  \t\t\targs: args\n\t  \t\t});\n\t  \t}\n\t  };\n\t\n\t  EventDirective.prototype.handleChange = function handleChange () {};\n\t\n\t  EventDirective.prototype.rebinding = function rebinding ( next, previous ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( !this.models ) return;\n\t  \tvar idx = this.models.indexOf( previous );\n\t\n\t  \tif ( ~idx ) {\n\t  \t\tthis.models.splice( idx, 1, next );\n\t  \t\tprevious.unregister( this );\n\t  \t\tif ( next ) next.addShuffleTask( function () { return next.register( this$1 ); } );\n\t  \t}\n\t  };\n\t\n\t  EventDirective.prototype.render = function render () {\n\t  \t// render events after everything else, so they fire after bindings\n\t  \tvar this$1 = this;\n\t\n\t  \t\trunloop.scheduleTask( function () { return this$1.events.forEach( function ( e ) { return e.listen( this$1 ); }, true ); } );\n\t  };\n\t\n\t  EventDirective.prototype.toString = function toString() { return ''; };\n\t\n\t  EventDirective.prototype.unbind = function unbind$1 () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar template = this.template.f;\n\t\n\t  \tif ( template.m ) {\n\t  \t\tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t  \t\tthis.resolvers = [];\n\t\n\t  \t\tif ( this.models ) this.models.forEach( function ( m ) {\n\t  \t\t\tif ( m.unregister ) m.unregister( this$1 );\n\t  \t\t});\n\t  \t\tthis.models = null;\n\t  \t}\n\t\n\t  \telse {\n\t  \t\t// TODO this is brittle and non-explicit, fix it\n\t  \t\tif ( this.action && this.action.unbind ) this.action.unbind();\n\t  \t\tif ( this.args && this.args.unbind ) this.args.unbind();\n\t  \t}\n\t  };\n\t\n\t  EventDirective.prototype.unrender = function unrender () {\n\t  \tthis.events.forEach( function ( e ) { return e.unlisten(); } );\n\t  };\n\t\n\t  EventDirective.prototype.update = function update () {\n\t  \tif ( this.method || !this.dirty ) return; // nothing to do\n\t\n\t  \tthis.dirty = false;\n\t\n\t  \t// ugh legacy\n\t  \tif ( this.action && this.action.update ) this.action.update();\n\t  \tif ( this.args && this.args.update ) this.args.update();\n\t  };\n\t\n\t  // TODO it's unfortunate that this has to run every time a\n\t  // component is rendered... is there a better way?\n\t  function updateLiveQueries ( component ) {\n\t  \t// Does this need to be added to any live queries?\n\t  \tvar instance = component.ractive;\n\t\n\t  \tdo {\n\t  \t\tvar liveQueries = instance._liveComponentQueries;\n\t\n\t  \t\tvar i = liveQueries.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar name = liveQueries[i];\n\t  \t\t\tvar query = liveQueries[ (\"_\" + name) ];\n\t\n\t  \t\t\tif ( query.test( component ) ) {\n\t  \t\t\t\tquery.add( component.instance );\n\t  \t\t\t\t// keep register of applicable selectors, for when we teardown\n\t  \t\t\t\tcomponent.liveQueries.push( query );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t} while ( instance = instance.parent );\n\t  }\n\t\n\t  function removeFromLiveComponentQueries ( component ) {\n\t  \tvar instance = component.ractive;\n\t\n\t  \twhile ( instance ) {\n\t  \t\tvar query = instance._liveComponentQueries[ (\"_\" + (component.name)) ];\n\t  \t\tif ( query ) query.remove( component );\n\t\n\t  \t\tinstance = instance.parent;\n\t  \t}\n\t  }\n\t\n\t  function makeDirty ( query ) {\n\t  \tquery.makeDirty();\n\t  }\n\t\n\t  var teardownHook = new Hook( 'teardown' );\n\t\n\t  var Component = (function (Item) {\n\t  \tfunction Component ( options, ComponentConstructor ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tItem.call( this, options );\n\t  \t\tthis.type = COMPONENT; // override ELEMENT from super\n\t\n\t  \t\tvar instance = create( ComponentConstructor.prototype );\n\t\n\t  \t\tthis.instance = instance;\n\t  \t\tthis.name = options.template.e;\n\t  \t\tthis.parentFragment = options.parentFragment;\n\t\n\t  \t\tthis.liveQueries = [];\n\t\n\t  \t\tif ( instance.el ) {\n\t  \t\t\twarnIfDebug( (\"The <\" + (this.name) + \"> component has a default 'el' property; it has been disregarded\") );\n\t  \t\t}\n\t\n\t  \t\tvar partials = options.template.p || {};\n\t  \t\tif ( !( 'content' in partials ) ) partials.content = options.template.f || [];\n\t  \t\tthis._partials = partials; // TEMP\n\t\n\t  \t\tthis.yielders = {};\n\t\n\t  \t\t// find container\n\t  \t\tvar fragment = options.parentFragment;\n\t  \t\tvar container;\n\t  \t\twhile ( fragment ) {\n\t  \t\t\tif ( fragment.owner.type === YIELDER ) {\n\t  \t\t\t\tcontainer = fragment.owner.container;\n\t  \t\t\t\tbreak;\n\t  \t\t\t}\n\t\n\t  \t\t\tfragment = fragment.parent;\n\t  \t\t}\n\t\n\t  \t\t// add component-instance-specific properties\n\t  \t\tinstance.parent = this.parentFragment.ractive;\n\t  \t\tinstance.container = container || null;\n\t  \t\tinstance.root = instance.parent.root;\n\t  \t\tinstance.component = this;\n\t\n\t  \t\tconstruct( this.instance, { partials: partials });\n\t\n\t  \t\t// for hackability, this could be an open option\n\t  \t\t// for any ractive instance, but for now, just\n\t  \t\t// for components and just for ractive...\n\t  \t\tinstance._inlinePartials = partials;\n\t\n\t  \t\tthis.attributeByName = {};\n\t\n\t  \t\tthis.attributes = [];\n\t  \t\tvar leftovers = [];\n\t  \t\t( this.template.m || [] ).forEach( function ( template ) {\n\t  \t\t\tswitch ( template.t ) {\n\t  \t\t\t\tcase ATTRIBUTE:\n\t  \t\t\t\tcase EVENT:\n\t  \t\t\t\tcase TRANSITION:\n\t  \t\t\t\t\tthis$1.attributes.push( createItem({\n\t  \t\t\t\t\t\towner: this$1,\n\t  \t\t\t\t\t\tparentFragment: this$1.parentFragment,\n\t  \t\t\t\t\t\ttemplate: template\n\t  \t\t\t\t\t}) );\n\t  \t\t\t\t\tbreak;\n\t\n\t  \t\t\t\tcase BINDING_FLAG:\n\t  \t\t\t\tcase DECORATOR:\n\t  \t\t\t\t\tbreak;\n\t\n\t  \t\t\t\tdefault:\n\t  \t\t\t\t\tleftovers.push( template );\n\t  \t\t\t\t\tbreak;\n\t  \t\t\t}\n\t  \t\t});\n\t\n\t  \t\tthis.attributes.push( new ConditionalAttribute({\n\t  \t\t\towner: this,\n\t  \t\t\tparentFragment: this.parentFragment,\n\t  \t\t\ttemplate: leftovers\n\t  \t\t}) );\n\t\n\t  \t\tthis.eventHandlers = [];\n\t  \t\tif ( this.template.v ) this.setupEvents();\n\t  \t}\n\t\n\t  \tComponent.prototype = Object.create( Item && Item.prototype );\n\t  \tComponent.prototype.constructor = Component;\n\t\n\t  \tComponent.prototype.bind = function bind$1$$ () {\n\t  \t\tthis.attributes.forEach( bind$1 );\n\t\n\t  \t\tinitialise( this.instance, {\n\t  \t\t\tpartials: this._partials\n\t  \t\t}, {\n\t  \t\t\tcssIds: this.parentFragment.cssIds\n\t  \t\t});\n\t\n\t  \t\tthis.eventHandlers.forEach( bind$1 );\n\t\n\t  \t\tthis.bound = true;\n\t  \t};\n\t\n\t  \tComponent.prototype.bubble = function bubble () {\n\t  \t\tif ( !this.dirty ) {\n\t  \t\t\tthis.dirty = true;\n\t  \t\t\tthis.parentFragment.bubble();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tComponent.prototype.checkYielders = function checkYielders () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tObject.keys( this.yielders ).forEach( function ( name ) {\n\t  \t\t\tif ( this$1.yielders[ name ].length > 1 ) {\n\t  \t\t\t\trunloop.end();\n\t  \t\t\t\tthrow new Error( (\"A component template can only have one {{yield\" + (name ? ' ' + name : '') + \"}} declaration at a time\") );\n\t  \t\t\t}\n\t  \t\t});\n\t  \t};\n\t\n\t  \tComponent.prototype.destroyed = function destroyed () {\n\t  \t\tif ( this.instance.fragment ) this.instance.fragment.destroyed();\n\t  \t};\n\t\n\t  \tComponent.prototype.detach = function detach () {\n\t  \t\treturn this.instance.fragment.detach();\n\t  \t};\n\t\n\t  \tComponent.prototype.find = function find ( selector ) {\n\t  \t\treturn this.instance.fragment.find( selector );\n\t  \t};\n\t\n\t  \tComponent.prototype.findAll = function findAll ( selector, query ) {\n\t  \t\tthis.instance.fragment.findAll( selector, query );\n\t  \t};\n\t\n\t  \tComponent.prototype.findComponent = function findComponent ( name ) {\n\t  \t\tif ( !name || this.name === name ) return this.instance;\n\t\n\t  \t\tif ( this.instance.fragment ) {\n\t  \t\t\treturn this.instance.fragment.findComponent( name );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tComponent.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t  \t\tif ( query.test( this ) ) {\n\t  \t\t\tquery.add( this.instance );\n\t\n\t  \t\t\tif ( query.live ) {\n\t  \t\t\t\tthis.liveQueries.push( query );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tthis.instance.fragment.findAllComponents( name, query );\n\t  \t};\n\t\n\t  \tComponent.prototype.firstNode = function firstNode ( skipParent ) {\n\t  \t\treturn this.instance.fragment.firstNode( skipParent );\n\t  \t};\n\t\n\t  \tComponent.prototype.render = function render$1$$ ( target, occupants ) {\n\t  \t\trender$1( this.instance, target, null, occupants );\n\t\n\t  \t\tthis.checkYielders();\n\t  \t\tthis.attributes.forEach( render );\n\t  \t\tthis.eventHandlers.forEach( render );\n\t  \t\tupdateLiveQueries( this );\n\t\n\t  \t\tthis.rendered = true;\n\t  \t};\n\t\n\t  \tComponent.prototype.setupEvents = function setupEvents () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar handlers = this.eventHandlers;\n\t\n\t  \t\tObject.keys( this.template.v ).forEach( function ( key ) {\n\t  \t\t\tvar eventNames = key.split( '-' );\n\t  \t\t\tvar template = this$1.template.v[ key ];\n\t\n\t  \t\t\teventNames.forEach( function ( eventName ) {\n\t  \t\t\t\tvar event = new RactiveEvent( this$1.instance, eventName );\n\t  \t\t\t\thandlers.push( new EventDirective( this$1, event, template ) );\n\t  \t\t\t});\n\t  \t\t});\n\t  \t};\n\t\n\t  \tComponent.prototype.shuffled = function shuffled () {\n\t  \t\tthis.liveQueries.forEach( makeDirty );\n\t  \t\tItem.prototype.shuffled.call(this);\n\t  \t};\n\t\n\t  \tComponent.prototype.toString = function toString () {\n\t  \t\treturn this.instance.toHTML();\n\t  \t};\n\t\n\t  \tComponent.prototype.unbind = function unbind$1 () {\n\t  \t\tthis.bound = false;\n\t\n\t  \t\tthis.attributes.forEach( unbind );\n\t\n\t  \t\tvar instance = this.instance;\n\t  \t\tinstance.viewmodel.teardown();\n\t  \t\tinstance.fragment.unbind();\n\t  \t\tinstance._observers.forEach( cancel );\n\t\n\t  \t\tremoveFromLiveComponentQueries( this );\n\t\n\t  \t\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n\t  \t\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n\t  \t\t}\n\t\n\t  \t\tteardownHook.fire( instance );\n\t  \t};\n\t\n\t  \tComponent.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tthis.rendered = false;\n\t\n\t  \t\tthis.shouldDestroy = shouldDestroy;\n\t  \t\tthis.instance.unrender();\n\t  \t\tthis.attributes.forEach( unrender );\n\t  \t\tthis.eventHandlers.forEach( unrender );\n\t  \t\tthis.liveQueries.forEach( function ( query ) { return query.remove( this$1.instance ); } );\n\t  \t};\n\t\n\t  \tComponent.prototype.update = function update$1 () {\n\t  \t\tthis.dirty = false;\n\t  \t\tthis.instance.fragment.update();\n\t  \t\tthis.checkYielders();\n\t  \t\tthis.attributes.forEach( update );\n\t  \t\tthis.eventHandlers.forEach( update );\n\t  \t};\n\t\n\t  \treturn Component;\n\t  }(Item));\n\t\n\t  var missingDecorator = {\n\t  \tupdate: noop,\n\t  \tteardown: noop\n\t  };\n\t\n\t  var Decorator = function Decorator ( options ) {\n\t  \tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t  \tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t  \tthis.parentFragment = this.owner.parentFragment;\n\t  \tthis.ractive = this.owner.ractive;\n\t  \tvar template = this.template = options.template;\n\t\n\t  \tthis.dynamicName = typeof template.f.n === 'object';\n\t  \tthis.dynamicArgs = !!template.f.d;\n\t\n\t  \tif ( this.dynamicName ) {\n\t  \t\tthis.nameFragment = new Fragment({\n\t  \t\t\towner: this,\n\t  \t\t\ttemplate: template.f.n\n\t  \t\t});\n\t  \t} else {\n\t  \t\tthis.name = template.f.n || template.f;\n\t  \t}\n\t\n\t  \tif ( this.dynamicArgs ) {\n\t  \t\tthis.argsFragment = new Fragment({\n\t  \t\t\towner: this,\n\t  \t\t\ttemplate: template.f.d\n\t  \t\t});\n\t  \t} else {\n\t  \t\tif ( template.f.a && template.f.a.s ) {\n\t  \t\t\tthis.args = [];\n\t  \t\t} else {\n\t  \t\t\tthis.args = template.f.a || [];\n\t  \t\t}\n\t  \t}\n\t\n\t  \tthis.node = null;\n\t  \tthis.intermediary = null;\n\t\n\t  \tthis.element.decorators.push( this );\n\t  };\n\t\n\t  Decorator.prototype.bind = function bind () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( this.dynamicName ) {\n\t  \t\tthis.nameFragment.bind();\n\t  \t\tthis.name = this.nameFragment.toString();\n\t  \t}\n\t\n\t  \tif ( this.dynamicArgs ) this.argsFragment.bind();\n\t\n\t  \t// TODO: dry this up once deprecation is done\n\t  \tif ( this.template.f.a && this.template.f.a.s ) {\n\t  \t\tthis.resolvers = [];\n\t  \t\tthis.models = this.template.f.a.r.map( function ( ref, i ) {\n\t  \t\t\tvar resolver;\n\t  \t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t  \t\t\tif ( !model ) {\n\t  \t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t  \t\t\t\t\tthis$1.models[i] = model;\n\t  \t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t  \t\t\t\t\tmodel.register( this$1 );\n\t  \t\t\t\t});\n\t\n\t  \t\t\t\tthis$1.resolvers.push( resolver );\n\t  \t\t\t} else model.register( this$1 );\n\t\n\t  \t\t\treturn model;\n\t  \t\t});\n\t  \t\tthis.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );\n\t  \t}\n\t  };\n\t\n\t  Decorator.prototype.bubble = function bubble () {\n\t  \tif ( !this.dirty ) {\n\t  \t\tthis.dirty = true;\n\t  \t\tthis.owner.bubble();\n\t  \t}\n\t  };\n\t\n\t  Decorator.prototype.destroyed = function destroyed () {\n\t  \tif ( this.intermediary ) this.intermediary.teardown();\n\t  };\n\t\n\t  Decorator.prototype.handleChange = function handleChange () { this.bubble(); };\n\t\n\t  Decorator.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t  \tvar idx = this.models.indexOf( previous );\n\t  \tif ( !~idx ) return;\n\t\n\t  \tnext = rebindMatch( this.template.f.a.r[ idx ], next, previous );\n\t  \tif ( next === previous ) return;\n\t\n\t  \tprevious.unregister( this );\n\t  \tthis.models.splice( idx, 1, next );\n\t  \tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t\n\t  \tif ( !safe ) this.bubble();\n\t  };\n\t\n\t  Decorator.prototype.render = function render () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\trunloop.scheduleTask( function () {\n\t  \t\tvar fn = findInViewHierarchy( 'decorators', this$1.ractive, this$1.name );\n\t\n\t  \t\tif ( !fn ) {\n\t  \t\t\twarnOnce( missingPlugin( this$1.name, 'decorator' ) );\n\t  \t\t\tthis$1.intermediary = missingDecorator;\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tthis$1.node = this$1.element.node;\n\t\n\t  \t\tvar args;\n\t  \t\tif ( this$1.argsFn ) {\n\t  \t\t\targs = this$1.models.map( function ( model ) {\n\t  \t\t\t\tif ( !model ) return undefined;\n\t\n\t  \t\t\t\treturn model.get();\n\t  \t\t\t});\n\t  \t\t\targs = this$1.argsFn.apply( this$1.ractive, args );\n\t  \t\t} else {\n\t  \t\t\targs = this$1.dynamicArgs ? this$1.argsFragment.getArgsList() : this$1.args;\n\t  \t\t}\n\t\n\t  \t\tthis$1.intermediary = fn.apply( this$1.ractive, [ this$1.node ].concat( args ) );\n\t\n\t  \t\tif ( !this$1.intermediary || !this$1.intermediary.teardown ) {\n\t  \t\t\tthrow new Error( (\"The '\" + (this$1.name) + \"' decorator must return an object with a teardown method\") );\n\t  \t\t}\n\t  \t}, true );\n\t  \tthis.rendered = true;\n\t  };\n\t\n\t  Decorator.prototype.toString = function toString () { return ''; };\n\t\n\t  Decorator.prototype.unbind = function unbind$1 () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( this.dynamicName ) this.nameFragment.unbind();\n\t  \tif ( this.dynamicArgs ) this.argsFragment.unbind();\n\t  \tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t  \tif ( this.models ) this.models.forEach( function ( m ) {\n\t  \t\tif ( m ) m.unregister( this$1 );\n\t  \t});\n\t  };\n\t\n\t  Decorator.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \tif ( ( !shouldDestroy || this.element.rendered ) && this.intermediary ) this.intermediary.teardown();\n\t  \tthis.rendered = false;\n\t  };\n\t\n\t  Decorator.prototype.update = function update () {\n\t  \tif ( !this.dirty ) return;\n\t\n\t  \tthis.dirty = false;\n\t\n\t  \tvar nameChanged = false;\n\t\n\t  \tif ( this.dynamicName && this.nameFragment.dirty ) {\n\t  \t\tvar name = this.nameFragment.toString();\n\t  \t\tnameChanged = name !== this.name;\n\t  \t\tthis.name = name;\n\t  \t}\n\t\n\t  \tif ( this.intermediary ) {\n\t  \t\tif ( nameChanged || !this.intermediary.update ) {\n\t  \t\t\tthis.unrender();\n\t  \t\t\tthis.render();\n\t  \t\t}\n\t  \t\telse {\n\t  \t\t\tif ( this.dynamicArgs ) {\n\t  \t\t\t\tif ( this.argsFragment.dirty ) {\n\t  \t\t\t\t\tvar args = this.argsFragment.getArgsList();\n\t  \t\t\t\t\tthis.intermediary.update.apply( this.ractive, args );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t\telse if ( this.argsFn ) {\n\t  \t\t\t\tvar args$1 = this.models.map( function ( model ) {\n\t  \t\t\t\t\tif ( !model ) return undefined;\n\t\n\t  \t\t\t\t\treturn model.get();\n\t  \t\t\t\t});\n\t  \t\t\t\tthis.intermediary.update.apply( this.ractive, this.argsFn.apply( this.ractive, args$1 ) );\n\t  \t\t\t}\n\t  \t\t\telse {\n\t  \t\t\t\tthis.intermediary.update.apply( this.ractive, this.args );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// need to run these for unrender/render cases\n\t  \t// so can't just be in conditional if above\n\t\n\t  \tif ( this.dynamicName && this.nameFragment.dirty ) {\n\t  \t\tthis.nameFragment.update();\n\t  \t}\n\t\n\t  \tif ( this.dynamicArgs && this.argsFragment.dirty ) {\n\t  \t\tthis.argsFragment.update();\n\t  \t}\n\t  };\n\t\n\t  var Doctype = (function (Item) {\n\t  \tfunction Doctype () {\n\t  \t\tItem.apply(this, arguments);\n\t  \t}\n\t\n\t  \tDoctype.prototype = Object.create( Item && Item.prototype );\n\t  \tDoctype.prototype.constructor = Doctype;\n\t\n\t  \tDoctype.prototype.bind = function bind () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \tDoctype.prototype.render = function render () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \tDoctype.prototype.teardown = function teardown () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \tDoctype.prototype.toString = function toString () {\n\t  \t\treturn '<!DOCTYPE' + this.template.a + '>';\n\t  \t};\n\t\n\t  \tDoctype.prototype.unbind = function unbind () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \tDoctype.prototype.unrender = function unrender () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \tDoctype.prototype.update = function update () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \treturn Doctype;\n\t  }(Item));\n\t\n\t  function updateLiveQueries$1 ( element ) {\n\t  \t// Does this need to be added to any live queries?\n\t  \tvar node = element.node;\n\t  \tvar instance = element.ractive;\n\t\n\t  \tdo {\n\t  \t\tvar liveQueries = instance._liveQueries;\n\t\n\t  \t\tvar i = liveQueries.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar selector = liveQueries[i];\n\t  \t\t\tvar query = liveQueries[ (\"_\" + selector) ];\n\t\n\t  \t\t\tif ( query.test( node ) ) {\n\t  \t\t\t\tquery.add( node );\n\t  \t\t\t\t// keep register of applicable selectors, for when we teardown\n\t  \t\t\t\telement.liveQueries.push( query );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t} while ( instance = instance.parent );\n\t  }\n\t\n\t  function warnAboutAmbiguity ( description, ractive ) {\n\t  \twarnOnceIfDebug( (\"The \" + description + \" being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\"), { ractive: ractive });\n\t  }\n\t\n\t  var Binding = function Binding ( element, name ) {\n\t  \tif ( name === void 0 ) name = 'value';\n\t\n\t  \t\tthis.element = element;\n\t  \tthis.ractive = element.ractive;\n\t  \tthis.attribute = element.attributeByName[ name ];\n\t\n\t  \tvar interpolator = this.attribute.interpolator;\n\t  \tinterpolator.twowayBinding = this;\n\t\n\t  \tvar model = interpolator.model;\n\t\n\t  \t// not bound?\n\t  \tif ( !model ) {\n\t  \t\t// try to force resolution\n\t  \t\tinterpolator.resolver.forceResolution();\n\t  \t\tmodel = interpolator.model;\n\t\n\t  \t\twarnAboutAmbiguity( (\"'\" + (interpolator.template.r) + \"' reference\"), this.ractive );\n\t  \t\t}\n\t\n\t  \t\telse if ( model.isUnresolved ) {\n\t  \t\t\t// reference expressions (e.g. foo[bar])\n\t  \t\t\tmodel.forceResolution();\n\t  \t\t\twarnAboutAmbiguity( 'expression', this.ractive );\n\t  \t}\n\t\n\t  \t// TODO include index/key/keypath refs as read-only\n\t  \telse if ( model.isReadonly ) {\n\t  \t\tvar keypath = model.getKeypath().replace( /^@/, '' );\n\t  \t\twarnOnceIfDebug( (\"Cannot use two-way binding on <\" + (element.name) + \"> element: \" + keypath + \" is read-only. To suppress this warning use <\" + (element.name) + \" twoway='false'...>\"), { ractive: this.ractive });\n\t  \t\treturn false;\n\t  \t}\n\t\n\t  \tthis.attribute.isTwoway = true;\n\t  \tthis.model = model;\n\t\n\t  \t// initialise value, if it's undefined\n\t  \tvar value = model.get();\n\t  \tthis.wasUndefined = value === undefined;\n\t\n\t  \tif ( value === undefined && this.getInitialValue ) {\n\t  \t\tvalue = this.getInitialValue();\n\t  \t\tmodel.set( value );\n\t  \t}\n\t  \tthis.lastVal( true, value );\n\t\n\t  \tvar parentForm = findElement( this.element, false, 'form' );\n\t  \tif ( parentForm ) {\n\t  \t\tthis.resetValue = value;\n\t  \t\tparentForm.formBindings.push( this );\n\t  \t}\n\t  };\n\t\n\t  Binding.prototype.bind = function bind () {\n\t  \tthis.model.registerTwowayBinding( this );\n\t  };\n\t\n\t  Binding.prototype.handleChange = function handleChange () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar value = this.getValue();\n\t  \tif ( this.lastVal() === value ) return;\n\t\n\t  \trunloop.start( this.root );\n\t  \tthis.attribute.locked = true;\n\t  \tthis.model.set( value );\n\t  \tthis.lastVal( true, value );\n\t\n\t  \t// if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up\n\t  \tif ( this.model.get() !== value ) this.attribute.locked = false;\n\t  \telse runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\t\n\t  \trunloop.end();\n\t  };\n\t\n\t  Binding.prototype.lastVal = function lastVal ( setting, value ) {\n\t  \tif ( setting ) this.lastValue = value;\n\t  \telse return this.lastValue;\n\t  };\n\t\n\t  Binding.prototype.rebinding = function rebinding ( next, previous ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( this.model && this.model === previous ) previous.unregisterTwowayBinding( this );\n\t  \tif ( next ) {\n\t  \t\tthis.model = next;\n\t  \t\trunloop.scheduleTask( function () { return next.registerTwowayBinding( this$1 ); } );\n\t  \t}\n\t  };\n\t\n\t  Binding.prototype.render = function render () {\n\t  \tthis.node = this.element.node;\n\t  \tthis.node._ractive.binding = this;\n\t  \tthis.rendered = true; // TODO is this used anywhere?\n\t  };\n\t\n\t  \tBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t  \t\tthis.model.set( node.value );\n\t  };\n\t\n\t  Binding.prototype.unbind = function unbind () {\n\t  \tthis.model.unregisterTwowayBinding( this );\n\t  };\n\t\n\t  Binding.prototype.unrender = function unrender () {\n\t  \t\t// noop?\n\t  \t};\n\t\n\t  // This is the handler for DOM events that would lead to a change in the model\n\t  // (i.e. change, sometimes, input, and occasionally click and keyup)\n\t  function handleDomEvent () {\n\t  \tthis._ractive.binding.handleChange();\n\t  }\n\t\n\t  var CheckboxBinding = (function (Binding) {\n\t  \tfunction CheckboxBinding ( element ) {\n\t  \t\tBinding.call( this, element, 'checked' );\n\t  \t}\n\t\n\t  \tCheckboxBinding.prototype = Object.create( Binding && Binding.prototype );\n\t  \tCheckboxBinding.prototype.constructor = CheckboxBinding;\n\t\n\t  \tCheckboxBinding.prototype.render = function render () {\n\t  \t\tBinding.prototype.render.call(this);\n\t\n\t  \t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t\n\t  \t\tif ( this.node.attachEvent ) {\n\t  \t\t\tthis.node.addEventListener( 'click', handleDomEvent, false );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tCheckboxBinding.prototype.unrender = function unrender () {\n\t  \t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t  \t\tthis.node.removeEventListener( 'click', handleDomEvent, false );\n\t  \t};\n\t\n\t  \tCheckboxBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\treturn !!this.element.getAttribute( 'checked' );\n\t  \t};\n\t\n\t  \tCheckboxBinding.prototype.getValue = function getValue () {\n\t  \t\treturn this.node.checked;\n\t  \t};\n\t\n\t  \tCheckboxBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t  \t\tthis.model.set( node.checked );\n\t  \t};\n\t\n\t  \treturn CheckboxBinding;\n\t  }(Binding));\n\t\n\t  function getBindingGroup ( group, model, getValue ) {\n\t  \tvar hash = \"\" + group + \"-bindingGroup\";\n\t  \treturn model[hash] || ( model[ hash ] = new BindingGroup( hash, model, getValue ) );\n\t  }\n\t\n\t  var BindingGroup = function BindingGroup ( hash, model, getValue ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.model = model;\n\t  \tthis.hash = hash;\n\t  \tthis.getValue = function () {\n\t  \t\tthis$1.value = getValue.call(this$1);\n\t  \t\treturn this$1.value;\n\t  \t};\n\t\n\t  \tthis.bindings = [];\n\t  };\n\t\n\t  BindingGroup.prototype.add = function add ( binding ) {\n\t  \tthis.bindings.push( binding );\n\t  };\n\t\n\t  BindingGroup.prototype.bind = function bind () {\n\t  \tthis.value = this.model.get();\n\t  \tthis.model.registerTwowayBinding( this );\n\t  \tthis.bound = true;\n\t  };\n\t\n\t  BindingGroup.prototype.remove = function remove ( binding ) {\n\t  \tremoveFromArray( this.bindings, binding );\n\t  \tif ( !this.bindings.length ) {\n\t  \t\tthis.unbind();\n\t  \t}\n\t  };\n\t\n\t  BindingGroup.prototype.unbind = function unbind () {\n\t  \tthis.model.unregisterTwowayBinding( this );\n\t  \tthis.bound = false;\n\t  \tdelete this.model[this.hash];\n\t  };\n\t\n\t  var push$2 = [].push;\n\t\n\t  function getValue() {\n\t  \tvar all = this.bindings.filter(function ( b ) { return b.node && b.node.checked; }).map(function ( b ) { return b.element.getAttribute( 'value' ); });\n\t  \tvar res = [];\n\t  \tall.forEach(function ( v ) { if ( !arrayContains( res, v ) ) res.push( v ); });\n\t  \treturn res;\n\t  }\n\t\n\t  var CheckboxNameBinding = (function (Binding) {\n\t  \tfunction CheckboxNameBinding ( element ) {\n\t  \t\tBinding.call( this, element, 'name' );\n\t\n\t  \t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\t\n\t  \t\t// Each input has a reference to an array containing it and its\n\t  \t\t// group, as two-way binding depends on being able to ascertain\n\t  \t\t// the status of all inputs within the group\n\t  \t\tthis.group = getBindingGroup( 'checkboxes', this.model, getValue );\n\t  \t\tthis.group.add( this );\n\t\n\t  \t\tif ( this.noInitialValue ) {\n\t  \t\t\tthis.group.noInitialValue = true;\n\t  \t\t}\n\t\n\t  \t\t// If no initial value was set, and this input is checked, we\n\t  \t\t// update the model\n\t  \t\tif ( this.group.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n\t  \t\t\tvar existingValue = this.model.get();\n\t  \t\t\tvar bindingValue = this.element.getAttribute( 'value' );\n\t\n\t  \t\t\tif ( !arrayContains( existingValue, bindingValue ) ) {\n\t  \t\t\t\tpush$2.call( existingValue, bindingValue ); // to avoid triggering runloop with array adaptor\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tCheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );\n\t  \tCheckboxNameBinding.prototype.constructor = CheckboxNameBinding;\n\t\n\t  \tCheckboxNameBinding.prototype.bind = function bind () {\n\t  \t\tif ( !this.group.bound ) {\n\t  \t\t\tthis.group.bind();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tCheckboxNameBinding.prototype.changed = function changed () {\n\t  \t\tvar wasChecked = !!this.isChecked;\n\t  \t\tthis.isChecked = this.node.checked;\n\t  \t\treturn this.isChecked === wasChecked;\n\t  \t};\n\t\n\t  \tCheckboxNameBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\t// This only gets called once per group (of inputs that\n\t  \t\t// share a name), because it only gets called if there\n\t  \t\t// isn't an initial value. By the same token, we can make\n\t  \t\t// a note of that fact that there was no initial value,\n\t  \t\t// and populate it using any `checked` attributes that\n\t  \t\t// exist (which users should avoid, but which we should\n\t  \t\t// support anyway to avoid breaking expectations)\n\t  \t\tthis.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?\n\t  \t\treturn [];\n\t  \t};\n\t\n\t  \tCheckboxNameBinding.prototype.getValue = function getValue$1 () {\n\t  \t\treturn this.group.value;\n\t  \t};\n\t\n\t  \tCheckboxNameBinding.prototype.handleChange = function handleChange () {\n\t  \t\tthis.isChecked = this.element.node.checked;\n\t  \t\tthis.group.value = this.model.get();\n\t  \t\tvar value = this.element.getAttribute( 'value' );\n\t  \t\tif ( this.isChecked && !arrayContains( this.group.value, value ) ) {\n\t  \t\t\tthis.group.value.push( value );\n\t  \t\t} else if ( !this.isChecked && arrayContains( this.group.value, value ) ) {\n\t  \t\t\tremoveFromArray( this.group.value, value );\n\t  \t\t}\n\t  \t\t// make sure super knows there's a change\n\t  \t\tthis.lastValue = null;\n\t  \t\tBinding.prototype.handleChange.call(this);\n\t  \t};\n\t\n\t  \tCheckboxNameBinding.prototype.render = function render () {\n\t  \t\tBinding.prototype.render.call(this);\n\t\n\t  \t\tvar node = this.node;\n\t\n\t  \t\tvar existingValue = this.model.get();\n\t  \t\tvar bindingValue = this.element.getAttribute( 'value' );\n\t\n\t  \t\tif ( isArray( existingValue ) ) {\n\t  \t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n\t  \t\t} else {\n\t  \t\t\tthis.isChecked = existingValue == bindingValue;\n\t  \t\t}\n\t\n\t  \t\tnode.name = '{{' + this.model.getKeypath() + '}}';\n\t  \t\tnode.checked = this.isChecked;\n\t\n\t  \t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\n\t  \t\t// in case of IE emergency, bind to click event as well\n\t  \t\tif ( node.attachEvent ) {\n\t  \t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tCheckboxNameBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t  \t\tthis.group.bindings.forEach( function ( binding ) { return binding.wasUndefined = true; } );\n\t\n\t  \t\tif ( node.checked ) {\n\t  \t\t\tvar valueSoFar = this.group.getValue();\n\t  \t\t\tvalueSoFar.push( this.element.getAttribute( 'value' ) );\n\t\n\t  \t\t\tthis.group.model.set( valueSoFar );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tCheckboxNameBinding.prototype.unbind = function unbind () {\n\t  \t\tthis.group.remove( this );\n\t  \t};\n\t\n\t  \tCheckboxNameBinding.prototype.unrender = function unrender () {\n\t  \t\tvar node = this.element.node;\n\t\n\t  \t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t  \t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t  \t};\n\t\n\t  \treturn CheckboxNameBinding;\n\t  }(Binding));\n\t\n\t  var ContentEditableBinding = (function (Binding) {\n\t  \tfunction ContentEditableBinding () {\n\t  \t\tBinding.apply(this, arguments);\n\t  \t}\n\t\n\t  \tContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );\n\t  \tContentEditableBinding.prototype.constructor = ContentEditableBinding;\n\t\n\t  \tContentEditableBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n\t  \t};\n\t\n\t  \tContentEditableBinding.prototype.getValue = function getValue () {\n\t  \t\treturn this.element.node.innerHTML;\n\t  \t};\n\t\n\t  \tContentEditableBinding.prototype.render = function render () {\n\t  \t\tBinding.prototype.render.call(this);\n\t\n\t  \t\tvar node = this.node;\n\t\n\t  \t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t  \t\tnode.addEventListener( 'blur', handleDomEvent, false );\n\t\n\t  \t\tif ( !this.ractive.lazy ) {\n\t  \t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\t\n\t  \t\t\tif ( node.attachEvent ) {\n\t  \t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \tContentEditableBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t  \t\tthis.model.set( node.innerHTML );\n\t  \t};\n\t\n\t  \tContentEditableBinding.prototype.unrender = function unrender () {\n\t  \t\tvar node = this.node;\n\t\n\t  \t\tnode.removeEventListener( 'blur', handleDomEvent, false );\n\t  \t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t  \t\tnode.removeEventListener( 'input', handleDomEvent, false );\n\t  \t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n\t  \t};\n\t\n\t  \treturn ContentEditableBinding;\n\t  }(Binding));\n\t\n\t  function handleBlur () {\n\t  \thandleDomEvent.call( this );\n\t\n\t  \tvar value = this._ractive.binding.model.get();\n\t  \tthis.value = value == undefined ? '' : value;\n\t  }\n\t\n\t  function handleDelay ( delay ) {\n\t  \tvar timeout;\n\t\n\t  \treturn function () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( timeout ) clearTimeout( timeout );\n\t\n\t  \t\ttimeout = setTimeout( function () {\n\t  \t\t\tvar binding = this$1._ractive.binding;\n\t  \t\t\tif ( binding.rendered ) handleDomEvent.call( this$1 );\n\t  \t\t\ttimeout = null;\n\t  \t\t}, delay );\n\t  \t};\n\t  }\n\t\n\t  var GenericBinding = (function (Binding) {\n\t  \tfunction GenericBinding () {\n\t  \t\tBinding.apply(this, arguments);\n\t  \t}\n\t\n\t  \tGenericBinding.prototype = Object.create( Binding && Binding.prototype );\n\t  \tGenericBinding.prototype.constructor = GenericBinding;\n\t\n\t  \tGenericBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\treturn '';\n\t  \t};\n\t\n\t  \tGenericBinding.prototype.getValue = function getValue () {\n\t  \t\treturn this.node.value;\n\t  \t};\n\t\n\t  \tGenericBinding.prototype.render = function render () {\n\t  \t\tBinding.prototype.render.call(this);\n\t\n\t  \t\t// any lazy setting for this element overrides the root\n\t  \t\t// if the value is a number, it's a timeout\n\t  \t\tvar lazy = this.ractive.lazy;\n\t  \t\tvar timeout = false;\n\t\n\t  \t\tif ( 'lazy' in this.element ) {\n\t  \t\t\tlazy = this.element.lazy;\n\t  \t\t}\n\t\n\t  \t\tif ( isNumeric( lazy ) ) {\n\t  \t\t\ttimeout = +lazy;\n\t  \t\t\tlazy = false;\n\t  \t\t}\n\t\n\t  \t\tthis.handler = timeout ? handleDelay( timeout ) : handleDomEvent;\n\t\n\t  \t\tvar node = this.node;\n\t\n\t  \t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\n\t  \t\tif ( !lazy ) {\n\t  \t\t\tnode.addEventListener( 'input', this.handler, false );\n\t\n\t  \t\t\tif ( node.attachEvent ) {\n\t  \t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tnode.addEventListener( 'blur', handleBlur, false );\n\t  \t};\n\t\n\t  \tGenericBinding.prototype.unrender = function unrender () {\n\t  \t\tvar node = this.element.node;\n\t  \t\tthis.rendered = false;\n\t\n\t  \t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t  \t\tnode.removeEventListener( 'input', this.handler, false );\n\t  \t\tnode.removeEventListener( 'keyup', this.handler, false );\n\t  \t\tnode.removeEventListener( 'blur', handleBlur, false );\n\t  \t};\n\t\n\t  \treturn GenericBinding;\n\t  }(Binding));\n\t\n\t  var FileBinding = (function (GenericBinding) {\n\t  \tfunction FileBinding () {\n\t  \t\tGenericBinding.apply(this, arguments);\n\t  \t}\n\t\n\t  \tFileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n\t  \tFileBinding.prototype.constructor = FileBinding;\n\t\n\t  \tFileBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\treturn undefined;\n\t  \t};\n\t\n\t  \tFileBinding.prototype.getValue = function getValue () {\n\t  \t\treturn this.node.files;\n\t  \t};\n\t\n\t  \tFileBinding.prototype.render = function render () {\n\t  \t\tthis.element.lazy = false;\n\t  \t\tGenericBinding.prototype.render.call(this);\n\t  \t};\n\t\n\t  \tFileBinding.prototype.setFromNode = function setFromNode( node ) {\n\t  \t\tthis.model.set( node.files );\n\t  \t};\n\t\n\t  \treturn FileBinding;\n\t  }(GenericBinding));\n\t\n\t  function getSelectedOptions ( select ) {\n\t      return select.selectedOptions\n\t  \t\t? toArray( select.selectedOptions )\n\t  \t\t: select.options\n\t  \t\t\t? toArray( select.options ).filter( function ( option ) { return option.selected; } )\n\t  \t\t\t: [];\n\t  }\n\t\n\t  var MultipleSelectBinding = (function (Binding) {\n\t  \tfunction MultipleSelectBinding () {\n\t  \t\tBinding.apply(this, arguments);\n\t  \t}\n\t\n\t  \tMultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n\t  \tMultipleSelectBinding.prototype.constructor = MultipleSelectBinding;\n\t\n\t  \tMultipleSelectBinding.prototype.forceUpdate = function forceUpdate () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar value = this.getValue();\n\t\n\t  \t\tif ( value !== undefined ) {\n\t  \t\t\tthis.attribute.locked = true;\n\t  \t\t\trunloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\t  \t\t\tthis.model.set( value );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tMultipleSelectBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\treturn this.element.options\n\t  \t\t\t.filter( function ( option ) { return option.getAttribute( 'selected' ); } )\n\t  \t\t\t.map( function ( option ) { return option.getAttribute( 'value' ); } );\n\t  \t};\n\t\n\t  \tMultipleSelectBinding.prototype.getValue = function getValue () {\n\t  \t\tvar options = this.element.node.options;\n\t  \t\tvar len = options.length;\n\t\n\t  \t\tvar selectedValues = [];\n\t\n\t  \t\tfor ( var i = 0; i < len; i += 1 ) {\n\t  \t\t\tvar option = options[i];\n\t\n\t  \t\t\tif ( option.selected ) {\n\t  \t\t\t\tvar optionValue = option._ractive ? option._ractive.value : option.value;\n\t  \t\t\t\tselectedValues.push( optionValue );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn selectedValues;\n\t  \t};\n\t\n\t  \tMultipleSelectBinding.prototype.handleChange = function handleChange () {\n\t  \t\tvar attribute = this.attribute;\n\t  \t\tvar previousValue = attribute.getValue();\n\t\n\t  \t\tvar value = this.getValue();\n\t\n\t  \t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n\t  \t\t\tBinding.prototype.handleChange.call(this);\n\t  \t\t}\n\t\n\t  \t\treturn this;\n\t  \t};\n\t\n\t  \tMultipleSelectBinding.prototype.render = function render () {\n\t  \t\tBinding.prototype.render.call(this);\n\t\n\t  \t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t\n\t  \t\tif ( this.model.get() === undefined ) {\n\t  \t\t\t// get value from DOM, if possible\n\t  \t\t\tthis.handleChange();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tMultipleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t  \t\tvar selectedOptions = getSelectedOptions( node );\n\t  \t\tvar i = selectedOptions.length;\n\t  \t\tvar result = new Array( i );\n\t\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar option = selectedOptions[i];\n\t  \t\t\tresult[i] = option._ractive ? option._ractive.value : option.value;\n\t  \t\t}\n\t\n\t  \t\tthis.model.set( result );\n\t  \t};\n\t\n\t  \tMultipleSelectBinding.prototype.setValue = function setValue () {\n\t  \t\tthrow new Error( 'TODO not implemented yet' );\n\t  \t};\n\t\n\t  \tMultipleSelectBinding.prototype.unrender = function unrender () {\n\t  \t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t  \t};\n\t\n\t  \tMultipleSelectBinding.prototype.updateModel = function updateModel () {\n\t  \t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n\t  \t\t\tthis.keypath.set( this.initialValue );\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn MultipleSelectBinding;\n\t  }(Binding));\n\t\n\t  var NumericBinding = (function (GenericBinding) {\n\t  \tfunction NumericBinding () {\n\t  \t\tGenericBinding.apply(this, arguments);\n\t  \t}\n\t\n\t  \tNumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n\t  \tNumericBinding.prototype.constructor = NumericBinding;\n\t\n\t  \tNumericBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\treturn undefined;\n\t  \t};\n\t\n\t  \tNumericBinding.prototype.getValue = function getValue () {\n\t  \t\tvar value = parseFloat( this.node.value );\n\t  \t\treturn isNaN( value ) ? undefined : value;\n\t  \t};\n\t\n\t  \tNumericBinding.prototype.setFromNode = function setFromNode( node ) {\n\t  \t\tvar value = parseFloat( node.value );\n\t  \t\tif ( !isNaN( value ) ) this.model.set( value );\n\t  \t};\n\t\n\t  \treturn NumericBinding;\n\t  }(GenericBinding));\n\t\n\t  var siblings = {};\n\t\n\t  function getSiblings ( hash ) {\n\t  \treturn siblings[ hash ] || ( siblings[ hash ] = [] );\n\t  }\n\t\n\t  var RadioBinding = (function (Binding) {\n\t  \tfunction RadioBinding ( element ) {\n\t  \t\tBinding.call( this, element, 'checked' );\n\t\n\t  \t\tthis.siblings = getSiblings( this.ractive._guid + this.element.getAttribute( 'name' ) );\n\t  \t\tthis.siblings.push( this );\n\t  \t}\n\t\n\t  \tRadioBinding.prototype = Object.create( Binding && Binding.prototype );\n\t  \tRadioBinding.prototype.constructor = RadioBinding;\n\t\n\t  \tRadioBinding.prototype.getValue = function getValue () {\n\t  \t\treturn this.node.checked;\n\t  \t};\n\t\n\t  \tRadioBinding.prototype.handleChange = function handleChange () {\n\t  \t\trunloop.start( this.root );\n\t\n\t  \t\tthis.siblings.forEach( function ( binding ) {\n\t  \t\t\tbinding.model.set( binding.getValue() );\n\t  \t\t});\n\t\n\t  \t\trunloop.end();\n\t  \t};\n\t\n\t  \tRadioBinding.prototype.render = function render () {\n\t  \t\tBinding.prototype.render.call(this);\n\t\n\t  \t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t\n\t  \t\tif ( this.node.attachEvent ) {\n\t  \t\t\tthis.node.addEventListener( 'click', handleDomEvent, false );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tRadioBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t  \t\tthis.model.set( node.checked );\n\t  \t};\n\t\n\t  \tRadioBinding.prototype.unbind = function unbind () {\n\t  \t\tremoveFromArray( this.siblings, this );\n\t  \t};\n\t\n\t  \tRadioBinding.prototype.unrender = function unrender () {\n\t  \t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t  \t\tthis.node.removeEventListener( 'click', handleDomEvent, false );\n\t  \t};\n\t\n\t  \treturn RadioBinding;\n\t  }(Binding));\n\t\n\t  function getValue$1() {\n\t  \tvar checked = this.bindings.filter( function ( b ) { return b.node.checked; } );\n\t  \tif ( checked.length > 0 ) {\n\t  \t\treturn checked[0].element.getAttribute( 'value' );\n\t  \t}\n\t  }\n\t\n\t  var RadioNameBinding = (function (Binding) {\n\t  \tfunction RadioNameBinding ( element ) {\n\t  \t\tBinding.call( this, element, 'name' );\n\t\n\t  \t\tthis.group = getBindingGroup( 'radioname', this.model, getValue$1 );\n\t  \t\tthis.group.add( this );\n\t\n\t  \t\tif ( element.checked ) {\n\t  \t\t\tthis.group.value = this.getValue();\n\t  \t\t}\n\t  \t}\n\t\n\t  \tRadioNameBinding.prototype = Object.create( Binding && Binding.prototype );\n\t  \tRadioNameBinding.prototype.constructor = RadioNameBinding;\n\t\n\t  \tRadioNameBinding.prototype.bind = function bind () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( !this.group.bound ) {\n\t  \t\t\tthis.group.bind();\n\t  \t\t}\n\t\n\t  \t\t// update name keypath when necessary\n\t  \t\tthis.nameAttributeBinding = {\n\t  \t\t\thandleChange: function () { return this$1.node.name = \"{{\" + (this$1.model.getKeypath()) + \"}}\"; }\n\t  \t\t};\n\t\n\t  \t\tthis.model.getKeypathModel().register( this.nameAttributeBinding );\n\t  \t};\n\t\n\t  \tRadioNameBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\tif ( this.element.getAttribute( 'checked' ) ) {\n\t  \t\t\treturn this.element.getAttribute( 'value' );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tRadioNameBinding.prototype.getValue = function getValue$1 () {\n\t  \t\treturn this.element.getAttribute( 'value' );\n\t  \t};\n\t\n\t  \tRadioNameBinding.prototype.handleChange = function handleChange () {\n\t  \t\t// If this <input> is the one that's checked, then the value of its\n\t  \t\t// `name` model gets set to its value\n\t  \t\tif ( this.node.checked ) {\n\t  \t\t\tthis.group.value = this.getValue();\n\t  \t\t\tBinding.prototype.handleChange.call(this);\n\t  \t\t}\n\t  \t};\n\t\n\t  \tRadioNameBinding.prototype.lastVal = function lastVal ( setting, value ) {\n\t  \t\tif ( !this.group ) return;\n\t  \t\tif ( setting ) this.group.lastValue = value;\n\t  \t\telse return this.group.lastValue;\n\t  \t};\n\t\n\t  \tRadioNameBinding.prototype.render = function render () {\n\t  \t\tBinding.prototype.render.call(this);\n\t\n\t  \t\tvar node = this.node;\n\t\n\t  \t\tnode.name = \"{{\" + (this.model.getKeypath()) + \"}}\";\n\t  \t\tnode.checked = this.model.get() == this.element.getAttribute( 'value' );\n\t\n\t  \t\tnode.addEventListener( 'change', handleDomEvent, false );\n\t\n\t  \t\tif ( node.attachEvent ) {\n\t  \t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tRadioNameBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t  \t\tif ( node.checked ) {\n\t  \t\t\tthis.group.model.set( this.element.getAttribute( 'value' ) );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tRadioNameBinding.prototype.unbind = function unbind () {\n\t  \t\tthis.group.remove( this );\n\t\n\t  \t\tthis.model.getKeypathModel().unregister( this.nameAttributeBinding );\n\t  \t};\n\t\n\t  \tRadioNameBinding.prototype.unrender = function unrender () {\n\t  \t\tvar node = this.node;\n\t\n\t  \t\tnode.removeEventListener( 'change', handleDomEvent, false );\n\t  \t\tnode.removeEventListener( 'click', handleDomEvent, false );\n\t  \t};\n\t\n\t  \treturn RadioNameBinding;\n\t  }(Binding));\n\t\n\t  var SingleSelectBinding = (function (Binding) {\n\t  \tfunction SingleSelectBinding () {\n\t  \t\tBinding.apply(this, arguments);\n\t  \t}\n\t\n\t  \tSingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n\t  \tSingleSelectBinding.prototype.constructor = SingleSelectBinding;\n\t\n\t  \tSingleSelectBinding.prototype.forceUpdate = function forceUpdate () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar value = this.getValue();\n\t\n\t  \t\tif ( value !== undefined ) {\n\t  \t\t\tthis.attribute.locked = true;\n\t  \t\t\trunloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\t  \t\t\tthis.model.set( value );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSingleSelectBinding.prototype.getInitialValue = function getInitialValue () {\n\t  \t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tvar options = this.element.options;\n\t  \t\tvar len = options.length;\n\t\n\t  \t\tif ( !len ) return;\n\t\n\t  \t\tvar value;\n\t  \t\tvar optionWasSelected;\n\t  \t\tvar i = len;\n\t\n\t  \t\t// take the final selected option...\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar option = options[i];\n\t\n\t  \t\t\tif ( option.getAttribute( 'selected' ) ) {\n\t  \t\t\t\tif ( !option.getAttribute( 'disabled' ) ) {\n\t  \t\t\t\t\tvalue = option.getAttribute( 'value' );\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\toptionWasSelected = true;\n\t  \t\t\t\tbreak;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// or the first non-disabled option, if none are selected\n\t  \t\tif ( !optionWasSelected ) {\n\t  \t\t\twhile ( ++i < len ) {\n\t  \t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n\t  \t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n\t  \t\t\t\t\tbreak;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// This is an optimisation (aka hack) that allows us to forgo some\n\t  \t\t// other more expensive work\n\t  \t\t// TODO does it still work? seems at odds with new architecture\n\t  \t\tif ( value !== undefined ) {\n\t  \t\t\tthis.element.attributeByName.value.value = value;\n\t  \t\t}\n\t\n\t  \t\treturn value;\n\t  \t};\n\t\n\t  \tSingleSelectBinding.prototype.getValue = function getValue () {\n\t  \t\tvar options = this.node.options;\n\t  \t\tvar len = options.length;\n\t\n\t  \t\tvar i;\n\t  \t\tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\t\tvar option = options[i];\n\t\n\t  \t\t\tif ( options[i].selected && !options[i].disabled ) {\n\t  \t\t\t\treturn option._ractive ? option._ractive.value : option.value;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSingleSelectBinding.prototype.render = function render () {\n\t  \t\tBinding.prototype.render.call(this);\n\t  \t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\t  \t};\n\t\n\t  \tSingleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {\n\t  \t\tvar option = getSelectedOptions( node )[0];\n\t  \t\tthis.model.set( option._ractive ? option._ractive.value : option.value );\n\t  \t};\n\t\n\t  \t// TODO this method is an anomaly... is it necessary?\n\t  \tSingleSelectBinding.prototype.setValue = function setValue ( value ) {\n\t  \t\tthis.model.set( value );\n\t  \t};\n\t\n\t  \tSingleSelectBinding.prototype.unrender = function unrender () {\n\t  \t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n\t  \t};\n\t\n\t  \treturn SingleSelectBinding;\n\t  }(Binding));\n\t\n\t  function isBindable ( attribute ) {\n\t  \treturn attribute &&\n\t  \t\t   attribute.template.f &&\n\t  \t       attribute.template.f.length === 1 &&\n\t  \t       attribute.template.f[0].t === INTERPOLATOR &&\n\t  \t       !attribute.template.f[0].s;\n\t  }\n\t\n\t  function selectBinding ( element ) {\n\t  \tvar attributes = element.attributeByName;\n\t\n\t  \t// contenteditable - bind if the contenteditable attribute is true\n\t  \t// or is bindable and may thus become true...\n\t  \tif ( element.getAttribute( 'contenteditable' ) || isBindable( attributes.contenteditable ) ) {\n\t  \t\t// ...and this element also has a value attribute to bind\n\t  \t\treturn isBindable( attributes.value ) ? ContentEditableBinding : null;\n\t  \t}\n\t\n\t  \t// <input>\n\t  \tif ( element.name === 'input' ) {\n\t  \t\tvar type = element.getAttribute( 'type' );\n\t\n\t  \t\tif ( type === 'radio' || type === 'checkbox' ) {\n\t  \t\t\tvar bindName = isBindable( attributes.name );\n\t  \t\t\tvar bindChecked = isBindable( attributes.checked );\n\t\n\t  \t\t\t// for radios we can either bind the name attribute, or the checked attribute - not both\n\t  \t\t\tif ( bindName && bindChecked ) {\n\t  \t\t\t\tif ( type === 'radio' ) {\n\t  \t\t\t\t\twarnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\t// A checkbox with bindings for both name and checked - see https://github.com/ractivejs/ractive/issues/1749\n\t  \t\t\t\t\treturn CheckboxBinding;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( bindName ) {\n\t  \t\t\t\treturn type === 'radio' ? RadioNameBinding : CheckboxNameBinding;\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( bindChecked ) {\n\t  \t\t\t\treturn type === 'radio' ? RadioBinding : CheckboxBinding;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tif ( type === 'file' && isBindable( attributes.value ) ) {\n\t  \t\t\treturn FileBinding;\n\t  \t\t}\n\t\n\t  \t\tif ( isBindable( attributes.value ) ) {\n\t  \t\t\treturn ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;\n\t  \t\t}\n\t\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \t// <select>\n\t  \tif ( element.name === 'select' && isBindable( attributes.value ) ) {\n\t  \t\treturn element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SingleSelectBinding;\n\t  \t}\n\t\n\t  \t// <textarea>\n\t  \tif ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n\t  \t\treturn GenericBinding;\n\t  \t}\n\t  }\n\t\n\t  function makeDirty$1 ( query ) {\n\t  \tquery.makeDirty();\n\t  }\n\t\n\t  var endsWithSemi = /;\\s*$/;\n\t\n\t  var Element = (function (Item) {\n\t  \tfunction Element ( options ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tItem.call( this, options );\n\t\n\t  \t\tthis.liveQueries = []; // TODO rare case. can we handle differently?\n\t\n\t  \t\tthis.name = options.template.e.toLowerCase();\n\t  \t\tthis.isVoid = voidElementNames.test( this.name );\n\t\n\t  \t\t// find parent element\n\t  \t\tthis.parent = findElement( this.parentFragment, false );\n\t\n\t  \t\tif ( this.parent && this.parent.name === 'option' ) {\n\t  \t\t\tthrow new Error( (\"An <option> element cannot contain other elements (encountered <\" + (this.name) + \">)\") );\n\t  \t\t}\n\t\n\t  \t\tthis.decorators = [];\n\t\n\t  \t\t// create attributes\n\t  \t\tthis.attributeByName = {};\n\t\n\t  \t\tthis.attributes = [];\n\t  \t\tvar leftovers = [];\n\t  \t\t( this.template.m || [] ).forEach( function ( template ) {\n\t  \t\t\tswitch ( template.t ) {\n\t  \t\t\t\tcase ATTRIBUTE:\n\t  \t\t\t\tcase BINDING_FLAG:\n\t  \t\t\t\tcase DECORATOR:\n\t  \t\t\t\tcase EVENT:\n\t  \t\t\t\tcase TRANSITION:\n\t  \t\t\t\t\tthis$1.attributes.push( createItem({\n\t  \t\t\t\t\t\towner: this$1,\n\t  \t\t\t\t\t\tparentFragment: this$1.parentFragment,\n\t  \t\t\t\t\t\ttemplate: template\n\t  \t\t\t\t\t}) );\n\t  \t\t\t\t\tbreak;\n\t\n\t  \t\t\t\tdefault:\n\t  \t\t\t\t\tleftovers.push( template );\n\t  \t\t\t\t\tbreak;\n\t  \t\t\t}\n\t  \t\t});\n\t\n\t  \t\tif ( leftovers.length ) {\n\t  \t\t\tthis.attributes.push( new ConditionalAttribute({\n\t  \t\t\t\towner: this,\n\t  \t\t\t\tparentFragment: this.parentFragment,\n\t  \t\t\t\ttemplate: leftovers\n\t  \t\t\t}) );\n\t  \t\t}\n\t\n\t  \t\tvar i = this.attributes.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar attr = this$1.attributes[ i ];\n\t  \t\t\tif ( attr.name === 'type' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t  \t\t\telse if ( attr.name === 'max' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t  \t\t\telse if ( attr.name === 'min' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t  \t\t\telse if ( attr.name === 'class' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t  \t\t\telse if ( attr.name === 'value' ) {\n\t  \t\t\t\tthis$1.attributes.push( this$1.attributes.splice( i, 1 )[ 0 ] );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// create children\n\t  \t\tif ( options.template.f && !options.deferContent ) {\n\t  \t\t\tthis.fragment = new Fragment({\n\t  \t\t\t\ttemplate: options.template.f,\n\t  \t\t\t\towner: this,\n\t  \t\t\t\tcssIds: null\n\t  \t\t\t});\n\t  \t\t}\n\t\n\t  \t\tthis.binding = null; // filled in later\n\t  \t}\n\t\n\t  \tElement.prototype = Object.create( Item && Item.prototype );\n\t  \tElement.prototype.constructor = Element;\n\t\n\t  \tElement.prototype.bind = function bind$1$$ () {\n\t  \t\tthis.attributes.binding = true;\n\t  \t\tthis.attributes.forEach( bind$1 );\n\t  \t\tthis.attributes.binding = false;\n\t\n\t  \t\tif ( this.fragment ) this.fragment.bind();\n\t\n\t  \t\t// create two-way binding if necessary\n\t  \t\tif ( !this.binding ) this.recreateTwowayBinding();\n\t  \t};\n\t\n\t  \tElement.prototype.createTwowayBinding = function createTwowayBinding () {\n\t  \t\tvar shouldBind = 'twoway' in this ? this.twoway : this.ractive.twoway;\n\t\n\t  \t\tif ( !shouldBind ) return null;\n\t\n\t  \t\tvar Binding = selectBinding( this );\n\t\n\t  \t\tif ( !Binding ) return null;\n\t\n\t  \t\tvar binding = new Binding( this );\n\t\n\t  \t\treturn binding && binding.model ?\n\t  \t\t\tbinding :\n\t  \t\t\tnull;\n\t  \t};\n\t\n\t  \tElement.prototype.destroyed = function destroyed () {\n\t  \t\tthis.attributes.forEach( function ( a ) { return a.destroyed(); } );\n\t  \t\tif ( this.fragment ) this.fragment.destroyed();\n\t  \t};\n\t\n\t  \tElement.prototype.detach = function detach () {\n\t  \t\t// if this element is no longer rendered, the transitions are complete and the attributes can be torn down\n\t  \t\tif ( !this.rendered ) this.destroyed();\n\t\n\t  \t\treturn detachNode( this.node );\n\t  \t};\n\t\n\t  \tElement.prototype.find = function find ( selector ) {\n\t  \t\tif ( matches( this.node, selector ) ) return this.node;\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\treturn this.fragment.find( selector );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tElement.prototype.findAll = function findAll ( selector, query ) {\n\t  \t\t// Add this node to the query, if applicable, and register the\n\t  \t\t// query on this element\n\t  \t\tvar matches = query.test( this.node );\n\t  \t\tif ( matches ) {\n\t  \t\t\tquery.add( this.node );\n\t  \t\t\tif ( query.live ) this.liveQueries.push( query );\n\t  \t\t}\n\t\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tthis.fragment.findAll( selector, query );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tElement.prototype.findComponent = function findComponent ( name ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\treturn this.fragment.findComponent( name );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tElement.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tthis.fragment.findAllComponents( name, query );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tElement.prototype.findNextNode = function findNextNode () {\n\t  \t\treturn null;\n\t  \t};\n\t\n\t  \tElement.prototype.firstNode = function firstNode () {\n\t  \t\treturn this.node;\n\t  \t};\n\t\n\t  \tElement.prototype.getAttribute = function getAttribute ( name ) {\n\t  \t\tvar attribute = this.attributeByName[ name ];\n\t  \t\treturn attribute ? attribute.getValue() : undefined;\n\t  \t};\n\t\n\t  \tElement.prototype.recreateTwowayBinding = function recreateTwowayBinding () {\n\t  \t\tif ( this.binding ) {\n\t  \t\t\tthis.binding.unbind();\n\t  \t\t\tthis.binding.unrender();\n\t  \t\t}\n\t\n\t  \t\tif ( this.binding = this.createTwowayBinding() ) {\n\t  \t\t\tthis.binding.bind();\n\t  \t\t\tif ( this.rendered ) this.binding.render();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tElement.prototype.render = function render$1 ( target, occupants ) {\n\t  \t\t// TODO determine correct namespace\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tthis.namespace = getNamespace( this );\n\t\n\t  \t\tvar node;\n\t  \t\tvar existing = false;\n\t\n\t  \t\tif ( occupants ) {\n\t  \t\t\tvar n;\n\t  \t\t\twhile ( ( n = occupants.shift() ) ) {\n\t  \t\t\t\tif ( n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() && n.namespaceURI === this$1.namespace ) {\n\t  \t\t\t\t\tthis$1.node = node = n;\n\t  \t\t\t\t\texisting = true;\n\t  \t\t\t\t\tbreak;\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\tdetachNode( n );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tif ( !node ) {\n\t  \t\t\tnode = createElement( this.template.e, this.namespace, this.getAttribute( 'is' ) );\n\t  \t\t\tthis.node = node;\n\t  \t\t}\n\t\n\t  \t\tdefineProperty( node, '_ractive', {\n\t  \t\t\tvalue: {\n\t  \t\t\t\tproxy: this\n\t  \t\t\t}\n\t  \t\t});\n\t\n\t  \t\t// Is this a top-level node of a component? If so, we may need to add\n\t  \t\t// a data-ractive-css attribute, for CSS encapsulation\n\t  \t\tif ( this.parentFragment.cssIds ) {\n\t  \t\t\tnode.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( function ( x ) { return (\"{\" + x + \"}\"); } ).join( ' ' ) );\n\t  \t\t}\n\t\n\t  \t\tif ( existing && this.foundNode ) this.foundNode( node );\n\t\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tvar children = existing ? toArray( node.childNodes ) : undefined;\n\t\n\t  \t\t\tthis.fragment.render( node, children );\n\t\n\t  \t\t\t// clean up leftover children\n\t  \t\t\tif ( children ) {\n\t  \t\t\t\tchildren.forEach( detachNode );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tif ( existing ) {\n\t  \t\t\t// store initial values for two-way binding\n\t  \t\t\tif ( this.binding && this.binding.wasUndefined ) this.binding.setFromNode( node );\n\t  \t\t\t// remove unused attributes\n\t  \t\t\tvar i = node.attributes.length;\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tvar name = node.attributes[i].name;\n\t  \t\t\t\tif ( !( name in this$1.attributeByName ) ) node.removeAttribute( name );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tthis.attributes.forEach( render );\n\t\n\t  \t\tif ( this.binding ) this.binding.render();\n\t\n\t  \t\tupdateLiveQueries$1( this );\n\t\n\t  \t\tif ( this._introTransition && this.ractive.transitionsEnabled ) {\n\t  \t\t\tthis._introTransition.isIntro = true;\n\t  \t\t\trunloop.registerTransition( this._introTransition );\n\t  \t\t}\n\t\n\t  \t\tif ( !existing ) {\n\t  \t\t\ttarget.appendChild( node );\n\t  \t\t}\n\t\n\t  \t\tthis.rendered = true;\n\t  \t};\n\t\n\t  \tElement.prototype.shuffled = function shuffled () {\n\t  \t\tthis.liveQueries.forEach( makeDirty$1 );\n\t  \t\tItem.prototype.shuffled.call(this);\n\t  \t};\n\t\n\t  \tElement.prototype.toString = function toString () {\n\t  \t\tvar tagName = this.template.e;\n\t\n\t  \t\tvar attrs = this.attributes.map( stringifyAttribute ).join( '' );\n\t\n\t  \t\t// Special case - selected options\n\t  \t\tif ( this.name === 'option' && this.isSelected() ) {\n\t  \t\t\tattrs += ' selected';\n\t  \t\t}\n\t\n\t  \t\t// Special case - two-way radio name bindings\n\t  \t\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n\t  \t\t\tattrs += ' checked';\n\t  \t\t}\n\t\n\t  \t\t// Special case style and class attributes and directives\n\t  \t\tvar style, cls;\n\t  \t\tthis.attributes.forEach( function ( attr ) {\n\t  \t\t\tif ( attr.name === 'class' ) {\n\t  \t\t\t\tcls = ( cls || '' ) + ( cls ? ' ' : '' ) + safeAttributeString( attr.getString() );\n\t  \t\t\t} else if ( attr.name === 'style' ) {\n\t  \t\t\t\tstyle = ( style || '' ) + ( style ? ' ' : '' ) + safeAttributeString( attr.getString() );\n\t  \t\t\t\tif ( style && !endsWithSemi.test( style ) ) style += ';';\n\t  \t\t\t} else if ( attr.styleName ) {\n\t  \t\t\t\tstyle = ( style || '' ) + ( style ? ' ' : '' ) +  \"\" + (decamelize( attr.styleName )) + \": \" + (safeAttributeString( attr.getString() )) + \";\";\n\t  \t\t\t} else if ( attr.inlineClass && attr.getValue() ) {\n\t  \t\t\t\tcls = ( cls || '' ) + ( cls ? ' ' : '' ) + attr.inlineClass;\n\t  \t\t\t}\n\t  \t\t});\n\t  \t\t// put classes first, then inline style\n\t  \t\tif ( style !== undefined ) attrs = ' style' + ( style ? (\"=\\\"\" + style + \"\\\"\") : '' ) + attrs;\n\t  \t\tif ( cls !== undefined ) attrs = ' class' + (cls ? (\"=\\\"\" + cls + \"\\\"\") : '') + attrs;\n\t\n\t  \t\tvar str = \"<\" + tagName + \"\" + attrs + \">\";\n\t\n\t  \t\tif ( this.isVoid ) return str;\n\t\n\t  \t\t// Special case - textarea\n\t  \t\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n\t  \t\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n\t  \t\t}\n\t\n\t  \t\t// Special case - contenteditable\n\t  \t\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n\t  \t\t\tstr += ( this.getAttribute( 'value' ) || '' );\n\t  \t\t}\n\t\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tstr += this.fragment.toString( !/^(?:script|style)$/i.test( this.template.e ) ); // escape text unless script/style\n\t  \t\t}\n\t\n\t  \t\tstr += \"</\" + tagName + \">\";\n\t  \t\treturn str;\n\t  \t};\n\t\n\t  \tElement.prototype.unbind = function unbind$1 () {\n\t  \t\tthis.attributes.forEach( unbind );\n\t\n\t  \t\tif ( this.binding ) this.binding.unbind();\n\t  \t\tif ( this.fragment ) this.fragment.unbind();\n\t  \t};\n\t\n\t  \tElement.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \t\tif ( !this.rendered ) return;\n\t  \t\tthis.rendered = false;\n\t\n\t  \t\t// unrendering before intro completed? complete it now\n\t  \t\t// TODO should be an API for aborting transitions\n\t  \t\tvar transition = this._introTransition;\n\t  \t\tif ( transition && transition.complete ) transition.complete();\n\t\n\t  \t\t// Detach as soon as we can\n\t  \t\tif ( this.name === 'option' ) {\n\t  \t\t\t// <option> elements detach immediately, so that\n\t  \t\t\t// their parent <select> element syncs correctly, and\n\t  \t\t\t// since option elements can't have transitions anyway\n\t  \t\t\tthis.detach();\n\t  \t\t} else if ( shouldDestroy ) {\n\t  \t\t\trunloop.detachWhenReady( this );\n\t  \t\t}\n\t\n\t  \t\tif ( this.fragment ) this.fragment.unrender();\n\t\n\t  \t\tif ( this.binding ) this.binding.unrender();\n\t\n\t  \t\t// outro transition\n\t  \t\tif ( this._outroTransition && this.ractive.transitionsEnabled ) {\n\t  \t\t\tthis._outroTransition.isIntro = false;\n\t  \t\t\trunloop.registerTransition( this._outroTransition );\n\t  \t\t}\n\t\n\t  \t\tremoveFromLiveQueries( this );\n\t  \t\t// TODO forms are a special case\n\t  \t};\n\t\n\t  \tElement.prototype.update = function update$1 () {\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t\n\t  \t\t\tthis.attributes.forEach( update );\n\t\n\t  \t\t\tif ( this.fragment ) this.fragment.update();\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Element;\n\t  }(Item));\n\t\n\t  function inputIsCheckedRadio ( element ) {\n\t  \tvar attributes = element.attributeByName;\n\t\n\t  \tvar typeAttribute  = attributes.type;\n\t  \tvar valueAttribute = attributes.value;\n\t  \tvar nameAttribute  = attributes.name;\n\t\n\t  \tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n\t  \t\treturn;\n\t  \t}\n\t\n\t  \tif ( valueAttribute.getValue() === nameAttribute.interpolator.model.get() ) {\n\t  \t\treturn true;\n\t  \t}\n\t  }\n\t\n\t  function stringifyAttribute ( attribute ) {\n\t  \tvar str = attribute.toString();\n\t  \treturn str ? ' ' + str : '';\n\t  }\n\t\n\t  function removeFromLiveQueries ( element ) {\n\t  \tvar i = element.liveQueries.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar query = element.liveQueries[i];\n\t  \t\tquery.remove( element.node );\n\t  \t}\n\t  }\n\t\n\t  function getNamespace ( element ) {\n\t  \t// Use specified namespace...\n\t  \tvar xmlns = element.getAttribute( 'xmlns' );\n\t  \tif ( xmlns ) return xmlns;\n\t\n\t  \t// ...or SVG namespace, if this is an <svg> element\n\t  \tif ( element.name === 'svg' ) return svg$1;\n\t\n\t  \tvar parent = element.parent;\n\t\n\t  \tif ( parent ) {\n\t  \t\t// ...or HTML, if the parent is a <foreignObject>\n\t  \t\tif ( parent.name === 'foreignobject' ) return html;\n\t\n\t  \t\t// ...or inherit from the parent node\n\t  \t\treturn parent.node.namespaceURI;\n\t  \t}\n\t\n\t  \treturn element.ractive.el.namespaceURI;\n\t  }\n\t\n\t  var Form = (function (Element) {\n\t  \tfunction Form ( options ) {\n\t  \t\tElement.call( this, options );\n\t  \t\tthis.formBindings = [];\n\t  \t}\n\t\n\t  \tForm.prototype = Object.create( Element && Element.prototype );\n\t  \tForm.prototype.constructor = Form;\n\t\n\t  \tForm.prototype.render = function render ( target, occupants ) {\n\t  \t\tElement.prototype.render.call( this, target, occupants );\n\t  \t\tthis.node.addEventListener( 'reset', handleReset, false );\n\t  \t};\n\t\n\t  \tForm.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \t\tthis.node.removeEventListener( 'reset', handleReset, false );\n\t  \t\tElement.prototype.unrender.call( this, shouldDestroy );\n\t  \t};\n\t\n\t  \treturn Form;\n\t  }(Element));\n\t\n\t  function handleReset () {\n\t  \tvar element = this._ractive.proxy;\n\t\n\t  \trunloop.start();\n\t  \telement.formBindings.forEach( updateModel$1 );\n\t  \trunloop.end();\n\t  }\n\t\n\t  function updateModel$1 ( binding ) {\n\t  \tbinding.model.set( binding.resetValue );\n\t  }\n\t\n\t  var Mustache = (function (Item) {\n\t  \tfunction Mustache ( options ) {\n\t  \t\tItem.call( this, options );\n\t\n\t  \t\tthis.parentFragment = options.parentFragment;\n\t  \t\tthis.template = options.template;\n\t  \t\tthis.index = options.index;\n\t  \t\tif ( options.owner ) this.parent = options.owner;\n\t\n\t  \t\tthis.isStatic = !!options.template.s;\n\t\n\t  \t\tthis.model = null;\n\t  \t\tthis.dirty = false;\n\t  \t}\n\t\n\t  \tMustache.prototype = Object.create( Item && Item.prototype );\n\t  \tMustache.prototype.constructor = Mustache;\n\t\n\t  \tMustache.prototype.bind = function bind () {\n\t  \t\t// try to find a model for this view\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar model = resolve$2( this.parentFragment, this.template );\n\t  \t\tvar value = model ? model.get() : undefined;\n\t\n\t  \t\tif ( this.isStatic ) {\n\t  \t\t\tthis.model = { get: function () { return value; } };\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tif ( model ) {\n\t  \t\t\tmodel.register( this );\n\t  \t\t\tthis.model = model;\n\t  \t\t} else {\n\t  \t\t\tthis.resolver = this.parentFragment.resolve( this.template.r, function ( model ) {\n\t  \t\t\t\tthis$1.model = model;\n\t  \t\t\t\tmodel.register( this$1 );\n\t\n\t  \t\t\t\tthis$1.handleChange();\n\t  \t\t\t\tthis$1.resolver = null;\n\t  \t\t\t});\n\t  \t\t}\n\t  \t};\n\t\n\t  \tMustache.prototype.handleChange = function handleChange () {\n\t  \t\tthis.bubble();\n\t  \t};\n\t\n\t  \tMustache.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t  \t\tnext = rebindMatch( this.template, next, previous );\n\t  \t\tif ( this['static'] ) return false;\n\t  \t\tif ( next === this.model ) return false;\n\t\n\t  \t\tif ( this.model ) {\n\t  \t\t\tthis.model.unregister( this );\n\t  \t\t}\n\t  \t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t  \t\tthis.model = next;\n\t  \t\tif ( !safe ) this.handleChange();\n\t  \t\treturn true;\n\t  \t};\n\t\n\t  \tMustache.prototype.unbind = function unbind () {\n\t  \t\tif ( !this.isStatic ) {\n\t  \t\t\tthis.model && this.model.unregister( this );\n\t  \t\t\tthis.model = undefined;\n\t  \t\t\tthis.resolver && this.resolver.unbind();\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Mustache;\n\t  }(Item));\n\t\n\t  var Interpolator = (function (Mustache) {\n\t  \tfunction Interpolator () {\n\t  \t\tMustache.apply(this, arguments);\n\t  \t}\n\t\n\t  \tInterpolator.prototype = Object.create( Mustache && Mustache.prototype );\n\t  \tInterpolator.prototype.constructor = Interpolator;\n\t\n\t  \tInterpolator.prototype.bubble = function bubble () {\n\t  \t\tif ( this.owner ) this.owner.bubble();\n\t  \t\tMustache.prototype.bubble.call(this);\n\t  \t};\n\t\n\t  \tInterpolator.prototype.detach = function detach () {\n\t  \t\treturn detachNode( this.node );\n\t  \t};\n\t\n\t  \tInterpolator.prototype.firstNode = function firstNode () {\n\t  \t\treturn this.node;\n\t  \t};\n\t\n\t  \tInterpolator.prototype.getString = function getString () {\n\t  \t\treturn this.model ? safeToStringValue( this.model.get() ) : '';\n\t  \t};\n\t\n\t  \tInterpolator.prototype.render = function render ( target, occupants ) {\n\t  \t\tif ( inAttributes() ) return;\n\t  \t\tvar value = this.getString();\n\t\n\t  \t\tthis.rendered = true;\n\t\n\t  \t\tif ( occupants ) {\n\t  \t\t\tvar n = occupants[0];\n\t  \t\t\tif ( n && n.nodeType === 3 ) {\n\t  \t\t\t\toccupants.shift();\n\t  \t\t\t\tif ( n.nodeValue !== value ) {\n\t  \t\t\t\t\tn.nodeValue = value;\n\t  \t\t\t\t}\n\t  \t\t\t} else {\n\t  \t\t\t\tn = this.node = doc.createTextNode( value );\n\t  \t\t\t\tif ( occupants[0] ) {\n\t  \t\t\t\t\ttarget.insertBefore( n, occupants[0] );\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\ttarget.appendChild( n );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.node = n;\n\t  \t\t} else {\n\t  \t\t\tthis.node = doc.createTextNode( value );\n\t  \t\t\ttarget.appendChild( this.node );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tInterpolator.prototype.toString = function toString ( escape ) {\n\t  \t\tvar string = this.getString();\n\t  \t\treturn escape ? escapeHtml( string ) : string;\n\t  \t};\n\t\n\t  \tInterpolator.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \t\tif ( shouldDestroy ) this.detach();\n\t  \t\tthis.rendered = false;\n\t  \t};\n\t\n\t  \tInterpolator.prototype.update = function update () {\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t  \t\t\tif ( this.rendered ) {\n\t  \t\t\t\tthis.node.data = this.getString();\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \tInterpolator.prototype.valueOf = function valueOf () {\n\t  \t\treturn this.model ? this.model.get() : undefined;\n\t  \t};\n\t\n\t  \treturn Interpolator;\n\t  }(Mustache));\n\t\n\t  var Input = (function (Element) {\n\t  \tfunction Input () {\n\t  \t\tElement.apply(this, arguments);\n\t  \t}\n\t\n\t  \tInput.prototype = Object.create( Element && Element.prototype );\n\t  \tInput.prototype.constructor = Input;\n\t\n\t  \tInput.prototype.render = function render ( target, occupants ) {\n\t  \t\tElement.prototype.render.call( this, target, occupants );\n\t  \t\tthis.node.defaultValue = this.node.value;\n\t  \t};\n\t\n\t  \treturn Input;\n\t  }(Element));\n\t\n\t  var Mapping = (function (Item) {\n\t  \tfunction Mapping ( options ) {\n\t  \t\tItem.call( this, options );\n\t\n\t  \t\tthis.name = options.template.n;\n\t\n\t  \t\tthis.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );\n\t  \t\tthis.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );\n\t  \t\tthis.parentFragment = this.element.parentFragment; // shared\n\t  \t\tthis.ractive = this.parentFragment.ractive;\n\t\n\t  \t\tthis.fragment = null;\n\t\n\t  \t\tthis.element.attributeByName[ this.name ] = this;\n\t\n\t  \t\tthis.value = options.template.f;\n\t  \t}\n\t\n\t  \tMapping.prototype = Object.create( Item && Item.prototype );\n\t  \tMapping.prototype.constructor = Mapping;\n\t\n\t  \tMapping.prototype.bind = function bind () {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tthis.fragment.bind();\n\t  \t\t}\n\t\n\t  \t\tvar template = this.template.f;\n\t  \t\tvar viewmodel = this.element.instance.viewmodel;\n\t\n\t  \t\tif ( template === 0 ) {\n\t  \t\t\t// empty attributes are `true`\n\t  \t\t\tviewmodel.joinKey( this.name ).set( true );\n\t  \t\t}\n\t\n\t  \t\telse if ( typeof template === 'string' ) {\n\t  \t\t\tvar parsed = parseJSON( template );\n\t  \t\t\tviewmodel.joinKey( this.name ).set( parsed ? parsed.value : template );\n\t  \t\t}\n\t\n\t  \t\telse if ( isArray( template ) ) {\n\t  \t\t\tcreateMapping( this, true );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tMapping.prototype.render = function render () {};\n\t\n\t  \tMapping.prototype.unbind = function unbind () {\n\t  \t\tif ( this.fragment ) this.fragment.unbind();\n\t  \t\tif ( this.boundFragment ) this.boundFragment.unbind();\n\t\n\t  \t\tif ( this.element.bound ) {\n\t  \t\t\tif ( this.link.target === this.model ) this.link.owner.unlink();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tMapping.prototype.unrender = function unrender () {};\n\t\n\t  \tMapping.prototype.update = function update () {\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t  \t\t\tif ( this.fragment ) this.fragment.update();\n\t  \t\t\tif ( this.boundFragment ) this.boundFragment.update();\n\t  \t\t\tif ( this.rendered ) this.updateDelegate();\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Mapping;\n\t  }(Item));\n\t\n\t  function createMapping ( item ) {\n\t  \tvar template = item.template.f;\n\t  \tvar viewmodel = item.element.instance.viewmodel;\n\t  \tvar childData = viewmodel.value;\n\t\n\t  \tif ( template.length === 1 && template[0].t === INTERPOLATOR ) {\n\t  \t\titem.model = resolve$2( item.parentFragment, template[0] );\n\t\n\t  \t\tif ( !item.model ) {\n\t  \t\t\twarnOnceIfDebug( (\"The \" + (item.name) + \"='{{\" + (template[0].r) + \"}}' mapping is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\"), { ractive: item.element.instance }); // TODO add docs page explaining item\n\t  \t\t\titem.parentFragment.ractive.get( item.name ); // side-effect: create mappings as necessary\n\t  \t\t\titem.model = item.parentFragment.findContext().joinKey( item.name );\n\t  \t\t}\n\t\n\t  \t\titem.link = viewmodel.createLink( item.name, item.model, template[0].r );\n\t\n\t  \t\tif ( item.model.get() === undefined && item.name in childData ) {\n\t  \t\t\titem.model.set( childData[ item.name ] );\n\t  \t\t}\n\t  \t}\n\t\n\t  \telse {\n\t  \t\titem.boundFragment = new Fragment({\n\t  \t\t\towner: item,\n\t  \t\t\ttemplate: template\n\t  \t\t}).bind();\n\t\n\t  \t\titem.model = viewmodel.joinKey( item.name );\n\t  \t\titem.model.set( item.boundFragment.valueOf() );\n\t\n\t  \t\t// item is a *bit* of a hack\n\t  \t\titem.boundFragment.bubble = function () {\n\t  \t\t\tFragment.prototype.bubble.call( item.boundFragment );\n\t  \t\t\t// defer this to avoid mucking around model deps if there happens to be an expression involved\n\t  \t\t\trunloop.scheduleTask(function () {\n\t  \t\t\t\titem.boundFragment.update();\n\t  \t\t\t\titem.model.set( item.boundFragment.valueOf() );\n\t  \t\t\t});\n\t  \t\t};\n\t  \t}\n\t  }\n\t\n\t  var Option = (function (Element) {\n\t  \tfunction Option ( options ) {\n\t  \t\tvar template = options.template;\n\t  \t\tif ( !template.a ) template.a = {};\n\t\n\t  \t\t// If the value attribute is missing, use the element's content,\n\t  \t\t// as long as it isn't disabled\n\t  \t\tif ( template.a.value === undefined && !( 'disabled' in template.a ) ) {\n\t  \t\t\ttemplate.a.value = template.f || '';\n\t  \t\t}\n\t\n\t  \t\tElement.call( this, options );\n\t\n\t  \t\tthis.select = findElement( this.parent || this.parentFragment, false, 'select' );\n\t  \t}\n\t\n\t  \tOption.prototype = Object.create( Element && Element.prototype );\n\t  \tOption.prototype.constructor = Option;\n\t\n\t  \tOption.prototype.bind = function bind () {\n\t  \t\tif ( !this.select ) {\n\t  \t\t\tElement.prototype.bind.call(this);\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\t// If the select has a value, it overrides the `selected` attribute on\n\t  \t\t// this option - so we delete the attribute\n\t  \t\tvar selectedAttribute = this.attributeByName.selected;\n\t  \t\tif ( selectedAttribute && this.select.getAttribute( 'value' ) !== undefined ) {\n\t  \t\t\tvar index = this.attributes.indexOf( selectedAttribute );\n\t  \t\t\tthis.attributes.splice( index, 1 );\n\t  \t\t\tdelete this.attributeByName.selected;\n\t  \t\t}\n\t\n\t  \t\tElement.prototype.bind.call(this);\n\t  \t\tthis.select.options.push( this );\n\t  \t};\n\t\n\t  \tOption.prototype.bubble = function bubble () {\n\t  \t\t// if we're using content as value, may need to update here\n\t  \t\tvar value = this.getAttribute( 'value' );\n\t  \t\tif ( this.node && this.node.value !== value ) {\n\t  \t\t\tthis.node._ractive.value = value;\n\t  \t\t}\n\t  \t\tElement.prototype.bubble.call(this);\n\t  \t};\n\t\n\t  \tOption.prototype.getAttribute = function getAttribute ( name ) {\n\t  \t\tvar attribute = this.attributeByName[ name ];\n\t  \t\treturn attribute ? attribute.getValue() : name === 'value' && this.fragment ? this.fragment.valueOf() : undefined;\n\t  \t};\n\t\n\t  \tOption.prototype.isSelected = function isSelected () {\n\t  \t\tvar optionValue = this.getAttribute( 'value' );\n\t\n\t  \t\tif ( optionValue === undefined || !this.select ) {\n\t  \t\t\treturn false;\n\t  \t\t}\n\t\n\t  \t\tvar selectValue = this.select.getAttribute( 'value' );\n\t\n\t  \t\tif ( selectValue == optionValue ) {\n\t  \t\t\treturn true;\n\t  \t\t}\n\t\n\t  \t\tif ( this.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n\t  \t\t\tvar i = selectValue.length;\n\t  \t\t\twhile ( i-- ) {\n\t  \t\t\t\tif ( selectValue[i] == optionValue ) {\n\t  \t\t\t\t\treturn true;\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \tOption.prototype.render = function render ( target, occupants ) {\n\t  \t\tElement.prototype.render.call( this, target, occupants );\n\t\n\t  \t\tif ( !this.attributeByName.value ) {\n\t  \t\t\tthis.node._ractive.value = this.getAttribute( 'value' );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tOption.prototype.unbind = function unbind () {\n\t  \t\tElement.prototype.unbind.call(this);\n\t\n\t  \t\tif ( this.select ) {\n\t  \t\t\tremoveFromArray( this.select.options, this );\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Option;\n\t  }(Element));\n\t\n\t  function getPartialTemplate ( ractive, name, parentFragment ) {\n\t  \t// If the partial in instance or view heirarchy instances, great\n\t  \tvar partial = getPartialFromRegistry( ractive, name, parentFragment || {} );\n\t  \tif ( partial ) return partial;\n\t\n\t  \t// Does it exist on the page as a script tag?\n\t  \tpartial = parser.fromId( name, { noThrow: true } );\n\t  \tif ( partial ) {\n\t  \t\t// parse and register to this ractive instance\n\t  \t\tvar parsed = parser.parseFor( partial, ractive );\n\t\n\t  \t\t// register extra partials on the ractive instance if they don't already exist\n\t  \t\tif ( parsed.p ) fillGaps( ractive.partials, parsed.p );\n\t\n\t  \t\t// register (and return main partial if there are others in the template)\n\t  \t\treturn ractive.partials[ name ] = parsed.t;\n\t  \t}\n\t  }\n\t\n\t  function getPartialFromRegistry ( ractive, name, parentFragment ) {\n\t  \t// if there was an instance up-hierarchy, cool\n\t  \tvar partial = findParentPartial( name, parentFragment.owner );\n\t  \tif ( partial ) return partial;\n\t\n\t  \t// find first instance in the ractive or view hierarchy that has this partial\n\t  \tvar instance = findInstance( 'partials', ractive, name );\n\t\n\t  \tif ( !instance ) { return; }\n\t\n\t  \tpartial = instance.partials[ name ];\n\t\n\t  \t// partial is a function?\n\t  \tvar fn;\n\t  \tif ( typeof partial === 'function' ) {\n\t  \t\tfn = partial.bind( instance );\n\t  \t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n\t  \t\tpartial = fn.call( ractive, parser );\n\t  \t}\n\t\n\t  \tif ( !partial && partial !== '' ) {\n\t  \t\twarnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive: ractive });\n\t  \t\treturn;\n\t  \t}\n\t\n\t  \t// If this was added manually to the registry,\n\t  \t// but hasn't been parsed, parse it now\n\t  \tif ( !parser.isParsed( partial ) ) {\n\t  \t\t// use the parseOptions of the ractive instance on which it was found\n\t  \t\tvar parsed = parser.parseFor( partial, instance );\n\t\n\t  \t\t// Partials cannot contain nested partials!\n\t  \t\t// TODO add a test for this\n\t  \t\tif ( parsed.p ) {\n\t  \t\t\twarnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });\n\t  \t\t}\n\t\n\t  \t\t// if fn, use instance to store result, otherwise needs to go\n\t  \t\t// in the correct point in prototype chain on instance or constructor\n\t  \t\tvar target = fn ? instance : findOwner( instance, name );\n\t\n\t  \t\t// may be a template with partials, which need to be registered and main template extracted\n\t  \t\ttarget.partials[ name ] = partial = parsed.t;\n\t  \t}\n\t\n\t  \t// store for reset\n\t  \tif ( fn ) partial._fn = fn;\n\t\n\t  \treturn partial.v ? partial.t : partial;\n\t  }\n\t\n\t  function findOwner ( ractive, key ) {\n\t  \treturn ractive.partials.hasOwnProperty( key )\n\t  \t\t? ractive\n\t  \t\t: findConstructor( ractive.constructor, key);\n\t  }\n\t\n\t  function findConstructor ( constructor, key ) {\n\t  \tif ( !constructor ) { return; }\n\t  \treturn constructor.partials.hasOwnProperty( key )\n\t  \t\t? constructor\n\t  \t\t: findConstructor( constructor._Parent, key );\n\t  }\n\t\n\t  function findParentPartial( name, parent ) {\n\t  \tif ( parent ) {\n\t  \t\tif ( parent.template && parent.template.p && parent.template.p[name] ) {\n\t  \t\t\treturn parent.template.p[name];\n\t  \t\t} else if ( parent.parentFragment && parent.parentFragment.owner ) {\n\t  \t\t\treturn findParentPartial( name, parent.parentFragment.owner );\n\t  \t\t}\n\t  \t}\n\t  }\n\t\n\t  var Partial = (function (Mustache) {\n\t  \tfunction Partial () {\n\t  \t\tMustache.apply(this, arguments);\n\t  \t}\n\t\n\t  \tPartial.prototype = Object.create( Mustache && Mustache.prototype );\n\t  \tPartial.prototype.constructor = Partial;\n\t\n\t  \tPartial.prototype.bind = function bind () {\n\t  \t\t// keep track of the reference name for future resets\n\t  \t\tthis.refName = this.template.r;\n\t\n\t  \t\t// name matches take priority over expressions\n\t  \t\tvar template = this.refName ? getPartialTemplate( this.ractive, this.refName, this.parentFragment ) || null : null;\n\t  \t\tvar templateObj;\n\t\n\t  \t\tif ( template ) {\n\t  \t\t\tthis.named = true;\n\t  \t\t\tthis.setTemplate( this.template.r, template );\n\t  \t\t}\n\t\n\t  \t\tif ( !template ) {\n\t  \t\t\tMustache.prototype.bind.call(this);\n\t  \t\t\tif ( this.model && ( templateObj = this.model.get() ) && typeof templateObj === 'object' && ( typeof templateObj.template === 'string' || isArray( templateObj.t ) ) ) {\n\t  \t\t\t\tif ( templateObj.template ) {\n\t  \t\t\t\t\tthis.source = templateObj.template;\n\t  \t\t\t\t\ttemplateObj = parsePartial( this.template.r, templateObj.template, this.ractive );\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\tthis.source = templateObj.t;\n\t  \t\t\t\t}\n\t  \t\t\t\tthis.setTemplate( this.template.r, templateObj.t );\n\t  \t\t\t} else if ( ( !this.model || typeof this.model.get() !== 'string' ) && this.refName ) {\n\t  \t\t\t\tthis.setTemplate( this.refName, template );\n\t  \t\t\t} else {\n\t  \t\t\t\tthis.setTemplate( this.model.get() );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tthis.fragment = new Fragment({\n\t  \t\t\towner: this,\n\t  \t\t\ttemplate: this.partialTemplate\n\t  \t\t}).bind();\n\t  \t};\n\t\n\t  \tPartial.prototype.detach = function detach () {\n\t  \t\treturn this.fragment.detach();\n\t  \t};\n\t\n\t  \tPartial.prototype.find = function find ( selector ) {\n\t  \t\treturn this.fragment.find( selector );\n\t  \t};\n\t\n\t  \tPartial.prototype.findAll = function findAll ( selector, query ) {\n\t  \t\tthis.fragment.findAll( selector, query );\n\t  \t};\n\t\n\t  \tPartial.prototype.findComponent = function findComponent ( name ) {\n\t  \t\treturn this.fragment.findComponent( name );\n\t  \t};\n\t\n\t  \tPartial.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t  \t\tthis.fragment.findAllComponents( name, query );\n\t  \t};\n\t\n\t  \tPartial.prototype.firstNode = function firstNode ( skipParent ) {\n\t  \t\treturn this.fragment.firstNode( skipParent );\n\t  \t};\n\t\n\t  \tPartial.prototype.forceResetTemplate = function forceResetTemplate () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tthis.partialTemplate = undefined;\n\t\n\t  \t\t// on reset, check for the reference name first\n\t  \t\tif ( this.refName ) {\n\t  \t\t\tthis.partialTemplate = getPartialTemplate( this.ractive, this.refName, this.parentFragment );\n\t  \t\t}\n\t\n\t  \t\t// then look for the resolved name\n\t  \t\tif ( !this.partialTemplate ) {\n\t  \t\t\tthis.partialTemplate = getPartialTemplate( this.ractive, this.name, this.parentFragment );\n\t  \t\t}\n\t\n\t  \t\tif ( !this.partialTemplate ) {\n\t  \t\t\twarnOnceIfDebug( (\"Could not find template for partial '\" + (this.name) + \"'\") );\n\t  \t\t\tthis.partialTemplate = [];\n\t  \t\t}\n\t\n\t  \t\tif ( this.inAttribute ) {\n\t  \t\t\tdoInAttributes( function () { return this$1.fragment.resetTemplate( this$1.partialTemplate ); } );\n\t  \t\t} else {\n\t  \t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t  \t\t}\n\t\n\t  \t\tthis.bubble();\n\t  \t};\n\t\n\t  \tPartial.prototype.render = function render ( target, occupants ) {\n\t  \t\tthis.fragment.render( target, occupants );\n\t  \t};\n\t\n\t  \tPartial.prototype.setTemplate = function setTemplate ( name, template ) {\n\t  \t\tthis.name = name;\n\t\n\t  \t\tif ( !template && template !== null ) template = getPartialTemplate( this.ractive, name, this.parentFragment );\n\t\n\t  \t\tif ( !template ) {\n\t  \t\t\twarnOnceIfDebug( (\"Could not find template for partial '\" + name + \"'\") );\n\t  \t\t}\n\t\n\t  \t\tthis.partialTemplate = template || [];\n\t  \t};\n\t\n\t  \tPartial.prototype.toString = function toString ( escape ) {\n\t  \t\treturn this.fragment.toString( escape );\n\t  \t};\n\t\n\t  \tPartial.prototype.unbind = function unbind () {\n\t  \t\tMustache.prototype.unbind.call(this);\n\t  \t\tthis.fragment.unbind();\n\t  \t};\n\t\n\t  \tPartial.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \t\tthis.fragment.unrender( shouldDestroy );\n\t  \t};\n\t\n\t  \tPartial.prototype.update = function update () {\n\t  \t\tvar template;\n\t\n\t  \t\tif ( this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t\n\t  \t\t\tif ( !this.named ) {\n\t  \t\t\t\tif ( this.model ) {\n\t  \t\t\t\t\ttemplate = this.model.get();\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tif ( template && typeof template === 'string' && template !== this.name ) {\n\t  \t\t\t\t\tthis.setTemplate( template );\n\t  \t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t  \t\t\t\t} else if ( template && typeof template === 'object' && ( typeof template.template === 'string' || isArray( template.t ) ) ) {\n\t  \t\t\t\t\tif ( template.t !== this.source && template.template !== this.source ) {\n\t  \t\t\t\t\t\tif ( template.template ) {\n\t  \t\t\t\t\t\t\tthis.source = template.template;\n\t  \t\t\t\t\t\t\ttemplate = parsePartial( this.name, template.template, this.ractive );\n\t  \t\t\t\t\t\t} else {\n\t  \t\t\t\t\t\t\tthis.source = template.t;\n\t  \t\t\t\t\t\t}\n\t  \t\t\t\t\t\tthis.setTemplate( this.name, template.t );\n\t  \t\t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n\t  \t\t\t\t\t}\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.fragment.update();\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Partial;\n\t  }(Mustache));\n\t\n\t  function parsePartial( name, partial, ractive ) {\n\t  \tvar parsed;\n\t\n\t  \ttry {\n\t  \t\tparsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n\t  \t} catch (e) {\n\t  \t\twarnIfDebug( (\"Could not parse partial from expression '\" + name + \"'\\n\" + (e.message)) );\n\t  \t}\n\t\n\t  \treturn parsed || { t: [] };\n\t  }\n\t\n\t  var RepeatedFragment = function RepeatedFragment ( options ) {\n\t  \tthis.parent = options.owner.parentFragment;\n\t\n\t  \t// bit of a hack, so reference resolution works without another\n\t  \t// layer of indirection\n\t  \tthis.parentFragment = this;\n\t  \tthis.owner = options.owner;\n\t  \tthis.ractive = this.parent.ractive;\n\t\n\t  \t// encapsulated styles should be inherited until they get applied by an element\n\t  \tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\t\n\t  \tthis.context = null;\n\t  \tthis.rendered = false;\n\t  \tthis.iterations = [];\n\t\n\t  \tthis.template = options.template;\n\t\n\t  \tthis.indexRef = options.indexRef;\n\t  \tthis.keyRef = options.keyRef;\n\t\n\t  \tthis.pendingNewIndices = null;\n\t  \tthis.previousIterations = null;\n\t\n\t  \t// track array versus object so updates of type rest\n\t  \tthis.isArray = false;\n\t  };\n\t\n\t  RepeatedFragment.prototype.bind = function bind ( context ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.context = context;\n\t  \tvar value = context.get();\n\t\n\t  \t// {{#each array}}...\n\t  \tif ( this.isArray = isArray( value ) ) {\n\t  \t\t// we can't use map, because of sparse arrays\n\t  \t\tthis.iterations = [];\n\t  \t\tvar max = value.length;\n\t  \t\tfor ( var i = 0; i < max; i += 1 ) {\n\t  \t\t\tthis$1.iterations[i] = this$1.createIteration( i, i );\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// {{#each object}}...\n\t  \telse if ( isObject( value ) ) {\n\t  \t\tthis.isArray = false;\n\t\n\t  \t\t// TODO this is a dreadful hack. There must be a neater way\n\t  \t\tif ( this.indexRef ) {\n\t  \t\t\tvar refs = this.indexRef.split( ',' );\n\t  \t\t\tthis.keyRef = refs[0];\n\t  \t\t\tthis.indexRef = refs[1];\n\t  \t\t}\n\t\n\t  \t\tthis.iterations = Object.keys( value ).map( function ( key, index ) {\n\t  \t\t\treturn this$1.createIteration( key, index );\n\t  \t\t});\n\t  \t}\n\t\n\t  \treturn this;\n\t  };\n\t\n\t  RepeatedFragment.prototype.bubble = function bubble () {\n\t  \tthis.owner.bubble();\n\t  };\n\t\n\t  RepeatedFragment.prototype.createIteration = function createIteration ( key, index ) {\n\t  \tvar fragment = new Fragment({\n\t  \t\towner: this,\n\t  \t\ttemplate: this.template\n\t  \t});\n\t\n\t  \t// TODO this is a bit hacky\n\t  \tfragment.key = key;\n\t  \tfragment.index = index;\n\t  \tfragment.isIteration = true;\n\t\n\t  \tvar model = this.context.joinKey( key );\n\t\n\t  \t// set up an iteration alias if there is one\n\t  \tif ( this.owner.template.z ) {\n\t  \t\tfragment.aliases = {};\n\t  \t\tfragment.aliases[ this.owner.template.z[0].n ] = model;\n\t  \t}\n\t\n\t  \treturn fragment.bind( model );\n\t  };\n\t\n\t  RepeatedFragment.prototype.destroyed = function destroyed () {\n\t  \tthis.iterations.forEach( function ( i ) { return i.destroyed(); } );\n\t  };\n\t\n\t  RepeatedFragment.prototype.detach = function detach () {\n\t  \tvar docFrag = createDocumentFragment();\n\t  \tthis.iterations.forEach( function ( fragment ) { return docFrag.appendChild( fragment.detach() ); } );\n\t  \treturn docFrag;\n\t  };\n\t\n\t  RepeatedFragment.prototype.find = function find ( selector ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar len = this.iterations.length;\n\t  \tvar i;\n\t\n\t  \tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\tvar found = this$1.iterations[i].find( selector );\n\t  \t\tif ( found ) return found;\n\t  \t}\n\t  };\n\t\n\t  RepeatedFragment.prototype.findAll = function findAll ( selector, query ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar len = this.iterations.length;\n\t  \tvar i;\n\t\n\t  \tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\tthis$1.iterations[i].findAll( selector, query );\n\t  \t}\n\t  };\n\t\n\t  RepeatedFragment.prototype.findComponent = function findComponent ( name ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar len = this.iterations.length;\n\t  \tvar i;\n\t\n\t  \tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\tvar found = this$1.iterations[i].findComponent( name );\n\t  \t\tif ( found ) return found;\n\t  \t}\n\t  };\n\t\n\t  RepeatedFragment.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar len = this.iterations.length;\n\t  \tvar i;\n\t\n\t  \tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\tthis$1.iterations[i].findAllComponents( name, query );\n\t  \t}\n\t  };\n\t\n\t  RepeatedFragment.prototype.findNextNode = function findNextNode ( iteration ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( iteration.index < this.iterations.length - 1 ) {\n\t  \t\tfor ( var i = iteration.index + 1; i < this$1.iterations.length; i++ ) {\n\t  \t\t\tvar node = this$1.iterations[ i ].firstNode( true );\n\t  \t\t\tif ( node ) return node;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn this.owner.findNextNode();\n\t  };\n\t\n\t  RepeatedFragment.prototype.firstNode = function firstNode ( skipParent ) {\n\t  \treturn this.iterations[0] ? this.iterations[0].firstNode( skipParent ) : null;\n\t  };\n\t\n\t  RepeatedFragment.prototype.rebinding = function rebinding ( next ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tthis.context = next;\n\t  \tthis.iterations.forEach( function ( fragment ) {\n\t  \t\tvar model = next ? next.joinKey( fragment.key || fragment.index ) : undefined;\n\t  \t\tfragment.context = model;\n\t  \t\tif ( this$1.owner.template.z ) {\n\t  \t\t\tfragment.aliases = {};\n\t  \t\t\tfragment.aliases[ this$1.owner.template.z[0].n ] = model;\n\t  \t\t}\n\t  \t});\n\t  };\n\t\n\t  RepeatedFragment.prototype.render = function render ( target, occupants ) {\n\t  \t// TODO use docFrag.cloneNode...\n\t\n\t  \tif ( this.iterations ) {\n\t  \t\tthis.iterations.forEach( function ( fragment ) { return fragment.render( target, occupants ); } );\n\t  \t}\n\t\n\t  \tthis.rendered = true;\n\t  };\n\t\n\t  RepeatedFragment.prototype.shuffle = function shuffle ( newIndices ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( !this.pendingNewIndices ) this.previousIterations = this.iterations.slice();\n\t\n\t  \tif ( !this.pendingNewIndices ) this.pendingNewIndices = [];\n\t\n\t  \tthis.pendingNewIndices.push( newIndices );\n\t\n\t  \tvar iterations = [];\n\t\n\t  \tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t  \t\tif ( newIndex === -1 ) return;\n\t\n\t  \t\tvar fragment = this$1.iterations[ oldIndex ];\n\t  \t\titerations[ newIndex ] = fragment;\n\t\n\t  \t\tif ( newIndex !== oldIndex && fragment ) fragment.dirty = true;\n\t  \t});\n\t\n\t  \tthis.iterations = iterations;\n\t\n\t  \tthis.bubble();\n\t  };\n\t\n\t  RepeatedFragment.prototype.shuffled = function shuffled () {\n\t  \tthis.iterations.forEach( function ( i ) { return i.shuffled(); } );\n\t  };\n\t\n\t  RepeatedFragment.prototype.toString = function toString$1$$ ( escape ) {\n\t  \treturn this.iterations ?\n\t  \t\tthis.iterations.map( escape ? toEscapedString : toString$1 ).join( '' ) :\n\t  \t\t'';\n\t  };\n\t\n\t  RepeatedFragment.prototype.unbind = function unbind$1 () {\n\t  \tthis.iterations.forEach( unbind );\n\t  \treturn this;\n\t  };\n\t\n\t  RepeatedFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t  \tthis.iterations.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n\t  \tif ( this.pendingNewIndices && this.previousIterations ) {\n\t  \t\tthis.previousIterations.forEach( function ( fragment ) {\n\t  \t\t\tif ( fragment.rendered ) shouldDestroy ? unrenderAndDestroy( fragment ) : unrender( fragment );\n\t  \t\t});\n\t  \t}\n\t  \tthis.rendered = false;\n\t  };\n\t\n\t  // TODO smart update\n\t  RepeatedFragment.prototype.update = function update$1 () {\n\t  \t// skip dirty check, since this is basically just a facade\n\t\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( this.pendingNewIndices ) {\n\t  \t\tthis.updatePostShuffle();\n\t  \t\treturn;\n\t  \t}\n\t\n\t  \tif ( this.updating ) return;\n\t  \tthis.updating = true;\n\t\n\t  \tvar value = this.context.get(),\n\t  \t\t\t  wasArray = this.isArray;\n\t\n\t  \tvar toRemove;\n\t  \tvar oldKeys;\n\t  \tvar reset = true;\n\t  \tvar i;\n\t\n\t  \tif ( this.isArray = isArray( value ) ) {\n\t  \t\tif ( wasArray ) {\n\t  \t\t\treset = false;\n\t  \t\t\tif ( this.iterations.length > value.length ) {\n\t  \t\t\t\ttoRemove = this.iterations.splice( value.length );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t} else if ( isObject( value ) && !wasArray ) {\n\t  \t\treset = false;\n\t  \t\ttoRemove = [];\n\t  \t\toldKeys = {};\n\t  \t\ti = this.iterations.length;\n\t\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar fragment$1 = this$1.iterations[i];\n\t  \t\t\tif ( fragment$1.key in value ) {\n\t  \t\t\t\toldKeys[ fragment$1.key ] = true;\n\t  \t\t\t} else {\n\t  \t\t\t\tthis$1.iterations.splice( i, 1 );\n\t  \t\t\t\ttoRemove.push( fragment$1 );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( reset ) {\n\t  \t\ttoRemove = this.iterations;\n\t  \t\tthis.iterations = [];\n\t  \t}\n\t\n\t  \tif ( toRemove ) {\n\t  \t\ttoRemove.forEach( function ( fragment ) {\n\t  \t\t\tfragment.unbind();\n\t  \t\t\tfragment.unrender( true );\n\t  \t\t});\n\t  \t}\n\t\n\t  \t// update the remaining ones\n\t  \tthis.iterations.forEach( update );\n\t\n\t  \t// add new iterations\n\t  \tvar newLength = isArray( value ) ?\n\t  \t\tvalue.length :\n\t  \t\tisObject( value ) ?\n\t  \t\t\tObject.keys( value ).length :\n\t  \t\t\t0;\n\t\n\t  \tvar docFrag;\n\t  \tvar fragment;\n\t\n\t  \tif ( newLength > this.iterations.length ) {\n\t  \t\tdocFrag = this.rendered ? createDocumentFragment() : null;\n\t  \t\ti = this.iterations.length;\n\t\n\t  \t\tif ( isArray( value ) ) {\n\t  \t\t\twhile ( i < value.length ) {\n\t  \t\t\t\tfragment = this$1.createIteration( i, i );\n\t\n\t  \t\t\t\tthis$1.iterations.push( fragment );\n\t  \t\t\t\tif ( this$1.rendered ) fragment.render( docFrag );\n\t\n\t  \t\t\t\ti += 1;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\telse if ( isObject( value ) ) {\n\t  \t\t\t// TODO this is a dreadful hack. There must be a neater way\n\t  \t\t\tif ( this.indexRef && !this.keyRef ) {\n\t  \t\t\t\tvar refs = this.indexRef.split( ',' );\n\t  \t\t\t\tthis.keyRef = refs[0];\n\t  \t\t\t\tthis.indexRef = refs[1];\n\t  \t\t\t}\n\t\n\t  \t\t\tObject.keys( value ).forEach( function ( key ) {\n\t  \t\t\t\tif ( !oldKeys || !( key in oldKeys ) ) {\n\t  \t\t\t\t\tfragment = this$1.createIteration( key, i );\n\t\n\t  \t\t\t\t\tthis$1.iterations.push( fragment );\n\t  \t\t\t\t\tif ( this$1.rendered ) fragment.render( docFrag );\n\t\n\t  \t\t\t\t\ti += 1;\n\t  \t\t\t\t}\n\t  \t\t\t});\n\t  \t\t}\n\t\n\t  \t\tif ( this.rendered ) {\n\t  \t\t\tvar parentNode = this.parent.findParentNode();\n\t  \t\t\tvar anchor = this.parent.findNextNode( this.owner );\n\t\n\t  \t\t\tparentNode.insertBefore( docFrag, anchor );\n\t  \t\t}\n\t  \t}\n\t\n\t  \tthis.updating = false;\n\t  };\n\t\n\t  RepeatedFragment.prototype.updatePostShuffle = function updatePostShuffle () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar newIndices = this.pendingNewIndices[ 0 ];\n\t\n\t  \t// map first shuffle through\n\t  \tthis.pendingNewIndices.slice( 1 ).forEach( function ( indices ) {\n\t  \t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t  \t\t\tnewIndices[ oldIndex ] = indices[ newIndex ];\n\t  \t\t});\n\t  \t});\n\t\n\t  \t// This algorithm (for detaching incorrectly-ordered fragments from the DOM and\n\t  \t// storing them in a document fragment for later reinsertion) seems a bit hokey,\n\t  \t// but it seems to work for now\n\t  \tvar len = this.context.get().length, oldLen = this.previousIterations.length;\n\t  \tvar i;\n\t  \tvar removed = {};\n\t\n\t  \tnewIndices.forEach( function ( newIndex, oldIndex ) {\n\t  \t\tvar fragment = this$1.previousIterations[ oldIndex ];\n\t  \t\tthis$1.previousIterations[ oldIndex ] = null;\n\t\n\t  \t\tif ( newIndex === -1 ) {\n\t  \t\t\tremoved[ oldIndex ] = fragment;\n\t  \t\t} else if ( fragment.index !== newIndex ) {\n\t  \t\t\tvar model = this$1.context.joinKey( newIndex );\n\t  \t\t\tfragment.index = newIndex;\n\t  \t\t\tfragment.context = model;\n\t  \t\t\tif ( this$1.owner.template.z ) {\n\t  \t\t\t\tfragment.aliases = {};\n\t  \t\t\t\tfragment.aliases[ this$1.owner.template.z[0].n ] = model;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t});\n\t\n\t  \t// if the array was spliced outside of ractive, sometimes there are leftover fragments not in the newIndices\n\t  \tthis.previousIterations.forEach( function ( frag, i ) {\n\t  \t\tif ( frag ) removed[ i ] = frag;\n\t  \t});\n\t\n\t  \t// create new/move existing iterations\n\t  \tvar docFrag = this.rendered ? createDocumentFragment() : null;\n\t  \tvar parentNode = this.rendered ? this.parent.findParentNode() : null;\n\t\n\t  \tvar contiguous = 'startIndex' in newIndices;\n\t  \ti = contiguous ? newIndices.startIndex : 0;\n\t\n\t  \tfor ( i; i < len; i++ ) {\n\t  \t\tvar frag = this$1.iterations[i];\n\t\n\t  \t\tif ( frag && contiguous ) {\n\t  \t\t\t// attach any built-up iterations\n\t  \t\t\tif ( this$1.rendered ) {\n\t  \t\t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\t  \t\t\t\tif ( docFrag.childNodes.length  ) parentNode.insertBefore( docFrag, frag.firstNode() );\n\t  \t\t\t}\n\t  \t\t\tcontinue;\n\t  \t\t}\n\t\n\t  \t\tif ( !frag ) this$1.iterations[i] = this$1.createIteration( i, i );\n\t\n\t  \t\tif ( this$1.rendered ) {\n\t  \t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\t\n\t  \t\t\tif ( frag ) docFrag.appendChild( frag.detach() );\n\t  \t\t\telse {\n\t  \t\t\t\tthis$1.iterations[i].render( docFrag );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// append any leftovers\n\t  \tif ( this.rendered ) {\n\t  \t\tfor ( i = len; i < oldLen; i++ ) {\n\t  \t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\t  \t\t}\n\t\n\t  \t\tif ( docFrag.childNodes.length ) {\n\t  \t\t\tparentNode.insertBefore( docFrag, this.owner.findNextNode() );\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// trigger removal on old nodes\n\t  \tObject.keys( removed ).forEach( function ( k ) { return removed[k].unbind().unrender( true ); } );\n\t\n\t  \tthis.iterations.forEach( update );\n\t\n\t  \tthis.pendingNewIndices = null;\n\t\n\t  \tthis.shuffled();\n\t  };\n\t\n\t  function isEmpty ( value ) {\n\t  \treturn !value ||\n\t  \t       ( isArray( value ) && value.length === 0 ) ||\n\t  \t\t   ( isObject( value ) && Object.keys( value ).length === 0 );\n\t  }\n\t\n\t  function getType ( value, hasIndexRef ) {\n\t  \tif ( hasIndexRef || isArray( value ) ) return SECTION_EACH;\n\t  \tif ( isObject( value ) || typeof value === 'function' ) return SECTION_IF_WITH;\n\t  \tif ( value === undefined ) return null;\n\t  \treturn SECTION_IF;\n\t  }\n\t\n\t  var Section = (function (Mustache) {\n\t  \tfunction Section ( options ) {\n\t  \t\tMustache.call( this, options );\n\t\n\t  \t\tthis.sectionType = options.template.n || null;\n\t  \t\tthis.templateSectionType = this.sectionType;\n\t  \t\tthis.subordinate = options.template.l === 1;\n\t  \t\tthis.fragment = null;\n\t  \t}\n\t\n\t  \tSection.prototype = Object.create( Mustache && Mustache.prototype );\n\t  \tSection.prototype.constructor = Section;\n\t\n\t  \tSection.prototype.bind = function bind () {\n\t  \t\tMustache.prototype.bind.call(this);\n\t\n\t  \t\tif ( this.subordinate ) {\n\t  \t\t\tthis.sibling = this.parentFragment.items[ this.parentFragment.items.indexOf( this ) - 1 ];\n\t  \t\t\tthis.sibling.nextSibling = this;\n\t  \t\t}\n\t\n\t  \t\t// if we managed to bind, we need to create children\n\t  \t\tif ( this.model ) {\n\t  \t\t\tthis.dirty = true;\n\t  \t\t\tthis.update();\n\t  \t\t} else if ( this.sectionType && this.sectionType === SECTION_UNLESS && ( !this.sibling || !this.sibling.isTruthy() ) ) {\n\t  \t\t\tthis.fragment = new Fragment({\n\t  \t\t\t\towner: this,\n\t  \t\t\t\ttemplate: this.template.f\n\t  \t\t\t}).bind();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSection.prototype.detach = function detach () {\n\t  \t\treturn this.fragment ? this.fragment.detach() : createDocumentFragment();\n\t  \t};\n\t\n\t  \tSection.prototype.find = function find ( selector ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\treturn this.fragment.find( selector );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSection.prototype.findAll = function findAll ( selector, query ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tthis.fragment.findAll( selector, query );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSection.prototype.findComponent = function findComponent ( name ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\treturn this.fragment.findComponent( name );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSection.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t  \t\tif ( this.fragment ) {\n\t  \t\t\tthis.fragment.findAllComponents( name, query );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSection.prototype.firstNode = function firstNode ( skipParent ) {\n\t  \t\treturn this.fragment && this.fragment.firstNode( skipParent );\n\t  \t};\n\t\n\t  \tSection.prototype.isTruthy = function isTruthy () {\n\t  \t\tif ( this.subordinate && this.sibling.isTruthy() ) return true;\n\t  \t\tvar value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n\t  \t\treturn !!value && ( this.templateSectionType === SECTION_IF_WITH || !isEmpty( value ) );\n\t  \t};\n\t\n\t  \tSection.prototype.rebinding = function rebinding ( next, previous, safe ) {\n\t  \t\tif ( Mustache.prototype.rebinding.call( this, next, previous, safe ) ) {\n\t  \t\t\tif ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {\n\t  \t\t\t\tthis.fragment.rebinding( next, previous );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSection.prototype.render = function render ( target, occupants ) {\n\t  \t\tthis.rendered = true;\n\t  \t\tif ( this.fragment ) this.fragment.render( target, occupants );\n\t  \t};\n\t\n\t  \tSection.prototype.shuffle = function shuffle ( newIndices ) {\n\t  \t\tif ( this.fragment && this.sectionType === SECTION_EACH ) {\n\t  \t\t\tthis.fragment.shuffle( newIndices );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSection.prototype.toString = function toString ( escape ) {\n\t  \t\treturn this.fragment ? this.fragment.toString( escape ) : '';\n\t  \t};\n\t\n\t  \tSection.prototype.unbind = function unbind () {\n\t  \t\tMustache.prototype.unbind.call(this);\n\t  \t\tif ( this.fragment ) this.fragment.unbind();\n\t  \t};\n\t\n\t  \tSection.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \t\tif ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );\n\t  \t\tthis.rendered = false;\n\t  \t};\n\t\n\t  \tSection.prototype.update = function update () {\n\t  \t\tif ( !this.dirty ) return;\n\t\n\t  \t\tif ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {\n\t  \t\t\tthis.fragment.context = this.model;\n\t  \t\t}\n\t\n\t  \t\tif ( !this.model && this.sectionType !== SECTION_UNLESS ) return;\n\t\n\t  \t\tthis.dirty = false;\n\t\n\t  \t\tvar value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n\t  \t\tvar siblingFalsey = !this.subordinate || !this.sibling.isTruthy();\n\t  \t\tvar lastType = this.sectionType;\n\t\n\t  \t\t// watch for switching section types\n\t  \t\tif ( this.sectionType === null || this.templateSectionType === null ) this.sectionType = getType( value, this.template.i );\n\t  \t\tif ( lastType && lastType !== this.sectionType && this.fragment ) {\n\t  \t\t\tif ( this.rendered ) {\n\t  \t\t\t\tthis.fragment.unbind().unrender( true );\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.fragment = null;\n\t  \t\t}\n\t\n\t  \t\tvar newFragment;\n\t\n\t  \t\tvar fragmentShouldExist = this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations\n\t  \t\t                            this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment\n\t  \t\t                            ( siblingFalsey && ( this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy() ) ); // if, unless, and if-with depend on siblings and the condition\n\t\n\t  \t\tif ( fragmentShouldExist ) {\n\t  \t\t\tif ( this.fragment ) {\n\t  \t\t\t\tthis.fragment.update();\n\t  \t\t\t} else {\n\t  \t\t\t\tif ( this.sectionType === SECTION_EACH ) {\n\t  \t\t\t\t\tnewFragment = new RepeatedFragment({\n\t  \t\t\t\t\t\towner: this,\n\t  \t\t\t\t\t\ttemplate: this.template.f,\n\t  \t\t\t\t\t\tindexRef: this.template.i\n\t  \t\t\t\t\t}).bind( this.model );\n\t  \t\t\t\t} else {\n\t  \t \t\t\t\t// only with and if-with provide context - if and unless do not\n\t  \t\t\t\t\tvar context = this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ? this.model : null;\n\t  \t\t\t\t\tnewFragment = new Fragment({\n\t  \t\t\t\t\t\towner: this,\n\t  \t\t\t\t\t\ttemplate: this.template.f\n\t  \t\t\t\t\t}).bind( context );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t} else {\n\t  \t\t\tif ( this.fragment && this.rendered ) {\n\t  \t\t\t\tthis.fragment.unbind().unrender( true );\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.fragment = null;\n\t  \t\t}\n\t\n\t  \t\tif ( newFragment ) {\n\t  \t\t\tif ( this.rendered ) {\n\t  \t\t\t\tvar parentNode = this.parentFragment.findParentNode();\n\t  \t\t\t\tvar anchor = this.parentFragment.findNextNode( this );\n\t\n\t  \t\t\t\tif ( anchor ) {\n\t  \t\t\t\t\tvar docFrag = createDocumentFragment();\n\t  \t\t\t\t\tnewFragment.render( docFrag );\n\t\n\t  \t\t\t\t\t// we use anchor.parentNode, not parentNode, because the sibling\n\t  \t\t\t\t\t// may be temporarily detached as a result of a shuffle\n\t  \t\t\t\t\tanchor.parentNode.insertBefore( docFrag, anchor );\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\tnewFragment.render( parentNode );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.fragment = newFragment;\n\t  \t\t}\n\t\n\t  \t\tif ( this.nextSibling ) {\n\t  \t\t\tthis.nextSibling.dirty = true;\n\t  \t\t\tthis.nextSibling.update();\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Section;\n\t  }(Mustache));\n\t\n\t  function valueContains ( selectValue, optionValue ) {\n\t  \tvar i = selectValue.length;\n\t  \twhile ( i-- ) {\n\t  \t\tif ( selectValue[i] == optionValue ) return true;\n\t  \t}\n\t  }\n\t\n\t  var Select = (function (Element) {\n\t  \tfunction Select ( options ) {\n\t  \t\tElement.call( this, options );\n\t  \t\tthis.options = [];\n\t  \t}\n\t\n\t  \tSelect.prototype = Object.create( Element && Element.prototype );\n\t  \tSelect.prototype.constructor = Select;\n\t\n\t  \tSelect.prototype.foundNode = function foundNode ( node ) {\n\t  \t\tif ( this.binding ) {\n\t  \t\t\tvar selectedOptions = getSelectedOptions( node );\n\t\n\t  \t\t\tif ( selectedOptions.length > 0 ) {\n\t  \t\t\t\tthis.selectedOptions = selectedOptions;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSelect.prototype.render = function render ( target, occupants ) {\n\t  \t\tElement.prototype.render.call( this, target, occupants );\n\t  \t\tthis.sync();\n\t\n\t  \t\tvar node = this.node;\n\t\n\t  \t\tvar i = node.options.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tnode.options[i].defaultSelected = node.options[i].selected;\n\t  \t\t}\n\t\n\t  \t\tthis.rendered = true;\n\t  \t};\n\t\n\t  \tSelect.prototype.sync = function sync () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar selectNode = this.node;\n\t\n\t  \t\tif ( !selectNode ) return;\n\t\n\t  \t\tvar options = toArray( selectNode.options );\n\t\n\t  \t\tif ( this.selectedOptions ) {\n\t  \t\t\toptions.forEach( function ( o ) {\n\t  \t\t\t\tif ( this$1.selectedOptions.indexOf( o ) >= 0 ) o.selected = true;\n\t  \t\t\t\telse o.selected = false;\n\t  \t\t\t});\n\t  \t\t\tthis.binding.setFromNode( selectNode );\n\t  \t\t\tdelete this.selectedOptions;\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tvar selectValue = this.getAttribute( 'value' );\n\t  \t\tvar isMultiple = this.getAttribute( 'multiple' );\n\t\n\t  \t\t// If the <select> has a specified value, that should override\n\t  \t\t// these options\n\t  \t\tif ( selectValue !== undefined ) {\n\t  \t\t\tvar optionWasSelected;\n\t\n\t  \t\t\toptions.forEach( function ( o ) {\n\t  \t\t\t\tvar optionValue = o._ractive ? o._ractive.value : o.value;\n\t  \t\t\t\tvar shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\t\n\t  \t\t\t\tif ( shouldSelect ) {\n\t  \t\t\t\t\toptionWasSelected = true;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\to.selected = shouldSelect;\n\t  \t\t\t});\n\t\n\t  \t\t\tif ( !optionWasSelected && !isMultiple ) {\n\t  \t\t\t\tif ( this.binding ) {\n\t  \t\t\t\t\tthis.binding.forceUpdate();\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// Otherwise the value should be initialised according to which\n\t  \t\t// <option> element is selected, if twoway binding is in effect\n\t  \t\telse if ( this.binding ) {\n\t  \t\t\tthis.binding.forceUpdate();\n\t  \t\t}\n\t  \t};\n\t\n\t  \tSelect.prototype.update = function update () {\n\t  \t\tElement.prototype.update.call(this);\n\t  \t\tthis.sync();\n\t  \t};\n\t\n\t  \treturn Select;\n\t  }(Element));\n\t\n\t  var Textarea = (function (Input) {\n\t  \tfunction Textarea( options ) {\n\t  \t\tvar template = options.template;\n\t\n\t  \t\toptions.deferContent = true;\n\t\n\t  \t\tInput.call( this, options );\n\t\n\t  \t\t// check for single interpolator binding\n\t  \t\tif ( !this.attributeByName.value ) {\n\t  \t\t\tif ( template.f && isBindable( { template: template } ) ) {\n\t  \t\t\t\tthis.attributes.push( createItem( {\n\t  \t\t\t\t\towner: this,\n\t  \t\t\t\t\ttemplate: { t: ATTRIBUTE, f: template.f, n: 'value' },\n\t  \t\t\t\t\tparentFragment: this.parentFragment\n\t  \t\t\t\t} ) );\n\t  \t\t\t} else {\n\t  \t\t\t\tthis.fragment = new Fragment({ owner: this, cssIds: null, template: template.f });\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tTextarea.prototype = Object.create( Input && Input.prototype );\n\t  \tTextarea.prototype.constructor = Textarea;\n\t\n\t  \tTextarea.prototype.bubble = function bubble () {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tif ( !this.dirty ) {\n\t  \t\t\tthis.dirty = true;\n\t\n\t  \t\t\tif ( this.rendered && !this.binding && this.fragment ) {\n\t  \t\t\t\trunloop.scheduleTask( function () {\n\t  \t\t\t\t\tthis$1.dirty = false;\n\t  \t\t\t\t\tthis$1.node.value = this$1.fragment.toString();\n\t  \t\t\t\t});\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.parentFragment.bubble(); // default behaviour\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Textarea;\n\t  }(Input));\n\t\n\t  var Text = (function (Item) {\n\t  \tfunction Text ( options ) {\n\t  \t\tItem.call( this, options );\n\t  \t\tthis.type = TEXT;\n\t  \t}\n\t\n\t  \tText.prototype = Object.create( Item && Item.prototype );\n\t  \tText.prototype.constructor = Text;\n\t\n\t  \tText.prototype.bind = function bind () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \tText.prototype.detach = function detach () {\n\t  \t\treturn detachNode( this.node );\n\t  \t};\n\t\n\t  \tText.prototype.firstNode = function firstNode () {\n\t  \t\treturn this.node;\n\t  \t};\n\t\n\t  \tText.prototype.render = function render ( target, occupants ) {\n\t  \t\tif ( inAttributes() ) return;\n\t  \t\tthis.rendered = true;\n\t\n\t  \t\tif ( occupants ) {\n\t  \t\t\tvar n = occupants[0];\n\t  \t\t\tif ( n && n.nodeType === 3 ) {\n\t  \t\t\t\toccupants.shift();\n\t  \t\t\t\tif ( n.nodeValue !== this.template ) {\n\t  \t\t\t\t\tn.nodeValue = this.template;\n\t  \t\t\t\t}\n\t  \t\t\t} else {\n\t  \t\t\t\tn = this.node = doc.createTextNode( this.template );\n\t  \t\t\t\tif ( occupants[0] ) {\n\t  \t\t\t\t\ttarget.insertBefore( n, occupants[0] );\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\ttarget.appendChild( n );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\tthis.node = n;\n\t  \t\t} else {\n\t  \t\t\tthis.node = doc.createTextNode( this.template );\n\t  \t\t\ttarget.appendChild( this.node );\n\t  \t\t}\n\t  \t};\n\t\n\t  \tText.prototype.toString = function toString ( escape ) {\n\t  \t\treturn escape ? escapeHtml( this.template ) : this.template;\n\t  \t};\n\t\n\t  \tText.prototype.unbind = function unbind () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \tText.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \t\tif ( this.rendered && shouldDestroy ) this.detach();\n\t  \t\tthis.rendered = false;\n\t  \t};\n\t\n\t  \tText.prototype.update = function update () {\n\t  \t\t// noop\n\t  \t};\n\t\n\t  \tText.prototype.valueOf = function valueOf () {\n\t  \t\treturn this.template;\n\t  \t};\n\t\n\t  \treturn Text;\n\t  }(Item));\n\t\n\t  var prefix;\n\t\n\t  if ( !isClient ) {\n\t  \tprefix = null;\n\t  } else {\n\t  \tvar prefixCache = {};\n\t  \tvar testStyle = createElement( 'div' ).style;\n\t\n\t  \tprefix = function ( prop ) {\n\t  \t\tprop = camelCase( prop );\n\t\n\t  \t\tif ( !prefixCache[ prop ] ) {\n\t  \t\t\tif ( testStyle[ prop ] !== undefined ) {\n\t  \t\t\t\tprefixCache[ prop ] = prop;\n\t  \t\t\t}\n\t\n\t  \t\t\telse {\n\t  \t\t\t\t// test vendors...\n\t  \t\t\t\tvar capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\t\n\t  \t\t\t\tvar i = vendors.length;\n\t  \t\t\t\twhile ( i-- ) {\n\t  \t\t\t\t\tvar vendor = vendors[i];\n\t  \t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n\t  \t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n\t  \t\t\t\t\t\tbreak;\n\t  \t\t\t\t\t}\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\treturn prefixCache[ prop ];\n\t  \t};\n\t  }\n\t\n\t  var prefix$1 = prefix;\n\t\n\t  var visible;\n\t  var hidden = 'hidden';\n\t\n\t  if ( doc ) {\n\t  \tvar prefix$2;\n\t\n\t  \tif ( hidden in doc ) {\n\t  \t\tprefix$2 = '';\n\t  \t} else {\n\t  \t\tvar i$1 = vendors.length;\n\t  \t\twhile ( i$1-- ) {\n\t  \t\t\tvar vendor = vendors[i$1];\n\t  \t\t\thidden = vendor + 'Hidden';\n\t\n\t  \t\t\tif ( hidden in doc ) {\n\t  \t\t\t\tprefix$2 = vendor;\n\t  \t\t\t\tbreak;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( prefix$2 !== undefined ) {\n\t  \t\tdoc.addEventListener( prefix$2 + 'visibilitychange', onChange );\n\t  \t\tonChange();\n\t  \t} else {\n\t  \t\t// gah, we're in an old browser\n\t  \t\tif ( 'onfocusout' in doc ) {\n\t  \t\t\tdoc.addEventListener( 'focusout', onHide );\n\t  \t\t\tdoc.addEventListener( 'focusin', onShow );\n\t  \t\t}\n\t\n\t  \t\telse {\n\t  \t\t\twin.addEventListener( 'pagehide', onHide );\n\t  \t\t\twin.addEventListener( 'blur', onHide );\n\t\n\t  \t\t\twin.addEventListener( 'pageshow', onShow );\n\t  \t\t\twin.addEventListener( 'focus', onShow );\n\t  \t\t}\n\t\n\t  \t\tvisible = true; // until proven otherwise. Not ideal but hey\n\t  \t}\n\t  }\n\t\n\t  function onChange () {\n\t  \tvisible = !doc[ hidden ];\n\t  }\n\t\n\t  function onHide () {\n\t  \tvisible = false;\n\t  }\n\t\n\t  function onShow () {\n\t  \tvisible = true;\n\t  }\n\t\n\t  var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\t\n\t  function unprefix ( prop ) {\n\t  \treturn prop.replace( unprefixPattern, '' );\n\t  }\n\t\n\t  var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\t\n\t  function hyphenate ( str ) {\n\t  \tif ( !str ) return ''; // edge case\n\t\n\t  \tif ( vendorPattern.test( str ) ) str = '-' + str;\n\t\n\t  \treturn str.replace( /[A-Z]/g, function ( match ) { return '-' + match.toLowerCase(); } );\n\t  }\n\t\n\t  var createTransitions;\n\t\n\t  if ( !isClient ) {\n\t  \tcreateTransitions = null;\n\t  } else {\n\t  \tvar testStyle$1 = createElement( 'div' ).style;\n\t  \tvar linear$1 = function ( x ) { return x; };\n\t\n\t  \tvar canUseCssTransitions = {};\n\t  \tvar cannotUseCssTransitions = {};\n\t\n\t  \t// determine some facts about our environment\n\t  \tvar TRANSITION$1;\n\t  \tvar TRANSITIONEND;\n\t  \tvar CSS_TRANSITIONS_ENABLED;\n\t  \tvar TRANSITION_DURATION;\n\t  \tvar TRANSITION_PROPERTY;\n\t  \tvar TRANSITION_TIMING_FUNCTION;\n\t\n\t  \tif ( testStyle$1.transition !== undefined ) {\n\t  \t\tTRANSITION$1 = 'transition';\n\t  \t\tTRANSITIONEND = 'transitionend';\n\t  \t\tCSS_TRANSITIONS_ENABLED = true;\n\t  \t} else if ( testStyle$1.webkitTransition !== undefined ) {\n\t  \t\tTRANSITION$1 = 'webkitTransition';\n\t  \t\tTRANSITIONEND = 'webkitTransitionEnd';\n\t  \t\tCSS_TRANSITIONS_ENABLED = true;\n\t  \t} else {\n\t  \t\tCSS_TRANSITIONS_ENABLED = false;\n\t  \t}\n\t\n\t  \tif ( TRANSITION$1 ) {\n\t  \t\tTRANSITION_DURATION = TRANSITION$1 + 'Duration';\n\t  \t\tTRANSITION_PROPERTY = TRANSITION$1 + 'Property';\n\t  \t\tTRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';\n\t  \t}\n\t\n\t  \tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\t\n\t  \t\t// Wait a beat (otherwise the target styles will be applied immediately)\n\t  \t\t// TODO use a fastdom-style mechanism?\n\t  \t\tsetTimeout( function () {\n\t  \t\t\tvar jsTransitionsComplete;\n\t  \t\t\tvar cssTransitionsComplete;\n\t  \t\t\tvar cssTimeout;\n\t\n\t  \t\t\tfunction transitionDone () { clearTimeout( cssTimeout ); }\n\t\n\t  \t\t\tfunction checkComplete () {\n\t  \t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n\t  \t\t\t\t\tt.unregisterCompleteHandler( transitionDone );\n\t  \t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n\t  \t\t\t\t\tt.ractive.fire( t.name + ':end', t.node, t.isIntro );\n\t  \t\t\t\t\tresolve();\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t\n\t  \t\t\t// this is used to keep track of which elements can use CSS to animate\n\t  \t\t\t// which properties\n\t  \t\t\tvar hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\t\n\t  \t\t\t// need to reset transition properties\n\t  \t\t\tvar style = t.node.style;\n\t  \t\t\tvar previous = {\n\t  \t\t\t\tproperty: style[ TRANSITION_PROPERTY ],\n\t  \t\t\t\ttiming: style[ TRANSITION_TIMING_FUNCTION ],\n\t  \t\t\t\tduration: style[ TRANSITION_DURATION ]\n\t  \t\t\t};\n\t\n\t  \t\t\tstyle[ TRANSITION_PROPERTY ] = changedProperties.map( prefix$1 ).map( hyphenate ).join( ',' );\n\t  \t\t\tstyle[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n\t  \t\t\tstyle[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\t\n\t  \t\t\tfunction transitionEndHandler ( event ) {\n\t  \t\t\t\tvar index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\t\n\t  \t\t\t\tif ( index !== -1 ) {\n\t  \t\t\t\t\tchangedProperties.splice( index, 1 );\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tif ( changedProperties.length ) {\n\t  \t\t\t\t\t// still transitioning...\n\t  \t\t\t\t\treturn;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tclearTimeout( cssTimeout );\n\t  \t\t\t\tcssTransitionsDone();\n\t  \t\t\t}\n\t\n\t  \t\t\tfunction cssTransitionsDone () {\n\t  \t\t\t\tstyle[ TRANSITION_PROPERTY ] = previous.property;\n\t  \t\t\t\tstyle[ TRANSITION_TIMING_FUNCTION ] = previous.duration;\n\t  \t\t\t\tstyle[ TRANSITION_DURATION ] = previous.timing;\n\t\n\t  \t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\n\t  \t\t\t\tcssTransitionsComplete = true;\n\t  \t\t\t\tcheckComplete();\n\t  \t\t\t}\n\t\n\t  \t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t\n\t  \t\t\t// safety net in case transitionend never fires\n\t  \t\t\tcssTimeout = setTimeout( function () {\n\t  \t\t\t\tchangedProperties = [];\n\t  \t\t\t\tcssTransitionsDone();\n\t  \t\t\t}, options.duration + ( options.delay || 0 ) + 50 );\n\t  \t\t\tt.registerCompleteHandler( transitionDone );\n\t\n\t  \t\t\tsetTimeout( function () {\n\t  \t\t\t\tvar i = changedProperties.length;\n\t  \t\t\t\tvar hash;\n\t  \t\t\t\tvar originalValue;\n\t  \t\t\t\tvar index;\n\t  \t\t\t\tvar propertiesToTransitionInJs = [];\n\t  \t\t\t\tvar prop;\n\t  \t\t\t\tvar suffix;\n\t  \t\t\t\tvar interpolator;\n\t\n\t  \t\t\t\twhile ( i-- ) {\n\t  \t\t\t\t\tprop = changedProperties[i];\n\t  \t\t\t\t\thash = hashPrefix + prop;\n\t\n\t  \t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n\t  \t\t\t\t\t\tstyle[ prefix$1( prop ) ] = to[ prop ];\n\t\n\t  \t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n\t  \t\t\t\t\t\t// this tag/property combo, find out now\n\t  \t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n\t  \t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t\n\t  \t\t\t\t\t\t\t// if this property is transitionable in this browser,\n\t  \t\t\t\t\t\t\t// the current style will be different from the target style\n\t  \t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n\t  \t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\t\n\t  \t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n\t  \t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n\t  \t\t\t\t\t\t\t\tstyle[ prefix$1( prop ) ] = originalValue;\n\t  \t\t\t\t\t\t\t}\n\t  \t\t\t\t\t\t}\n\t  \t\t\t\t\t}\n\t\n\t  \t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n\t  \t\t\t\t\t\t// we need to fall back to timer-based stuff\n\t  \t\t\t\t\t\tif ( originalValue === undefined ) {\n\t  \t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\t  \t\t\t\t\t\t}\n\t\n\t  \t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n\t  \t\t\t\t\t\t// will get confused\n\t  \t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n\t  \t\t\t\t\t\tif ( index === -1 ) {\n\t  \t\t\t\t\t\t\twarnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });\n\t  \t\t\t\t\t\t} else {\n\t  \t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n\t  \t\t\t\t\t\t}\n\t\n\t  \t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\t\n\t  \t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n\t  \t\t\t\t\t\tinterpolator = interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ) || ( function () { return to[ prop ]; } );\n\t\n\t  \t\t\t\t\t\t// ...then kick off a timer-based transition\n\t  \t\t\t\t\t\tpropertiesToTransitionInJs.push({\n\t  \t\t\t\t\t\t\tname: prefix$1( prop ),\n\t  \t\t\t\t\t\t\tinterpolator: interpolator,\n\t  \t\t\t\t\t\t\tsuffix: suffix\n\t  \t\t\t\t\t\t});\n\t  \t\t\t\t\t}\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\t// javascript transitions\n\t  \t\t\t\tif ( propertiesToTransitionInJs.length ) {\n\t  \t\t\t\t\tvar easing;\n\t\n\t  \t\t\t\t\tif ( typeof options.easing === 'string' ) {\n\t  \t\t\t\t\t\teasing = t.ractive.easing[ options.easing ];\n\t\n\t  \t\t\t\t\t\tif ( !easing ) {\n\t  \t\t\t\t\t\t\twarnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );\n\t  \t\t\t\t\t\t\teasing = linear$1;\n\t  \t\t\t\t\t\t}\n\t  \t\t\t\t\t} else if ( typeof options.easing === 'function' ) {\n\t  \t\t\t\t\t\teasing = options.easing;\n\t  \t\t\t\t\t} else {\n\t  \t\t\t\t\t\teasing = linear$1;\n\t  \t\t\t\t\t}\n\t\n\t  \t\t\t\t\tnew Ticker({\n\t  \t\t\t\t\t\tduration: options.duration,\n\t  \t\t\t\t\t\teasing: easing,\n\t  \t\t\t\t\t\tstep: function ( pos ) {\n\t  \t\t\t\t\t\t\tvar i = propertiesToTransitionInJs.length;\n\t  \t\t\t\t\t\t\twhile ( i-- ) {\n\t  \t\t\t\t\t\t\t\tvar prop = propertiesToTransitionInJs[i];\n\t  \t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n\t  \t\t\t\t\t\t\t}\n\t  \t\t\t\t\t\t},\n\t  \t\t\t\t\t\tcomplete: function () {\n\t  \t\t\t\t\t\t\tjsTransitionsComplete = true;\n\t  \t\t\t\t\t\t\tcheckComplete();\n\t  \t\t\t\t\t\t}\n\t  \t\t\t\t\t});\n\t  \t\t\t\t} else {\n\t  \t\t\t\t\tjsTransitionsComplete = true;\n\t  \t\t\t\t}\n\t\n\t  \t\t\t\tif ( !changedProperties.length ) {\n\t  \t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n\t  \t\t\t\t\t// the fact that it will never fire\n\t  \t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\t  \t\t\t\t\tcssTransitionsComplete = true;\n\t  \t\t\t\t\tcheckComplete();\n\t  \t\t\t\t}\n\t  \t\t\t}, 0 );\n\t  \t\t}, options.delay || 0 );\n\t  \t};\n\t  }\n\t\n\t  var createTransitions$1 = createTransitions;\n\t\n\t  function resetStyle ( node, style ) {\n\t  \tif ( style ) {\n\t  \t\tnode.setAttribute( 'style', style );\n\t  \t} else {\n\t  \t\t// Next line is necessary, to remove empty style attribute!\n\t  \t\t// See http://stackoverflow.com/a/7167553\n\t  \t\tnode.getAttribute( 'style' );\n\t  \t\tnode.removeAttribute( 'style' );\n\t  \t}\n\t  }\n\t\n\t  var getComputedStyle = win && ( win.getComputedStyle || legacy.getComputedStyle );\n\t  var resolved = Promise$1.resolve();\n\t\n\t  var names = {\n\t  \tt0: 'intro-outro',\n\t  \tt1: 'intro',\n\t  \tt2: 'outro'\n\t  };\n\t\n\t  var Transition = function Transition ( options ) {\n\t  \tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n\t  \tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n\t  \tthis.ractive = this.owner.ractive;\n\t  \tthis.template = options.template;\n\t  \tthis.parentFragment = options.parentFragment;\n\t  \tthis.options = options;\n\t  \tthis.onComplete = [];\n\t  };\n\t\n\t  Transition.prototype.animateStyle = function animateStyle ( style, value, options ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( arguments.length === 4 ) {\n\t  \t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n\t  \t}\n\t\n\t  \t// Special case - page isn't visible. Don't animate anything, because\n\t  \t// that way you'll never get CSS transitionend events\n\t  \tif ( !visible ) {\n\t  \t\tthis.setStyle( style, value );\n\t  \t\treturn resolved;\n\t  \t}\n\t\n\t  \tvar to;\n\t\n\t  \tif ( typeof style === 'string' ) {\n\t  \t\tto = {};\n\t  \t\tto[ style ] = value;\n\t  \t} else {\n\t  \t\tto = style;\n\t\n\t  \t\t// shuffle arguments\n\t  \t\toptions = value;\n\t  \t}\n\t\n\t  \t// As of 0.3.9, transition authors should supply an `option` object with\n\t  \t// `duration` and `easing` properties (and optional `delay`), plus a\n\t  \t// callback function that gets called after the animation completes\n\t\n\t  \t// TODO remove this check in a future version\n\t  \tif ( !options ) {\n\t  \t\twarnOnceIfDebug( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n\t  \t\toptions = this;\n\t  \t}\n\t\n\t  \treturn new Promise$1( function ( fulfil ) {\n\t  \t\t// Edge case - if duration is zero, set style synchronously and complete\n\t  \t\tif ( !options.duration ) {\n\t  \t\t\tthis$1.setStyle( to );\n\t  \t\t\tfulfil();\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\t// Get a list of the properties we're animating\n\t  \t\tvar propertyNames = Object.keys( to );\n\t  \t\tvar changedProperties = [];\n\t\n\t  \t\t// Store the current styles\n\t  \t\tvar computedStyle = getComputedStyle( this$1.owner.node );\n\t\n\t  \t\tvar i = propertyNames.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tvar prop = propertyNames[i];\n\t  \t\t\tvar current = computedStyle[ prefix$1( prop ) ];\n\t\n\t  \t\t\tif ( current === '0px' ) current = 0;\n\t\n\t  \t\t\t// we need to know if we're actually changing anything\n\t  \t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n\t  \t\t\t\tchangedProperties.push( prop );\n\t\n\t  \t\t\t\t// make the computed style explicit, so we can animate where\n\t  \t\t\t\t// e.g. height='auto'\n\t  \t\t\t\tthis$1.owner.node.style[ prefix$1( prop ) ] = current;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\t// If we're not actually changing anything, the transitionend event\n\t  \t\t// will never fire! So we complete early\n\t  \t\tif ( !changedProperties.length ) {\n\t  \t\t\tfulfil();\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tcreateTransitions$1( this$1, to, options, changedProperties, fulfil );\n\t  \t});\n\t  };\n\t\n\t  Transition.prototype.bind = function bind () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar options = this.options;\n\t  \tif ( options.template ) {\n\t  \t\tif ( options.template.v === 't0' || options.template.v == 't1' ) this.element._introTransition = this;\n\t  \t\tif ( options.template.v === 't0' || options.template.v == 't2' ) this.element._outroTransition = this;\n\t  \t\tthis.eventName = names[ options.template.v ];\n\t  \t}\n\t\n\t  \tvar ractive = this.owner.ractive;\n\t\n\t  \tif ( options.name ) {\n\t  \t\tthis.name = options.name;\n\t  \t} else {\n\t  \t\tvar name = options.template.f;\n\t  \t\tif ( typeof name.n === 'string' ) name = name.n;\n\t\n\t  \t\tif ( typeof name !== 'string' ) {\n\t  \t\t\tvar fragment = new Fragment({\n\t  \t\t\t\towner: this.owner,\n\t  \t\t\t\ttemplate: name.n\n\t  \t\t\t}).bind(); // TODO need a way to capture values without bind()\n\t\n\t  \t\t\tname = fragment.toString();\n\t  \t\t\tfragment.unbind();\n\t\n\t  \t\t\tif ( name === '' ) {\n\t  \t\t\t\t// empty string okay, just no transition\n\t  \t\t\t\treturn;\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tthis.name = name;\n\t  \t}\n\t\n\t  \tif ( options.params ) {\n\t  \t\tthis.params = options.params;\n\t  \t} else {\n\t  \t\tif ( options.template.f.a && !options.template.f.a.s ) {\n\t  \t\t\tthis.params = options.template.f.a;\n\t  \t\t}\n\t\n\t  \t\telse if ( options.template.f.d ) {\n\t  \t\t\t// TODO is there a way to interpret dynamic arguments without all the\n\t  \t\t\t// 'dependency thrashing'?\n\t  \t\t\tvar fragment$1 = new Fragment({\n\t  \t\t\t\towner: this.owner,\n\t  \t\t\t\ttemplate: options.template.f.d\n\t  \t\t\t}).bind();\n\t\n\t  \t\t\tthis.params = fragment$1.getArgsList();\n\t  \t\t\tfragment$1.unbind();\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( typeof this.name === 'function' ) {\n\t  \t\tthis._fn = this.name;\n\t  \t\tthis.name = this._fn.name;\n\t  \t} else {\n\t  \t\tthis._fn = findInViewHierarchy( 'transitions', ractive, this.name );\n\t  \t}\n\t\n\t  \tif ( !this._fn ) {\n\t  \t\twarnOnceIfDebug( missingPlugin( this.name, 'transition' ), { ractive: ractive });\n\t  \t}\n\t\n\t  \t// TODO: dry up after deprecation is done\n\t  \tif ( options.template && this.template.f.a && this.template.f.a.s ) {\n\t  \t\tthis.resolvers = [];\n\t  \t\tthis.models = this.template.f.a.r.map( function ( ref, i ) {\n\t  \t\t\tvar resolver;\n\t  \t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n\t  \t\t\tif ( !model ) {\n\t  \t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n\t  \t\t\t\t\tthis$1.models[i] = model;\n\t  \t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n\t  \t\t\t\t\tmodel.register( this$1 );\n\t  \t\t\t\t});\n\t\n\t  \t\t\t\tthis$1.resolvers.push( resolver );\n\t  \t\t\t} else model.register( this$1 );\n\t\n\t  \t\t\treturn model;\n\t  \t\t});\n\t  \t\tthis.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );\n\t  \t}\n\t  };\n\t\n\t  Transition.prototype.destroyed = function destroyed () {};\n\t\n\t  Transition.prototype.getStyle = function getStyle ( props ) {\n\t  \tvar computedStyle = getComputedStyle( this.owner.node );\n\t\n\t  \tif ( typeof props === 'string' ) {\n\t  \t\tvar value = computedStyle[ prefix$1( props ) ];\n\t  \t\treturn value === '0px' ? 0 : value;\n\t  \t}\n\t\n\t  \tif ( !isArray( props ) ) {\n\t  \t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n\t  \t}\n\t\n\t  \tvar styles = {};\n\t\n\t  \tvar i = props.length;\n\t  \twhile ( i-- ) {\n\t  \t\tvar prop = props[i];\n\t  \t\tvar value$1 = computedStyle[ prefix$1( prop ) ];\n\t\n\t  \t\tif ( value$1 === '0px' ) value$1 = 0;\n\t  \t\tstyles[ prop ] = value$1;\n\t  \t}\n\t\n\t  \treturn styles;\n\t  };\n\t\n\t  Transition.prototype.processParams = function processParams ( params, defaults ) {\n\t  \tif ( typeof params === 'number' ) {\n\t  \t\tparams = { duration: params };\n\t  \t}\n\t\n\t  \telse if ( typeof params === 'string' ) {\n\t  \t\tif ( params === 'slow' ) {\n\t  \t\t\tparams = { duration: 600 };\n\t  \t\t} else if ( params === 'fast' ) {\n\t  \t\t\tparams = { duration: 200 };\n\t  \t\t} else {\n\t  \t\t\tparams = { duration: 400 };\n\t  \t\t}\n\t  \t} else if ( !params ) {\n\t  \t\tparams = {};\n\t  \t}\n\t\n\t  \treturn extendObj( {}, defaults, params );\n\t  };\n\t\n\t  Transition.prototype.rebinding = function rebinding ( next, previous ) {\n\t  \tvar idx = this.models.indexOf( previous );\n\t  \tif ( !~idx ) return;\n\t\n\t  \tnext = rebindMatch( this.template.f.a.r[ idx ], next, previous );\n\t  \tif ( next === previous ) return;\n\t\n\t  \tprevious.unregister( this );\n\t  \tthis.models.splice( idx, 1, next );\n\t  \tif ( next ) next.addShuffleRegister( this, 'mark' );\n\t  };\n\t\n\t  Transition.prototype.registerCompleteHandler = function registerCompleteHandler ( fn ) {\n\t  \taddToArray( this.onComplete, fn );\n\t  };\n\t\n\t  Transition.prototype.render = function render () {};\n\t\n\t  Transition.prototype.setStyle = function setStyle ( style, value ) {\n\t  \tif ( typeof style === 'string' ) {\n\t  \t\tthis.owner.node.style[ prefix$1( style ) ] = value;\n\t  \t}\n\t\n\t  \telse {\n\t  \t\tvar prop;\n\t  \t\tfor ( prop in style ) {\n\t  \t\t\tif ( style.hasOwnProperty( prop ) ) {\n\t  \t\t\t\tthis.owner.node.style[ prefix$1( prop ) ] = style[ prop ];\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn this;\n\t  };\n\t\n\t  Transition.prototype.start = function start () {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar node = this.node = this.element.node;\n\t  \tvar originalStyle = node.getAttribute( 'style' );\n\t\n\t  \tvar completed;\n\t  \tvar args = this.params;\n\t\n\t  \t// create t.complete() - we don't want this on the prototype,\n\t  \t// because we don't want `this` silliness when passing it as\n\t  \t// an argument\n\t  \tthis.complete = function ( noReset ) {\n\t  \t\tif ( completed ) {\n\t  \t\t\treturn;\n\t  \t\t}\n\t\n\t  \t\tthis$1.onComplete.forEach( function ( fn ) { return fn(); } );\n\t  \t\tif ( !noReset && this$1.isIntro ) {\n\t  \t\t\tresetStyle( node, originalStyle);\n\t  \t\t}\n\t\n\t  \t\tthis$1._manager.remove( this$1 );\n\t\n\t  \t\tcompleted = true;\n\t  \t};\n\t\n\t  \t// If the transition function doesn't exist, abort\n\t  \tif ( !this._fn ) {\n\t  \t\tthis.complete();\n\t  \t\treturn;\n\t  \t}\n\t\n\t  \t// get expression args if supplied\n\t  \tif ( this.argsFn ) {\n\t  \t\tvar values = this.models.map( function ( model ) {\n\t  \t\t\tif ( !model ) return undefined;\n\t\n\t  \t\t\treturn model.get();\n\t  \t\t});\n\t  \t\targs = this.argsFn.apply( this.ractive, values );\n\t  \t}\n\t\n\t  \tvar promise = this._fn.apply( this.ractive, [ this ].concat( args ) );\n\t  \tif ( promise ) promise.then( this.complete );\n\t  };\n\t\n\t  Transition.prototype.toString = function toString () { return ''; };\n\t\n\t  Transition.prototype.unbind = function unbind$1 () {\n\t  \tif ( this.resolvers ) this.resolvers.forEach( unbind );\n\t  };\n\t\n\t  Transition.prototype.unregisterCompleteHandler = function unregisterCompleteHandler ( fn ) {\n\t  \tremoveFromArray( this.onComplete, fn );\n\t  };\n\t\n\t  Transition.prototype.unrender = function unrender () {};\n\t\n\t  Transition.prototype.update = function update () {};\n\t\n\t  var elementCache = {};\n\t\n\t  var ieBug;\n\t  var ieBlacklist;\n\t\n\t  try {\n\t  \tcreateElement( 'table' ).innerHTML = 'foo';\n\t  } catch ( err ) {\n\t  \tieBug = true;\n\t\n\t  \tieBlacklist = {\n\t  \t\tTABLE:  [ '<table class=\"x\">', '</table>' ],\n\t  \t\tTHEAD:  [ '<table><thead class=\"x\">', '</thead></table>' ],\n\t  \t\tTBODY:  [ '<table><tbody class=\"x\">', '</tbody></table>' ],\n\t  \t\tTR:     [ '<table><tr class=\"x\">', '</tr></table>' ],\n\t  \t\tSELECT: [ '<select class=\"x\">', '</select>' ]\n\t  \t};\n\t  }\n\t\n\t  function insertHtml ( html, node, docFrag ) {\n\t  \tvar nodes = [];\n\t\n\t  \t// render 0 and false\n\t  \tif ( html == null || html === '' ) return nodes;\n\t\n\t  \tvar container;\n\t  \tvar wrapper;\n\t  \tvar selectedOption;\n\t\n\t  \tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n\t  \t\tcontainer = element( 'DIV' );\n\t  \t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n\t  \t\tcontainer = container.querySelector( '.x' );\n\t\n\t  \t\tif ( container.tagName === 'SELECT' ) {\n\t  \t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t  \t\t}\n\t  \t}\n\t\n\t  \telse if ( node.namespaceURI === svg$1 ) {\n\t  \t\tcontainer = element( 'DIV' );\n\t  \t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n\t  \t\tcontainer = container.querySelector( '.x' );\n\t  \t}\n\t\n\t  \telse if ( node.tagName === 'TEXTAREA' ) {\n\t  \t\tcontainer = createElement( 'div' );\n\t\n\t  \t\tif ( typeof container.textContent !== 'undefined' ) {\n\t  \t\t\tcontainer.textContent = html;\n\t  \t\t} else {\n\t  \t\t\tcontainer.innerHTML = html;\n\t  \t\t}\n\t  \t}\n\t\n\t  \telse {\n\t  \t\tcontainer = element( node.tagName );\n\t  \t\tcontainer.innerHTML = html;\n\t\n\t  \t\tif ( container.tagName === 'SELECT' ) {\n\t  \t\t\tselectedOption = container.options[ container.selectedIndex ];\n\t  \t\t}\n\t  \t}\n\t\n\t  \tvar child;\n\t  \twhile ( child = container.firstChild ) {\n\t  \t\tnodes.push( child );\n\t  \t\tdocFrag.appendChild( child );\n\t  \t}\n\t\n\t  \t// This is really annoying. Extracting <option> nodes from the\n\t  \t// temporary container <select> causes the remaining ones to\n\t  \t// become selected. So now we have to deselect them. IE8, you\n\t  \t// amaze me. You really do\n\t  \t// ...and now Chrome too\n\t  \tvar i;\n\t  \tif ( node.tagName === 'SELECT' ) {\n\t  \t\ti = nodes.length;\n\t  \t\twhile ( i-- ) {\n\t  \t\t\tif ( nodes[i] !== selectedOption ) {\n\t  \t\t\t\tnodes[i].selected = false;\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn nodes;\n\t  }\n\t\n\t  function element ( tagName ) {\n\t  \treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n\t  }\n\t\n\t  var Triple = (function (Mustache) {\n\t  \tfunction Triple ( options ) {\n\t  \t\tMustache.call( this, options );\n\t  \t}\n\t\n\t  \tTriple.prototype = Object.create( Mustache && Mustache.prototype );\n\t  \tTriple.prototype.constructor = Triple;\n\t\n\t  \tTriple.prototype.detach = function detach () {\n\t  \t\tvar docFrag = createDocumentFragment();\n\t  \t\tthis.nodes.forEach( function ( node ) { return docFrag.appendChild( node ); } );\n\t  \t\treturn docFrag;\n\t  \t};\n\t\n\t  \tTriple.prototype.find = function find ( selector ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar len = this.nodes.length;\n\t  \t\tvar i;\n\t\n\t  \t\tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\t\tvar node = this$1.nodes[i];\n\t\n\t  \t\t\tif ( node.nodeType !== 1 ) continue;\n\t\n\t  \t\t\tif ( matches( node, selector ) ) return node;\n\t\n\t  \t\t\tvar queryResult = node.querySelector( selector );\n\t  \t\t\tif ( queryResult ) return queryResult;\n\t  \t\t}\n\t\n\t  \t\treturn null;\n\t  \t};\n\t\n\t  \tTriple.prototype.findAll = function findAll ( selector, query ) {\n\t  \t\tvar this$1 = this;\n\t\n\t  \t\tvar len = this.nodes.length;\n\t  \t\tvar i;\n\t\n\t  \t\tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\t\tvar node = this$1.nodes[i];\n\t\n\t  \t\t\tif ( node.nodeType !== 1 ) continue;\n\t\n\t  \t\t\tif ( query.test( node ) ) query.add( node );\n\t\n\t  \t\t\tvar queryAllResult = node.querySelectorAll( selector );\n\t  \t\t\tif ( queryAllResult ) {\n\t  \t\t\t\tvar numNodes = queryAllResult.length;\n\t  \t\t\t\tvar j;\n\t\n\t  \t\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n\t  \t\t\t\t\tquery.add( queryAllResult[j] );\n\t  \t\t\t\t}\n\t  \t\t\t}\n\t  \t\t}\n\t  \t};\n\t\n\t  \tTriple.prototype.findComponent = function findComponent () {\n\t  \t\treturn null;\n\t  \t};\n\t\n\t  \tTriple.prototype.firstNode = function firstNode () {\n\t  \t\treturn this.nodes[0];\n\t  \t};\n\t\n\t  \tTriple.prototype.render = function render ( target ) {\n\t  \t\tvar html = this.model ? this.model.get() : '';\n\t  \t\tthis.nodes = insertHtml( html, this.parentFragment.findParentNode(), target );\n\t  \t\tthis.rendered = true;\n\t  \t};\n\t\n\t  \tTriple.prototype.toString = function toString () {\n\t  \t\treturn this.model && this.model.get() != null ? decodeCharacterReferences( '' + this.model.get() ) : '';\n\t  \t};\n\t\n\t  \tTriple.prototype.unrender = function unrender () {\n\t  \t\tif ( this.nodes ) this.nodes.forEach( function ( node ) { return detachNode( node ); } );\n\t  \t\tthis.rendered = false;\n\t  \t};\n\t\n\t  \tTriple.prototype.update = function update () {\n\t  \t\tif ( this.rendered && this.dirty ) {\n\t  \t\t\tthis.dirty = false;\n\t\n\t  \t\t\tthis.unrender();\n\t  \t\t\tvar docFrag = createDocumentFragment();\n\t  \t\t\tthis.render( docFrag );\n\t\n\t  \t\t\tvar parentNode = this.parentFragment.findParentNode();\n\t  \t\t\tvar anchor = this.parentFragment.findNextNode( this );\n\t\n\t  \t\t\tparentNode.insertBefore( docFrag, anchor );\n\t  \t\t} else {\n\t  \t\t\t// make sure to reset the dirty flag even if not rendered\n\t  \t\t\tthis.dirty = false;\n\t  \t\t}\n\t  \t};\n\t\n\t  \treturn Triple;\n\t  }(Mustache));\n\t\n\t  var Yielder = (function (Item) {\n\t  \tfunction Yielder ( options ) {\n\t  \t\tItem.call( this, options );\n\t\n\t  \t\tthis.container = options.parentFragment.ractive;\n\t  \t\tthis.component = this.container.component;\n\t\n\t  \t\tthis.containerFragment = options.parentFragment;\n\t  \t\tthis.parentFragment = this.component.parentFragment;\n\t\n\t  \t\t// {{yield}} is equivalent to {{yield content}}\n\t  \t\tthis.name = options.template.n || '';\n\t  \t}\n\t\n\t  \tYielder.prototype = Object.create( Item && Item.prototype );\n\t  \tYielder.prototype.constructor = Yielder;\n\t\n\t  \tYielder.prototype.bind = function bind () {\n\t  \t\tvar name = this.name;\n\t\n\t  \t\t( this.component.yielders[ name ] || ( this.component.yielders[ name ] = [] ) ).push( this );\n\t\n\t  \t\t// TODO don't parse here\n\t  \t\tvar template = this.container._inlinePartials[ name || 'content' ];\n\t\n\t  \t\tif ( typeof template === 'string' ) {\n\t  \t\t\ttemplate = parse( template ).t;\n\t  \t\t}\n\t\n\t  \t\tif ( !template ) {\n\t  \t\t\twarnIfDebug( (\"Could not find template for partial \\\"\" + name + \"\\\"\"), { ractive: this.ractive });\n\t  \t\t\ttemplate = [];\n\t  \t\t}\n\t\n\t  \t\tthis.fragment = new Fragment({\n\t  \t\t\towner: this,\n\t  \t\t\tractive: this.container.parent,\n\t  \t\t\ttemplate: template\n\t  \t\t}).bind();\n\t  \t};\n\t\n\t  \tYielder.prototype.bubble = function bubble () {\n\t  \t\tif ( !this.dirty ) {\n\t  \t\t\tthis.containerFragment.bubble();\n\t  \t\t\tthis.dirty = true;\n\t  \t\t}\n\t  \t};\n\t\n\t  \tYielder.prototype.detach = function detach () {\n\t  \t\treturn this.fragment.detach();\n\t  \t};\n\t\n\t  \tYielder.prototype.find = function find ( selector ) {\n\t  \t\treturn this.fragment.find( selector );\n\t  \t};\n\t\n\t  \tYielder.prototype.findAll = function findAll ( selector, queryResult ) {\n\t  \t\tthis.fragment.findAll( selector, queryResult );\n\t  \t};\n\t\n\t  \tYielder.prototype.findComponent = function findComponent ( name ) {\n\t  \t\treturn this.fragment.findComponent( name );\n\t  \t};\n\t\n\t  \tYielder.prototype.findAllComponents = function findAllComponents ( name, queryResult ) {\n\t  \t\tthis.fragment.findAllComponents( name, queryResult );\n\t  \t};\n\t\n\t  \tYielder.prototype.findNextNode = function findNextNode() {\n\t  \t\treturn this.containerFragment.findNextNode( this );\n\t  \t};\n\t\n\t  \tYielder.prototype.firstNode = function firstNode ( skipParent ) {\n\t  \t\treturn this.fragment.firstNode( skipParent );\n\t  \t};\n\t\n\t  \tYielder.prototype.render = function render ( target, occupants ) {\n\t  \t\treturn this.fragment.render( target, occupants );\n\t  \t};\n\t\n\t  \tYielder.prototype.setTemplate = function setTemplate ( name ) {\n\t  \t\tvar template = this.parentFragment.ractive.partials[ name ];\n\t\n\t  \t\tif ( typeof template === 'string' ) {\n\t  \t\t\ttemplate = parse( template ).t;\n\t  \t\t}\n\t\n\t  \t\tthis.partialTemplate = template || []; // TODO warn on missing partial\n\t  \t};\n\t\n\t  \tYielder.prototype.toString = function toString ( escape ) {\n\t  \t\treturn this.fragment.toString( escape );\n\t  \t};\n\t\n\t  \tYielder.prototype.unbind = function unbind () {\n\t  \t\tthis.fragment.unbind();\n\t  \t\tremoveFromArray( this.component.yielders[ this.name ], this );\n\t  \t};\n\t\n\t  \tYielder.prototype.unrender = function unrender ( shouldDestroy ) {\n\t  \t\tthis.fragment.unrender( shouldDestroy );\n\t  \t};\n\t\n\t  \tYielder.prototype.update = function update () {\n\t  \t\tthis.dirty = false;\n\t  \t\tthis.fragment.update();\n\t  \t};\n\t\n\t  \treturn Yielder;\n\t  }(Item));\n\t\n\t  // finds the component constructor in the registry or view hierarchy registries\n\t  function getComponentConstructor ( ractive, name ) {\n\t  \tvar instance = findInstance( 'components', ractive, name );\n\t  \tvar Component;\n\t\n\t  \tif ( instance ) {\n\t  \t\tComponent = instance.components[ name ];\n\t\n\t  \t\t// best test we have for not Ractive.extend\n\t  \t\tif ( !Component._Parent ) {\n\t  \t\t\t// function option, execute and store for reset\n\t  \t\t\tvar fn = Component.bind( instance );\n\t  \t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n\t  \t\t\tComponent = fn();\n\t\n\t  \t\t\tif ( !Component ) {\n\t  \t\t\t\twarnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive: ractive });\n\t  \t\t\t\treturn;\n\t  \t\t\t}\n\t\n\t  \t\t\tif ( typeof Component === 'string' ) {\n\t  \t\t\t\t// allow string lookup\n\t  \t\t\t\tComponent = getComponentConstructor( ractive, Component );\n\t  \t\t\t}\n\t\n\t  \t\t\tComponent._fn = fn;\n\t  \t\t\tinstance.components[ name ] = Component;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn Component;\n\t  }\n\t\n\t  var constructors = {};\n\t  constructors[ ALIAS ] = Alias;\n\t  constructors[ DOCTYPE ] = Doctype;\n\t  constructors[ INTERPOLATOR ] = Interpolator;\n\t  constructors[ PARTIAL ] = Partial;\n\t  constructors[ SECTION ] = Section;\n\t  constructors[ TRIPLE ] = Triple;\n\t  constructors[ YIELDER ] = Yielder;\n\t\n\t  constructors[ ATTRIBUTE ] = Attribute;\n\t  constructors[ BINDING_FLAG ] = BindingFlag;\n\t  constructors[ DECORATOR ] = Decorator;\n\t  constructors[ EVENT ] = EventDirective;\n\t  constructors[ TRANSITION ] = Transition;\n\t\n\t  var specialElements = {\n\t  \tdoctype: Doctype,\n\t  \tform: Form,\n\t  \tinput: Input,\n\t  \toption: Option,\n\t  \tselect: Select,\n\t  \ttextarea: Textarea\n\t  };\n\t\n\t  function createItem ( options ) {\n\t  \tif ( typeof options.template === 'string' ) {\n\t  \t\treturn new Text( options );\n\t  \t}\n\t\n\t  \tif ( options.template.t === ELEMENT ) {\n\t  \t\t// could be component or element\n\t  \t\tvar ComponentConstructor = getComponentConstructor( options.parentFragment.ractive, options.template.e );\n\t  \t\tif ( ComponentConstructor ) {\n\t  \t\t\treturn new Component( options, ComponentConstructor );\n\t  \t\t}\n\t\n\t  \t\tvar tagName = options.template.e.toLowerCase();\n\t\n\t  \t\tvar ElementConstructor = specialElements[ tagName ] || Element;\n\t  \t\treturn new ElementConstructor( options );\n\t  \t}\n\t\n\t  \tvar Item;\n\t\n\t  \t// component mappings are a special case of attribute\n\t  \tif ( options.template.t === ATTRIBUTE ) {\n\t  \t\tvar el = options.owner;\n\t  \t\tif ( !el || ( el.type !== COMPONENT && el.type !== ELEMENT ) ) {\n\t  \t\t\tel = findElement( options.parentFragment );\n\t  \t\t}\n\t  \t\toptions.element = el;\n\t\n\t  \t\tItem = el.type === COMPONENT ? Mapping : Attribute;\n\t  \t} else {\n\t  \t\tItem = constructors[ options.template.t ];\n\t  \t}\n\t\n\t  \tif ( !Item ) throw new Error( (\"Unrecognised item type \" + (options.template.t)) );\n\t\n\t  \treturn new Item( options );\n\t  }\n\t\n\t  // TODO all this code needs to die\n\t  function processItems ( items, values, guid, counter ) {\n\t  \tif ( counter === void 0 ) counter = 0;\n\t\n\t  \treturn items.map( function ( item ) {\n\t  \t\tif ( item.type === TEXT ) {\n\t  \t\t\treturn item.template;\n\t  \t\t}\n\t\n\t  \t\tif ( item.fragment ) {\n\t  \t\t\tif ( item.fragment.iterations ) {\n\t  \t\t\t\treturn item.fragment.iterations.map( function ( fragment ) {\n\t  \t\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n\t  \t\t\t\t}).join( '' );\n\t  \t\t\t} else {\n\t  \t\t\t\treturn processItems( item.fragment.items, values, guid, counter );\n\t  \t\t\t}\n\t  \t\t}\n\t\n\t  \t\tvar placeholderId = \"\" + guid + \"-\" + (counter++);\n\t  \t\tvar model = item.model || item.newModel;\n\t\n\t  \t\tvalues[ placeholderId ] = model ?\n\t  \t\t\tmodel.wrapper ?\n\t  \t\t\t\tmodel.wrapperValue :\n\t  \t\t\t\tmodel.get() :\n\t  \t\t\tundefined;\n\t\n\t  \t\treturn '${' + placeholderId + '}';\n\t  \t}).join( '' );\n\t  }\n\t\n\t  function unrenderAndDestroy$1 ( item ) {\n\t  \titem.unrender( true );\n\t  }\n\t\n\t  var Fragment = function Fragment ( options ) {\n\t  \tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\t\n\t  \tthis.isRoot = !options.owner.parentFragment;\n\t  \tthis.parent = this.isRoot ? null : this.owner.parentFragment;\n\t  \tthis.ractive = options.ractive || ( this.isRoot ? options.owner : this.parent.ractive );\n\t\n\t  \tthis.componentParent = ( this.isRoot && this.ractive.component ) ? this.ractive.component.parentFragment : null;\n\t\n\t  \tthis.context = null;\n\t  \tthis.rendered = false;\n\t\n\t  \t// encapsulated styles should be inherited until they get applied by an element\n\t  \tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\t\n\t  \tthis.resolvers = [];\n\t\n\t  \tthis.dirty = false;\n\t  \tthis.dirtyArgs = this.dirtyValue = true; // TODO getArgsList is nonsense - should deprecate legacy directives style\n\t\n\t  \tthis.template = options.template || [];\n\t  \tthis.createItems();\n\t  };\n\t\n\t  Fragment.prototype.bind = function bind$1$$ ( context ) {\n\t  \tthis.context = context;\n\t  \tthis.items.forEach( bind$1 );\n\t  \tthis.bound = true;\n\t\n\t  \t// in rare cases, a forced resolution (or similar) will cause the\n\t  \t// fragment to be dirty before it's even finished binding. In those\n\t  \t// cases we update immediately\n\t  \tif ( this.dirty ) this.update();\n\t\n\t  \treturn this;\n\t  };\n\t\n\t  Fragment.prototype.bubble = function bubble () {\n\t  \tthis.dirtyArgs = this.dirtyValue = true;\n\t\n\t  \tif ( !this.dirty ) {\n\t  \t\tthis.dirty = true;\n\t\n\t  \t\tif ( this.isRoot ) { // TODO encapsulate 'is component root, but not overall root' check?\n\t  \t\t\tif ( this.ractive.component ) {\n\t  \t\t\t\tthis.ractive.component.bubble();\n\t  \t\t\t} else if ( this.bound ) {\n\t  \t\t\t\trunloop.addFragment( this );\n\t  \t\t\t}\n\t  \t\t} else {\n\t  \t\t\tthis.owner.bubble();\n\t  \t\t}\n\t  \t}\n\t  };\n\t\n\t  Fragment.prototype.createItems = function createItems () {\n\t  \t// this is a hot code path\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar max = this.template.length;\n\t  \tthis.items = [];\n\t  \tfor ( var i = 0; i < max; i++ ) {\n\t  \t\tthis$1.items[i] = createItem({ parentFragment: this$1, template: this$1.template[i], index: i });\n\t  \t}\n\t  };\n\t\n\t  Fragment.prototype.destroyed = function destroyed () {\n\t  \tthis.items.forEach( function ( i ) { return i.destroyed(); } );\n\t  };\n\t\n\t  Fragment.prototype.detach = function detach () {\n\t  \tvar docFrag = createDocumentFragment();\n\t  \tthis.items.forEach( function ( item ) { return docFrag.appendChild( item.detach() ); } );\n\t  \treturn docFrag;\n\t  };\n\t\n\t  Fragment.prototype.find = function find ( selector ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar len = this.items.length;\n\t  \tvar i;\n\t\n\t  \tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\tvar found = this$1.items[i].find( selector );\n\t  \t\tif ( found ) return found;\n\t  \t}\n\t  };\n\t\n\t  Fragment.prototype.findAll = function findAll ( selector, query ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( this.items ) {\n\t  \t\tvar len = this.items.length;\n\t  \t\tvar i;\n\t\n\t  \t\tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\t\tvar item = this$1.items[i];\n\t\n\t  \t\t\tif ( item.findAll ) {\n\t  \t\t\t\titem.findAll( selector, query );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn query;\n\t  };\n\t\n\t  Fragment.prototype.findComponent = function findComponent ( name ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar len = this.items.length;\n\t  \tvar i;\n\t\n\t  \tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\tvar found = this$1.items[i].findComponent( name );\n\t  \t\tif ( found ) return found;\n\t  \t}\n\t  };\n\t\n\t  Fragment.prototype.findAllComponents = function findAllComponents ( name, query ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( this.items ) {\n\t  \t\tvar len = this.items.length;\n\t  \t\tvar i;\n\t\n\t  \t\tfor ( i = 0; i < len; i += 1 ) {\n\t  \t\t\tvar item = this$1.items[i];\n\t\n\t  \t\t\tif ( item.findAllComponents ) {\n\t  \t\t\t\titem.findAllComponents( name, query );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn query;\n\t  };\n\t\n\t  Fragment.prototype.findContext = function findContext () {\n\t  \tvar fragment = this;\n\t  \twhile ( fragment && !fragment.context ) fragment = fragment.parent;\n\t  \tif ( !fragment ) return this.ractive.viewmodel;\n\t  \telse return fragment.context;\n\t  };\n\t\n\t  Fragment.prototype.findNextNode = function findNextNode ( item ) {\n\t  \t// search for the next node going forward\n\t  \tvar this$1 = this;\n\t\n\t  \t\tif ( item ) {\n\t  \t\tfor ( var i = item.index + 1; i < this$1.items.length; i++ ) {\n\t  \t\t\tif ( !this$1.items[ i ] ) continue;\n\t\n\t  \t\t\tvar node = this$1.items[ i ].firstNode( true );\n\t  \t\t\tif ( node ) return node;\n\t  \t\t}\n\t  \t}\n\t\n\t  \t// if this is the root fragment, and there are no more items,\n\t  \t// it means we're at the end...\n\t  \tif ( this.isRoot ) {\n\t  \t\tif ( this.ractive.component ) {\n\t  \t\t\treturn this.ractive.component.parentFragment.findNextNode( this.ractive.component );\n\t  \t\t}\n\t\n\t  \t\t// TODO possible edge case with other content\n\t  \t\t// appended to this.ractive.el?\n\t  \t\treturn null;\n\t  \t}\n\t\n\t  \tif ( this.parent ) return this.owner.findNextNode( this ); // the argument is in case the parent is a RepeatedFragment\n\t  };\n\t\n\t  Fragment.prototype.findParentNode = function findParentNode () {\n\t  \tvar fragment = this;\n\t\n\t  \tdo {\n\t  \t\tif ( fragment.owner.type === ELEMENT ) {\n\t  \t\t\treturn fragment.owner.node;\n\t  \t\t}\n\t\n\t  \t\tif ( fragment.isRoot && !fragment.ractive.component ) { // TODO encapsulate check\n\t  \t\t\treturn fragment.ractive.el;\n\t  \t\t}\n\t\n\t  \t\tif ( fragment.owner.type === YIELDER ) {\n\t  \t\t\tfragment = fragment.owner.containerFragment;\n\t  \t\t} else {\n\t  \t\t\tfragment = fragment.componentParent || fragment.parent; // TODO ugh\n\t  \t\t}\n\t  \t} while ( fragment );\n\t\n\t  \tthrow new Error( 'Could not find parent node' ); // TODO link to issue tracker\n\t  };\n\t\n\t  Fragment.prototype.findRepeatingFragment = function findRepeatingFragment () {\n\t  \tvar fragment = this;\n\t  \t// TODO better check than fragment.parent.iterations\n\t  \twhile ( ( fragment.parent || fragment.componentParent ) && !fragment.isIteration ) {\n\t  \t\tfragment = fragment.parent || fragment.componentParent;\n\t  \t}\n\t\n\t  \treturn fragment;\n\t  };\n\t\n\t  Fragment.prototype.firstNode = function firstNode ( skipParent ) {\n\t  \tvar this$1 = this;\n\t\n\t  \t\tvar node;\n\t  \tfor ( var i = 0; i < this$1.items.length; i++ ) {\n\t  \t\tnode = this$1.items[i].firstNode( true );\n\t\n\t  \t\tif ( node ) {\n\t  \t\t\treturn node;\n\t  \t\t}\n\t  \t}\n\t\n\t  \tif ( skipParent ) return null;\n\t\n\t  \treturn this.parent.findNextNode( this.owner );\n\t  };\n\t\n\t  // TODO ideally, this would be deprecated in favour of an\n\t  // expression-like approach\n\t  Fragment.prototype.getArgsList = function getArgsList () {\n\t  \tif ( this.dirtyArgs ) {\n\t  \t\tvar values = {};\n\t  \t\tvar source = processItems( this.items, values, this.ractive._guid );\n\t  \t\tvar parsed = parseJSON( '[' + source + ']', values );\n\t\n\t  \t\tthis.argsList = parsed ?\n\t  \t\t\tparsed.value :\n\t  \t\t\t[ this.toString() ];\n\t\n\t  \t\tthis.dirtyArgs = false;\n\t  \t}\n\t\n\t  \treturn this.argsList;\n\t  };\n\t\n\t  Fragment.prototype.rebinding = function rebinding ( next ) {\n\t  \tthis.context = next;\n\t  };\n\t\n\t  Fragment.prototype.render = function render ( target, occupants ) {\n\t  \tif ( this.rendered ) throw new Error( 'Fragment is already rendered!' );\n\t  \tthis.rendered = true;\n\t\n\t  \tthis.items.forEach( function ( item ) { return item.render( target, occupants ); } );\n\t  };\n\t\n\t  Fragment.prototype.resetTemplate = function resetTemplate ( template ) {\n\t  \tvar wasBound = this.bound;\n\t  \tvar wasRendered = this.rendered;\n\t\n\t  \t// TODO ensure transitions are disabled globally during reset\n\t\n\t  \tif ( wasBound ) {\n\t  \t\tif ( wasRendered ) this.unrender( true );\n\t  \t\tthis.unbind();\n\t  \t}\n\t\n\t  \tthis.template = template;\n\t  \tthis.createItems();\n\t\n\t  \tif ( wasBound ) {\n\t  \t\tthis.bind( this.context );\n\t\n\t  \t\tif ( wasRendered ) {\n\t  \t\t\tvar parentNode = this.findParentNode();\n\t  \t\t\tvar anchor = this.findNextNode();\n\t\n\t  \t\t\tif ( anchor ) {\n\t  \t\t\t\tvar docFrag = createDocumentFragment();\n\t  \t\t\t\tthis.render( docFrag );\n\t  \t\t\t\tparentNode.insertBefore( docFrag, anchor );\n\t  \t\t\t} else {\n\t  \t\t\t\tthis.render( parentNode );\n\t  \t\t\t}\n\t  \t\t}\n\t  \t}\n\t  };\n\t\n\t  Fragment.prototype.resolve = function resolve ( template, callback ) {\n\t  \tif ( !this.context && this.parent.resolve ) {\n\t  \t\treturn this.parent.resolve( template, callback );\n\t  \t}\n\t\n\t  \tvar resolver = new ReferenceResolver( this, template, callback );\n\t  \tthis.resolvers.push( resolver );\n\t\n\t  \treturn resolver; // so we can e.g. force resolution\n\t  };\n\t\n\t  Fragment.prototype.shuffled = function shuffled () {\n\t  \tthis.items.forEach( function ( i ) { return i.shuffled(); } );\n\t  };\n\t\n\t  Fragment.prototype.toHtml = function toHtml () {\n\t  \treturn this.toString();\n\t  };\n\t\n\t  Fragment.prototype.toString = function toString$1$$ ( escape ) {\n\t  \treturn this.items.map( escape ? toEscapedString : toString$1 ).join( '' );\n\t  };\n\t\n\t  Fragment.prototype.unbind = function unbind$1 () {\n\t  \tthis.items.forEach( unbind );\n\t  \tthis.bound = false;\n\t\n\t  \treturn this;\n\t  };\n\t\n\t  Fragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n\t  \tthis.items.forEach( shouldDestroy ? unrenderAndDestroy$1 : unrender );\n\t  \tthis.rendered = false;\n\t  };\n\t\n\t  Fragment.prototype.update = function update$1 () {\n\t  \tif ( this.dirty ) {\n\t  \t\tif ( !this.updating ) {\n\t  \t\t\tthis.dirty = false;\n\t  \t\t\tthis.updating = true;\n\t  \t\t\tthis.items.forEach( update );\n\t  \t\t\tthis.updating = false;\n\t  \t\t} else if ( this.isRoot ) {\n\t  \t\t\trunloop.addFragmentToRoot( this );\n\t  \t\t}\n\t  \t}\n\t  };\n\t\n\t  Fragment.prototype.valueOf = function valueOf () {\n\t  \tif ( this.items.length === 1 ) {\n\t  \t\treturn this.items[0].valueOf();\n\t  \t}\n\t\n\t  \tif ( this.dirtyValue ) {\n\t  \t\tvar values = {};\n\t  \t\tvar source = processItems( this.items, values, this.ractive._guid );\n\t  \t\tvar parsed = parseJSON( source, values );\n\t\n\t  \t\tthis.value = parsed ?\n\t  \t\t\tparsed.value :\n\t  \t\t\tthis.toString();\n\t\n\t  \t\tthis.dirtyValue = false;\n\t  \t}\n\t\n\t  \treturn this.value;\n\t  };\n\t\n\t  // TODO should resetTemplate be asynchronous? i.e. should it be a case\n\t  // of outro, update template, intro? I reckon probably not, since that\n\t  // could be achieved with unrender-resetTemplate-render. Also, it should\n\t  // conceptually be similar to resetPartial, which couldn't be async\n\t\n\t  function Ractive$resetTemplate ( template ) {\n\t  \ttemplateConfigurator.init( null, this, { template: template });\n\t\n\t  \tvar transitionsEnabled = this.transitionsEnabled;\n\t  \tthis.transitionsEnabled = false;\n\t\n\t  \t// Is this is a component, we need to set the `shouldDestroy`\n\t  \t// flag, otherwise it will assume by default that a parent node\n\t  \t// will be detached, and therefore it doesn't need to bother\n\t  \t// detaching its own nodes\n\t  \tvar component = this.component;\n\t  \tif ( component ) component.shouldDestroy = true;\n\t  \tthis.unrender();\n\t  \tif ( component ) component.shouldDestroy = false;\n\t\n\t  \t// remove existing fragment and create new one\n\t  \tthis.fragment.unbind().unrender( true );\n\t\n\t  \tthis.fragment = new Fragment({\n\t  \t\ttemplate: this.template,\n\t  \t\troot: this,\n\t  \t\towner: this\n\t  \t});\n\t\n\t  \tvar docFrag = createDocumentFragment();\n\t  \tthis.fragment.bind( this.viewmodel ).render( docFrag );\n\t\n\t  \t// if this is a component, its el may not be valid, so find a\n\t  \t// target based on the component container\n\t  \tif ( component ) {\n\t  \t\tthis.fragment.findParentNode().insertBefore( docFrag, component.findNextNode() );\n\t  \t} else {\n\t  \t\tthis.el.insertBefore( docFrag, this.anchor );\n\t  \t}\n\t\n\t  \tthis.transitionsEnabled = transitionsEnabled;\n\t  }\n\t\n\t  var reverse$1 = makeArrayMethod( 'reverse' ).path;\n\t\n\t  function Ractive$set ( keypath, value ) {\n\t  \tvar ractive = this;\n\t\n\t  \treturn set( ractive, build( ractive, keypath, value ) );\n\t  }\n\t\n\t  var shift$1 = makeArrayMethod( 'shift' ).path;\n\t\n\t  var sort$1 = makeArrayMethod( 'sort' ).path;\n\t\n\t  var splice$1 = makeArrayMethod( 'splice' ).path;\n\t\n\t  function Ractive$subtract ( keypath, d ) {\n\t  \treturn add( this, keypath, ( d === undefined ? -1 : -d ) );\n\t  }\n\t\n\t  var teardownHook$1 = new Hook( 'teardown' );\n\t\n\t  // Teardown. This goes through the root fragment and all its children, removing observers\n\t  // and generally cleaning up after itself\n\t\n\t  function Ractive$teardown () {\n\t  \tif ( this.torndown ) {\n\t  \t\twarnIfDebug( 'ractive.teardown() was called on a Ractive instance that was already torn down' );\n\t  \t\treturn Promise$1.resolve();\n\t  \t}\n\t\n\t  \tthis.torndown = true;\n\t  \tthis.fragment.unbind();\n\t  \tthis.viewmodel.teardown();\n\t\n\t  \tthis._observers.forEach( cancel );\n\t\n\t  \tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n\t  \t\tremoveFromArray( this.el.__ractive_instances__, this );\n\t  \t}\n\t\n\t  \tthis.shouldDestroy = true;\n\t  \tvar promise = ( this.fragment.rendered ? this.unrender() : Promise$1.resolve() );\n\t\n\t  \tteardownHook$1.fire( this );\n\t\n\t  \treturn promise;\n\t  }\n\t\n\t  function Ractive$toggle ( keypath ) {\n\t  \tif ( typeof keypath !== 'string' ) {\n\t  \t\tthrow new TypeError( badArguments );\n\t  \t}\n\t\n\t  \treturn set( this, gather( this, keypath ).map( function ( m ) { return [ m, !m.get() ]; } ) );\n\t  }\n\t\n\t  function Ractive$toCSS() {\n\t  \tvar cssIds = [ this.cssId ].concat( this.findAllComponents().map( function ( c ) { return c.cssId; } ) );\n\t  \tvar uniqueCssIds = Object.keys(cssIds.reduce( function ( ids, id ) { return (ids[id] = true, ids); }, {}));\n\t  \treturn getCSS( uniqueCssIds );\n\t  }\n\t\n\t  function Ractive$toHTML () {\n\t  \treturn this.fragment.toString( true );\n\t  }\n\t\n\t  function toText () {\n\t  \treturn this.fragment.toString( false );\n\t  }\n\t\n\t  function Ractive$transition ( name, node, params ) {\n\t\n\t  \tif ( node instanceof HTMLElement ) {\n\t  \t\t// good to go\n\t  \t}\n\t  \telse if ( isObject( node ) ) {\n\t  \t\t// omitted, use event node\n\t  \t\tparams = node;\n\t  \t}\n\t\n\t  \t// if we allow query selector, then it won't work\n\t  \t// simple params like \"fast\"\n\t\n\t  \t// else if ( typeof node === 'string' ) {\n\t  \t// \t// query selector\n\t  \t// \tnode = this.find( node )\n\t  \t// }\n\t\n\t  \tnode = node || this.event.node;\n\t\n\t  \tif ( !node || !node._ractive ) {\n\t  \t\tfatal( (\"No node was supplied for transition \" + name) );\n\t  \t}\n\t\n\t  \tparams = params || {};\n\t  \tvar owner = node._ractive.proxy;\n\t  \tvar transition = new Transition({ owner: owner, parentFragment: owner.parentFragment, name: name, params: params });\n\t  \ttransition.bind();\n\t\n\t  \tvar promise = runloop.start( this, true );\n\t  \trunloop.registerTransition( transition );\n\t  \trunloop.end();\n\t\n\t  \tpromise.then( function () { return transition.unbind(); } );\n\t  \treturn promise;\n\t  }\n\t\n\t  function unlink$1( here ) {\n\t  \tvar promise = runloop.start();\n\t  \tthis.viewmodel.joinAll( splitKeypathI( here ), { lastLink: false } ).unlink();\n\t  \trunloop.end();\n\t  \treturn promise;\n\t  }\n\t\n\t  var unrenderHook$1 = new Hook( 'unrender' );\n\t\n\t  function Ractive$unrender () {\n\t  \tif ( !this.fragment.rendered ) {\n\t  \t\twarnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n\t  \t\treturn Promise$1.resolve();\n\t  \t}\n\t\n\t  \tvar promise = runloop.start( this, true );\n\t\n\t  \t// If this is a component, and the component isn't marked for destruction,\n\t  \t// don't detach nodes from the DOM unnecessarily\n\t  \tvar shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\t  \tthis.fragment.unrender( shouldDestroy );\n\t\n\t  \tremoveFromArray( this.el.__ractive_instances__, this );\n\t\n\t  \tunrenderHook$1.fire( this );\n\t\n\t  \trunloop.end();\n\t  \treturn promise;\n\t  }\n\t\n\t  var unshift$1 = makeArrayMethod( 'unshift' ).path;\n\t\n\t  function Ractive$updateModel ( keypath, cascade ) {\n\t  \tvar promise = runloop.start( this, true );\n\t\n\t  \tif ( !keypath ) {\n\t  \t\tthis.viewmodel.updateFromBindings( true );\n\t  \t} else {\n\t  \t\tthis.viewmodel.joinAll( splitKeypathI( keypath ) ).updateFromBindings( cascade !== false );\n\t  \t}\n\t\n\t  \trunloop.end();\n\t\n\t  \treturn promise;\n\t  }\n\t\n\t  var proto = {\n\t  \tadd: Ractive$add,\n\t  \tanimate: Ractive$animate,\n\t  \tdetach: Ractive$detach,\n\t  \tfind: Ractive$find,\n\t  \tfindAll: Ractive$findAll,\n\t  \tfindAllComponents: Ractive$findAllComponents,\n\t  \tfindComponent: Ractive$findComponent,\n\t  \tfindContainer: Ractive$findContainer,\n\t  \tfindParent: Ractive$findParent,\n\t  \tfire: Ractive$fire,\n\t  \tget: Ractive$get,\n\t  \tgetNodeInfo: getNodeInfo,\n\t  \tinsert: Ractive$insert,\n\t  \tlink: link$1,\n\t  \tmerge: thisRactive$merge,\n\t  \tobserve: observe,\n\t  \tobserveList: observeList,\n\t  \tobserveOnce: observeOnce,\n\t  \t// TODO reinstate these\n\t  \t// observeListOnce,\n\t  \toff: Ractive$off,\n\t  \ton: Ractive$on,\n\t  \tonce: Ractive$once,\n\t  \tpop: pop$1,\n\t  \tpush: push$1,\n\t  \trender: Ractive$render,\n\t  \treset: Ractive$reset,\n\t  \tresetPartial: resetPartial,\n\t  \tresetTemplate: Ractive$resetTemplate,\n\t  \treverse: reverse$1,\n\t  \tset: Ractive$set,\n\t  \tshift: shift$1,\n\t  \tsort: sort$1,\n\t  \tsplice: splice$1,\n\t  \tsubtract: Ractive$subtract,\n\t  \tteardown: Ractive$teardown,\n\t  \ttoggle: Ractive$toggle,\n\t  \ttoCSS: Ractive$toCSS,\n\t  \ttoCss: Ractive$toCSS,\n\t  \ttoHTML: Ractive$toHTML,\n\t  \ttoHtml: Ractive$toHTML,\n\t  \ttoText: toText,\n\t  \ttransition: Ractive$transition,\n\t  \tunlink: unlink$1,\n\t  \tunrender: Ractive$unrender,\n\t  \tunshift: unshift$1,\n\t  \tupdate: Ractive$update,\n\t  \tupdateModel: Ractive$updateModel\n\t  };\n\t\n\t  function wrap$1 ( method, superMethod, force ) {\n\t\n\t  \tif ( force || needsSuper( method, superMethod ) )  {\n\t\n\t  \t\treturn function () {\n\t\n\t  \t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\t\n\t  \t\t\tthis._super = superMethod;\n\t\n\t  \t\t\tresult = method.apply( this, arguments );\n\t\n\t  \t\t\tif ( hasSuper ) {\n\t  \t\t\t\tthis._super = _super;\n\t  \t\t\t}\n\t\n\t  \t\t\treturn result;\n\t  \t\t};\n\t  \t}\n\t\n\t  \telse {\n\t  \t\treturn method;\n\t  \t}\n\t  }\n\t\n\t  function needsSuper ( method, superMethod ) {\n\t  \treturn typeof superMethod === 'function' && /_super/.test( method );\n\t  }\n\t\n\t  function unwrap ( Child ) {\n\t  \tvar options = {};\n\t\n\t  \twhile ( Child ) {\n\t  \t\taddRegistries( Child, options );\n\t  \t\taddOtherOptions( Child, options );\n\t\n\t  \t\tif ( Child._Parent !== Ractive ) {\n\t  \t\t\tChild = Child._Parent;\n\t  \t\t} else {\n\t  \t\t\tChild = false;\n\t  \t\t}\n\t  \t}\n\t\n\t  \treturn options;\n\t  }\n\t\n\t  function addRegistries ( Child, options ) {\n\t  \tregistries.forEach( function ( r ) {\n\t  \t\taddRegistry(\n\t  \t\t\tr.useDefaults ? Child.prototype : Child,\n\t  \t\t\toptions, r.name );\n\t  \t});\n\t  }\n\t\n\t  function addRegistry ( target, options, name ) {\n\t  \tvar registry, keys = Object.keys( target[ name ] );\n\t\n\t  \tif ( !keys.length ) { return; }\n\t\n\t  \tif ( !( registry = options[ name ] ) ) {\n\t  \t\tregistry = options[ name ] = {};\n\t  \t}\n\t\n\t  \tkeys\n\t  \t\t.filter( function ( key ) { return !( key in registry ); } )\n\t  \t\t.forEach( function ( key ) { return registry[ key ] = target[ name ][ key ]; } );\n\t  }\n\t\n\t  function addOtherOptions ( Child, options ) {\n\t  \tObject.keys( Child.prototype ).forEach( function ( key ) {\n\t  \t\tif ( key === 'computed' ) { return; }\n\t\n\t  \t\tvar value = Child.prototype[ key ];\n\t\n\t  \t\tif ( !( key in options ) ) {\n\t  \t\t\toptions[ key ] = value._method ? value._method : value;\n\t  \t\t}\n\t\n\t  \t\t// is it a wrapped function?\n\t  \t\telse if ( typeof options[ key ] === 'function'\n\t  \t\t\t\t&& typeof value === 'function'\n\t  \t\t\t\t&& options[ key ]._method ) {\n\t\n\t  \t\t\tvar result, needsSuper = value._method;\n\t\n\t  \t\t\tif ( needsSuper ) { value = value._method; }\n\t\n\t  \t\t\t// rewrap bound directly to parent fn\n\t  \t\t\tresult = wrap$1( options[ key ]._method, value );\n\t\n\t  \t\t\tif ( needsSuper ) { result._method = result; }\n\t\n\t  \t\t\toptions[ key ] = result;\n\t  \t\t}\n\t  \t});\n\t  }\n\t\n\t  function extend () {\n\t  \tvar options = [], len = arguments.length;\n\t  \twhile ( len-- ) options[ len ] = arguments[ len ];\n\t\n\t  \tif( !options.length ) {\n\t  \t\treturn extendOne( this );\n\t  \t} else {\n\t  \t\treturn options.reduce( extendOne, this );\n\t  \t}\n\t  }\n\t\n\t  function extendOne ( Parent, options ) {\n\t  \tif ( options === void 0 ) options = {};\n\t\n\t  \tvar Child, proto;\n\t\n\t  \t// if we're extending with another Ractive instance...\n\t  \t//\n\t  \t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n\t  \t//   var Spiderman = Human.extend( Spider );\n\t  \t//\n\t  \t// ...inherit prototype methods and default options as well\n\t  \tif ( options.prototype instanceof Ractive ) {\n\t  \t\toptions = unwrap( options );\n\t  \t}\n\t\n\t  \tChild = function ( options ) {\n\t  \t\tif ( !( this instanceof Child ) ) return new Child( options );\n\t\n\t  \t\tconstruct( this, options || {} );\n\t  \t\tinitialise( this, options || {}, {} );\n\t  \t};\n\t\n\t  \tproto = create( Parent.prototype );\n\t  \tproto.constructor = Child;\n\t\n\t  \t// Static properties\n\t  \tdefineProperties( Child, {\n\t  \t\t// alias prototype as defaults\n\t  \t\tdefaults: { value: proto },\n\t\n\t  \t\t// extendable\n\t  \t\textend: { value: extend, writable: true, configurable: true },\n\t\n\t  \t\t// Parent - for IE8, can't use Object.getPrototypeOf\n\t  \t\t_Parent: { value: Parent }\n\t  \t});\n\t\n\t  \t// extend configuration\n\t  \tconfig.extend( Parent, proto, options );\n\t\n\t  \tdataConfigurator.extend( Parent, proto, options );\n\t\n\t  \tif ( options.computed ) {\n\t  \t\tproto.computed = extendObj( create( Parent.prototype.computed ), options.computed );\n\t  \t}\n\t\n\t  \tChild.prototype = proto;\n\t\n\t  \treturn Child;\n\t  }\n\t\n\t  function joinKeys () {\n\t  \tvar keys = [], len = arguments.length;\n\t  \twhile ( len-- ) keys[ len ] = arguments[ len ];\n\t\n\t  \treturn keys.map( escapeKey ).join( '.' );\n\t  }\n\t\n\t  function splitKeypath ( keypath ) {\n\t  \treturn splitKeypathI( keypath ).map( unescapeKey );\n\t  }\n\t\n\t  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n\t  // older browsers, these are made available via a shim - here, we do a quick\n\t  // pre-flight check to make sure that either a) we're not in a shit browser,\n\t  // or b) we're using a Ractive-legacy.js build\n\t  var FUNCTION = 'function';\n\t\n\t  if (\n\t  \ttypeof Date.now !== FUNCTION                 ||\n\t  \ttypeof String.prototype.trim !== FUNCTION    ||\n\t  \ttypeof Object.keys !== FUNCTION              ||\n\t  \ttypeof Array.prototype.indexOf !== FUNCTION  ||\n\t  \ttypeof Array.prototype.forEach !== FUNCTION  ||\n\t  \ttypeof Array.prototype.map !== FUNCTION      ||\n\t  \ttypeof Array.prototype.filter !== FUNCTION   ||\n\t  \t( win && typeof win.addEventListener !== FUNCTION )\n\t  ) {\n\t  \tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n\t  }\n\t\n\t  function Ractive ( options ) {\n\t  \tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\t\n\t  \tconstruct( this, options || {} );\n\t  \tinitialise( this, options || {}, {} );\n\t  }\n\t\n\t  extendObj( Ractive.prototype, proto, defaults );\n\t  Ractive.prototype.constructor = Ractive;\n\t\n\t  // alias prototype as `defaults`\n\t  Ractive.defaults = Ractive.prototype;\n\t\n\t  // static properties\n\t  defineProperties( Ractive, {\n\t\n\t  \t// debug flag\n\t  \tDEBUG:          { writable: true, value: true },\n\t  \tDEBUG_PROMISES: { writable: true, value: true },\n\t\n\t  \t// static methods:\n\t  \textend:         { value: extend },\n\t  \tescapeKey:      { value: escapeKey },\n\t  \tgetNodeInfo:    { value: staticInfo },\n\t  \tjoinKeys:       { value: joinKeys },\n\t  \tparse:          { value: parse },\n\t  \tsplitKeypath:   { value: splitKeypath },\n\t  \tunescapeKey:    { value: unescapeKey },\n\t  \tgetCSS:         { value: getCSS },\n\t\n\t  \t// namespaced constructors\n\t  \tPromise:        { value: Promise$1 },\n\t\n\t  \t// support\n\t  \tenhance:        { writable: true, value: false },\n\t  \tsvg:            { value: svg },\n\t  \tmagic:          { value: magicSupported },\n\t\n\t  \t// version\n\t  \tVERSION:        { value: '0.8.5' },\n\t\n\t  \t// plugins\n\t  \tadaptors:       { writable: true, value: {} },\n\t  \tcomponents:     { writable: true, value: {} },\n\t  \tdecorators:     { writable: true, value: {} },\n\t  \teasing:         { writable: true, value: easing },\n\t  \tevents:         { writable: true, value: {} },\n\t  \tinterpolators:  { writable: true, value: interpolators },\n\t  \tpartials:       { writable: true, value: {} },\n\t  \ttransitions:    { writable: true, value: {} }\n\t  });\n\t\n\t  return Ractive;\n\t\n\t}));\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports={\"v\":4,\"t\":[{\"t\":7,\"e\":\"Header\"},\" \",{\"t\":7,\"e\":\"main\",\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"intro-wrap\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"h1\",\"f\":[\"Select your username\"]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"label\",\"f\":[\"Username: \",{\"t\":7,\"e\":\"input\",\"m\":[{\"n\":\"change\",\"f\":\"handleInput\",\"t\":70},{\"n\":\"name\",\"f\":\"user\",\"t\":13},{\"n\":\"type\",\"f\":\"input\",\"t\":13},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"user\"}],\"t\":13}]}]},\" \",{\"t\":7,\"e\":\"br\"},\" \",{\"t\":7,\"e\":\"button\",\"m\":[{\"n\":\"tap\",\"f\":\"hideUserForm\",\"t\":70}],\"f\":[\"Select\"]}]}]}],\"n\":51,\"r\":\"selectUser\"},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"page-wrap\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input status-wrap\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"col-1\",\"t\":13}],\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"div\",\"f\":[\"Your username is \",{\"t\":7,\"e\":\"strong\",\"f\":[{\"t\":2,\"r\":\"user\"}]}]}],\"n\":50,\"r\":\"user\"},\" \",{\"t\":7,\"e\":\"div\",\"f\":[\"Connection status: \",{\"t\":7,\"e\":\"strong\",\"f\":[{\"t\":4,\"f\":[\"open\"],\"n\":50,\"r\":\"conn\"},{\"t\":4,\"n\":51,\"f\":[\"closed\"],\"l\":1}]}]},\" \",{\"t\":4,\"f\":[{\"t\":7,\"e\":\"button\",\"m\":[{\"n\":\"tap\",\"f\":\"connect\",\"t\":70}],\"f\":[\"connect\"]}],\"n\":50,\"x\":{\"r\":[\"conn\"],\"s\":\"!_0\"}}]},{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"col-2\",\"t\":13}],\"f\":[\" \",{\"t\":4,\"f\":[{\"t\":7,\"e\":\"div\",\"f\":[\"Incoming from \",{\"t\":7,\"e\":\"strong\",\"f\":[{\"t\":2,\"r\":\"vibrate.sender\"}]}]}],\"n\":50,\"x\":{\"r\":[\"vibrate.sender\",\"sending\"],\"s\":\"_0&&!_1\"}},\" \",{\"t\":4,\"f\":[{\"t\":7,\"e\":\"div\",\"f\":[\"Sending...\"]}],\"n\":50,\"r\":\"sending\"}]}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"label\",\"f\":[\"Username: \",{\"t\":7,\"e\":\"input\",\"m\":[{\"n\":\"change\",\"f\":\"changeUser\",\"t\":70},{\"n\":\"type\",\"f\":\"input\",\"t\":13},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"vibrate.recipient\"}],\"t\":13}]}]}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"button vibrate\",\"t\":13},{\"n\":\"press\",\"f\":\"startVibrate\",\"t\":70},{\"n\":\"pressup\",\"f\":\"endVibrate\",\"t\":70}],\"f\":[{\"t\":4,\"f\":[\"SENDING\"],\"n\":50,\"r\":\"sending\"},{\"t\":4,\"n\":51,\"f\":[\"PUSH\"],\"l\":1}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"select\",\"m\":[{\"n\":\"change\",\"f\":\"selectSpeed\",\"t\":70},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"vibrate.speed\"}],\"t\":13}],\"f\":[{\"t\":7,\"e\":\"option\",\"m\":[{\"n\":\"value\",\"f\":\"200\",\"t\":13}],\"f\":[\"Fast\"]},\" \",{\"t\":7,\"e\":\"option\",\"m\":[{\"n\":\"value\",\"f\":\"500\",\"t\":13}],\"f\":[\"Medium\"]},\" \",{\"t\":7,\"e\":\"option\",\"m\":[{\"n\":\"value\",\"f\":\"1000\",\"t\":13}],\"f\":[\"Slow\"]}]}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"input\",\"m\":[{\"n\":\"change\",\"f\":\"selectSpeed\",\"t\":70},{\"n\":\"type\",\"f\":\"range\",\"t\":13},{\"n\":\"min\",\"f\":\"100\",\"t\":13},{\"n\":\"max\",\"f\":\"1000\",\"t\":13},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"vibrate.speed\"}],\"t\":13}]}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"input\",\"m\":[{\"n\":\"change\",\"f\":\"selectSpeed\",\"t\":70},{\"n\":\"type\",\"f\":\"input\",\"t\":13},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"vibrate.speed\"}],\"t\":13}]}]}]}]}],\"e\":{}};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = function () {\n\t    'use strict';\n\t\n\t    var Ractive = __webpack_require__(2);\n\t    var template = __webpack_require__(5);\n\t\n\t    function HeaderComponent(root) {\n\t        var component = Ractive.extend({\n\t            template: template,\n\t            oninit: function oninit() {\n\t                this.on('toggleMenu', function (event) {\n\t                    this.toggle(\"menuOpen\");\n\t\n\t                    if (this.get(\"signupOpen\")) {\n\t                        this.set({ signupOpen: false });\n\t                    }\n\t                });\n\t                this.on('toggleSignup', function (event) {\n\t                    console.log(\"signup\");\n\t                    this.toggle(\"signupOpen\");\n\t                    this.set(\"menuOpen\", false);\n\t                });\n\t            }\n\t        });\n\t        return component;\n\t    }\n\t\n\t    return HeaderComponent;\n\t}();\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<header> <h1>Veebrate</h1> </header>\";\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\n\t *   Copyright (c) 2011-2015 The original author or authors\n\t *   ------------------------------------------------------\n\t *   All rights reserved. This program and the accompanying materials\n\t *   are made available under the terms of the Eclipse Public License v1.0\n\t *   and Apache License v2.0 which accompanies this distribution.\n\t *\n\t *       The Eclipse Public License is available at\n\t *       http://www.eclipse.org/legal/epl-v10.html\n\t *\n\t *       The Apache License v2.0 is available at\n\t *       http://www.opensource.org/licenses/apache2.0.php\n\t *\n\t *   You may elect to redistribute this code under either of these licenses.\n\t */\n\t!function (factory) {\n\t  if (true) {\n\t    // CommonJS loader\n\t    var SockJS = __webpack_require__(7);\n\t    if(!SockJS) {\n\t      throw new Error('vertx-eventbus.js requires sockjs-client, see http://sockjs.org');\n\t    }\n\t    factory(SockJS);\n\t  } else if (typeof define === 'function' && define.amd) {\n\t    // AMD loader\n\t    define('vertx-eventbus', ['sockjs'], factory);\n\t  } else {\n\t    // plain old include\n\t    if (typeof this.SockJS === 'undefined') {\n\t      throw new Error('vertx-eventbus.js requires sockjs-client, see http://sockjs.org');\n\t    }\n\t\n\t    EventBus = factory(this.SockJS);\n\t  }\n\t}(function (SockJS) {\n\t\n\t  function makeUUID() {\n\t    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (a, b) {\n\t      return b = Math.random() * 16, (a == 'y' ? b & 3 | 8 : b | 0).toString(16);\n\t    });\n\t  }\n\t\n\t  function mergeHeaders(defaultHeaders, headers) {\n\t    if (defaultHeaders) {\n\t      if(!headers) {\n\t        return defaultHeaders;\n\t      }\n\t\n\t      for (var headerName in defaultHeaders) {\n\t        if (defaultHeaders.hasOwnProperty(headerName)) {\n\t          // user can overwrite the default headers\n\t          if (typeof headers[headerName] === 'undefined') {\n\t            headers[headerName] = defaultHeaders[headerName];\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // headers are required to be a object\n\t    return headers || {};\n\t  }\n\t\n\t  /**\n\t   * EventBus\n\t   *\n\t   * @param url\n\t   * @param options\n\t   * @constructor\n\t   */\n\t  var EventBus = function (url, options) {\n\t    var self = this;\n\t\n\t    options = options || {};\n\t\n\t    var pingInterval = options.vertxbus_ping_interval || 5000;\n\t    var pingTimerID;\n\t\n\t    // attributes\n\t    this.sockJSConn = new SockJS(url, null, options);\n\t    this.state = EventBus.CONNECTING;\n\t    this.handlers = {};\n\t    this.replyHandlers = {};\n\t    this.defaultHeaders = null;\n\t\n\t    // default event handlers\n\t    this.onerror = function (err) {\n\t      try {\n\t        console.error(err);\n\t      } catch (e) {\n\t        // dev tools are disabled so we cannot use console on IE\n\t      }\n\t    };\n\t\n\t    var sendPing = function () {\n\t      self.sockJSConn.send(JSON.stringify({type: 'ping'}));\n\t    };\n\t\n\t    this.sockJSConn.onopen = function () {\n\t      // Send the first ping then send a ping every pingInterval milliseconds\n\t      sendPing();\n\t      pingTimerID = setInterval(sendPing, pingInterval);\n\t      self.state = EventBus.OPEN;\n\t      self.onopen && self.onopen();\n\t    };\n\t\n\t    this.sockJSConn.onclose = function (e) {\n\t      self.state = EventBus.CLOSED;\n\t      if (pingTimerID) clearInterval(pingTimerID);\n\t      self.onclose && self.onclose(e);\n\t    };\n\t\n\t    this.sockJSConn.onmessage = function (e) {\n\t      var json = JSON.parse(e.data);\n\t\n\t      // define a reply function on the message itself\n\t      if (json.replyAddress) {\n\t        Object.defineProperty(json, 'reply', {\n\t          value: function (message, headers, callback) {\n\t            self.send(json.replyAddress, message, headers, callback);\n\t          }\n\t        });\n\t      }\n\t\n\t      if (self.handlers[json.address]) {\n\t        // iterate all registered handlers\n\t        var handlers = self.handlers[json.address];\n\t        for (var i = 0; i < handlers.length; i++) {\n\t          if (json.type === 'err') {\n\t            handlers[i]({failureCode: json.failureCode, failureType: json.failureType, message: json.message});\n\t          } else {\n\t            handlers[i](null, json);\n\t          }\n\t        }\n\t      } else if (self.replyHandlers[json.address]) {\n\t        // Might be a reply message\n\t        var handler = self.replyHandlers[json.address];\n\t        delete self.replyHandlers[json.address];\n\t        if (json.type === 'err') {\n\t          handler({failureCode: json.failureCode, failureType: json.failureType, message: json.message});\n\t        } else {\n\t          handler(null, json);\n\t        }\n\t      } else {\n\t        if (json.type === 'err') {\n\t          self.onerror(json);\n\t        } else {\n\t          try {\n\t            console.warn('No handler found for message: ', json);\n\t          } catch (e) {\n\t            // dev tools are disabled so we cannot use console on IE\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Send a message\n\t   *\n\t   * @param {String} address\n\t   * @param {Object} message\n\t   * @param {Object} [headers]\n\t   * @param {Function} [callback]\n\t   */\n\t  EventBus.prototype.send = function (address, message, headers, callback) {\n\t    // are we ready?\n\t    if (this.state != EventBus.OPEN) {\n\t      throw new Error('INVALID_STATE_ERR');\n\t    }\n\t\n\t    if (typeof headers === 'function') {\n\t      callback = headers;\n\t      headers = {};\n\t    }\n\t\n\t    var envelope = {\n\t      type: 'send',\n\t      address: address,\n\t      headers: mergeHeaders(this.defaultHeaders, headers),\n\t      body: message\n\t    };\n\t\n\t    if (callback) {\n\t      var replyAddress = makeUUID();\n\t      envelope.replyAddress = replyAddress;\n\t      this.replyHandlers[replyAddress] = callback;\n\t    }\n\t\n\t    this.sockJSConn.send(JSON.stringify(envelope));\n\t  };\n\t\n\t  /**\n\t   * Publish a message\n\t   *\n\t   * @param {String} address\n\t   * @param {Object} message\n\t   * @param {Object} [headers]\n\t   */\n\t  EventBus.prototype.publish = function (address, message, headers) {\n\t    // are we ready?\n\t    if (this.state != EventBus.OPEN) {\n\t      throw new Error('INVALID_STATE_ERR');\n\t    }\n\t\n\t    this.sockJSConn.send(JSON.stringify({\n\t      type: 'publish',\n\t      address: address,\n\t      headers: mergeHeaders(this.defaultHeaders, headers),\n\t      body: message\n\t    }));\n\t  };\n\t\n\t  /**\n\t   * Register a new handler\n\t   *\n\t   * @param {String} address\n\t   * @param {Object} [headers]\n\t   * @param {Function} callback\n\t   */\n\t  EventBus.prototype.registerHandler = function (address, headers, callback) {\n\t    // are we ready?\n\t    if (this.state != EventBus.OPEN) {\n\t      throw new Error('INVALID_STATE_ERR');\n\t    }\n\t\n\t    if (typeof headers === 'function') {\n\t      callback = headers;\n\t      headers = {};\n\t    }\n\t\n\t    // ensure it is an array\n\t    if (!this.handlers[address]) {\n\t      this.handlers[address] = [];\n\t      // First handler for this address so we should register the connection\n\t      this.sockJSConn.send(JSON.stringify({\n\t        type: 'register',\n\t        address: address,\n\t        headers: mergeHeaders(this.defaultHeaders, headers)\n\t      }));\n\t    }\n\t\n\t    this.handlers[address].push(callback);\n\t  };\n\t\n\t  /**\n\t   * Unregister a handler\n\t   *\n\t   * @param {String} address\n\t   * @param {Object} [headers]\n\t   * @param {Function} callback\n\t   */\n\t  EventBus.prototype.unregisterHandler = function (address, headers, callback) {\n\t    // are we ready?\n\t    if (this.state != EventBus.OPEN) {\n\t      throw new Error('INVALID_STATE_ERR');\n\t    }\n\t\n\t    var handlers = this.handlers[address];\n\t\n\t    if (handlers) {\n\t\n\t      if (typeof headers === 'function') {\n\t        callback = headers;\n\t        headers = {};\n\t      }\n\t\n\t      var idx = handlers.indexOf(callback);\n\t      if (idx != -1) {\n\t        handlers.splice(idx, 1);\n\t        if (handlers.length === 0) {\n\t          // No more local handlers so we should unregister the connection\n\t          this.sockJSConn.send(JSON.stringify({\n\t            type: 'unregister',\n\t            address: address,\n\t            headers: mergeHeaders(this.defaultHeaders, headers)\n\t          }));\n\t\n\t          delete this.handlers[address];\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Closes the connection to the EvenBus Bridge.\n\t   */\n\t  EventBus.prototype.close = function () {\n\t    this.state = EventBus.CLOSING;\n\t    this.sockJSConn.close();\n\t  };\n\t\n\t  EventBus.CONNECTING = 0;\n\t  EventBus.OPEN = 1;\n\t  EventBus.CLOSING = 2;\n\t  EventBus.CLOSED = 3;\n\t\n\t  if (true) {\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t      exports = module.exports = EventBus;\n\t    } else {\n\t      exports.EventBus = EventBus;\n\t    }\n\t  } else {\n\t    return EventBus;\n\t  }\n\t});\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar transportList = __webpack_require__(8);\n\t\n\tmodule.exports = __webpack_require__(56)(transportList);\n\t\n\t// TODO can't get rid of this until all servers do\n\tif ('_sockjs_onload' in global) {\n\t  setTimeout(global._sockjs_onload, 1);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = [\n\t  // streaming transports\n\t  __webpack_require__(9)\n\t, __webpack_require__(26)\n\t, __webpack_require__(36)\n\t, __webpack_require__(38)\n\t, __webpack_require__(41)(__webpack_require__(38))\n\t\n\t  // polling transports\n\t, __webpack_require__(49)\n\t, __webpack_require__(41)(__webpack_require__(49))\n\t, __webpack_require__(51)\n\t, __webpack_require__(52)\n\t, __webpack_require__(41)(__webpack_require__(51))\n\t, __webpack_require__(53)\n\t];\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar utils = __webpack_require__(11)\n\t  , urlUtils = __webpack_require__(14)\n\t  , inherits = __webpack_require__(22)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  , WebsocketDriver = __webpack_require__(25)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:websocket');\n\t}\n\t\n\tfunction WebSocketTransport(transUrl) {\n\t  if (!WebSocketTransport.enabled()) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t\n\t  EventEmitter.call(this);\n\t  debug('constructor', transUrl);\n\t\n\t  var self = this;\n\t  var url = urlUtils.addPath(transUrl, '/websocket');\n\t  if (url.slice(0, 5) === 'https') {\n\t    url = 'wss' + url.slice(5);\n\t  } else {\n\t    url = 'ws' + url.slice(4);\n\t  }\n\t  this.url = url;\n\t\n\t  this.ws = new WebsocketDriver(this.url);\n\t  this.ws.onmessage = function(e) {\n\t    debug('message event', e.data);\n\t    self.emit('message', e.data);\n\t  };\n\t  // Firefox has an interesting bug. If a websocket connection is\n\t  // created after onunload, it stays alive even when user\n\t  // navigates away from the page. In such situation let's lie -\n\t  // let's not open the ws connection at all. See:\n\t  // https://github.com/sockjs/sockjs-client/issues/28\n\t  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n\t  this.unloadRef = utils.unloadAdd(function() {\n\t    debug('unload');\n\t    self.ws.close();\n\t  });\n\t  this.ws.onclose = function(e) {\n\t    debug('close event', e.code, e.reason);\n\t    self.emit('close', e.code, e.reason);\n\t    self._cleanup();\n\t  };\n\t  this.ws.onerror = function(e) {\n\t    debug('error event', e);\n\t    self.emit('close', 1006, 'WebSocket connection broken');\n\t    self._cleanup();\n\t  };\n\t}\n\t\n\tinherits(WebSocketTransport, EventEmitter);\n\t\n\tWebSocketTransport.prototype.send = function(data) {\n\t  var msg = '[' + data + ']';\n\t  debug('send', msg);\n\t  this.ws.send(msg);\n\t};\n\t\n\tWebSocketTransport.prototype.close = function() {\n\t  debug('close');\n\t  if (this.ws) {\n\t    this.ws.close();\n\t  }\n\t  this._cleanup();\n\t};\n\t\n\tWebSocketTransport.prototype._cleanup = function() {\n\t  debug('_cleanup');\n\t  var ws = this.ws;\n\t  if (ws) {\n\t    ws.onmessage = ws.onclose = ws.onerror = null;\n\t  }\n\t  utils.unloadDel(this.unloadRef);\n\t  this.unloadRef = this.ws = null;\n\t  this.removeAllListeners();\n\t};\n\t\n\tWebSocketTransport.enabled = function() {\n\t  debug('enabled');\n\t  return !!WebsocketDriver;\n\t};\n\tWebSocketTransport.transportName = 'websocket';\n\t\n\t// In theory, ws should require 1 round trip. But in chrome, this is\n\t// not very stable over SSL. Most likely a ws connection requires a\n\t// separate SSL connection, in which case 2 round trips are an\n\t// absolute minumum.\n\tWebSocketTransport.roundTrips = 2;\n\t\n\tmodule.exports = WebSocketTransport;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar random = __webpack_require__(12);\n\t\n\tvar onUnload = {}\n\t  , afterUnload = false\n\t    // detect google chrome packaged apps because they don't allow the 'unload' event\n\t  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime\n\t  ;\n\t\n\tmodule.exports = {\n\t  attachEvent: function(event, listener) {\n\t    if (typeof global.addEventListener !== 'undefined') {\n\t      global.addEventListener(event, listener, false);\n\t    } else if (global.document && global.attachEvent) {\n\t      // IE quirks.\n\t      // According to: http://stevesouders.com/misc/test-postmessage.php\n\t      // the message gets delivered only to 'document', not 'window'.\n\t      global.document.attachEvent('on' + event, listener);\n\t      // I get 'window' for ie8.\n\t      global.attachEvent('on' + event, listener);\n\t    }\n\t  }\n\t\n\t, detachEvent: function(event, listener) {\n\t    if (typeof global.addEventListener !== 'undefined') {\n\t      global.removeEventListener(event, listener, false);\n\t    } else if (global.document && global.detachEvent) {\n\t      global.document.detachEvent('on' + event, listener);\n\t      global.detachEvent('on' + event, listener);\n\t    }\n\t  }\n\t\n\t, unloadAdd: function(listener) {\n\t    if (isChromePackagedApp) {\n\t      return null;\n\t    }\n\t\n\t    var ref = random.string(8);\n\t    onUnload[ref] = listener;\n\t    if (afterUnload) {\n\t      setTimeout(this.triggerUnloadCallbacks, 0);\n\t    }\n\t    return ref;\n\t  }\n\t\n\t, unloadDel: function(ref) {\n\t    if (ref in onUnload) {\n\t      delete onUnload[ref];\n\t    }\n\t  }\n\t\n\t, triggerUnloadCallbacks: function() {\n\t    for (var ref in onUnload) {\n\t      onUnload[ref]();\n\t      delete onUnload[ref];\n\t    }\n\t  }\n\t};\n\t\n\tvar unloadTriggered = function() {\n\t  if (afterUnload) {\n\t    return;\n\t  }\n\t  afterUnload = true;\n\t  module.exports.triggerUnloadCallbacks();\n\t};\n\t\n\t// 'unload' alone is not reliable in opera within an iframe, but we\n\t// can't use `beforeunload` as IE fires it on javascript: links.\n\tif (!isChromePackagedApp) {\n\t  module.exports.attachEvent('unload', unloadTriggered);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* global crypto:true */\n\tvar crypto = __webpack_require__(13);\n\t\n\t// This string has length 32, a power of 2, so the modulus doesn't introduce a\n\t// bias.\n\tvar _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';\n\tmodule.exports = {\n\t  string: function(length) {\n\t    var max = _randomStringChars.length;\n\t    var bytes = crypto.randomBytes(length);\n\t    var ret = [];\n\t    for (var i = 0; i < length; i++) {\n\t      ret.push(_randomStringChars.substr(bytes[i] % max, 1));\n\t    }\n\t    return ret.join('');\n\t  }\n\t\n\t, number: function(max) {\n\t    return Math.floor(Math.random() * max);\n\t  }\n\t\n\t, numberString: function(max) {\n\t    var t = ('' + (max - 1)).length;\n\t    var p = new Array(t + 1).join('0');\n\t    return (p + this.number(max)).slice(-t);\n\t  }\n\t};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tif (global.crypto && global.crypto.getRandomValues) {\n\t  module.exports.randomBytes = function(length) {\n\t    var bytes = new Uint8Array(length);\n\t    global.crypto.getRandomValues(bytes);\n\t    return bytes;\n\t  };\n\t} else {\n\t  module.exports.randomBytes = function(length) {\n\t    var bytes = new Array(length);\n\t    for (var i = 0; i < length; i++) {\n\t      bytes[i] = Math.floor(Math.random() * 256);\n\t    }\n\t    return bytes;\n\t  };\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar URL = __webpack_require__(15);\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:utils:url');\n\t}\n\t\n\tmodule.exports = {\n\t  getOrigin: function(url) {\n\t    if (!url) {\n\t      return null;\n\t    }\n\t\n\t    var p = new URL(url);\n\t    if (p.protocol === 'file:') {\n\t      return null;\n\t    }\n\t\n\t    var port = p.port;\n\t    if (!port) {\n\t      port = (p.protocol === 'https:') ? '443' : '80';\n\t    }\n\t\n\t    return p.protocol + '//' + p.hostname + ':' + port;\n\t  }\n\t\n\t, isOriginEqual: function(a, b) {\n\t    var res = this.getOrigin(a) === this.getOrigin(b);\n\t    debug('same', a, b, res);\n\t    return res;\n\t  }\n\t\n\t, isSchemeEqual: function(a, b) {\n\t    return (a.split(':')[0] === b.split(':')[0]);\n\t  }\n\t\n\t, addPath: function (url, path) {\n\t    var qs = url.split('?');\n\t    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');\n\t  }\n\t\n\t, addQuery: function (url, q) {\n\t    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));\n\t  }\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar required = __webpack_require__(16)\n\t  , lolcation = __webpack_require__(17)\n\t  , qs = __webpack_require__(18)\n\t  , relativere = /^\\/(?!\\/)/\n\t  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i;\n\t\n\t/**\n\t * These are the parse instructions for the URL parsers, it informs the parser\n\t * about:\n\t *\n\t * 0. The char it Needs to parse, if it's a string it should be done using\n\t *    indexOf, RegExp using exec and NaN means set as current value.\n\t * 1. The property we should set when parsing this value.\n\t * 2. Indication if it's backwards or forward parsing, when set as number it's\n\t *    the value of extra chars that should be split off.\n\t * 3. Inherit from location if non existing in the parser.\n\t * 4. `toLowerCase` the resulting value.\n\t */\n\tvar instructions = [\n\t  ['#', 'hash'],                        // Extract from the back.\n\t  ['?', 'query'],                       // Extract from the back.\n\t  ['/', 'pathname'],                    // Extract from the back.\n\t  ['@', 'auth', 1],                     // Extract from the front.\n\t  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n\t  [/:(\\d+)$/, 'port'],                  // RegExp the back.\n\t  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n\t];\n\t\n\t /**\n\t * @typedef ProtocolExtract\n\t * @type Object\n\t * @property {String} protocol Protocol matched in the URL, in lowercase\n\t * @property {Boolean} slashes Indicates whether the protocol is followed by double slash (\"//\")\n\t * @property {String} rest     Rest of the URL that is not part of the protocol\n\t */\n\t\n\t /**\n\t  * Extract protocol information from a URL with/without double slash (\"//\")\n\t  *\n\t  * @param  {String} address   URL we want to extract from.\n\t  * @return {ProtocolExtract}  Extracted information\n\t  * @api private\n\t  */\n\tfunction extractProtocol(address) {\n\t  var match = protocolre.exec(address);\n\t\n\t  return {\n\t    protocol: match[1] ? match[1].toLowerCase() : '',\n\t    slashes: !!match[2],\n\t    rest: match[3] ? match[3] : ''\n\t  };\n\t}\n\t\n\t/**\n\t * The actual URL instance. Instead of returning an object we've opted-in to\n\t * create an actual constructor as it's much more memory efficient and\n\t * faster and it pleases my OCD.\n\t *\n\t * @constructor\n\t * @param {String} address URL we want to parse.\n\t * @param {Object|String} location Location defaults for relative paths.\n\t * @param {Boolean|Function} parser Parser for the query string.\n\t * @api public\n\t */\n\tfunction URL(address, location, parser) {\n\t  if (!(this instanceof URL)) {\n\t    return new URL(address, location, parser);\n\t  }\n\t\n\t  var relative = relativere.test(address)\n\t    , parse, instruction, index, key\n\t    , type = typeof location\n\t    , url = this\n\t    , extracted\n\t    , i = 0;\n\t\n\t  //\n\t  // The following if statements allows this module two have compatibility with\n\t  // 2 different API:\n\t  //\n\t  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n\t  //    where the boolean indicates that the query string should also be parsed.\n\t  //\n\t  // 2. The `URL` interface of the browser which accepts a URL, object as\n\t  //    arguments. The supplied object will be used as default values / fall-back\n\t  //    for relative paths.\n\t  //\n\t  if ('object' !== type && 'string' !== type) {\n\t    parser = location;\n\t    location = null;\n\t  }\n\t\n\t  if (parser && 'function' !== typeof parser) {\n\t    parser = qs.parse;\n\t  }\n\t\n\t  location = lolcation(location);\n\t\n\t  //\n\t  // extract protocol information before running the instructions\n\t  //\n\t  extracted = extractProtocol(address);\n\t  url.protocol = extracted.protocol || location.protocol || '';\n\t  url.slashes = extracted.slashes || location.slashes;\n\t  address = extracted.rest;\n\t\n\t  for (; i < instructions.length; i++) {\n\t    instruction = instructions[i];\n\t    parse = instruction[0];\n\t    key = instruction[1];\n\t\n\t    if (parse !== parse) {\n\t      url[key] = address;\n\t    } else if ('string' === typeof parse) {\n\t      if (~(index = address.indexOf(parse))) {\n\t        if ('number' === typeof instruction[2]) {\n\t          url[key] = address.slice(0, index);\n\t          address = address.slice(index + instruction[2]);\n\t        } else {\n\t          url[key] = address.slice(index);\n\t          address = address.slice(0, index);\n\t        }\n\t      }\n\t    } else if (index = parse.exec(address)) {\n\t      url[key] = index[1];\n\t      address = address.slice(0, address.length - index[0].length);\n\t    }\n\t\n\t    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');\n\t\n\t    //\n\t    // Hostname, host and protocol should be lowercased so they can be used to\n\t    // create a proper `origin`.\n\t    //\n\t    if (instruction[4]) {\n\t      url[key] = url[key].toLowerCase();\n\t    }\n\t  }\n\t\n\t  //\n\t  // Also parse the supplied query string in to an object. If we're supplied\n\t  // with a custom parser as function use that instead of the default build-in\n\t  // parser.\n\t  //\n\t  if (parser) url.query = parser(url.query);\n\t\n\t  //\n\t  // We should not add port numbers if they are already the default port number\n\t  // for a given protocol. As the host also contains the port number we're going\n\t  // override it with the hostname which contains no port number.\n\t  //\n\t  if (!required(url.port, url.protocol)) {\n\t    url.host = url.hostname;\n\t    url.port = '';\n\t  }\n\t\n\t  //\n\t  // Parse down the `auth` for the username and password.\n\t  //\n\t  url.username = url.password = '';\n\t  if (url.auth) {\n\t    instruction = url.auth.split(':');\n\t    url.username = instruction[0] || '';\n\t    url.password = instruction[1] || '';\n\t  }\n\t\n\t  //\n\t  // The href is just the compiled result.\n\t  //\n\t  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol +'//'+ url.host : 'null';\n\t  url.href = url.toString();\n\t}\n\t\n\t/**\n\t * This is convenience method for changing properties in the URL instance to\n\t * insure that they all propagate correctly.\n\t *\n\t * @param {String} part          Property we need to adjust.\n\t * @param {Mixed} value          The newly assigned value.\n\t * @param {Boolean|Function} fn  When setting the query, it will be the function used to parse\n\t *                               the query.\n\t *                               When setting the protocol, double slash will be removed from\n\t *                               the final url if it is true.\n\t * @returns {URL}\n\t * @api public\n\t */\n\tURL.prototype.set = function set(part, value, fn) {\n\t  var url = this;\n\t\n\t  if ('query' === part) {\n\t    if ('string' === typeof value && value.length) {\n\t      value = (fn || qs.parse)(value);\n\t    }\n\t\n\t    url[part] = value;\n\t  } else if ('port' === part) {\n\t    url[part] = value;\n\t\n\t    if (!required(value, url.protocol)) {\n\t      url.host = url.hostname;\n\t      url[part] = '';\n\t    } else if (value) {\n\t      url.host = url.hostname +':'+ value;\n\t    }\n\t  } else if ('hostname' === part) {\n\t    url[part] = value;\n\t\n\t    if (url.port) value += ':'+ url.port;\n\t    url.host = value;\n\t  } else if ('host' === part) {\n\t    url[part] = value;\n\t\n\t    if (/:\\d+$/.test(value)) {\n\t      value = value.split(':');\n\t      url.port = value.pop();\n\t      url.hostname = value.join(':');\n\t    } else {\n\t      url.hostname = value;\n\t      url.port = '';\n\t    }\n\t  } else if ('protocol' === part) {\n\t    url.protocol = value.toLowerCase();\n\t    url.slashes = !fn;\n\t  } else {\n\t    url[part] = value;\n\t  }\n\t\n\t  for (var i = 0; i < instructions.length; i++) {\n\t    var ins = instructions[i];\n\t\n\t    if (ins[4]) {\n\t      url[ins[1]] = url[ins[1]].toLowerCase();\n\t    }\n\t  }\n\t\n\t  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol +'//'+ url.host : 'null';\n\t  url.href = url.toString();\n\t\n\t  return url;\n\t};\n\t\n\t/**\n\t * Transform the properties back in to a valid and full URL string.\n\t *\n\t * @param {Function} stringify Optional query stringify function.\n\t * @returns {String}\n\t * @api public\n\t */\n\tURL.prototype.toString = function toString(stringify) {\n\t  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\t\n\t  var query\n\t    , url = this\n\t    , protocol = url.protocol;\n\t\n\t  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\t\n\t  var result = protocol + (url.slashes ? '//' : '');\n\t\n\t  if (url.username) {\n\t    result += url.username;\n\t    if (url.password) result += ':'+ url.password;\n\t    result += '@';\n\t  }\n\t\n\t  result += url.host + url.pathname;\n\t\n\t  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n\t  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\t\n\t  if (url.hash) result += url.hash;\n\t\n\t  return result;\n\t};\n\t\n\t//\n\t// Expose the URL parser and some additional properties that might be useful for\n\t// others or testing.\n\t//\n\tURL.extractProtocol = extractProtocol;\n\tURL.location = lolcation;\n\tURL.qs = qs;\n\t\n\tmodule.exports = URL;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Check if we're required to add a port number.\n\t *\n\t * @see https://url.spec.whatwg.org/#default-port\n\t * @param {Number|String} port Port number we need to check\n\t * @param {String} protocol Protocol we need to check against.\n\t * @returns {Boolean} Is it a default port for the given protocol\n\t * @api private\n\t */\n\tmodule.exports = function required(port, protocol) {\n\t  protocol = protocol.split(':')[0];\n\t  port = +port;\n\t\n\t  if (!port) return false;\n\t\n\t  switch (protocol) {\n\t    case 'http':\n\t    case 'ws':\n\t    return port !== 80;\n\t\n\t    case 'https':\n\t    case 'wss':\n\t    return port !== 443;\n\t\n\t    case 'ftp':\n\t    return port !== 21;\n\t\n\t    case 'gopher':\n\t    return port !== 70;\n\t\n\t    case 'file':\n\t    return false;\n\t  }\n\t\n\t  return port !== 0;\n\t};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n\t\n\t/**\n\t * These properties should not be copied or inherited from. This is only needed\n\t * for all non blob URL's as a blob URL does not include a hash, only the\n\t * origin.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tvar ignore = { hash: 1, query: 1 }\n\t  , URL;\n\t\n\t/**\n\t * The location object differs when your code is loaded through a normal page,\n\t * Worker or through a worker using a blob. And with the blobble begins the\n\t * trouble as the location object will contain the URL of the blob, not the\n\t * location of the page where our code is loaded in. The actual origin is\n\t * encoded in the `pathname` so we can thankfully generate a good \"default\"\n\t * location from it so we can generate proper relative URL's again.\n\t *\n\t * @param {Object|String} loc Optional default location object.\n\t * @returns {Object} lolcation object.\n\t * @api public\n\t */\n\tmodule.exports = function lolcation(loc) {\n\t  loc = loc || global.location || {};\n\t  URL = URL || __webpack_require__(15);\n\t\n\t  var finaldestination = {}\n\t    , type = typeof loc\n\t    , key;\n\t\n\t  if ('blob:' === loc.protocol) {\n\t    finaldestination = new URL(unescape(loc.pathname), {});\n\t  } else if ('string' === type) {\n\t    finaldestination = new URL(loc, {});\n\t    for (key in ignore) delete finaldestination[key];\n\t  } else if ('object' === type) {\n\t    for (key in loc) {\n\t      if (key in ignore) continue;\n\t      finaldestination[key] = loc[key];\n\t    }\n\t\n\t    if (finaldestination.slashes === undefined) {\n\t      finaldestination.slashes = slashes.test(loc.href);\n\t    }\n\t  }\n\t\n\t  return finaldestination;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * Simple query string parser.\n\t *\n\t * @param {String} query The query string that needs to be parsed.\n\t * @returns {Object}\n\t * @api public\n\t */\n\tfunction querystring(query) {\n\t  var parser = /([^=?&]+)=?([^&]*)/g\n\t    , result = {}\n\t    , part;\n\t\n\t  //\n\t  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n\t  // the lastIndex property so we can continue executing this loop until we've\n\t  // parsed all results.\n\t  //\n\t  for (;\n\t    part = parser.exec(query);\n\t    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n\t  );\n\t\n\t  return result;\n\t}\n\t\n\t/**\n\t * Transform a query string to an object.\n\t *\n\t * @param {Object} obj Object that should be transformed.\n\t * @param {String} prefix Optional prefix.\n\t * @returns {String}\n\t * @api public\n\t */\n\tfunction querystringify(obj, prefix) {\n\t  prefix = prefix || '';\n\t\n\t  var pairs = [];\n\t\n\t  //\n\t  // Optionally prefix with a '?' if needed\n\t  //\n\t  if ('string' !== typeof prefix) prefix = '?';\n\t\n\t  for (var key in obj) {\n\t    if (has.call(obj, key)) {\n\t      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n\t    }\n\t  }\n\t\n\t  return pairs.length ? prefix + pairs.join('&') : '';\n\t}\n\t\n\t//\n\t// Expose the module.\n\t//\n\texports.stringify = querystringify;\n\texports.parse = querystring;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(20);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  return ('WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  return JSON.stringify(v);\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(21);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    if ('function' === typeof exports.formatArgs) {\n\t      args = exports.formatArgs.apply(self, args);\n\t    }\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options){\n\t  options = options || {};\n\t  if ('string' == typeof val) return parse(val);\n\t  return options.long\n\t    ? long(val)\n\t    : short(val);\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = '' + str;\n\t  if (str.length > 10000) return;\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\t  if (!match) return;\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s;\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction short(ms) {\n\t  if (ms >= d) return Math.round(ms / d) + 'd';\n\t  if (ms >= h) return Math.round(ms / h) + 'h';\n\t  if (ms >= m) return Math.round(ms / m) + 'm';\n\t  if (ms >= s) return Math.round(ms / s) + 's';\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction long(ms) {\n\t  return plural(ms, d, 'day')\n\t    || plural(ms, h, 'hour')\n\t    || plural(ms, m, 'minute')\n\t    || plural(ms, s, 'second')\n\t    || ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) return;\n\t  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , EventTarget = __webpack_require__(24)\n\t  ;\n\t\n\tfunction EventEmitter() {\n\t  EventTarget.call(this);\n\t}\n\t\n\tinherits(EventEmitter, EventTarget);\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  if (type) {\n\t    delete this._listeners[type];\n\t  } else {\n\t    this._listeners = {};\n\t  }\n\t};\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  var self = this\n\t    , fired = false;\n\t\n\t  function g() {\n\t    self.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  this.on(type, g);\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var listeners = this._listeners[type];\n\t  if (!listeners) {\n\t    return;\n\t  }\n\t  var args = Array.prototype.slice.call(arguments, 1);\n\t  for (var i = 0; i < listeners.length; i++) {\n\t    listeners[i].apply(this, args);\n\t  }\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;\n\tEventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;\n\t\n\tmodule.exports.EventEmitter = EventEmitter;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/* Simplified implementation of DOM2 EventTarget.\n\t *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n\t */\n\t\n\tfunction EventTarget() {\n\t  this._listeners = {};\n\t}\n\t\n\tEventTarget.prototype.addEventListener = function(eventType, listener) {\n\t  if (!(eventType in this._listeners)) {\n\t    this._listeners[eventType] = [];\n\t  }\n\t  var arr = this._listeners[eventType];\n\t  // #4\n\t  if (arr.indexOf(listener) === -1) {\n\t    // Make a copy so as not to interfere with a current dispatchEvent.\n\t    arr = arr.concat([listener]);\n\t  }\n\t  this._listeners[eventType] = arr;\n\t};\n\t\n\tEventTarget.prototype.removeEventListener = function(eventType, listener) {\n\t  var arr = this._listeners[eventType];\n\t  if (!arr) {\n\t    return;\n\t  }\n\t  var idx = arr.indexOf(listener);\n\t  if (idx !== -1) {\n\t    if (arr.length > 1) {\n\t      // Make a copy so as not to interfere with a current dispatchEvent.\n\t      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\n\t    } else {\n\t      delete this._listeners[eventType];\n\t    }\n\t    return;\n\t  }\n\t};\n\t\n\tEventTarget.prototype.dispatchEvent = function(event) {\n\t  var t = event.type;\n\t  var args = Array.prototype.slice.call(arguments, 0);\n\t  // TODO: This doesn't match the real behavior; per spec, onfoo get\n\t  // their place in line from the /first/ time they're set from\n\t  // non-null. Although WebKit bumps it to the end every time it's\n\t  // set.\n\t  if (this['on' + t]) {\n\t    this['on' + t].apply(this, args);\n\t  }\n\t  if (t in this._listeners) {\n\t    // Grab a reference to the listeners list. removeEventListener may alter the list.\n\t    var listeners = this._listeners[t];\n\t    for (var i = 0; i < listeners.length; i++) {\n\t      listeners[i].apply(this, args);\n\t    }\n\t  }\n\t};\n\t\n\tmodule.exports = EventTarget;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global.WebSocket || global.MozWebSocket;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , AjaxBasedTransport = __webpack_require__(27)\n\t  , XhrReceiver = __webpack_require__(31)\n\t  , XHRCorsObject = __webpack_require__(32)\n\t  , XHRLocalObject = __webpack_require__(34)\n\t  , browser = __webpack_require__(35)\n\t  ;\n\t\n\tfunction XhrStreamingTransport(transUrl) {\n\t  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);\n\t}\n\t\n\tinherits(XhrStreamingTransport, AjaxBasedTransport);\n\t\n\tXhrStreamingTransport.enabled = function(info) {\n\t  if (info.nullOrigin) {\n\t    return false;\n\t  }\n\t  // Opera doesn't support xhr-streaming #60\n\t  // But it might be able to #92\n\t  if (browser.isOpera()) {\n\t    return false;\n\t  }\n\t\n\t  return XHRCorsObject.enabled;\n\t};\n\t\n\tXhrStreamingTransport.transportName = 'xhr-streaming';\n\tXhrStreamingTransport.roundTrips = 2; // preflight, ajax\n\t\n\t// Safari gets confused when a streaming ajax request is started\n\t// before onload. This causes the load indicator to spin indefinetely.\n\t// Only require body when used in a browser\n\tXhrStreamingTransport.needBody = !!global.document;\n\t\n\tmodule.exports = XhrStreamingTransport;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , urlUtils = __webpack_require__(14)\n\t  , SenderReceiver = __webpack_require__(28)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:ajax-based');\n\t}\n\t\n\tfunction createAjaxSender(AjaxObject) {\n\t  return function(url, payload, callback) {\n\t    debug('create ajax sender', url, payload);\n\t    var opt = {};\n\t    if (typeof payload === 'string') {\n\t      opt.headers = {'Content-type':'text/plain'};\n\t    }\n\t    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');\n\t    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);\n\t    xo.once('finish', function(status) {\n\t      debug('finish', status);\n\t      xo = null;\n\t\n\t      if (status !== 200 && status !== 204) {\n\t        return callback(new Error('http status ' + status));\n\t      }\n\t      callback();\n\t    });\n\t    return function() {\n\t      debug('abort');\n\t      xo.close();\n\t      xo = null;\n\t\n\t      var err = new Error('Aborted');\n\t      err.code = 1000;\n\t      callback(err);\n\t    };\n\t  };\n\t}\n\t\n\tfunction AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {\n\t  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);\n\t}\n\t\n\tinherits(AjaxBasedTransport, SenderReceiver);\n\t\n\tmodule.exports = AjaxBasedTransport;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , urlUtils = __webpack_require__(14)\n\t  , BufferedSender = __webpack_require__(29)\n\t  , Polling = __webpack_require__(30)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:sender-receiver');\n\t}\n\t\n\tfunction SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {\n\t  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);\n\t  debug(pollUrl);\n\t  var self = this;\n\t  BufferedSender.call(this, transUrl, senderFunc);\n\t\n\t  this.poll = new Polling(Receiver, pollUrl, AjaxObject);\n\t  this.poll.on('message', function(msg) {\n\t    debug('poll message', msg);\n\t    self.emit('message', msg);\n\t  });\n\t  this.poll.once('close', function(code, reason) {\n\t    debug('poll close', code, reason);\n\t    self.poll = null;\n\t    self.emit('close', code, reason);\n\t    self.close();\n\t  });\n\t}\n\t\n\tinherits(SenderReceiver, BufferedSender);\n\t\n\tSenderReceiver.prototype.close = function() {\n\t  debug('close');\n\t  this.removeAllListeners();\n\t  if (this.poll) {\n\t    this.poll.abort();\n\t    this.poll = null;\n\t  }\n\t  this.stop();\n\t};\n\t\n\tmodule.exports = SenderReceiver;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:buffered-sender');\n\t}\n\t\n\tfunction BufferedSender(url, sender) {\n\t  debug(url);\n\t  EventEmitter.call(this);\n\t  this.sendBuffer = [];\n\t  this.sender = sender;\n\t  this.url = url;\n\t}\n\t\n\tinherits(BufferedSender, EventEmitter);\n\t\n\tBufferedSender.prototype.send = function(message) {\n\t  debug('send', message);\n\t  this.sendBuffer.push(message);\n\t  if (!this.sendStop) {\n\t    this.sendSchedule();\n\t  }\n\t};\n\t\n\t// For polling transports in a situation when in the message callback,\n\t// new message is being send. If the sending connection was started\n\t// before receiving one, it is possible to saturate the network and\n\t// timeout due to the lack of receiving socket. To avoid that we delay\n\t// sending messages by some small time, in order to let receiving\n\t// connection be started beforehand. This is only a halfmeasure and\n\t// does not fix the big problem, but it does make the tests go more\n\t// stable on slow networks.\n\tBufferedSender.prototype.sendScheduleWait = function() {\n\t  debug('sendScheduleWait');\n\t  var self = this;\n\t  var tref;\n\t  this.sendStop = function() {\n\t    debug('sendStop');\n\t    self.sendStop = null;\n\t    clearTimeout(tref);\n\t  };\n\t  tref = setTimeout(function() {\n\t    debug('timeout');\n\t    self.sendStop = null;\n\t    self.sendSchedule();\n\t  }, 25);\n\t};\n\t\n\tBufferedSender.prototype.sendSchedule = function() {\n\t  debug('sendSchedule', this.sendBuffer.length);\n\t  var self = this;\n\t  if (this.sendBuffer.length > 0) {\n\t    var payload = '[' + this.sendBuffer.join(',') + ']';\n\t    this.sendStop = this.sender(this.url, payload, function(err) {\n\t      self.sendStop = null;\n\t      if (err) {\n\t        debug('error', err);\n\t        self.emit('close', err.code || 1006, 'Sending error: ' + err);\n\t        self._cleanup();\n\t      } else {\n\t        self.sendScheduleWait();\n\t      }\n\t    });\n\t    this.sendBuffer = [];\n\t  }\n\t};\n\t\n\tBufferedSender.prototype._cleanup = function() {\n\t  debug('_cleanup');\n\t  this.removeAllListeners();\n\t};\n\t\n\tBufferedSender.prototype.stop = function() {\n\t  debug('stop');\n\t  this._cleanup();\n\t  if (this.sendStop) {\n\t    this.sendStop();\n\t    this.sendStop = null;\n\t  }\n\t};\n\t\n\tmodule.exports = BufferedSender;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:polling');\n\t}\n\t\n\tfunction Polling(Receiver, receiveUrl, AjaxObject) {\n\t  debug(receiveUrl);\n\t  EventEmitter.call(this);\n\t  this.Receiver = Receiver;\n\t  this.receiveUrl = receiveUrl;\n\t  this.AjaxObject = AjaxObject;\n\t  this._scheduleReceiver();\n\t}\n\t\n\tinherits(Polling, EventEmitter);\n\t\n\tPolling.prototype._scheduleReceiver = function() {\n\t  debug('_scheduleReceiver');\n\t  var self = this;\n\t  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);\n\t\n\t  poll.on('message', function(msg) {\n\t    debug('message', msg);\n\t    self.emit('message', msg);\n\t  });\n\t\n\t  poll.once('close', function(code, reason) {\n\t    debug('close', code, reason, self.pollIsClosing);\n\t    self.poll = poll = null;\n\t\n\t    if (!self.pollIsClosing) {\n\t      if (reason === 'network') {\n\t        self._scheduleReceiver();\n\t      } else {\n\t        self.emit('close', code || 1006, reason);\n\t        self.removeAllListeners();\n\t      }\n\t    }\n\t  });\n\t};\n\t\n\tPolling.prototype.abort = function() {\n\t  debug('abort');\n\t  this.removeAllListeners();\n\t  this.pollIsClosing = true;\n\t  if (this.poll) {\n\t    this.poll.abort();\n\t  }\n\t};\n\t\n\tmodule.exports = Polling;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:receiver:xhr');\n\t}\n\t\n\tfunction XhrReceiver(url, AjaxObject) {\n\t  debug(url);\n\t  EventEmitter.call(this);\n\t  var self = this;\n\t\n\t  this.bufferPosition = 0;\n\t\n\t  this.xo = new AjaxObject('POST', url, null);\n\t  this.xo.on('chunk', this._chunkHandler.bind(this));\n\t  this.xo.once('finish', function(status, text) {\n\t    debug('finish', status, text);\n\t    self._chunkHandler(status, text);\n\t    self.xo = null;\n\t    var reason = status === 200 ? 'network' : 'permanent';\n\t    debug('close', reason);\n\t    self.emit('close', null, reason);\n\t    self._cleanup();\n\t  });\n\t}\n\t\n\tinherits(XhrReceiver, EventEmitter);\n\t\n\tXhrReceiver.prototype._chunkHandler = function(status, text) {\n\t  debug('_chunkHandler', status);\n\t  if (status !== 200 || !text) {\n\t    return;\n\t  }\n\t\n\t  for (var idx = -1; ; this.bufferPosition += idx + 1) {\n\t    var buf = text.slice(this.bufferPosition);\n\t    idx = buf.indexOf('\\n');\n\t    if (idx === -1) {\n\t      break;\n\t    }\n\t    var msg = buf.slice(0, idx);\n\t    if (msg) {\n\t      debug('message', msg);\n\t      this.emit('message', msg);\n\t    }\n\t  }\n\t};\n\t\n\tXhrReceiver.prototype._cleanup = function() {\n\t  debug('_cleanup');\n\t  this.removeAllListeners();\n\t};\n\t\n\tXhrReceiver.prototype.abort = function() {\n\t  debug('abort');\n\t  if (this.xo) {\n\t    this.xo.close();\n\t    debug('close');\n\t    this.emit('close', null, 'user');\n\t    this.xo = null;\n\t  }\n\t  this._cleanup();\n\t};\n\t\n\tmodule.exports = XhrReceiver;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , XhrDriver = __webpack_require__(33)\n\t  ;\n\t\n\tfunction XHRCorsObject(method, url, payload, opts) {\n\t  XhrDriver.call(this, method, url, payload, opts);\n\t}\n\t\n\tinherits(XHRCorsObject, XhrDriver);\n\t\n\tXHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;\n\t\n\tmodule.exports = XHRCorsObject;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';\n\t\n\tvar EventEmitter = __webpack_require__(23).EventEmitter\n\t  , inherits = __webpack_require__(22)\n\t  , utils = __webpack_require__(11)\n\t  , urlUtils = __webpack_require__(14)\n\t  , XHR = global.XMLHttpRequest\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:browser:xhr');\n\t}\n\t\n\tfunction AbstractXHRObject(method, url, payload, opts) {\n\t  debug(method, url);\n\t  var self = this;\n\t  EventEmitter.call(this);\n\t\n\t  setTimeout(function () {\n\t    self._start(method, url, payload, opts);\n\t  }, 0);\n\t}\n\t\n\tinherits(AbstractXHRObject, EventEmitter);\n\t\n\tAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\n\t  var self = this;\n\t\n\t  try {\n\t    this.xhr = new XHR();\n\t  } catch (x) {}\n\t\n\t  if (!this.xhr) {\n\t    debug('no xhr');\n\t    this.emit('finish', 0, 'no xhr support');\n\t    this._cleanup();\n\t    return;\n\t  }\n\t\n\t  // several browsers cache POSTs\n\t  url = urlUtils.addQuery(url, 't=' + (+new Date()));\n\t\n\t  // Explorer tends to keep connection open, even after the\n\t  // tab gets closed: http://bugs.jquery.com/ticket/5280\n\t  this.unloadRef = utils.unloadAdd(function() {\n\t    debug('unload cleanup');\n\t    self._cleanup(true);\n\t  });\n\t  try {\n\t    this.xhr.open(method, url, true);\n\t    if (this.timeout && 'timeout' in this.xhr) {\n\t      this.xhr.timeout = this.timeout;\n\t      this.xhr.ontimeout = function() {\n\t        debug('xhr timeout');\n\t        self.emit('finish', 0, '');\n\t        self._cleanup(false);\n\t      };\n\t    }\n\t  } catch (e) {\n\t    debug('exception', e);\n\t    // IE raises an exception on wrong port.\n\t    this.emit('finish', 0, '');\n\t    this._cleanup(false);\n\t    return;\n\t  }\n\t\n\t  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {\n\t    debug('withCredentials');\n\t    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n\t    // \"This never affects same-site requests.\"\n\t\n\t    this.xhr.withCredentials = 'true';\n\t  }\n\t  if (opts && opts.headers) {\n\t    for (var key in opts.headers) {\n\t      this.xhr.setRequestHeader(key, opts.headers[key]);\n\t    }\n\t  }\n\t\n\t  this.xhr.onreadystatechange = function() {\n\t    if (self.xhr) {\n\t      var x = self.xhr;\n\t      var text, status;\n\t      debug('readyState', x.readyState);\n\t      switch (x.readyState) {\n\t      case 3:\n\t        // IE doesn't like peeking into responseText or status\n\t        // on Microsoft.XMLHTTP and readystate=3\n\t        try {\n\t          status = x.status;\n\t          text = x.responseText;\n\t        } catch (e) {}\n\t        debug('status', status);\n\t        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n\t        if (status === 1223) {\n\t          status = 204;\n\t        }\n\t\n\t        // IE does return readystate == 3 for 404 answers.\n\t        if (status === 200 && text && text.length > 0) {\n\t          debug('chunk');\n\t          self.emit('chunk', status, text);\n\t        }\n\t        break;\n\t      case 4:\n\t        status = x.status;\n\t        debug('status', status);\n\t        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n\t        if (status === 1223) {\n\t          status = 204;\n\t        }\n\t        // IE returns this for a bad port\n\t        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx\n\t        if (status === 12005 || status === 12029) {\n\t          status = 0;\n\t        }\n\t\n\t        debug('finish', status, x.responseText);\n\t        self.emit('finish', status, x.responseText);\n\t        self._cleanup(false);\n\t        break;\n\t      }\n\t    }\n\t  };\n\t\n\t  try {\n\t    self.xhr.send(payload);\n\t  } catch (e) {\n\t    self.emit('finish', 0, '');\n\t    self._cleanup(false);\n\t  }\n\t};\n\t\n\tAbstractXHRObject.prototype._cleanup = function(abort) {\n\t  debug('cleanup');\n\t  if (!this.xhr) {\n\t    return;\n\t  }\n\t  this.removeAllListeners();\n\t  utils.unloadDel(this.unloadRef);\n\t\n\t  // IE needs this field to be a function\n\t  this.xhr.onreadystatechange = function() {};\n\t  if (this.xhr.ontimeout) {\n\t    this.xhr.ontimeout = null;\n\t  }\n\t\n\t  if (abort) {\n\t    try {\n\t      this.xhr.abort();\n\t    } catch (x) {}\n\t  }\n\t  this.unloadRef = this.xhr = null;\n\t};\n\t\n\tAbstractXHRObject.prototype.close = function() {\n\t  debug('close');\n\t  this._cleanup(true);\n\t};\n\t\n\tAbstractXHRObject.enabled = !!XHR;\n\t// override XMLHttpRequest for IE6/7\n\t// obfuscate to avoid firewalls\n\tvar axo = ['Active'].concat('Object').join('X');\n\tif (!AbstractXHRObject.enabled && (axo in global)) {\n\t  debug('overriding xmlhttprequest');\n\t  XHR = function() {\n\t    try {\n\t      return new global[axo]('Microsoft.XMLHTTP');\n\t    } catch (e) {\n\t      return null;\n\t    }\n\t  };\n\t  AbstractXHRObject.enabled = !!new XHR();\n\t}\n\t\n\tvar cors = false;\n\ttry {\n\t  cors = 'withCredentials' in new XHR();\n\t} catch (ignored) {}\n\t\n\tAbstractXHRObject.supportsCORS = cors;\n\t\n\tmodule.exports = AbstractXHRObject;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(10)))\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , XhrDriver = __webpack_require__(33)\n\t  ;\n\t\n\tfunction XHRLocalObject(method, url, payload /*, opts */) {\n\t  XhrDriver.call(this, method, url, payload, {\n\t    noCredentials: true\n\t  });\n\t}\n\t\n\tinherits(XHRLocalObject, XhrDriver);\n\t\n\tXHRLocalObject.enabled = XhrDriver.enabled;\n\t\n\tmodule.exports = XHRLocalObject;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tmodule.exports = {\n\t  isOpera: function() {\n\t    return global.navigator &&\n\t      /opera/i.test(global.navigator.userAgent);\n\t  }\n\t\n\t, isKonqueror: function() {\n\t    return global.navigator &&\n\t      /konqueror/i.test(global.navigator.userAgent);\n\t  }\n\t\n\t  // #187 wrap document.domain in try/catch because of WP8 from file:///\n\t, hasDomain: function () {\n\t    // non-browser client always has a domain\n\t    if (!global.document) {\n\t      return true;\n\t    }\n\t\n\t    try {\n\t      return !!global.document.domain;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  }\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , AjaxBasedTransport = __webpack_require__(27)\n\t  , XhrReceiver = __webpack_require__(31)\n\t  , XDRObject = __webpack_require__(37)\n\t  ;\n\t\n\t// According to:\n\t//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n\t//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n\t\n\tfunction XdrStreamingTransport(transUrl) {\n\t  if (!XDRObject.enabled) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\n\t}\n\t\n\tinherits(XdrStreamingTransport, AjaxBasedTransport);\n\t\n\tXdrStreamingTransport.enabled = function(info) {\n\t  if (info.cookie_needed || info.nullOrigin) {\n\t    return false;\n\t  }\n\t  return XDRObject.enabled && info.sameScheme;\n\t};\n\t\n\tXdrStreamingTransport.transportName = 'xdr-streaming';\n\tXdrStreamingTransport.roundTrips = 2; // preflight, ajax\n\t\n\tmodule.exports = XdrStreamingTransport;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tvar EventEmitter = __webpack_require__(23).EventEmitter\n\t  , inherits = __webpack_require__(22)\n\t  , eventUtils = __webpack_require__(11)\n\t  , browser = __webpack_require__(35)\n\t  , urlUtils = __webpack_require__(14)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:sender:xdr');\n\t}\n\t\n\t// References:\n\t//   http://ajaxian.com/archives/100-line-ajax-wrapper\n\t//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\n\t\n\tfunction XDRObject(method, url, payload) {\n\t  debug(method, url);\n\t  var self = this;\n\t  EventEmitter.call(this);\n\t\n\t  setTimeout(function() {\n\t    self._start(method, url, payload);\n\t  }, 0);\n\t}\n\t\n\tinherits(XDRObject, EventEmitter);\n\t\n\tXDRObject.prototype._start = function(method, url, payload) {\n\t  debug('_start');\n\t  var self = this;\n\t  var xdr = new global.XDomainRequest();\n\t  // IE caches even POSTs\n\t  url = urlUtils.addQuery(url, 't=' + (+new Date()));\n\t\n\t  xdr.onerror = function() {\n\t    debug('onerror');\n\t    self._error();\n\t  };\n\t  xdr.ontimeout = function() {\n\t    debug('ontimeout');\n\t    self._error();\n\t  };\n\t  xdr.onprogress = function() {\n\t    debug('progress', xdr.responseText);\n\t    self.emit('chunk', 200, xdr.responseText);\n\t  };\n\t  xdr.onload = function() {\n\t    debug('load');\n\t    self.emit('finish', 200, xdr.responseText);\n\t    self._cleanup(false);\n\t  };\n\t  this.xdr = xdr;\n\t  this.unloadRef = eventUtils.unloadAdd(function() {\n\t    self._cleanup(true);\n\t  });\n\t  try {\n\t    // Fails with AccessDenied if port number is bogus\n\t    this.xdr.open(method, url);\n\t    if (this.timeout) {\n\t      this.xdr.timeout = this.timeout;\n\t    }\n\t    this.xdr.send(payload);\n\t  } catch (x) {\n\t    this._error();\n\t  }\n\t};\n\t\n\tXDRObject.prototype._error = function() {\n\t  this.emit('finish', 0, '');\n\t  this._cleanup(false);\n\t};\n\t\n\tXDRObject.prototype._cleanup = function(abort) {\n\t  debug('cleanup', abort);\n\t  if (!this.xdr) {\n\t    return;\n\t  }\n\t  this.removeAllListeners();\n\t  eventUtils.unloadDel(this.unloadRef);\n\t\n\t  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;\n\t  if (abort) {\n\t    try {\n\t      this.xdr.abort();\n\t    } catch (x) {}\n\t  }\n\t  this.unloadRef = this.xdr = null;\n\t};\n\t\n\tXDRObject.prototype.close = function() {\n\t  debug('close');\n\t  this._cleanup(true);\n\t};\n\t\n\t// IE 8/9 if the request target uses the same scheme - #79\n\tXDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());\n\t\n\tmodule.exports = XDRObject;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), (function() { return this; }())))\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , AjaxBasedTransport = __webpack_require__(27)\n\t  , EventSourceReceiver = __webpack_require__(39)\n\t  , XHRCorsObject = __webpack_require__(32)\n\t  , EventSourceDriver = __webpack_require__(40)\n\t  ;\n\t\n\tfunction EventSourceTransport(transUrl) {\n\t  if (!EventSourceTransport.enabled()) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t\n\t  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);\n\t}\n\t\n\tinherits(EventSourceTransport, AjaxBasedTransport);\n\t\n\tEventSourceTransport.enabled = function() {\n\t  return !!EventSourceDriver;\n\t};\n\t\n\tEventSourceTransport.transportName = 'eventsource';\n\tEventSourceTransport.roundTrips = 2;\n\t\n\tmodule.exports = EventSourceTransport;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  , EventSourceDriver = __webpack_require__(40)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:receiver:eventsource');\n\t}\n\t\n\tfunction EventSourceReceiver(url) {\n\t  debug(url);\n\t  EventEmitter.call(this);\n\t\n\t  var self = this;\n\t  var es = this.es = new EventSourceDriver(url);\n\t  es.onmessage = function(e) {\n\t    debug('message', e.data);\n\t    self.emit('message', decodeURI(e.data));\n\t  };\n\t  es.onerror = function(e) {\n\t    debug('error', es.readyState, e);\n\t    // ES on reconnection has readyState = 0 or 1.\n\t    // on network error it's CLOSED = 2\n\t    var reason = (es.readyState !== 2 ? 'network' : 'permanent');\n\t    self._cleanup();\n\t    self._close(reason);\n\t  };\n\t}\n\t\n\tinherits(EventSourceReceiver, EventEmitter);\n\t\n\tEventSourceReceiver.prototype.abort = function() {\n\t  debug('abort');\n\t  this._cleanup();\n\t  this._close('user');\n\t};\n\t\n\tEventSourceReceiver.prototype._cleanup = function() {\n\t  debug('cleanup');\n\t  var es = this.es;\n\t  if (es) {\n\t    es.onmessage = es.onerror = null;\n\t    es.close();\n\t    this.es = null;\n\t  }\n\t};\n\t\n\tEventSourceReceiver.prototype._close = function(reason) {\n\t  debug('close', reason);\n\t  var self = this;\n\t  // Safari and chrome < 15 crash if we close window before\n\t  // waiting for ES cleanup. See:\n\t  // https://code.google.com/p/chromium/issues/detail?id=89155\n\t  setTimeout(function() {\n\t    self.emit('close', null, reason);\n\t    self.removeAllListeners();\n\t  }, 200);\n\t};\n\t\n\tmodule.exports = EventSourceReceiver;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global.EventSource;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , IframeTransport = __webpack_require__(42)\n\t  , objectUtils = __webpack_require__(48)\n\t  ;\n\t\n\tmodule.exports = function(transport) {\n\t\n\t  function IframeWrapTransport(transUrl, baseUrl) {\n\t    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);\n\t  }\n\t\n\t  inherits(IframeWrapTransport, IframeTransport);\n\t\n\t  IframeWrapTransport.enabled = function(url, info) {\n\t    if (!global.document) {\n\t      return false;\n\t    }\n\t\n\t    var iframeInfo = objectUtils.extend({}, info);\n\t    iframeInfo.sameOrigin = true;\n\t    return transport.enabled(iframeInfo) && IframeTransport.enabled();\n\t  };\n\t\n\t  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;\n\t  IframeWrapTransport.needBody = true;\n\t  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)\n\t\n\t  IframeWrapTransport.facadeTransport = transport;\n\t\n\t  return IframeWrapTransport;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\t// Few cool transports do work only for same-origin. In order to make\n\t// them work cross-domain we shall use iframe, served from the\n\t// remote domain. New browsers have capabilities to communicate with\n\t// cross domain iframe using postMessage(). In IE it was implemented\n\t// from IE 8+, but of course, IE got some details wrong:\n\t//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n\t//    http://stevesouders.com/misc/test-postmessage.php\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , JSON3 = __webpack_require__(43)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  , version = __webpack_require__(46)\n\t  , urlUtils = __webpack_require__(14)\n\t  , iframeUtils = __webpack_require__(47)\n\t  , eventUtils = __webpack_require__(11)\n\t  , random = __webpack_require__(12)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:transport:iframe');\n\t}\n\t\n\tfunction IframeTransport(transport, transUrl, baseUrl) {\n\t  if (!IframeTransport.enabled()) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t  EventEmitter.call(this);\n\t\n\t  var self = this;\n\t  this.origin = urlUtils.getOrigin(baseUrl);\n\t  this.baseUrl = baseUrl;\n\t  this.transUrl = transUrl;\n\t  this.transport = transport;\n\t  this.windowId = random.string(8);\n\t\n\t  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;\n\t  debug(transport, transUrl, iframeUrl);\n\t\n\t  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {\n\t    debug('err callback');\n\t    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');\n\t    self.close();\n\t  });\n\t\n\t  this.onmessageCallback = this._message.bind(this);\n\t  eventUtils.attachEvent('message', this.onmessageCallback);\n\t}\n\t\n\tinherits(IframeTransport, EventEmitter);\n\t\n\tIframeTransport.prototype.close = function() {\n\t  debug('close');\n\t  this.removeAllListeners();\n\t  if (this.iframeObj) {\n\t    eventUtils.detachEvent('message', this.onmessageCallback);\n\t    try {\n\t      // When the iframe is not loaded, IE raises an exception\n\t      // on 'contentWindow'.\n\t      this.postMessage('c');\n\t    } catch (x) {}\n\t    this.iframeObj.cleanup();\n\t    this.iframeObj = null;\n\t    this.onmessageCallback = this.iframeObj = null;\n\t  }\n\t};\n\t\n\tIframeTransport.prototype._message = function(e) {\n\t  debug('message', e.data);\n\t  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {\n\t    debug('not same origin', e.origin, this.origin);\n\t    return;\n\t  }\n\t\n\t  var iframeMessage;\n\t  try {\n\t    iframeMessage = JSON3.parse(e.data);\n\t  } catch (ignored) {\n\t    debug('bad json', e.data);\n\t    return;\n\t  }\n\t\n\t  if (iframeMessage.windowId !== this.windowId) {\n\t    debug('mismatched window id', iframeMessage.windowId, this.windowId);\n\t    return;\n\t  }\n\t\n\t  switch (iframeMessage.type) {\n\t  case 's':\n\t    this.iframeObj.loaded();\n\t    // window global dependency\n\t    this.postMessage('s', JSON3.stringify([\n\t      version\n\t    , this.transport\n\t    , this.transUrl\n\t    , this.baseUrl\n\t    ]));\n\t    break;\n\t  case 't':\n\t    this.emit('message', iframeMessage.data);\n\t    break;\n\t  case 'c':\n\t    var cdata;\n\t    try {\n\t      cdata = JSON3.parse(iframeMessage.data);\n\t    } catch (ignored) {\n\t      debug('bad json', iframeMessage.data);\n\t      return;\n\t    }\n\t    this.emit('close', cdata[0], cdata[1]);\n\t    this.close();\n\t    break;\n\t  }\n\t};\n\t\n\tIframeTransport.prototype.postMessage = function(type, data) {\n\t  debug('postMessage', type, data);\n\t  this.iframeObj.post(JSON3.stringify({\n\t    windowId: this.windowId\n\t  , type: type\n\t  , data: data || ''\n\t  }), this.origin);\n\t};\n\t\n\tIframeTransport.prototype.send = function(message) {\n\t  debug('send', message);\n\t  this.postMessage('m', message);\n\t};\n\t\n\tIframeTransport.enabled = function() {\n\t  return iframeUtils.iframeEnabled;\n\t};\n\t\n\tIframeTransport.transportName = 'iframe';\n\tIframeTransport.roundTrips = 2;\n\t\n\tmodule.exports = IframeTransport;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n\t;(function () {\n\t  // Detect the `define` function exposed by asynchronous module loaders. The\n\t  // strict `define` check is necessary for compatibility with `r.js`.\n\t  var isLoader = \"function\" === \"function\" && __webpack_require__(45);\n\t\n\t  // A set of types used to distinguish objects from primitives.\n\t  var objectTypes = {\n\t    \"function\": true,\n\t    \"object\": true\n\t  };\n\t\n\t  // Detect the `exports` object exposed by CommonJS implementations.\n\t  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\t\n\t  // Use the `global` object exposed by Node (including Browserify via\n\t  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n\t  // and the `window` object in browsers. Rhino exports a `global` function\n\t  // instead.\n\t  var root = objectTypes[typeof window] && window || this,\n\t      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\t\n\t  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n\t    root = freeGlobal;\n\t  }\n\t\n\t  // Public: Initializes JSON 3 using the given `context` object, attaching the\n\t  // `stringify` and `parse` functions to the specified `exports` object.\n\t  function runInContext(context, exports) {\n\t    context || (context = root[\"Object\"]());\n\t    exports || (exports = root[\"Object\"]());\n\t\n\t    // Native constructor aliases.\n\t    var Number = context[\"Number\"] || root[\"Number\"],\n\t        String = context[\"String\"] || root[\"String\"],\n\t        Object = context[\"Object\"] || root[\"Object\"],\n\t        Date = context[\"Date\"] || root[\"Date\"],\n\t        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n\t        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n\t        Math = context[\"Math\"] || root[\"Math\"],\n\t        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\t\n\t    // Delegate to the native `stringify` and `parse` implementations.\n\t    if (typeof nativeJSON == \"object\" && nativeJSON) {\n\t      exports.stringify = nativeJSON.stringify;\n\t      exports.parse = nativeJSON.parse;\n\t    }\n\t\n\t    // Convenience aliases.\n\t    var objectProto = Object.prototype,\n\t        getClass = objectProto.toString,\n\t        isProperty, forEach, undef;\n\t\n\t    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n\t    var isExtended = new Date(-3509827334573292);\n\t    try {\n\t      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n\t      // results for certain dates in Opera >= 10.53.\n\t      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n\t        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n\t        // but clips the values returned by the date methods to the range of\n\t        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n\t        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n\t    } catch (exception) {}\n\t\n\t    // Internal: Determines whether the native `JSON.stringify` and `parse`\n\t    // implementations are spec-compliant. Based on work by Ken Snyder.\n\t    function has(name) {\n\t      if (has[name] !== undef) {\n\t        // Return cached feature test result.\n\t        return has[name];\n\t      }\n\t      var isSupported;\n\t      if (name == \"bug-string-char-index\") {\n\t        // IE <= 7 doesn't support accessing string characters using square\n\t        // bracket notation. IE 8 only supports this for primitives.\n\t        isSupported = \"a\"[0] != \"a\";\n\t      } else if (name == \"json\") {\n\t        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n\t        // supported.\n\t        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n\t      } else {\n\t        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n\t        // Test `JSON.stringify`.\n\t        if (name == \"json-stringify\") {\n\t          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n\t          if (stringifySupported) {\n\t            // A test function object with a custom `toJSON` method.\n\t            (value = function () {\n\t              return 1;\n\t            }).toJSON = value;\n\t            try {\n\t              stringifySupported =\n\t                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n\t                // primitives as object literals.\n\t                stringify(0) === \"0\" &&\n\t                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n\t                // literals.\n\t                stringify(new Number()) === \"0\" &&\n\t                stringify(new String()) == '\"\"' &&\n\t                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n\t                // does not define a canonical JSON representation (this applies to\n\t                // objects with `toJSON` properties as well, *unless* they are nested\n\t                // within an object or array).\n\t                stringify(getClass) === undef &&\n\t                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n\t                // FF 3.1b3 pass this test.\n\t                stringify(undef) === undef &&\n\t                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n\t                // respectively, if the value is omitted entirely.\n\t                stringify() === undef &&\n\t                // FF 3.1b1, 2 throw an error if the given value is not a number,\n\t                // string, array, object, Boolean, or `null` literal. This applies to\n\t                // objects with custom `toJSON` methods as well, unless they are nested\n\t                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n\t                // methods entirely.\n\t                stringify(value) === \"1\" &&\n\t                stringify([value]) == \"[1]\" &&\n\t                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n\t                // `\"[null]\"`.\n\t                stringify([undef]) == \"[null]\" &&\n\t                // YUI 3.0.0b1 fails to serialize `null` literals.\n\t                stringify(null) == \"null\" &&\n\t                // FF 3.1b1, 2 halts serialization if an array contains a function:\n\t                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n\t                // elides non-JSON values from objects and arrays, unless they\n\t                // define custom `toJSON` methods.\n\t                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n\t                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n\t                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n\t                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n\t                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n\t                stringify(null, value) === \"1\" &&\n\t                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n\t                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n\t                // serialize extended years.\n\t                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n\t                // The milliseconds are optional in ES 5, but required in 5.1.\n\t                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n\t                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n\t                // four-digit years instead of six-digit years. Credits: @Yaffle.\n\t                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n\t                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n\t                // values less than 1000. Credits: @Yaffle.\n\t                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n\t            } catch (exception) {\n\t              stringifySupported = false;\n\t            }\n\t          }\n\t          isSupported = stringifySupported;\n\t        }\n\t        // Test `JSON.parse`.\n\t        if (name == \"json-parse\") {\n\t          var parse = exports.parse;\n\t          if (typeof parse == \"function\") {\n\t            try {\n\t              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n\t              // Conforming implementations should also coerce the initial argument to\n\t              // a string prior to parsing.\n\t              if (parse(\"0\") === 0 && !parse(false)) {\n\t                // Simple parsing test.\n\t                value = parse(serialized);\n\t                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n\t                if (parseSupported) {\n\t                  try {\n\t                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n\t                    parseSupported = !parse('\"\\t\"');\n\t                  } catch (exception) {}\n\t                  if (parseSupported) {\n\t                    try {\n\t                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n\t                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n\t                      // certain octal literals.\n\t                      parseSupported = parse(\"01\") !== 1;\n\t                    } catch (exception) {}\n\t                  }\n\t                  if (parseSupported) {\n\t                    try {\n\t                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n\t                      // points. These environments, along with FF 3.1b1 and 2,\n\t                      // also allow trailing commas in JSON objects and arrays.\n\t                      parseSupported = parse(\"1.\") !== 1;\n\t                    } catch (exception) {}\n\t                  }\n\t                }\n\t              }\n\t            } catch (exception) {\n\t              parseSupported = false;\n\t            }\n\t          }\n\t          isSupported = parseSupported;\n\t        }\n\t      }\n\t      return has[name] = !!isSupported;\n\t    }\n\t\n\t    if (!has(\"json\")) {\n\t      // Common `[[Class]]` name aliases.\n\t      var functionClass = \"[object Function]\",\n\t          dateClass = \"[object Date]\",\n\t          numberClass = \"[object Number]\",\n\t          stringClass = \"[object String]\",\n\t          arrayClass = \"[object Array]\",\n\t          booleanClass = \"[object Boolean]\";\n\t\n\t      // Detect incomplete support for accessing string characters by index.\n\t      var charIndexBuggy = has(\"bug-string-char-index\");\n\t\n\t      // Define additional utility methods if the `Date` methods are buggy.\n\t      if (!isExtended) {\n\t        var floor = Math.floor;\n\t        // A mapping between the months of the year and the number of days between\n\t        // January 1st and the first of the respective month.\n\t        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n\t        // Internal: Calculates the number of days between the Unix epoch and the\n\t        // first day of the given month.\n\t        var getDay = function (year, month) {\n\t          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n\t        };\n\t      }\n\t\n\t      // Internal: Determines if a property is a direct property of the given\n\t      // object. Delegates to the native `Object#hasOwnProperty` method.\n\t      if (!(isProperty = objectProto.hasOwnProperty)) {\n\t        isProperty = function (property) {\n\t          var members = {}, constructor;\n\t          if ((members.__proto__ = null, members.__proto__ = {\n\t            // The *proto* property cannot be set multiple times in recent\n\t            // versions of Firefox and SeaMonkey.\n\t            \"toString\": 1\n\t          }, members).toString != getClass) {\n\t            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n\t            // supports the mutable *proto* property.\n\t            isProperty = function (property) {\n\t              // Capture and break the object's prototype chain (see section 8.6.2\n\t              // of the ES 5.1 spec). The parenthesized expression prevents an\n\t              // unsafe transformation by the Closure Compiler.\n\t              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n\t              // Restore the original prototype chain.\n\t              this.__proto__ = original;\n\t              return result;\n\t            };\n\t          } else {\n\t            // Capture a reference to the top-level `Object` constructor.\n\t            constructor = members.constructor;\n\t            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n\t            // other environments.\n\t            isProperty = function (property) {\n\t              var parent = (this.constructor || constructor).prototype;\n\t              return property in this && !(property in parent && this[property] === parent[property]);\n\t            };\n\t          }\n\t          members = null;\n\t          return isProperty.call(this, property);\n\t        };\n\t      }\n\t\n\t      // Internal: Normalizes the `for...in` iteration algorithm across\n\t      // environments. Each enumerated key is yielded to a `callback` function.\n\t      forEach = function (object, callback) {\n\t        var size = 0, Properties, members, property;\n\t\n\t        // Tests for bugs in the current environment's `for...in` algorithm. The\n\t        // `valueOf` property inherits the non-enumerable flag from\n\t        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n\t        (Properties = function () {\n\t          this.valueOf = 0;\n\t        }).prototype.valueOf = 0;\n\t\n\t        // Iterate over a new instance of the `Properties` class.\n\t        members = new Properties();\n\t        for (property in members) {\n\t          // Ignore all properties inherited from `Object.prototype`.\n\t          if (isProperty.call(members, property)) {\n\t            size++;\n\t          }\n\t        }\n\t        Properties = members = null;\n\t\n\t        // Normalize the iteration algorithm.\n\t        if (!size) {\n\t          // A list of non-enumerable properties inherited from `Object.prototype`.\n\t          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n\t          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n\t          // properties.\n\t          forEach = function (object, callback) {\n\t            var isFunction = getClass.call(object) == functionClass, property, length;\n\t            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n\t            for (property in object) {\n\t              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n\t              // certain conditions; IE does not.\n\t              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n\t                callback(property);\n\t              }\n\t            }\n\t            // Manually invoke the callback for each non-enumerable property.\n\t            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n\t          };\n\t        } else if (size == 2) {\n\t          // Safari <= 2.0.4 enumerates shadowed properties twice.\n\t          forEach = function (object, callback) {\n\t            // Create a set of iterated properties.\n\t            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n\t            for (property in object) {\n\t              // Store each property name to prevent double enumeration. The\n\t              // `prototype` property of functions is not enumerated due to cross-\n\t              // environment inconsistencies.\n\t              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n\t                callback(property);\n\t              }\n\t            }\n\t          };\n\t        } else {\n\t          // No bugs detected; use the standard `for...in` algorithm.\n\t          forEach = function (object, callback) {\n\t            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n\t            for (property in object) {\n\t              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n\t                callback(property);\n\t              }\n\t            }\n\t            // Manually invoke the callback for the `constructor` property due to\n\t            // cross-environment inconsistencies.\n\t            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n\t              callback(property);\n\t            }\n\t          };\n\t        }\n\t        return forEach(object, callback);\n\t      };\n\t\n\t      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n\t      // `filter` argument may specify either a function that alters how object and\n\t      // array members are serialized, or an array of strings and numbers that\n\t      // indicates which properties should be serialized. The optional `width`\n\t      // argument may be either a string or number that specifies the indentation\n\t      // level of the output.\n\t      if (!has(\"json-stringify\")) {\n\t        // Internal: A map of control characters and their escaped equivalents.\n\t        var Escapes = {\n\t          92: \"\\\\\\\\\",\n\t          34: '\\\\\"',\n\t          8: \"\\\\b\",\n\t          12: \"\\\\f\",\n\t          10: \"\\\\n\",\n\t          13: \"\\\\r\",\n\t          9: \"\\\\t\"\n\t        };\n\t\n\t        // Internal: Converts `value` into a zero-padded string such that its\n\t        // length is at least equal to `width`. The `width` must be <= 6.\n\t        var leadingZeroes = \"000000\";\n\t        var toPaddedString = function (width, value) {\n\t          // The `|| 0` expression is necessary to work around a bug in\n\t          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n\t          return (leadingZeroes + (value || 0)).slice(-width);\n\t        };\n\t\n\t        // Internal: Double-quotes a string `value`, replacing all ASCII control\n\t        // characters (characters with code unit values between 0 and 31) with\n\t        // their escaped equivalents. This is an implementation of the\n\t        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n\t        var unicodePrefix = \"\\\\u00\";\n\t        var quote = function (value) {\n\t          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n\t          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n\t          for (; index < length; index++) {\n\t            var charCode = value.charCodeAt(index);\n\t            // If the character is a control character, append its Unicode or\n\t            // shorthand escape sequence; otherwise, append the character as-is.\n\t            switch (charCode) {\n\t              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n\t                result += Escapes[charCode];\n\t                break;\n\t              default:\n\t                if (charCode < 32) {\n\t                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n\t                  break;\n\t                }\n\t                result += useCharIndex ? symbols[index] : value.charAt(index);\n\t            }\n\t          }\n\t          return result + '\"';\n\t        };\n\t\n\t        // Internal: Recursively serializes an object. Implements the\n\t        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n\t        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n\t          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n\t          try {\n\t            // Necessary for host object support.\n\t            value = object[property];\n\t          } catch (exception) {}\n\t          if (typeof value == \"object\" && value) {\n\t            className = getClass.call(value);\n\t            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n\t              if (value > -1 / 0 && value < 1 / 0) {\n\t                // Dates are serialized according to the `Date#toJSON` method\n\t                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n\t                // for the ISO 8601 date time string format.\n\t                if (getDay) {\n\t                  // Manually compute the year, month, date, hours, minutes,\n\t                  // seconds, and milliseconds if the `getUTC*` methods are\n\t                  // buggy. Adapted from @Yaffle's `date-shim` project.\n\t                  date = floor(value / 864e5);\n\t                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n\t                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n\t                  date = 1 + date - getDay(year, month);\n\t                  // The `time` value specifies the time within the day (see ES\n\t                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n\t                  // to compute `A modulo B`, as the `%` operator does not\n\t                  // correspond to the `modulo` operation for negative numbers.\n\t                  time = (value % 864e5 + 864e5) % 864e5;\n\t                  // The hours, minutes, seconds, and milliseconds are obtained by\n\t                  // decomposing the time within the day. See section 15.9.1.10.\n\t                  hours = floor(time / 36e5) % 24;\n\t                  minutes = floor(time / 6e4) % 60;\n\t                  seconds = floor(time / 1e3) % 60;\n\t                  milliseconds = time % 1e3;\n\t                } else {\n\t                  year = value.getUTCFullYear();\n\t                  month = value.getUTCMonth();\n\t                  date = value.getUTCDate();\n\t                  hours = value.getUTCHours();\n\t                  minutes = value.getUTCMinutes();\n\t                  seconds = value.getUTCSeconds();\n\t                  milliseconds = value.getUTCMilliseconds();\n\t                }\n\t                // Serialize extended years correctly.\n\t                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n\t                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n\t                  // Months, dates, hours, minutes, and seconds should have two\n\t                  // digits; milliseconds should have three.\n\t                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n\t                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n\t                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n\t              } else {\n\t                value = null;\n\t              }\n\t            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n\t              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n\t              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n\t              // ignores all `toJSON` methods on these objects unless they are\n\t              // defined directly on an instance.\n\t              value = value.toJSON(property);\n\t            }\n\t          }\n\t          if (callback) {\n\t            // If a replacement function was provided, call it to obtain the value\n\t            // for serialization.\n\t            value = callback.call(object, property, value);\n\t          }\n\t          if (value === null) {\n\t            return \"null\";\n\t          }\n\t          className = getClass.call(value);\n\t          if (className == booleanClass) {\n\t            // Booleans are represented literally.\n\t            return \"\" + value;\n\t          } else if (className == numberClass) {\n\t            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n\t            // `\"null\"`.\n\t            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n\t          } else if (className == stringClass) {\n\t            // Strings are double-quoted and escaped.\n\t            return quote(\"\" + value);\n\t          }\n\t          // Recursively serialize objects and arrays.\n\t          if (typeof value == \"object\") {\n\t            // Check for cyclic structures. This is a linear search; performance\n\t            // is inversely proportional to the number of unique nested objects.\n\t            for (length = stack.length; length--;) {\n\t              if (stack[length] === value) {\n\t                // Cyclic structures cannot be serialized by `JSON.stringify`.\n\t                throw TypeError();\n\t              }\n\t            }\n\t            // Add the object to the stack of traversed objects.\n\t            stack.push(value);\n\t            results = [];\n\t            // Save the current indentation level and indent one additional level.\n\t            prefix = indentation;\n\t            indentation += whitespace;\n\t            if (className == arrayClass) {\n\t              // Recursively serialize array elements.\n\t              for (index = 0, length = value.length; index < length; index++) {\n\t                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n\t                results.push(element === undef ? \"null\" : element);\n\t              }\n\t              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n\t            } else {\n\t              // Recursively serialize object members. Members are selected from\n\t              // either a user-specified list of property names, or the object\n\t              // itself.\n\t              forEach(properties || value, function (property) {\n\t                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n\t                if (element !== undef) {\n\t                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n\t                  // is not the empty string, let `member` {quote(property) + \":\"}\n\t                  // be the concatenation of `member` and the `space` character.\"\n\t                  // The \"`space` character\" refers to the literal space\n\t                  // character, not the `space` {width} argument provided to\n\t                  // `JSON.stringify`.\n\t                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n\t                }\n\t              });\n\t              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n\t            }\n\t            // Remove the object from the traversed object stack.\n\t            stack.pop();\n\t            return result;\n\t          }\n\t        };\n\t\n\t        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n\t        exports.stringify = function (source, filter, width) {\n\t          var whitespace, callback, properties, className;\n\t          if (objectTypes[typeof filter] && filter) {\n\t            if ((className = getClass.call(filter)) == functionClass) {\n\t              callback = filter;\n\t            } else if (className == arrayClass) {\n\t              // Convert the property names array into a makeshift set.\n\t              properties = {};\n\t              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n\t            }\n\t          }\n\t          if (width) {\n\t            if ((className = getClass.call(width)) == numberClass) {\n\t              // Convert the `width` to an integer and create a string containing\n\t              // `width` number of space characters.\n\t              if ((width -= width % 1) > 0) {\n\t                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n\t              }\n\t            } else if (className == stringClass) {\n\t              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n\t            }\n\t          }\n\t          // Opera <= 7.54u2 discards the values associated with empty string keys\n\t          // (`\"\"`) only if they are used directly within an object member list\n\t          // (e.g., `!(\"\" in { \"\": 1})`).\n\t          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n\t        };\n\t      }\n\t\n\t      // Public: Parses a JSON source string.\n\t      if (!has(\"json-parse\")) {\n\t        var fromCharCode = String.fromCharCode;\n\t\n\t        // Internal: A map of escaped control characters and their unescaped\n\t        // equivalents.\n\t        var Unescapes = {\n\t          92: \"\\\\\",\n\t          34: '\"',\n\t          47: \"/\",\n\t          98: \"\\b\",\n\t          116: \"\\t\",\n\t          110: \"\\n\",\n\t          102: \"\\f\",\n\t          114: \"\\r\"\n\t        };\n\t\n\t        // Internal: Stores the parser state.\n\t        var Index, Source;\n\t\n\t        // Internal: Resets the parser state and throws a `SyntaxError`.\n\t        var abort = function () {\n\t          Index = Source = null;\n\t          throw SyntaxError();\n\t        };\n\t\n\t        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n\t        // the end of the source string. A token may be a string, number, `null`\n\t        // literal, or Boolean literal.\n\t        var lex = function () {\n\t          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n\t          while (Index < length) {\n\t            charCode = source.charCodeAt(Index);\n\t            switch (charCode) {\n\t              case 9: case 10: case 13: case 32:\n\t                // Skip whitespace tokens, including tabs, carriage returns, line\n\t                // feeds, and space characters.\n\t                Index++;\n\t                break;\n\t              case 123: case 125: case 91: case 93: case 58: case 44:\n\t                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n\t                // the current position.\n\t                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n\t                Index++;\n\t                return value;\n\t              case 34:\n\t                // `\"` delimits a JSON string; advance to the next character and\n\t                // begin parsing the string. String tokens are prefixed with the\n\t                // sentinel `@` character to distinguish them from punctuators and\n\t                // end-of-string tokens.\n\t                for (value = \"@\", Index++; Index < length;) {\n\t                  charCode = source.charCodeAt(Index);\n\t                  if (charCode < 32) {\n\t                    // Unescaped ASCII control characters (those with a code unit\n\t                    // less than the space character) are not permitted.\n\t                    abort();\n\t                  } else if (charCode == 92) {\n\t                    // A reverse solidus (`\\`) marks the beginning of an escaped\n\t                    // control character (including `\"`, `\\`, and `/`) or Unicode\n\t                    // escape sequence.\n\t                    charCode = source.charCodeAt(++Index);\n\t                    switch (charCode) {\n\t                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n\t                        // Revive escaped control characters.\n\t                        value += Unescapes[charCode];\n\t                        Index++;\n\t                        break;\n\t                      case 117:\n\t                        // `\\u` marks the beginning of a Unicode escape sequence.\n\t                        // Advance to the first character and validate the\n\t                        // four-digit code point.\n\t                        begin = ++Index;\n\t                        for (position = Index + 4; Index < position; Index++) {\n\t                          charCode = source.charCodeAt(Index);\n\t                          // A valid sequence comprises four hexdigits (case-\n\t                          // insensitive) that form a single hexadecimal value.\n\t                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n\t                            // Invalid Unicode escape sequence.\n\t                            abort();\n\t                          }\n\t                        }\n\t                        // Revive the escaped character.\n\t                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n\t                        break;\n\t                      default:\n\t                        // Invalid escape sequence.\n\t                        abort();\n\t                    }\n\t                  } else {\n\t                    if (charCode == 34) {\n\t                      // An unescaped double-quote character marks the end of the\n\t                      // string.\n\t                      break;\n\t                    }\n\t                    charCode = source.charCodeAt(Index);\n\t                    begin = Index;\n\t                    // Optimize for the common case where a string is valid.\n\t                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n\t                      charCode = source.charCodeAt(++Index);\n\t                    }\n\t                    // Append the string as-is.\n\t                    value += source.slice(begin, Index);\n\t                  }\n\t                }\n\t                if (source.charCodeAt(Index) == 34) {\n\t                  // Advance to the next character and return the revived string.\n\t                  Index++;\n\t                  return value;\n\t                }\n\t                // Unterminated string.\n\t                abort();\n\t              default:\n\t                // Parse numbers and literals.\n\t                begin = Index;\n\t                // Advance past the negative sign, if one is specified.\n\t                if (charCode == 45) {\n\t                  isSigned = true;\n\t                  charCode = source.charCodeAt(++Index);\n\t                }\n\t                // Parse an integer or floating-point value.\n\t                if (charCode >= 48 && charCode <= 57) {\n\t                  // Leading zeroes are interpreted as octal literals.\n\t                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n\t                    // Illegal octal literal.\n\t                    abort();\n\t                  }\n\t                  isSigned = false;\n\t                  // Parse the integer component.\n\t                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n\t                  // Floats cannot contain a leading decimal point; however, this\n\t                  // case is already accounted for by the parser.\n\t                  if (source.charCodeAt(Index) == 46) {\n\t                    position = ++Index;\n\t                    // Parse the decimal component.\n\t                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n\t                    if (position == Index) {\n\t                      // Illegal trailing decimal.\n\t                      abort();\n\t                    }\n\t                    Index = position;\n\t                  }\n\t                  // Parse exponents. The `e` denoting the exponent is\n\t                  // case-insensitive.\n\t                  charCode = source.charCodeAt(Index);\n\t                  if (charCode == 101 || charCode == 69) {\n\t                    charCode = source.charCodeAt(++Index);\n\t                    // Skip past the sign following the exponent, if one is\n\t                    // specified.\n\t                    if (charCode == 43 || charCode == 45) {\n\t                      Index++;\n\t                    }\n\t                    // Parse the exponential component.\n\t                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n\t                    if (position == Index) {\n\t                      // Illegal empty exponent.\n\t                      abort();\n\t                    }\n\t                    Index = position;\n\t                  }\n\t                  // Coerce the parsed value to a JavaScript number.\n\t                  return +source.slice(begin, Index);\n\t                }\n\t                // A negative sign may only precede numbers.\n\t                if (isSigned) {\n\t                  abort();\n\t                }\n\t                // `true`, `false`, and `null` literals.\n\t                if (source.slice(Index, Index + 4) == \"true\") {\n\t                  Index += 4;\n\t                  return true;\n\t                } else if (source.slice(Index, Index + 5) == \"false\") {\n\t                  Index += 5;\n\t                  return false;\n\t                } else if (source.slice(Index, Index + 4) == \"null\") {\n\t                  Index += 4;\n\t                  return null;\n\t                }\n\t                // Unrecognized token.\n\t                abort();\n\t            }\n\t          }\n\t          // Return the sentinel `$` character if the parser has reached the end\n\t          // of the source string.\n\t          return \"$\";\n\t        };\n\t\n\t        // Internal: Parses a JSON `value` token.\n\t        var get = function (value) {\n\t          var results, hasMembers;\n\t          if (value == \"$\") {\n\t            // Unexpected end of input.\n\t            abort();\n\t          }\n\t          if (typeof value == \"string\") {\n\t            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n\t              // Remove the sentinel `@` character.\n\t              return value.slice(1);\n\t            }\n\t            // Parse object and array literals.\n\t            if (value == \"[\") {\n\t              // Parses a JSON array, returning a new JavaScript array.\n\t              results = [];\n\t              for (;; hasMembers || (hasMembers = true)) {\n\t                value = lex();\n\t                // A closing square bracket marks the end of the array literal.\n\t                if (value == \"]\") {\n\t                  break;\n\t                }\n\t                // If the array literal contains elements, the current token\n\t                // should be a comma separating the previous element from the\n\t                // next.\n\t                if (hasMembers) {\n\t                  if (value == \",\") {\n\t                    value = lex();\n\t                    if (value == \"]\") {\n\t                      // Unexpected trailing `,` in array literal.\n\t                      abort();\n\t                    }\n\t                  } else {\n\t                    // A `,` must separate each array element.\n\t                    abort();\n\t                  }\n\t                }\n\t                // Elisions and leading commas are not permitted.\n\t                if (value == \",\") {\n\t                  abort();\n\t                }\n\t                results.push(get(value));\n\t              }\n\t              return results;\n\t            } else if (value == \"{\") {\n\t              // Parses a JSON object, returning a new JavaScript object.\n\t              results = {};\n\t              for (;; hasMembers || (hasMembers = true)) {\n\t                value = lex();\n\t                // A closing curly brace marks the end of the object literal.\n\t                if (value == \"}\") {\n\t                  break;\n\t                }\n\t                // If the object literal contains members, the current token\n\t                // should be a comma separator.\n\t                if (hasMembers) {\n\t                  if (value == \",\") {\n\t                    value = lex();\n\t                    if (value == \"}\") {\n\t                      // Unexpected trailing `,` in object literal.\n\t                      abort();\n\t                    }\n\t                  } else {\n\t                    // A `,` must separate each object member.\n\t                    abort();\n\t                  }\n\t                }\n\t                // Leading commas are not permitted, object property names must be\n\t                // double-quoted strings, and a `:` must separate each property\n\t                // name and value.\n\t                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n\t                  abort();\n\t                }\n\t                results[value.slice(1)] = get(lex());\n\t              }\n\t              return results;\n\t            }\n\t            // Unexpected token encountered.\n\t            abort();\n\t          }\n\t          return value;\n\t        };\n\t\n\t        // Internal: Updates a traversed object member.\n\t        var update = function (source, property, callback) {\n\t          var element = walk(source, property, callback);\n\t          if (element === undef) {\n\t            delete source[property];\n\t          } else {\n\t            source[property] = element;\n\t          }\n\t        };\n\t\n\t        // Internal: Recursively traverses a parsed JSON object, invoking the\n\t        // `callback` function for each value. This is an implementation of the\n\t        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n\t        var walk = function (source, property, callback) {\n\t          var value = source[property], length;\n\t          if (typeof value == \"object\" && value) {\n\t            // `forEach` can't be used to traverse an array in Opera <= 8.54\n\t            // because its `Object#hasOwnProperty` implementation returns `false`\n\t            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n\t            if (getClass.call(value) == arrayClass) {\n\t              for (length = value.length; length--;) {\n\t                update(value, length, callback);\n\t              }\n\t            } else {\n\t              forEach(value, function (property) {\n\t                update(value, property, callback);\n\t              });\n\t            }\n\t          }\n\t          return callback.call(source, property, value);\n\t        };\n\t\n\t        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n\t        exports.parse = function (source, callback) {\n\t          var result, value;\n\t          Index = 0;\n\t          Source = \"\" + source;\n\t          result = get(lex());\n\t          // If a JSON string contains multiple tokens, it is invalid.\n\t          if (lex() != \"$\") {\n\t            abort();\n\t          }\n\t          // Reset the parser state.\n\t          Index = Source = null;\n\t          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n\t        };\n\t      }\n\t    }\n\t\n\t    exports[\"runInContext\"] = runInContext;\n\t    return exports;\n\t  }\n\t\n\t  if (freeExports && !isLoader) {\n\t    // Export for CommonJS environments.\n\t    runInContext(root, freeExports);\n\t  } else {\n\t    // Export for web browsers and JavaScript engines.\n\t    var nativeJSON = root.JSON,\n\t        previousJSON = root[\"JSON3\"],\n\t        isRestored = false;\n\t\n\t    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n\t      // Public: Restores the original value of the global `JSON` object and\n\t      // returns a reference to the `JSON3` object.\n\t      \"noConflict\": function () {\n\t        if (!isRestored) {\n\t          isRestored = true;\n\t          root.JSON = nativeJSON;\n\t          root[\"JSON3\"] = previousJSON;\n\t          nativeJSON = previousJSON = null;\n\t        }\n\t        return JSON3;\n\t      }\n\t    }));\n\t\n\t    root.JSON = {\n\t      \"parse\": JSON3.parse,\n\t      \"stringify\": JSON3.stringify\n\t    };\n\t  }\n\t\n\t  // Export for asynchronous module loaders.\n\t  if (isLoader) {\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t      return JSON3;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t}).call(this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(44)(module), (function() { return this; }())))\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\n\t\tif(!module.webpackPolyfill) {\n\t\t\tmodule.deprecate = function() {};\n\t\t\tmodule.paths = [];\n\t\t\t// module.parent = undefined by default\n\t\t\tmodule.children = [];\n\t\t\tmodule.webpackPolyfill = 1;\n\t\t}\n\t\treturn module;\n\t}\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\tmodule.exports = '1.0.3';\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tvar eventUtils = __webpack_require__(11)\n\t  , JSON3 = __webpack_require__(43)\n\t  , browser = __webpack_require__(35)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:utils:iframe');\n\t}\n\t\n\tmodule.exports = {\n\t  WPrefix: '_jp'\n\t, currentWindowId: null\n\t\n\t, polluteGlobalNamespace: function() {\n\t    if (!(module.exports.WPrefix in global)) {\n\t      global[module.exports.WPrefix] = {};\n\t    }\n\t  }\n\t\n\t, postMessage: function(type, data) {\n\t    if (global.parent !== global) {\n\t      global.parent.postMessage(JSON3.stringify({\n\t        windowId: module.exports.currentWindowId\n\t      , type: type\n\t      , data: data || ''\n\t      }), '*');\n\t    } else {\n\t      debug('Cannot postMessage, no parent window.', type, data);\n\t    }\n\t  }\n\t\n\t, createIframe: function(iframeUrl, errorCallback) {\n\t    var iframe = global.document.createElement('iframe');\n\t    var tref, unloadRef;\n\t    var unattach = function() {\n\t      debug('unattach');\n\t      clearTimeout(tref);\n\t      // Explorer had problems with that.\n\t      try {\n\t        iframe.onload = null;\n\t      } catch (x) {}\n\t      iframe.onerror = null;\n\t    };\n\t    var cleanup = function() {\n\t      debug('cleanup');\n\t      if (iframe) {\n\t        unattach();\n\t        // This timeout makes chrome fire onbeforeunload event\n\t        // within iframe. Without the timeout it goes straight to\n\t        // onunload.\n\t        setTimeout(function() {\n\t          if (iframe) {\n\t            iframe.parentNode.removeChild(iframe);\n\t          }\n\t          iframe = null;\n\t        }, 0);\n\t        eventUtils.unloadDel(unloadRef);\n\t      }\n\t    };\n\t    var onerror = function(err) {\n\t      debug('onerror', err);\n\t      if (iframe) {\n\t        cleanup();\n\t        errorCallback(err);\n\t      }\n\t    };\n\t    var post = function(msg, origin) {\n\t      debug('post', msg, origin);\n\t      try {\n\t        // When the iframe is not loaded, IE raises an exception\n\t        // on 'contentWindow'.\n\t        setTimeout(function() {\n\t          if (iframe && iframe.contentWindow) {\n\t            iframe.contentWindow.postMessage(msg, origin);\n\t          }\n\t        }, 0);\n\t      } catch (x) {}\n\t    };\n\t\n\t    iframe.src = iframeUrl;\n\t    iframe.style.display = 'none';\n\t    iframe.style.position = 'absolute';\n\t    iframe.onerror = function() {\n\t      onerror('onerror');\n\t    };\n\t    iframe.onload = function() {\n\t      debug('onload');\n\t      // `onload` is triggered before scripts on the iframe are\n\t      // executed. Give it few seconds to actually load stuff.\n\t      clearTimeout(tref);\n\t      tref = setTimeout(function() {\n\t        onerror('onload timeout');\n\t      }, 2000);\n\t    };\n\t    global.document.body.appendChild(iframe);\n\t    tref = setTimeout(function() {\n\t      onerror('timeout');\n\t    }, 15000);\n\t    unloadRef = eventUtils.unloadAdd(cleanup);\n\t    return {\n\t      post: post\n\t    , cleanup: cleanup\n\t    , loaded: unattach\n\t    };\n\t  }\n\t\n\t/* jshint undef: false, newcap: false */\n\t/* eslint no-undef: 0, new-cap: 0 */\n\t, createHtmlfile: function(iframeUrl, errorCallback) {\n\t    var axo = ['Active'].concat('Object').join('X');\n\t    var doc = new global[axo]('htmlfile');\n\t    var tref, unloadRef;\n\t    var iframe;\n\t    var unattach = function() {\n\t      clearTimeout(tref);\n\t      iframe.onerror = null;\n\t    };\n\t    var cleanup = function() {\n\t      if (doc) {\n\t        unattach();\n\t        eventUtils.unloadDel(unloadRef);\n\t        iframe.parentNode.removeChild(iframe);\n\t        iframe = doc = null;\n\t        CollectGarbage();\n\t      }\n\t    };\n\t    var onerror = function(r)  {\n\t      debug('onerror', r);\n\t      if (doc) {\n\t        cleanup();\n\t        errorCallback(r);\n\t      }\n\t    };\n\t    var post = function(msg, origin) {\n\t      try {\n\t        // When the iframe is not loaded, IE raises an exception\n\t        // on 'contentWindow'.\n\t        setTimeout(function() {\n\t          if (iframe && iframe.contentWindow) {\n\t              iframe.contentWindow.postMessage(msg, origin);\n\t          }\n\t        }, 0);\n\t      } catch (x) {}\n\t    };\n\t\n\t    doc.open();\n\t    doc.write('<html><s' + 'cript>' +\n\t              'document.domain=\"' + global.document.domain + '\";' +\n\t              '</s' + 'cript></html>');\n\t    doc.close();\n\t    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];\n\t    var c = doc.createElement('div');\n\t    doc.body.appendChild(c);\n\t    iframe = doc.createElement('iframe');\n\t    c.appendChild(iframe);\n\t    iframe.src = iframeUrl;\n\t    iframe.onerror = function() {\n\t      onerror('onerror');\n\t    };\n\t    tref = setTimeout(function() {\n\t      onerror('timeout');\n\t    }, 15000);\n\t    unloadRef = eventUtils.unloadAdd(cleanup);\n\t    return {\n\t      post: post\n\t    , cleanup: cleanup\n\t    , loaded: unattach\n\t    };\n\t  }\n\t};\n\t\n\tmodule.exports.iframeEnabled = false;\n\tif (global.document) {\n\t  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n\t  // huge delay, or not at all.\n\t  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||\n\t    typeof global.postMessage === 'object') && (!browser.isKonqueror());\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), (function() { return this; }())))\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = {\n\t  isObject: function(obj) {\n\t    var type = typeof obj;\n\t    return type === 'function' || type === 'object' && !!obj;\n\t  }\n\t\n\t, extend: function(obj) {\n\t    if (!this.isObject(obj)) {\n\t      return obj;\n\t    }\n\t    var source, prop;\n\t    for (var i = 1, length = arguments.length; i < length; i++) {\n\t      source = arguments[i];\n\t      for (prop in source) {\n\t        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n\t          obj[prop] = source[prop];\n\t        }\n\t      }\n\t    }\n\t    return obj;\n\t  }\n\t};\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , HtmlfileReceiver = __webpack_require__(50)\n\t  , XHRLocalObject = __webpack_require__(34)\n\t  , AjaxBasedTransport = __webpack_require__(27)\n\t  ;\n\t\n\tfunction HtmlFileTransport(transUrl) {\n\t  if (!HtmlfileReceiver.enabled) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);\n\t}\n\t\n\tinherits(HtmlFileTransport, AjaxBasedTransport);\n\t\n\tHtmlFileTransport.enabled = function(info) {\n\t  return HtmlfileReceiver.enabled && info.sameOrigin;\n\t};\n\t\n\tHtmlFileTransport.transportName = 'htmlfile';\n\tHtmlFileTransport.roundTrips = 2;\n\t\n\tmodule.exports = HtmlFileTransport;\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , iframeUtils = __webpack_require__(47)\n\t  , urlUtils = __webpack_require__(14)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  , random = __webpack_require__(12)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:receiver:htmlfile');\n\t}\n\t\n\tfunction HtmlfileReceiver(url) {\n\t  debug(url);\n\t  EventEmitter.call(this);\n\t  var self = this;\n\t  iframeUtils.polluteGlobalNamespace();\n\t\n\t  this.id = 'a' + random.string(6);\n\t  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));\n\t\n\t  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);\n\t  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?\n\t      iframeUtils.createHtmlfile : iframeUtils.createIframe;\n\t\n\t  global[iframeUtils.WPrefix][this.id] = {\n\t    start: function() {\n\t      debug('start');\n\t      self.iframeObj.loaded();\n\t    }\n\t  , message: function(data) {\n\t      debug('message', data);\n\t      self.emit('message', data);\n\t    }\n\t  , stop: function() {\n\t      debug('stop');\n\t      self._cleanup();\n\t      self._close('network');\n\t    }\n\t  };\n\t  this.iframeObj = constructFunc(url, function() {\n\t    debug('callback');\n\t    self._cleanup();\n\t    self._close('permanent');\n\t  });\n\t}\n\t\n\tinherits(HtmlfileReceiver, EventEmitter);\n\t\n\tHtmlfileReceiver.prototype.abort = function() {\n\t  debug('abort');\n\t  this._cleanup();\n\t  this._close('user');\n\t};\n\t\n\tHtmlfileReceiver.prototype._cleanup = function() {\n\t  debug('_cleanup');\n\t  if (this.iframeObj) {\n\t    this.iframeObj.cleanup();\n\t    this.iframeObj = null;\n\t  }\n\t  delete global[iframeUtils.WPrefix][this.id];\n\t};\n\t\n\tHtmlfileReceiver.prototype._close = function(reason) {\n\t  debug('_close', reason);\n\t  this.emit('close', null, reason);\n\t  this.removeAllListeners();\n\t};\n\t\n\tHtmlfileReceiver.htmlfileEnabled = false;\n\t\n\t// obfuscate to avoid firewalls\n\tvar axo = ['Active'].concat('Object').join('X');\n\tif (axo in global) {\n\t  try {\n\t    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');\n\t  } catch (x) {}\n\t}\n\t\n\tHtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;\n\t\n\tmodule.exports = HtmlfileReceiver;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), (function() { return this; }())))\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , AjaxBasedTransport = __webpack_require__(27)\n\t  , XhrReceiver = __webpack_require__(31)\n\t  , XHRCorsObject = __webpack_require__(32)\n\t  , XHRLocalObject = __webpack_require__(34)\n\t  ;\n\t\n\tfunction XhrPollingTransport(transUrl) {\n\t  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);\n\t}\n\t\n\tinherits(XhrPollingTransport, AjaxBasedTransport);\n\t\n\tXhrPollingTransport.enabled = function(info) {\n\t  if (info.nullOrigin) {\n\t    return false;\n\t  }\n\t\n\t  if (XHRLocalObject.enabled && info.sameOrigin) {\n\t    return true;\n\t  }\n\t  return XHRCorsObject.enabled;\n\t};\n\t\n\tXhrPollingTransport.transportName = 'xhr-polling';\n\tXhrPollingTransport.roundTrips = 2; // preflight, ajax\n\t\n\tmodule.exports = XhrPollingTransport;\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , AjaxBasedTransport = __webpack_require__(27)\n\t  , XdrStreamingTransport = __webpack_require__(36)\n\t  , XhrReceiver = __webpack_require__(31)\n\t  , XDRObject = __webpack_require__(37)\n\t  ;\n\t\n\tfunction XdrPollingTransport(transUrl) {\n\t  if (!XDRObject.enabled) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);\n\t}\n\t\n\tinherits(XdrPollingTransport, AjaxBasedTransport);\n\t\n\tXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\n\tXdrPollingTransport.transportName = 'xdr-polling';\n\tXdrPollingTransport.roundTrips = 2; // preflight, ajax\n\t\n\tmodule.exports = XdrPollingTransport;\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\t// The simplest and most robust transport, using the well-know cross\n\t// domain hack - JSONP. This transport is quite inefficient - one\n\t// message could use up to one http request. But at least it works almost\n\t// everywhere.\n\t// Known limitations:\n\t//   o you will get a spinning cursor\n\t//   o for Konqueror a dumb timer is needed to detect errors\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , SenderReceiver = __webpack_require__(28)\n\t  , JsonpReceiver = __webpack_require__(54)\n\t  , jsonpSender = __webpack_require__(55)\n\t  ;\n\t\n\tfunction JsonPTransport(transUrl) {\n\t  if (!JsonPTransport.enabled()) {\n\t    throw new Error('Transport created when disabled');\n\t  }\n\t  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);\n\t}\n\t\n\tinherits(JsonPTransport, SenderReceiver);\n\t\n\tJsonPTransport.enabled = function() {\n\t  return !!global.document;\n\t};\n\t\n\tJsonPTransport.transportName = 'jsonp-polling';\n\tJsonPTransport.roundTrips = 1;\n\tJsonPTransport.needBody = true;\n\t\n\tmodule.exports = JsonPTransport;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tvar utils = __webpack_require__(47)\n\t  , random = __webpack_require__(12)\n\t  , browser = __webpack_require__(35)\n\t  , urlUtils = __webpack_require__(14)\n\t  , inherits = __webpack_require__(22)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:receiver:jsonp');\n\t}\n\t\n\tfunction JsonpReceiver(url) {\n\t  debug(url);\n\t  var self = this;\n\t  EventEmitter.call(this);\n\t\n\t  utils.polluteGlobalNamespace();\n\t\n\t  this.id = 'a' + random.string(6);\n\t  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));\n\t\n\t  global[utils.WPrefix][this.id] = this._callback.bind(this);\n\t  this._createScript(urlWithId);\n\t\n\t  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n\t  this.timeoutId = setTimeout(function() {\n\t    debug('timeout');\n\t    self._abort(new Error('JSONP script loaded abnormally (timeout)'));\n\t  }, JsonpReceiver.timeout);\n\t}\n\t\n\tinherits(JsonpReceiver, EventEmitter);\n\t\n\tJsonpReceiver.prototype.abort = function() {\n\t  debug('abort');\n\t  if (global[utils.WPrefix][this.id]) {\n\t    var err = new Error('JSONP user aborted read');\n\t    err.code = 1000;\n\t    this._abort(err);\n\t  }\n\t};\n\t\n\tJsonpReceiver.timeout = 35000;\n\tJsonpReceiver.scriptErrorTimeout = 1000;\n\t\n\tJsonpReceiver.prototype._callback = function(data) {\n\t  debug('_callback', data);\n\t  this._cleanup();\n\t\n\t  if (this.aborting) {\n\t    return;\n\t  }\n\t\n\t  if (data) {\n\t    debug('message', data);\n\t    this.emit('message', data);\n\t  }\n\t  this.emit('close', null, 'network');\n\t  this.removeAllListeners();\n\t};\n\t\n\tJsonpReceiver.prototype._abort = function(err) {\n\t  debug('_abort', err);\n\t  this._cleanup();\n\t  this.aborting = true;\n\t  this.emit('close', err.code, err.message);\n\t  this.removeAllListeners();\n\t};\n\t\n\tJsonpReceiver.prototype._cleanup = function() {\n\t  debug('_cleanup');\n\t  clearTimeout(this.timeoutId);\n\t  if (this.script2) {\n\t    this.script2.parentNode.removeChild(this.script2);\n\t    this.script2 = null;\n\t  }\n\t  if (this.script) {\n\t    var script = this.script;\n\t    // Unfortunately, you can't really abort script loading of\n\t    // the script.\n\t    script.parentNode.removeChild(script);\n\t    script.onreadystatechange = script.onerror =\n\t        script.onload = script.onclick = null;\n\t    this.script = null;\n\t  }\n\t  delete global[utils.WPrefix][this.id];\n\t};\n\t\n\tJsonpReceiver.prototype._scriptError = function() {\n\t  debug('_scriptError');\n\t  var self = this;\n\t  if (this.errorTimer) {\n\t    return;\n\t  }\n\t\n\t  this.errorTimer = setTimeout(function() {\n\t    if (!self.loadedOkay) {\n\t      self._abort(new Error('JSONP script loaded abnormally (onerror)'));\n\t    }\n\t  }, JsonpReceiver.scriptErrorTimeout);\n\t};\n\t\n\tJsonpReceiver.prototype._createScript = function(url) {\n\t  debug('_createScript', url);\n\t  var self = this;\n\t  var script = this.script = global.document.createElement('script');\n\t  var script2;  // Opera synchronous load trick.\n\t\n\t  script.id = 'a' + random.string(8);\n\t  script.src = url;\n\t  script.type = 'text/javascript';\n\t  script.charset = 'UTF-8';\n\t  script.onerror = this._scriptError.bind(this);\n\t  script.onload = function() {\n\t    debug('onload');\n\t    self._abort(new Error('JSONP script loaded abnormally (onload)'));\n\t  };\n\t\n\t  // IE9 fires 'error' event after onreadystatechange or before, in random order.\n\t  // Use loadedOkay to determine if actually errored\n\t  script.onreadystatechange = function() {\n\t    debug('onreadystatechange', script.readyState);\n\t    if (/loaded|closed/.test(script.readyState)) {\n\t      if (script && script.htmlFor && script.onclick) {\n\t        self.loadedOkay = true;\n\t        try {\n\t          // In IE, actually execute the script.\n\t          script.onclick();\n\t        } catch (x) {}\n\t      }\n\t      if (script) {\n\t        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));\n\t      }\n\t    }\n\t  };\n\t  // IE: event/htmlFor/onclick trick.\n\t  // One can't rely on proper order for onreadystatechange. In order to\n\t  // make sure, set a 'htmlFor' and 'event' properties, so that\n\t  // script code will be installed as 'onclick' handler for the\n\t  // script object. Later, onreadystatechange, manually execute this\n\t  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n\t  // set. For reference see:\n\t  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n\t  // Also, read on that about script ordering:\n\t  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n\t  if (typeof script.async === 'undefined' && global.document.attachEvent) {\n\t    // According to mozilla docs, in recent browsers script.async defaults\n\t    // to 'true', so we may use it to detect a good browser:\n\t    // https://developer.mozilla.org/en/HTML/Element/script\n\t    if (!browser.isOpera()) {\n\t      // Naively assume we're in IE\n\t      try {\n\t        script.htmlFor = script.id;\n\t        script.event = 'onclick';\n\t      } catch (x) {}\n\t      script.async = true;\n\t    } else {\n\t      // Opera, second sync script hack\n\t      script2 = this.script2 = global.document.createElement('script');\n\t      script2.text = \"try{var a = document.getElementById('\" + script.id + \"'); if(a)a.onerror();}catch(x){};\";\n\t      script.async = script2.async = false;\n\t    }\n\t  }\n\t  if (typeof script.async !== 'undefined') {\n\t    script.async = true;\n\t  }\n\t\n\t  var head = global.document.getElementsByTagName('head')[0];\n\t  head.insertBefore(script, head.firstChild);\n\t  if (script2) {\n\t    head.insertBefore(script2, head.firstChild);\n\t  }\n\t};\n\t\n\tmodule.exports = JsonpReceiver;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), (function() { return this; }())))\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tvar random = __webpack_require__(12)\n\t  , urlUtils = __webpack_require__(14)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:sender:jsonp');\n\t}\n\t\n\tvar form, area;\n\t\n\tfunction createIframe(id) {\n\t  debug('createIframe', id);\n\t  try {\n\t    // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n\t    return global.document.createElement('<iframe name=\"' + id + '\">');\n\t  } catch (x) {\n\t    var iframe = global.document.createElement('iframe');\n\t    iframe.name = id;\n\t    return iframe;\n\t  }\n\t}\n\t\n\tfunction createForm() {\n\t  debug('createForm');\n\t  form = global.document.createElement('form');\n\t  form.style.display = 'none';\n\t  form.style.position = 'absolute';\n\t  form.method = 'POST';\n\t  form.enctype = 'application/x-www-form-urlencoded';\n\t  form.acceptCharset = 'UTF-8';\n\t\n\t  area = global.document.createElement('textarea');\n\t  area.name = 'd';\n\t  form.appendChild(area);\n\t\n\t  global.document.body.appendChild(form);\n\t}\n\t\n\tmodule.exports = function(url, payload, callback) {\n\t  debug(url, payload);\n\t  if (!form) {\n\t    createForm();\n\t  }\n\t  var id = 'a' + random.string(8);\n\t  form.target = id;\n\t  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);\n\t\n\t  var iframe = createIframe(id);\n\t  iframe.id = id;\n\t  iframe.style.display = 'none';\n\t  form.appendChild(iframe);\n\t\n\t  try {\n\t    area.value = payload;\n\t  } catch (e) {\n\t    // seriously broken browsers get here\n\t  }\n\t  form.submit();\n\t\n\t  var completed = function(err) {\n\t    debug('completed', id, err);\n\t    if (!iframe.onerror) {\n\t      return;\n\t    }\n\t    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\n\t    // Opera mini doesn't like if we GC iframe\n\t    // immediately, thus this timeout.\n\t    setTimeout(function() {\n\t      debug('cleaning up', id);\n\t      iframe.parentNode.removeChild(iframe);\n\t      iframe = null;\n\t    }, 500);\n\t    area.value = '';\n\t    // It is not possible to detect if the iframe succeeded or\n\t    // failed to submit our form.\n\t    callback(err);\n\t  };\n\t  iframe.onerror = function() {\n\t    debug('onerror', id);\n\t    completed();\n\t  };\n\t  iframe.onload = function() {\n\t    debug('onload', id);\n\t    completed();\n\t  };\n\t  iframe.onreadystatechange = function(e) {\n\t    debug('onreadystatechange', id, iframe.readyState, e);\n\t    if (iframe.readyState === 'complete') {\n\t      completed();\n\t    }\n\t  };\n\t  return function() {\n\t    debug('aborted', id);\n\t    completed(new Error('Aborted'));\n\t  };\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), (function() { return this; }())))\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\t__webpack_require__(57);\n\t\n\tvar URL = __webpack_require__(15)\n\t  , inherits = __webpack_require__(22)\n\t  , JSON3 = __webpack_require__(43)\n\t  , random = __webpack_require__(12)\n\t  , escape = __webpack_require__(58)\n\t  , urlUtils = __webpack_require__(14)\n\t  , eventUtils = __webpack_require__(11)\n\t  , transport = __webpack_require__(59)\n\t  , objectUtils = __webpack_require__(48)\n\t  , browser = __webpack_require__(35)\n\t  , log = __webpack_require__(60)\n\t  , Event = __webpack_require__(61)\n\t  , EventTarget = __webpack_require__(24)\n\t  , loc = __webpack_require__(62)\n\t  , CloseEvent = __webpack_require__(63)\n\t  , TransportMessageEvent = __webpack_require__(64)\n\t  , InfoReceiver = __webpack_require__(65)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  // Make debug module available globally so you can enable via the console easily\n\t  global.dbg = __webpack_require__(19);\n\t  debug = global.dbg('sockjs-client:main');\n\t}\n\t\n\tvar transports;\n\t\n\t// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface\n\tfunction SockJS(url, protocols, options) {\n\t  if (!(this instanceof SockJS)) {\n\t    return new SockJS(url, protocols, options);\n\t  }\n\t  if (arguments.length < 1) {\n\t    throw new TypeError(\"Failed to construct 'SockJS: 1 argument required, but only 0 present\");\n\t  }\n\t  EventTarget.call(this);\n\t\n\t  this.readyState = SockJS.CONNECTING;\n\t  this.extensions = '';\n\t  this.protocol = '';\n\t\n\t  // non-standard extension\n\t  options = options || {};\n\t  if (options.protocols_whitelist) {\n\t    log.warn(\"'protocols_whitelist' is DEPRECATED. Use 'transports' instead.\");\n\t  }\n\t  this._transportsWhitelist = options.transports;\n\t\n\t  var sessionId = options.sessionId || 8;\n\t  if (typeof sessionId === 'function') {\n\t    this._generateSessionId = sessionId;\n\t  } else if (typeof sessionId === 'number') {\n\t    this._generateSessionId = function() {\n\t      return random.string(sessionId);\n\t    };\n\t  } else {\n\t    throw new TypeError(\"If sessionId is used in the options, it needs to be a number or a function.\");\n\t  }\n\t\n\t  this._server = options.server || random.numberString(1000);\n\t\n\t  // Step 1 of WS spec - parse and validate the url. Issue #8\n\t  var parsedUrl = new URL(url);\n\t  if (!parsedUrl.host || !parsedUrl.protocol) {\n\t    throw new SyntaxError(\"The URL '\" + url + \"' is invalid\");\n\t  } else if (parsedUrl.hash) {\n\t    throw new SyntaxError('The URL must not contain a fragment');\n\t  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\n\t    throw new SyntaxError(\"The URL's scheme must be either 'http:' or 'https:'. '\" + parsedUrl.protocol + \"' is not allowed.\");\n\t  }\n\t\n\t  var secure = parsedUrl.protocol === 'https:';\n\t  // Step 2 - don't allow secure origin with an insecure protocol\n\t  if (loc.protocol === 'https' && !secure) {\n\t    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');\n\t  }\n\t\n\t  // Step 3 - check port access - no need here\n\t  // Step 4 - parse protocols argument\n\t  if (!protocols) {\n\t    protocols = [];\n\t  } else if (!Array.isArray(protocols)) {\n\t    protocols = [protocols];\n\t  }\n\t\n\t  // Step 5 - check protocols argument\n\t  var sortedProtocols = protocols.sort();\n\t  sortedProtocols.forEach(function(proto, i) {\n\t    if (!proto) {\n\t      throw new SyntaxError(\"The protocols entry '\" + proto + \"' is invalid.\");\n\t    }\n\t    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {\n\t      throw new SyntaxError(\"The protocols entry '\" + proto + \"' is duplicated.\");\n\t    }\n\t  });\n\t\n\t  // Step 6 - convert origin\n\t  var o = urlUtils.getOrigin(loc.href);\n\t  this._origin = o ? o.toLowerCase() : null;\n\t\n\t  // remove the trailing slash\n\t  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\\/+$/, ''));\n\t\n\t  // store the sanitized url\n\t  this.url = parsedUrl.href;\n\t  debug('using url', this.url);\n\t\n\t  // Step 7 - start connection in background\n\t  // obtain server info\n\t  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26\n\t  this._urlInfo = {\n\t    nullOrigin: !browser.hasDomain()\n\t  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)\n\t  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)\n\t  };\n\t\n\t  this._ir = new InfoReceiver(this.url, this._urlInfo);\n\t  this._ir.once('finish', this._receiveInfo.bind(this));\n\t}\n\t\n\tinherits(SockJS, EventTarget);\n\t\n\tfunction userSetCode(code) {\n\t  return code === 1000 || (code >= 3000 && code <= 4999);\n\t}\n\t\n\tSockJS.prototype.close = function(code, reason) {\n\t  // Step 1\n\t  if (code && !userSetCode(code)) {\n\t    throw new Error('InvalidAccessError: Invalid code');\n\t  }\n\t  // Step 2.4 states the max is 123 bytes, but we are just checking length\n\t  if (reason && reason.length > 123) {\n\t    throw new SyntaxError('reason argument has an invalid length');\n\t  }\n\t\n\t  // Step 3.1\n\t  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {\n\t    return;\n\t  }\n\t\n\t  // TODO look at docs to determine how to set this\n\t  var wasClean = true;\n\t  this._close(code || 1000, reason || 'Normal closure', wasClean);\n\t};\n\t\n\tSockJS.prototype.send = function(data) {\n\t  // #13 - convert anything non-string to string\n\t  // TODO this currently turns objects into [object Object]\n\t  if (typeof data !== 'string') {\n\t    data = '' + data;\n\t  }\n\t  if (this.readyState === SockJS.CONNECTING) {\n\t    throw new Error('InvalidStateError: The connection has not been established yet');\n\t  }\n\t  if (this.readyState !== SockJS.OPEN) {\n\t    return;\n\t  }\n\t  this._transport.send(escape.quote(data));\n\t};\n\t\n\tSockJS.version = __webpack_require__(46);\n\t\n\tSockJS.CONNECTING = 0;\n\tSockJS.OPEN = 1;\n\tSockJS.CLOSING = 2;\n\tSockJS.CLOSED = 3;\n\t\n\tSockJS.prototype._receiveInfo = function(info, rtt) {\n\t  debug('_receiveInfo', rtt);\n\t  this._ir = null;\n\t  if (!info) {\n\t    this._close(1002, 'Cannot connect to server');\n\t    return;\n\t  }\n\t\n\t  // establish a round-trip timeout (RTO) based on the\n\t  // round-trip time (RTT)\n\t  this._rto = this.countRTO(rtt);\n\t  // allow server to override url used for the actual transport\n\t  this._transUrl = info.base_url ? info.base_url : this.url;\n\t  info = objectUtils.extend(info, this._urlInfo);\n\t  debug('info', info);\n\t  // determine list of desired and supported transports\n\t  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);\n\t  this._transports = enabledTransports.main;\n\t  debug(this._transports.length + ' enabled transports');\n\t\n\t  this._connect();\n\t};\n\t\n\tSockJS.prototype._connect = function() {\n\t  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {\n\t    debug('attempt', Transport.transportName);\n\t    if (Transport.needBody) {\n\t      if (!global.document.body ||\n\t          (typeof global.document.readyState !== 'undefined' &&\n\t            global.document.readyState !== 'complete' &&\n\t            global.document.readyState !== 'interactive')) {\n\t        debug('waiting for body');\n\t        this._transports.unshift(Transport);\n\t        eventUtils.attachEvent('load', this._connect.bind(this));\n\t        return;\n\t      }\n\t    }\n\t\n\t    // calculate timeout based on RTO and round trips. Default to 5s\n\t    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;\n\t    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);\n\t    debug('using timeout', timeoutMs);\n\t\n\t    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());\n\t    debug('transport url', transportUrl);\n\t    var transportObj = new Transport(transportUrl, this._transUrl);\n\t    transportObj.on('message', this._transportMessage.bind(this));\n\t    transportObj.once('close', this._transportClose.bind(this));\n\t    transportObj.transportName = Transport.transportName;\n\t    this._transport = transportObj;\n\t\n\t    return;\n\t  }\n\t  this._close(2000, 'All transports failed', false);\n\t};\n\t\n\tSockJS.prototype._transportTimeout = function() {\n\t  debug('_transportTimeout');\n\t  if (this.readyState === SockJS.CONNECTING) {\n\t    this._transportClose(2007, 'Transport timed out');\n\t  }\n\t};\n\t\n\tSockJS.prototype._transportMessage = function(msg) {\n\t  debug('_transportMessage', msg);\n\t  var self = this\n\t    , type = msg.slice(0, 1)\n\t    , content = msg.slice(1)\n\t    , payload\n\t    ;\n\t\n\t  // first check for messages that don't need a payload\n\t  switch (type) {\n\t    case 'o':\n\t      this._open();\n\t      return;\n\t    case 'h':\n\t      this.dispatchEvent(new Event('heartbeat'));\n\t      debug('heartbeat', this.transport);\n\t      return;\n\t  }\n\t\n\t  if (content) {\n\t    try {\n\t      payload = JSON3.parse(content);\n\t    } catch (e) {\n\t      debug('bad json', content);\n\t    }\n\t  }\n\t\n\t  if (typeof payload === 'undefined') {\n\t    debug('empty payload', content);\n\t    return;\n\t  }\n\t\n\t  switch (type) {\n\t    case 'a':\n\t      if (Array.isArray(payload)) {\n\t        payload.forEach(function(p) {\n\t          debug('message', self.transport, p);\n\t          self.dispatchEvent(new TransportMessageEvent(p));\n\t        });\n\t      }\n\t      break;\n\t    case 'm':\n\t      debug('message', this.transport, payload);\n\t      this.dispatchEvent(new TransportMessageEvent(payload));\n\t      break;\n\t    case 'c':\n\t      if (Array.isArray(payload) && payload.length === 2) {\n\t        this._close(payload[0], payload[1], true);\n\t      }\n\t      break;\n\t  }\n\t};\n\t\n\tSockJS.prototype._transportClose = function(code, reason) {\n\t  debug('_transportClose', this.transport, code, reason);\n\t  if (this._transport) {\n\t    this._transport.removeAllListeners();\n\t    this._transport = null;\n\t    this.transport = null;\n\t  }\n\t\n\t  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {\n\t    this._connect();\n\t    return;\n\t  }\n\t\n\t  this._close(code, reason);\n\t};\n\t\n\tSockJS.prototype._open = function() {\n\t  debug('_open', this._transport.transportName, this.readyState);\n\t  if (this.readyState === SockJS.CONNECTING) {\n\t    if (this._transportTimeoutId) {\n\t      clearTimeout(this._transportTimeoutId);\n\t      this._transportTimeoutId = null;\n\t    }\n\t    this.readyState = SockJS.OPEN;\n\t    this.transport = this._transport.transportName;\n\t    this.dispatchEvent(new Event('open'));\n\t    debug('connected', this.transport);\n\t  } else {\n\t    // The server might have been restarted, and lost track of our\n\t    // connection.\n\t    this._close(1006, 'Server lost session');\n\t  }\n\t};\n\t\n\tSockJS.prototype._close = function(code, reason, wasClean) {\n\t  debug('_close', this.transport, code, reason, wasClean, this.readyState);\n\t  var forceFail = false;\n\t\n\t  if (this._ir) {\n\t    forceFail = true;\n\t    this._ir.close();\n\t    this._ir = null;\n\t  }\n\t  if (this._transport) {\n\t    this._transport.close();\n\t    this._transport = null;\n\t    this.transport = null;\n\t  }\n\t\n\t  if (this.readyState === SockJS.CLOSED) {\n\t    throw new Error('InvalidStateError: SockJS has already been closed');\n\t  }\n\t\n\t  this.readyState = SockJS.CLOSING;\n\t  setTimeout(function() {\n\t    this.readyState = SockJS.CLOSED;\n\t\n\t    if (forceFail) {\n\t      this.dispatchEvent(new Event('error'));\n\t    }\n\t\n\t    var e = new CloseEvent('close');\n\t    e.wasClean = wasClean || false;\n\t    e.code = code || 1000;\n\t    e.reason = reason;\n\t\n\t    this.dispatchEvent(e);\n\t    this.onmessage = this.onclose = this.onerror = null;\n\t    debug('disconnected');\n\t  }.bind(this), 0);\n\t};\n\t\n\t// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n\t// and RFC 2988.\n\tSockJS.prototype.countRTO = function(rtt) {\n\t  // In a local environment, when using IE8/9 and the `jsonp-polling`\n\t  // transport the time needed to establish a connection (the time that pass\n\t  // from the opening of the transport to the call of `_dispatchOpen`) is\n\t  // around 200msec (the lower bound used in the article above) and this\n\t  // causes spurious timeouts. For this reason we calculate a value slightly\n\t  // larger than that used in the article.\n\t  if (rtt > 100) {\n\t    return 4 * rtt; // rto > 400msec\n\t  }\n\t  return 300 + rtt; // 300msec < rto <= 400msec\n\t};\n\t\n\tmodule.exports = function(availableTransports) {\n\t  transports = transport(availableTransports);\n\t  __webpack_require__(70)(SockJS, availableTransports);\n\t  return SockJS;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), (function() { return this; }())))\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t/* eslint-disable */\n\t/* jscs: disable */\n\t'use strict';\n\t\n\t// pulled specific shims from https://github.com/es-shims/es5-shim\n\t\n\tvar ArrayPrototype = Array.prototype;\n\tvar ObjectPrototype = Object.prototype;\n\tvar FunctionPrototype = Function.prototype;\n\tvar StringPrototype = String.prototype;\n\tvar array_slice = ArrayPrototype.slice;\n\t\n\tvar _toString = ObjectPrototype.toString;\n\tvar isFunction = function (val) {\n\t    return ObjectPrototype.toString.call(val) === '[object Function]';\n\t};\n\tvar isArray = function isArray(obj) {\n\t    return _toString.call(obj) === '[object Array]';\n\t};\n\tvar isString = function isString(obj) {\n\t    return _toString.call(obj) === '[object String]';\n\t};\n\t\n\tvar supportsDescriptors = Object.defineProperty && (function () {\n\t    try {\n\t        Object.defineProperty({}, 'x', {});\n\t        return true;\n\t    } catch (e) { /* this is ES3 */\n\t        return false;\n\t    }\n\t}());\n\t\n\t// Define configurable, writable and non-enumerable props\n\t// if they don't exist.\n\tvar defineProperty;\n\tif (supportsDescriptors) {\n\t    defineProperty = function (object, name, method, forceAssign) {\n\t        if (!forceAssign && (name in object)) { return; }\n\t        Object.defineProperty(object, name, {\n\t            configurable: true,\n\t            enumerable: false,\n\t            writable: true,\n\t            value: method\n\t        });\n\t    };\n\t} else {\n\t    defineProperty = function (object, name, method, forceAssign) {\n\t        if (!forceAssign && (name in object)) { return; }\n\t        object[name] = method;\n\t    };\n\t}\n\tvar defineProperties = function (object, map, forceAssign) {\n\t    for (var name in map) {\n\t        if (ObjectPrototype.hasOwnProperty.call(map, name)) {\n\t          defineProperty(object, name, map[name], forceAssign);\n\t        }\n\t    }\n\t};\n\t\n\tvar toObject = function (o) {\n\t    if (o == null) { // this matches both null and undefined\n\t        throw new TypeError(\"can't convert \" + o + ' to object');\n\t    }\n\t    return Object(o);\n\t};\n\t\n\t//\n\t// Util\n\t// ======\n\t//\n\t\n\t// ES5 9.4\n\t// http://es5.github.com/#x9.4\n\t// http://jsperf.com/to-integer\n\t\n\tfunction toInteger(num) {\n\t    var n = +num;\n\t    if (n !== n) { // isNaN\n\t        n = 0;\n\t    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n\t        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n\t    }\n\t    return n;\n\t}\n\t\n\tfunction ToUint32(x) {\n\t    return x >>> 0;\n\t}\n\t\n\t//\n\t// Function\n\t// ========\n\t//\n\t\n\t// ES-5 15.3.4.5\n\t// http://es5.github.com/#x15.3.4.5\n\t\n\tfunction Empty() {}\n\t\n\tdefineProperties(FunctionPrototype, {\n\t    bind: function bind(that) { // .length is 1\n\t        // 1. Let Target be the this value.\n\t        var target = this;\n\t        // 2. If IsCallable(Target) is false, throw a TypeError exception.\n\t        if (!isFunction(target)) {\n\t            throw new TypeError('Function.prototype.bind called on incompatible ' + target);\n\t        }\n\t        // 3. Let A be a new (possibly empty) internal list of all of the\n\t        //   argument values provided after thisArg (arg1, arg2 etc), in order.\n\t        // XXX slicedArgs will stand in for \"A\" if used\n\t        var args = array_slice.call(arguments, 1); // for normal call\n\t        // 4. Let F be a new native ECMAScript object.\n\t        // 11. Set the [[Prototype]] internal property of F to the standard\n\t        //   built-in Function prototype object as specified in 15.3.3.1.\n\t        // 12. Set the [[Call]] internal property of F as described in\n\t        //   15.3.4.5.1.\n\t        // 13. Set the [[Construct]] internal property of F as described in\n\t        //   15.3.4.5.2.\n\t        // 14. Set the [[HasInstance]] internal property of F as described in\n\t        //   15.3.4.5.3.\n\t        var binder = function () {\n\t\n\t            if (this instanceof bound) {\n\t                // 15.3.4.5.2 [[Construct]]\n\t                // When the [[Construct]] internal method of a function object,\n\t                // F that was created using the bind function is called with a\n\t                // list of arguments ExtraArgs, the following steps are taken:\n\t                // 1. Let target be the value of F's [[TargetFunction]]\n\t                //   internal property.\n\t                // 2. If target has no [[Construct]] internal method, a\n\t                //   TypeError exception is thrown.\n\t                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\n\t                //   property.\n\t                // 4. Let args be a new list containing the same values as the\n\t                //   list boundArgs in the same order followed by the same\n\t                //   values as the list ExtraArgs in the same order.\n\t                // 5. Return the result of calling the [[Construct]] internal\n\t                //   method of target providing args as the arguments.\n\t\n\t                var result = target.apply(\n\t                    this,\n\t                    args.concat(array_slice.call(arguments))\n\t                );\n\t                if (Object(result) === result) {\n\t                    return result;\n\t                }\n\t                return this;\n\t\n\t            } else {\n\t                // 15.3.4.5.1 [[Call]]\n\t                // When the [[Call]] internal method of a function object, F,\n\t                // which was created using the bind function is called with a\n\t                // this value and a list of arguments ExtraArgs, the following\n\t                // steps are taken:\n\t                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\n\t                //   property.\n\t                // 2. Let boundThis be the value of F's [[BoundThis]] internal\n\t                //   property.\n\t                // 3. Let target be the value of F's [[TargetFunction]] internal\n\t                //   property.\n\t                // 4. Let args be a new list containing the same values as the\n\t                //   list boundArgs in the same order followed by the same\n\t                //   values as the list ExtraArgs in the same order.\n\t                // 5. Return the result of calling the [[Call]] internal method\n\t                //   of target providing boundThis as the this value and\n\t                //   providing args as the arguments.\n\t\n\t                // equiv: target.call(this, ...boundArgs, ...args)\n\t                return target.apply(\n\t                    that,\n\t                    args.concat(array_slice.call(arguments))\n\t                );\n\t\n\t            }\n\t\n\t        };\n\t\n\t        // 15. If the [[Class]] internal property of Target is \"Function\", then\n\t        //     a. Let L be the length property of Target minus the length of A.\n\t        //     b. Set the length own property of F to either 0 or L, whichever is\n\t        //       larger.\n\t        // 16. Else set the length own property of F to 0.\n\t\n\t        var boundLength = Math.max(0, target.length - args.length);\n\t\n\t        // 17. Set the attributes of the length own property of F to the values\n\t        //   specified in 15.3.5.1.\n\t        var boundArgs = [];\n\t        for (var i = 0; i < boundLength; i++) {\n\t            boundArgs.push('$' + i);\n\t        }\n\t\n\t        // XXX Build a dynamic function with desired amount of arguments is the only\n\t        // way to set the length property of a function.\n\t        // In environments where Content Security Policies enabled (Chrome extensions,\n\t        // for ex.) all use of eval or Function costructor throws an exception.\n\t        // However in all of these environments Function.prototype.bind exists\n\t        // and so this code will never be executed.\n\t        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n\t\n\t        if (target.prototype) {\n\t            Empty.prototype = target.prototype;\n\t            bound.prototype = new Empty();\n\t            // Clean up dangling references.\n\t            Empty.prototype = null;\n\t        }\n\t\n\t        // TODO\n\t        // 18. Set the [[Extensible]] internal property of F to true.\n\t\n\t        // TODO\n\t        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\n\t        // 20. Call the [[DefineOwnProperty]] internal method of F with\n\t        //   arguments \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\n\t        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\n\t        //   false.\n\t        // 21. Call the [[DefineOwnProperty]] internal method of F with\n\t        //   arguments \"arguments\", PropertyDescriptor {[[Get]]: thrower,\n\t        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\n\t        //   and false.\n\t\n\t        // TODO\n\t        // NOTE Function objects created using Function.prototype.bind do not\n\t        // have a prototype property or the [[Code]], [[FormalParameters]], and\n\t        // [[Scope]] internal properties.\n\t        // XXX can't delete prototype in pure-js.\n\t\n\t        // 22. Return F.\n\t        return bound;\n\t    }\n\t});\n\t\n\t//\n\t// Array\n\t// =====\n\t//\n\t\n\t// ES5 15.4.3.2\n\t// http://es5.github.com/#x15.4.3.2\n\t// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\n\tdefineProperties(Array, { isArray: isArray });\n\t\n\t\n\tvar boxedString = Object('a');\n\tvar splitString = boxedString[0] !== 'a' || !(0 in boxedString);\n\t\n\tvar properlyBoxesContext = function properlyBoxed(method) {\n\t    // Check node 0.6.21 bug where third parameter is not boxed\n\t    var properlyBoxesNonStrict = true;\n\t    var properlyBoxesStrict = true;\n\t    if (method) {\n\t        method.call('foo', function (_, __, context) {\n\t            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }\n\t        });\n\t\n\t        method.call([1], function () {\n\t            'use strict';\n\t            properlyBoxesStrict = typeof this === 'string';\n\t        }, 'x');\n\t    }\n\t    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\n\t};\n\t\n\tdefineProperties(ArrayPrototype, {\n\t    forEach: function forEach(fun /*, thisp*/) {\n\t        var object = toObject(this),\n\t            self = splitString && isString(this) ? this.split('') : object,\n\t            thisp = arguments[1],\n\t            i = -1,\n\t            length = self.length >>> 0;\n\t\n\t        // If no callback function or if callback is not a callable function\n\t        if (!isFunction(fun)) {\n\t            throw new TypeError(); // TODO message\n\t        }\n\t\n\t        while (++i < length) {\n\t            if (i in self) {\n\t                // Invoke the callback function with call, passing arguments:\n\t                // context, property value, property key, thisArg object\n\t                // context\n\t                fun.call(thisp, self[i], i, object);\n\t            }\n\t        }\n\t    }\n\t}, !properlyBoxesContext(ArrayPrototype.forEach));\n\t\n\t// ES5 15.4.4.14\n\t// http://es5.github.com/#x15.4.4.14\n\t// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\n\tvar hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;\n\tdefineProperties(ArrayPrototype, {\n\t    indexOf: function indexOf(sought /*, fromIndex */ ) {\n\t        var self = splitString && isString(this) ? this.split('') : toObject(this),\n\t            length = self.length >>> 0;\n\t\n\t        if (!length) {\n\t            return -1;\n\t        }\n\t\n\t        var i = 0;\n\t        if (arguments.length > 1) {\n\t            i = toInteger(arguments[1]);\n\t        }\n\t\n\t        // handle negative indices\n\t        i = i >= 0 ? i : Math.max(0, length + i);\n\t        for (; i < length; i++) {\n\t            if (i in self && self[i] === sought) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t}, hasFirefox2IndexOfBug);\n\t\n\t//\n\t// String\n\t// ======\n\t//\n\t\n\t// ES5 15.5.4.14\n\t// http://es5.github.com/#x15.5.4.14\n\t\n\t// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\n\t// Many browsers do not split properly with regular expressions or they\n\t// do not perform the split correctly under obscure conditions.\n\t// See http://blog.stevenlevithan.com/archives/cross-browser-split\n\t// I've tested in many browsers and this seems to cover the deviant ones:\n\t//    'ab'.split(/(?:ab)*/) should be [\"\", \"\"], not [\"\"]\n\t//    '.'.split(/(.?)(.?)/) should be [\"\", \".\", \"\", \"\"], not [\"\", \"\"]\n\t//    'tesst'.split(/(s)*/) should be [\"t\", undefined, \"e\", \"s\", \"t\"], not\n\t//       [undefined, \"t\", undefined, \"e\", ...]\n\t//    ''.split(/.?/) should be [], not [\"\"]\n\t//    '.'.split(/()()/) should be [\".\"], not [\"\", \"\", \".\"]\n\t\n\tvar string_split = StringPrototype.split;\n\tif (\n\t    'ab'.split(/(?:ab)*/).length !== 2 ||\n\t    '.'.split(/(.?)(.?)/).length !== 4 ||\n\t    'tesst'.split(/(s)*/)[1] === 't' ||\n\t    'test'.split(/(?:)/, -1).length !== 4 ||\n\t    ''.split(/.?/).length ||\n\t    '.'.split(/()()/).length > 1\n\t) {\n\t    (function () {\n\t        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group\n\t\n\t        StringPrototype.split = function (separator, limit) {\n\t            var string = this;\n\t            if (separator === void 0 && limit === 0) {\n\t                return [];\n\t            }\n\t\n\t            // If `separator` is not a regex, use native split\n\t            if (_toString.call(separator) !== '[object RegExp]') {\n\t                return string_split.call(this, separator, limit);\n\t            }\n\t\n\t            var output = [],\n\t                flags = (separator.ignoreCase ? 'i' : '') +\n\t                        (separator.multiline  ? 'm' : '') +\n\t                        (separator.extended   ? 'x' : '') + // Proposed for ES6\n\t                        (separator.sticky     ? 'y' : ''), // Firefox 3+\n\t                lastLastIndex = 0,\n\t                // Make `global` and avoid `lastIndex` issues by working with a copy\n\t                separator2, match, lastIndex, lastLength;\n\t            separator = new RegExp(separator.source, flags + 'g');\n\t            string += ''; // Type-convert\n\t            if (!compliantExecNpcg) {\n\t                // Doesn't need flags gy, but they don't hurt\n\t                separator2 = new RegExp('^' + separator.source + '$(?!\\\\s)', flags);\n\t            }\n\t            /* Values for `limit`, per the spec:\n\t             * If undefined: 4294967295 // Math.pow(2, 32) - 1\n\t             * If 0, Infinity, or NaN: 0\n\t             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n\t             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n\t             * If other: Type-convert, then use the above rules\n\t             */\n\t            limit = limit === void 0 ?\n\t                -1 >>> 0 : // Math.pow(2, 32) - 1\n\t                ToUint32(limit);\n\t            while (match = separator.exec(string)) {\n\t                // `separator.lastIndex` is not reliable cross-browser\n\t                lastIndex = match.index + match[0].length;\n\t                if (lastIndex > lastLastIndex) {\n\t                    output.push(string.slice(lastLastIndex, match.index));\n\t                    // Fix browsers whose `exec` methods don't consistently return `undefined` for\n\t                    // nonparticipating capturing groups\n\t                    if (!compliantExecNpcg && match.length > 1) {\n\t                        match[0].replace(separator2, function () {\n\t                            for (var i = 1; i < arguments.length - 2; i++) {\n\t                                if (arguments[i] === void 0) {\n\t                                    match[i] = void 0;\n\t                                }\n\t                            }\n\t                        });\n\t                    }\n\t                    if (match.length > 1 && match.index < string.length) {\n\t                        ArrayPrototype.push.apply(output, match.slice(1));\n\t                    }\n\t                    lastLength = match[0].length;\n\t                    lastLastIndex = lastIndex;\n\t                    if (output.length >= limit) {\n\t                        break;\n\t                    }\n\t                }\n\t                if (separator.lastIndex === match.index) {\n\t                    separator.lastIndex++; // Avoid an infinite loop\n\t                }\n\t            }\n\t            if (lastLastIndex === string.length) {\n\t                if (lastLength || !separator.test('')) {\n\t                    output.push('');\n\t                }\n\t            } else {\n\t                output.push(string.slice(lastLastIndex));\n\t            }\n\t            return output.length > limit ? output.slice(0, limit) : output;\n\t        };\n\t    }());\n\t\n\t// [bugfix, chrome]\n\t// If separator is undefined, then the result array contains just one String,\n\t// which is the this value (converted to a String). If limit is not undefined,\n\t// then the output array is truncated so that it contains no more than limit\n\t// elements.\n\t// \"0\".split(undefined, 0) -> []\n\t} else if ('0'.split(void 0, 0).length) {\n\t    StringPrototype.split = function split(separator, limit) {\n\t        if (separator === void 0 && limit === 0) { return []; }\n\t        return string_split.call(this, separator, limit);\n\t    };\n\t}\n\t\n\t// ES5 15.5.4.20\n\t// whitespace from: http://es5.github.io/#x15.5.4.20\n\tvar ws = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n\t    '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028' +\n\t    '\\u2029\\uFEFF';\n\tvar zeroWidth = '\\u200b';\n\tvar wsRegexChars = '[' + ws + ']';\n\tvar trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');\n\tvar trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');\n\tvar hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());\n\tdefineProperties(StringPrototype, {\n\t    // http://blog.stevenlevithan.com/archives/faster-trim-javascript\n\t    // http://perfectionkills.com/whitespace-deviations/\n\t    trim: function trim() {\n\t        if (this === void 0 || this === null) {\n\t            throw new TypeError(\"can't convert \" + this + ' to object');\n\t        }\n\t        return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');\n\t    }\n\t}, hasTrimWhitespaceBug);\n\t\n\t// ECMA-262, 3rd B.2.3\n\t// Not an ECMAScript standard, although ECMAScript 3rd Edition has a\n\t// non-normative section suggesting uniform semantics and it should be\n\t// normalized across all browsers\n\t// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\n\tvar string_substr = StringPrototype.substr;\n\tvar hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';\n\tdefineProperties(StringPrototype, {\n\t    substr: function substr(start, length) {\n\t        return string_substr.call(\n\t            this,\n\t            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,\n\t            length\n\t        );\n\t    }\n\t}, hasNegativeSubstrBug);\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar JSON3 = __webpack_require__(43);\n\t\n\t// Some extra characters that Chrome gets wrong, and substitutes with\n\t// something else on the wire.\n\tvar extraEscapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g\n\t  , extraLookup;\n\t\n\t// This may be quite slow, so let's delay until user actually uses bad\n\t// characters.\n\tvar unrollLookup = function(escapable) {\n\t  var i;\n\t  var unrolled = {};\n\t  var c = [];\n\t  for (i = 0; i < 65536; i++) {\n\t    c.push( String.fromCharCode(i) );\n\t  }\n\t  escapable.lastIndex = 0;\n\t  c.join('').replace(escapable, function(a) {\n\t    unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n\t    return '';\n\t  });\n\t  escapable.lastIndex = 0;\n\t  return unrolled;\n\t};\n\t\n\t// Quote string, also taking care of unicode characters that browsers\n\t// often break. Especially, take care of unicode surrogates:\n\t// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\n\tmodule.exports = {\n\t  quote: function(string) {\n\t    var quoted = JSON3.stringify(string);\n\t\n\t    // In most cases this should be very fast and good enough.\n\t    extraEscapable.lastIndex = 0;\n\t    if (!extraEscapable.test(quoted)) {\n\t      return quoted;\n\t    }\n\t\n\t    if (!extraLookup) {\n\t      extraLookup = unrollLookup(extraEscapable);\n\t    }\n\t\n\t    return quoted.replace(extraEscapable, function(a) {\n\t      return extraLookup[a];\n\t    });\n\t  }\n\t};\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:utils:transport');\n\t}\n\t\n\tmodule.exports = function(availableTransports) {\n\t  return {\n\t    filterToEnabled: function(transportsWhitelist, info) {\n\t      var transports = {\n\t        main: []\n\t      , facade: []\n\t      };\n\t      if (!transportsWhitelist) {\n\t        transportsWhitelist = [];\n\t      } else if (typeof transportsWhitelist === 'string') {\n\t        transportsWhitelist = [transportsWhitelist];\n\t      }\n\t\n\t      availableTransports.forEach(function(trans) {\n\t        if (!trans) {\n\t          return;\n\t        }\n\t\n\t        if (trans.transportName === 'websocket' && info.websocket === false) {\n\t          debug('disabled from server', 'websocket');\n\t          return;\n\t        }\n\t\n\t        if (transportsWhitelist.length &&\n\t            transportsWhitelist.indexOf(trans.transportName) === -1) {\n\t          debug('not in whitelist', trans.transportName);\n\t          return;\n\t        }\n\t\n\t        if (trans.enabled(info)) {\n\t          debug('enabled', trans.transportName);\n\t          transports.main.push(trans);\n\t          if (trans.facadeTransport) {\n\t            transports.facade.push(trans.facadeTransport);\n\t          }\n\t        } else {\n\t          debug('disabled', trans.transportName);\n\t        }\n\t      });\n\t      return transports;\n\t    }\n\t  };\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar logObject = {};\n\t['log', 'debug', 'warn'].forEach(function (level) {\n\t  var levelExists = global.console && global.console[level] && global.console[level].apply;\n\t  logObject[level] = levelExists ? function () {\n\t    return global.console[level].apply(global.console, arguments);\n\t  } : (level === 'log' ? function () {} : logObject.log);\n\t});\n\t\n\tmodule.exports = logObject;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction Event(eventType) {\n\t  this.type = eventType;\n\t}\n\t\n\tEvent.prototype.initEvent = function(eventType, canBubble, cancelable) {\n\t  this.type = eventType;\n\t  this.bubbles = canBubble;\n\t  this.cancelable = cancelable;\n\t  this.timeStamp = +new Date();\n\t  return this;\n\t};\n\t\n\tEvent.prototype.stopPropagation = function() {};\n\tEvent.prototype.preventDefault  = function() {};\n\t\n\tEvent.CAPTURING_PHASE = 1;\n\tEvent.AT_TARGET       = 2;\n\tEvent.BUBBLING_PHASE  = 3;\n\t\n\tmodule.exports = Event;\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tmodule.exports = global.location || {\n\t  origin: 'http://localhost:80'\n\t, protocol: 'http'\n\t, host: 'localhost'\n\t, port: 80\n\t, href: 'http://localhost/'\n\t, hash: ''\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , Event = __webpack_require__(61)\n\t  ;\n\t\n\tfunction CloseEvent() {\n\t  Event.call(this);\n\t  this.initEvent('close', false, false);\n\t  this.wasClean = false;\n\t  this.code = 0;\n\t  this.reason = '';\n\t}\n\t\n\tinherits(CloseEvent, Event);\n\t\n\tmodule.exports = CloseEvent;\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , Event = __webpack_require__(61)\n\t  ;\n\t\n\tfunction TransportMessageEvent(data) {\n\t  Event.call(this);\n\t  this.initEvent('message', false, false);\n\t  this.data = data;\n\t}\n\t\n\tinherits(TransportMessageEvent, Event);\n\t\n\tmodule.exports = TransportMessageEvent;\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar EventEmitter = __webpack_require__(23).EventEmitter\n\t  , inherits = __webpack_require__(22)\n\t  , urlUtils = __webpack_require__(14)\n\t  , XDR = __webpack_require__(37)\n\t  , XHRCors = __webpack_require__(32)\n\t  , XHRLocal = __webpack_require__(34)\n\t  , XHRFake = __webpack_require__(66)\n\t  , InfoIframe = __webpack_require__(67)\n\t  , InfoAjax = __webpack_require__(69)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:info-receiver');\n\t}\n\t\n\tfunction InfoReceiver(baseUrl, urlInfo) {\n\t  debug(baseUrl);\n\t  var self = this;\n\t  EventEmitter.call(this);\n\t\n\t  setTimeout(function() {\n\t    self.doXhr(baseUrl, urlInfo);\n\t  }, 0);\n\t}\n\t\n\tinherits(InfoReceiver, EventEmitter);\n\t\n\t// TODO this is currently ignoring the list of available transports and the whitelist\n\t\n\tInfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {\n\t  // determine method of CORS support (if needed)\n\t  if (urlInfo.sameOrigin) {\n\t    return new InfoAjax(url, XHRLocal);\n\t  }\n\t  if (XHRCors.enabled) {\n\t    return new InfoAjax(url, XHRCors);\n\t  }\n\t  if (XDR.enabled && urlInfo.sameScheme) {\n\t    return new InfoAjax(url, XDR);\n\t  }\n\t  if (InfoIframe.enabled()) {\n\t    return new InfoIframe(baseUrl, url);\n\t  }\n\t  return new InfoAjax(url, XHRFake);\n\t};\n\t\n\tInfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {\n\t  var self = this\n\t    , url = urlUtils.addPath(baseUrl, '/info')\n\t    ;\n\t  debug('doXhr', url);\n\t\n\t  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);\n\t\n\t  this.timeoutRef = setTimeout(function() {\n\t    debug('timeout');\n\t    self._cleanup(false);\n\t    self.emit('finish');\n\t  }, InfoReceiver.timeout);\n\t\n\t  this.xo.once('finish', function(info, rtt) {\n\t    debug('finish', info, rtt);\n\t    self._cleanup(true);\n\t    self.emit('finish', info, rtt);\n\t  });\n\t};\n\t\n\tInfoReceiver.prototype._cleanup = function(wasClean) {\n\t  debug('_cleanup');\n\t  clearTimeout(this.timeoutRef);\n\t  this.timeoutRef = null;\n\t  if (!wasClean && this.xo) {\n\t    this.xo.close();\n\t  }\n\t  this.xo = null;\n\t};\n\t\n\tInfoReceiver.prototype.close = function() {\n\t  debug('close');\n\t  this.removeAllListeners();\n\t  this._cleanup(false);\n\t};\n\t\n\tInfoReceiver.timeout = 8000;\n\t\n\tmodule.exports = InfoReceiver;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar EventEmitter = __webpack_require__(23).EventEmitter\n\t  , inherits = __webpack_require__(22)\n\t  ;\n\t\n\tfunction XHRFake(/* method, url, payload, opts */) {\n\t  var self = this;\n\t  EventEmitter.call(this);\n\t\n\t  this.to = setTimeout(function() {\n\t    self.emit('finish', 200, '{}');\n\t  }, XHRFake.timeout);\n\t}\n\t\n\tinherits(XHRFake, EventEmitter);\n\t\n\tXHRFake.prototype.close = function() {\n\t  clearTimeout(this.to);\n\t};\n\t\n\tXHRFake.timeout = 2000;\n\t\n\tmodule.exports = XHRFake;\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tvar EventEmitter = __webpack_require__(23).EventEmitter\n\t  , inherits = __webpack_require__(22)\n\t  , JSON3 = __webpack_require__(43)\n\t  , utils = __webpack_require__(11)\n\t  , IframeTransport = __webpack_require__(42)\n\t  , InfoReceiverIframe = __webpack_require__(68)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:info-iframe');\n\t}\n\t\n\tfunction InfoIframe(baseUrl, url) {\n\t  var self = this;\n\t  EventEmitter.call(this);\n\t\n\t  var go = function() {\n\t    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);\n\t\n\t    ifr.once('message', function(msg) {\n\t      if (msg) {\n\t        var d;\n\t        try {\n\t          d = JSON3.parse(msg);\n\t        } catch (e) {\n\t          debug('bad json', msg);\n\t          self.emit('finish');\n\t          self.close();\n\t          return;\n\t        }\n\t\n\t        var info = d[0], rtt = d[1];\n\t        self.emit('finish', info, rtt);\n\t      }\n\t      self.close();\n\t    });\n\t\n\t    ifr.once('close', function() {\n\t      self.emit('finish');\n\t      self.close();\n\t    });\n\t  };\n\t\n\t  // TODO this seems the same as the 'needBody' from transports\n\t  if (!global.document.body) {\n\t    utils.attachEvent('load', go);\n\t  } else {\n\t    go();\n\t  }\n\t}\n\t\n\tinherits(InfoIframe, EventEmitter);\n\t\n\tInfoIframe.enabled = function() {\n\t  return IframeTransport.enabled();\n\t};\n\t\n\tInfoIframe.prototype.close = function() {\n\t  if (this.ifr) {\n\t    this.ifr.close();\n\t  }\n\t  this.removeAllListeners();\n\t  this.ifr = null;\n\t};\n\t\n\tmodule.exports = InfoIframe;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), (function() { return this; }())))\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar inherits = __webpack_require__(22)\n\t  , EventEmitter = __webpack_require__(23).EventEmitter\n\t  , JSON3 = __webpack_require__(43)\n\t  , XHRLocalObject = __webpack_require__(34)\n\t  , InfoAjax = __webpack_require__(69)\n\t  ;\n\t\n\tfunction InfoReceiverIframe(transUrl) {\n\t  var self = this;\n\t  EventEmitter.call(this);\n\t\n\t  this.ir = new InfoAjax(transUrl, XHRLocalObject);\n\t  this.ir.once('finish', function(info, rtt) {\n\t    self.ir = null;\n\t    self.emit('message', JSON3.stringify([info, rtt]));\n\t  });\n\t}\n\t\n\tinherits(InfoReceiverIframe, EventEmitter);\n\t\n\tInfoReceiverIframe.transportName = 'iframe-info-receiver';\n\t\n\tInfoReceiverIframe.prototype.close = function() {\n\t  if (this.ir) {\n\t    this.ir.close();\n\t    this.ir = null;\n\t  }\n\t  this.removeAllListeners();\n\t};\n\t\n\tmodule.exports = InfoReceiverIframe;\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar EventEmitter = __webpack_require__(23).EventEmitter\n\t  , inherits = __webpack_require__(22)\n\t  , JSON3 = __webpack_require__(43)\n\t  , objectUtils = __webpack_require__(48)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:info-ajax');\n\t}\n\t\n\tfunction InfoAjax(url, AjaxObject) {\n\t  EventEmitter.call(this);\n\t\n\t  var self = this;\n\t  var t0 = +new Date();\n\t  this.xo = new AjaxObject('GET', url);\n\t\n\t  this.xo.once('finish', function(status, text) {\n\t    var info, rtt;\n\t    if (status === 200) {\n\t      rtt = (+new Date()) - t0;\n\t      if (text) {\n\t        try {\n\t          info = JSON3.parse(text);\n\t        } catch (e) {\n\t          debug('bad json', text);\n\t        }\n\t      }\n\t\n\t      if (!objectUtils.isObject(info)) {\n\t        info = {};\n\t      }\n\t    }\n\t    self.emit('finish', info, rtt);\n\t    self.removeAllListeners();\n\t  });\n\t}\n\t\n\tinherits(InfoAjax, EventEmitter);\n\t\n\tInfoAjax.prototype.close = function() {\n\t  this.removeAllListeners();\n\t  this.xo.close();\n\t};\n\t\n\tmodule.exports = InfoAjax;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar urlUtils = __webpack_require__(14)\n\t  , eventUtils = __webpack_require__(11)\n\t  , JSON3 = __webpack_require__(43)\n\t  , FacadeJS = __webpack_require__(71)\n\t  , InfoIframeReceiver = __webpack_require__(68)\n\t  , iframeUtils = __webpack_require__(47)\n\t  , loc = __webpack_require__(62)\n\t  ;\n\t\n\tvar debug = function() {};\n\tif (process.env.NODE_ENV !== 'production') {\n\t  debug = __webpack_require__(19)('sockjs-client:iframe-bootstrap');\n\t}\n\t\n\tmodule.exports = function(SockJS, availableTransports) {\n\t  var transportMap = {};\n\t  availableTransports.forEach(function(at) {\n\t    if (at.facadeTransport) {\n\t      transportMap[at.facadeTransport.transportName] = at.facadeTransport;\n\t    }\n\t  });\n\t\n\t  // hard-coded for the info iframe\n\t  // TODO see if we can make this more dynamic\n\t  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;\n\t  var parentOrigin;\n\t\n\t  /* eslint-disable camelcase */\n\t  SockJS.bootstrap_iframe = function() {\n\t    /* eslint-enable camelcase */\n\t    var facade;\n\t    iframeUtils.currentWindowId = loc.hash.slice(1);\n\t    var onMessage = function(e) {\n\t      if (e.source !== parent) {\n\t        return;\n\t      }\n\t      if (typeof parentOrigin === 'undefined') {\n\t        parentOrigin = e.origin;\n\t      }\n\t      if (e.origin !== parentOrigin) {\n\t        return;\n\t      }\n\t\n\t      var iframeMessage;\n\t      try {\n\t        iframeMessage = JSON3.parse(e.data);\n\t      } catch (ignored) {\n\t        debug('bad json', e.data);\n\t        return;\n\t      }\n\t\n\t      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {\n\t        return;\n\t      }\n\t      switch (iframeMessage.type) {\n\t      case 's':\n\t        var p;\n\t        try {\n\t          p = JSON3.parse(iframeMessage.data);\n\t        } catch (ignored) {\n\t          debug('bad json', iframeMessage.data);\n\t          break;\n\t        }\n\t        var version = p[0];\n\t        var transport = p[1];\n\t        var transUrl = p[2];\n\t        var baseUrl = p[3];\n\t        debug(version, transport, transUrl, baseUrl);\n\t        // change this to semver logic\n\t        if (version !== SockJS.version) {\n\t          throw new Error('Incompatibile SockJS! Main site uses:' +\n\t                    ' \"' + version + '\", the iframe:' +\n\t                    ' \"' + SockJS.version + '\".');\n\t        }\n\t\n\t        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||\n\t            !urlUtils.isOriginEqual(baseUrl, loc.href)) {\n\t          throw new Error('Can\\'t connect to different domain from within an ' +\n\t                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');\n\t        }\n\t        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));\n\t        break;\n\t      case 'm':\n\t        facade._send(iframeMessage.data);\n\t        break;\n\t      case 'c':\n\t        if (facade) {\n\t          facade._close();\n\t        }\n\t        facade = null;\n\t        break;\n\t      }\n\t    };\n\t\n\t    eventUtils.attachEvent('message', onMessage);\n\t\n\t    // Start\n\t    iframeUtils.postMessage('s');\n\t  };\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar JSON3 = __webpack_require__(43)\n\t  , iframeUtils = __webpack_require__(47)\n\t  ;\n\t\n\tfunction FacadeJS(transport) {\n\t  this._transport = transport;\n\t  transport.on('message', this._transportMessage.bind(this));\n\t  transport.on('close', this._transportClose.bind(this));\n\t}\n\t\n\tFacadeJS.prototype._transportClose = function(code, reason) {\n\t  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));\n\t};\n\tFacadeJS.prototype._transportMessage = function(frame) {\n\t  iframeUtils.postMessage('t', frame);\n\t};\n\tFacadeJS.prototype._send = function(data) {\n\t  this._transport.send(data);\n\t};\n\tFacadeJS.prototype._close = function() {\n\t  this._transport.close();\n\t  this._transport.removeAllListeners();\n\t};\n\t\n\tmodule.exports = FacadeJS;\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function (root, factory) {\n\t\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(73)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t\n\t  else if (typeof module !== 'undefined') {\n\t    factory(require('ractive'), require('hammerjs'));\n\t  }\n\t\n\t  else {\n\t    factory(root.Ractive, root.Hammer);\n\t  }\n\t\n\t}(this, function (Ractive, Hammer) {\n\t\n\t  // Check the recognizers documentation.\n\t  // http://hammerjs.github.io/recognizer-tap\n\t\n\t  var defaults = {\n\t    tap: {\n\t      recognizerClass: Hammer.Tap,\n\t      options: {\n\t        time: 500\n\t      },\n\t      events: [\n\t        'tap' \n\t      ]\n\t    },\n\t    doubletap: {\n\t      recognizerClass: Hammer.Tap,\n\t      options: {\n\t        taps: 2,\n\t        event: 'doubletap'\n\t      },\n\t      recognizeWith: ['tap'],\n\t      events: [\n\t        'doubletap' \n\t      ]\n\t    },\n\t    swipe: {\n\t      recognizerClass: Hammer.Swipe,\n\t      options: {},\n\t      events: [\n\t        'swipe',\n\t        'swipeleft',\n\t        'swiperight',\n\t        'swipeup',\n\t        'swipedown' \n\t      ]\n\t    },\n\t    pan: {\n\t      recognizerClass: Hammer.Pan,\n\t      options: {\n\t        direction: Hammer.DIRECTION_HORIZONTAL\n\t      },\n\t      recognizeWith: ['swipe'],\n\t      events: [\n\t        'pan',\n\t        'panstart',\n\t        'panmove',\n\t        'panend',\n\t        'pancancel',\n\t        'panleft',\n\t        'panright',\n\t        'panup',\n\t        'pandown' \n\t      ]\n\t    },\n\t    press: {\n\t      recognizerClass: Hammer.Press,\n\t      options: {},\n\t      events: [\n\t        'press',\n\t        'pressup'\n\t      ]\n\t    },\n\t    rotate: {\n\t      recognizerClass: Hammer.Rotate,\n\t      options: {},\n\t      events: [\n\t        'rotate',\n\t        'rotatestart',\n\t        'rotatemove',\n\t        'rotateend',\n\t        'rotatecancel' \n\t      ]\n\t    },\n\t    pinch: {\n\t      recognizerClass: Hammer.Pinch,\n\t      options: {},\n\t      recognizeWith: ['rotate'],\n\t      events: [\n\t        'pinch',\n\t        'pinchstart',\n\t        'pinchmove',\n\t        'pinchend',\n\t        'pinchcancel',\n\t        'pinchin',\n\t        'pinchout' \n\t      ]\n\t    }\n\t  };\n\t\n\t  var aliases;\n\t\n\t  // bind all events using buildEvent\n\t  for (var recognizerName in defaults) {\n\t    if (!defaults.hasOwnProperty(recognizerName)) continue;\n\t    \n\t    var events = defaults[recognizerName].events;\n\t    for (var i = 0; i < events.length; i++) {\n\t      buildEvent(events[i], recognizerName, defaults[recognizerName]);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * buildEvent : buildEvent(event, recognizerName, config)\n\t   * (private) registers an event handler for buildEvent.\n\t   *\n\t   *     buildEvent('panstart', 'pan', { ... });\n\t   */\n\t\n\t  function buildEvent(eventName, recognizerName, config) {\n\t    Ractive.events[eventName] = buildEventHandler(eventName, recognizerName, config);\n\t  }\n\t\n\t  /**\n\t   * buildEventHandler() : buildEventHandler(event, recognizerName, config)\n\t   * (private) Creates the event handler for a given `eventName` that will be\n\t   * registered to `Ractive.events`.\n\t   */\n\t\n\t  function buildEventHandler(eventName, recognizerName, config) {\n\t    return function (node, fire) {\n\t      var hammerManager = getHammerManager(node);\n\t\n\t      var recognizerExists = (hammerManager.get(recognizerName) !== null);\n\t\n\t      if (!recognizerExists) {\n\t        // init with default options\n\t        var recognizer = new config.recognizerClass(config.options);\n\t\n\t        // Hammer.Recognizer.set merges it on top of the defaults supplied above\n\t        var options = parseOptions(node, recognizerName);\n\t        if (options)\n\t          recognizer.set(options);\n\t\n\t        hammerManager.add(recognizer);\n\t        \n\t        updateRecognizeWith(hammerManager);\n\t      }\n\t\n\t      // register the handler\n\t      hammerManager.on(eventName, function (e) {\n\t        fire({\n\t          node: node,\n\t          original: e\n\t        });\n\t      });\n\t\n\t      // handle exits\n\t      function teardown() {\n\t        getHammerManager(node).destroy();\n\t        delete node._hammer;\n\t      }\n\t\n\t      return { teardown: teardown };\n\t    };\n\t  }\n\t\n\t  /**\n\t   * updateRecognizeWith : updateRecognizeWith(hammerManager)\n\t   * (private) Sets recognizeWith if defaults have it\n\t   *\n\t   * Since we add recognizers dynamically and without any strict order,\n\t   *  we need to guard against trying to set a requireWith for a recognizer\n\t   *  that haven't been created yet.\n\t   * \n\t   */\n\t  function updateRecognizeWith(hammerManager) {\n\t    for (var i = 0; i < hammerManager.recognizers.length; i++) {\n\t      var recognizer = hammerManager.recognizers[i];\n\t      var recognizerName = recognizer.options.event;\n\t\n\t      if (!defaults[recognizerName].hasOwnProperty('recognizeWith')) continue;\n\t      \n\t      var recognizeWiths = defaults[recognizerName].recognizeWith;\n\t      for (var k = 0; k < recognizeWiths.length; k++) {\n\t        // Verify that the recgonizer we're trying to depend on is really there\n\t        if (!hammerManager.get(recognizeWiths[k])) continue;\n\t\n\t        // It's safe to recognizeWith multiple times for the same recognizer\n\t        recognizer.recognizeWith(recognizeWiths[k]);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * parseOptions : parseOptions(node, key)\n\t   * (private) Returns options for a given DOM node.\n\t   *\n\t   *     node = <div data-swipe-direction='left' data-swipe-threshold='2'>\n\t   *\n\t   *     parseOptions(node, 'swipe')\n\t   *     => { direction: 'left', threshold: 2 }\n\t   */\n\t\n\t  function parseOptions(node, key) {\n\t    var attrs = node.attributes,\n\t        output,\n\t        re = new RegExp(\"^(?:data-)?\"+key+\"-(.*)$\");\n\t\n\t    for (var i = attrs.length-1; i >= 0; i--) {\n\t      var attr = attrs[i],\n\t          m = attr.name.match(re);\n\t\n\t      if (!m) continue;\n\t      if (!output) output = {};\n\t      output[m[1]] = parseHammerValue(attr.value, m[1]);\n\t    }\n\t\n\t    return output;\n\t  }\n\t\n\t  /**\n\t   * parseHammerValue : parseHammerValue(str, key)\n\t   * (private) Value-izes a given string `str`, converting it to a number as\n\t   * needed. If `key` is given, it can also resolve aliases for that given\n\t   * key.\n\t   *\n\t   * Used by `getData()`. \n\t   *\n\t   *     parseHammerValue(\"100\")   => 100\n\t   *     parseHammerValue(\"right\") => \"right\"\n\t   *     parseHammerValue(\"right\", \"direction\") => Hammer.DIRECTION_RIGHT\n\t   */\n\t\n\t  function parseHammerValue(str, key) {\n\t    if (str.match && str.match(/^-?\\d+(?:\\.\\d+)?$/)) return +str;\n\t    return (aliases[key] && aliases[key][str]) ||\n\t      aliases.all[str] || str;\n\t  }\n\t\n\t  /*\n\t   * Aliases for `val()`.\n\t   */\n\t\n\t  aliases = {\n\t    all: {\n\t      'true': true,\n\t      'false': false,\n\t      'undefined': undefined,\n\t      'null': null\n\t    },\n\t    direction: {\n\t      'none': Hammer.DIRECTION_NONE,\n\t      'all': Hammer.DIRECTION_ALL,\n\t      'up': Hammer.DIRECTION_UP,\n\t      'down': Hammer.DIRECTION_DOWN,\n\t      'left': Hammer.DIRECTION_LEFT,\n\t      'right': Hammer.DIRECTION_RIGHT,\n\t      'horizontal': Hammer.DIRECTION_HORIZONTAL,\n\t      'vertical': Hammer.DIRECTION_VERTICAL\n\t    }\n\t  };\n\t\n\t  /**\n\t   * getHammerManager : getHammerManager(node)\n\t   * (private) Returns the `HammerManager` instance for the given node.\n\t   */\n\t\n\t  function getHammerManager(node) {\n\t    if (node._hammer) return node._hammer;\n\t\n\t    node._hammer = new Hammer.Manager(node, {recognizers: []});\n\t    return node._hammer;\n\t  }\n\t\n\t\n\t  return {defaults: defaults};\n\t\n\t}));\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n\t * http://hammerjs.github.io/\n\t *\n\t * Copyright (c) 2016 Jorik Tangelder;\n\t * Licensed under the MIT license */\n\t(function(window, document, exportName, undefined) {\n\t  'use strict';\n\t\n\tvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n\tvar TEST_ELEMENT = document.createElement('div');\n\t\n\tvar TYPE_FUNCTION = 'function';\n\t\n\tvar round = Math.round;\n\tvar abs = Math.abs;\n\tvar now = Date.now;\n\t\n\t/**\n\t * set a timeout with a given scope\n\t * @param {Function} fn\n\t * @param {Number} timeout\n\t * @param {Object} context\n\t * @returns {number}\n\t */\n\tfunction setTimeoutContext(fn, timeout, context) {\n\t    return setTimeout(bindFn(fn, context), timeout);\n\t}\n\t\n\t/**\n\t * if the argument is an array, we want to execute the fn on each entry\n\t * if it aint an array we don't want to do a thing.\n\t * this is used by all the methods that accept a single and array argument.\n\t * @param {*|Array} arg\n\t * @param {String} fn\n\t * @param {Object} [context]\n\t * @returns {Boolean}\n\t */\n\tfunction invokeArrayArg(arg, fn, context) {\n\t    if (Array.isArray(arg)) {\n\t        each(arg, context[fn], context);\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * walk objects and arrays\n\t * @param {Object} obj\n\t * @param {Function} iterator\n\t * @param {Object} context\n\t */\n\tfunction each(obj, iterator, context) {\n\t    var i;\n\t\n\t    if (!obj) {\n\t        return;\n\t    }\n\t\n\t    if (obj.forEach) {\n\t        obj.forEach(iterator, context);\n\t    } else if (obj.length !== undefined) {\n\t        i = 0;\n\t        while (i < obj.length) {\n\t            iterator.call(context, obj[i], i, obj);\n\t            i++;\n\t        }\n\t    } else {\n\t        for (i in obj) {\n\t            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * wrap a method with a deprecation warning and stack trace\n\t * @param {Function} method\n\t * @param {String} name\n\t * @param {String} message\n\t * @returns {Function} A new function wrapping the supplied method.\n\t */\n\tfunction deprecate(method, name, message) {\n\t    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n\t    return function() {\n\t        var e = new Error('get-stack-trace');\n\t        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n\t            .replace(/^\\s+at\\s+/gm, '')\n\t            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\t\n\t        var log = window.console && (window.console.warn || window.console.log);\n\t        if (log) {\n\t            log.call(window.console, deprecationMessage, stack);\n\t        }\n\t        return method.apply(this, arguments);\n\t    };\n\t}\n\t\n\t/**\n\t * extend object.\n\t * means that properties in dest will be overwritten by the ones in src.\n\t * @param {Object} target\n\t * @param {...Object} objects_to_assign\n\t * @returns {Object} target\n\t */\n\tvar assign;\n\tif (typeof Object.assign !== 'function') {\n\t    assign = function assign(target) {\n\t        if (target === undefined || target === null) {\n\t            throw new TypeError('Cannot convert undefined or null to object');\n\t        }\n\t\n\t        var output = Object(target);\n\t        for (var index = 1; index < arguments.length; index++) {\n\t            var source = arguments[index];\n\t            if (source !== undefined && source !== null) {\n\t                for (var nextKey in source) {\n\t                    if (source.hasOwnProperty(nextKey)) {\n\t                        output[nextKey] = source[nextKey];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return output;\n\t    };\n\t} else {\n\t    assign = Object.assign;\n\t}\n\t\n\t/**\n\t * extend object.\n\t * means that properties in dest will be overwritten by the ones in src.\n\t * @param {Object} dest\n\t * @param {Object} src\n\t * @param {Boolean} [merge=false]\n\t * @returns {Object} dest\n\t */\n\tvar extend = deprecate(function extend(dest, src, merge) {\n\t    var keys = Object.keys(src);\n\t    var i = 0;\n\t    while (i < keys.length) {\n\t        if (!merge || (merge && dest[keys[i]] === undefined)) {\n\t            dest[keys[i]] = src[keys[i]];\n\t        }\n\t        i++;\n\t    }\n\t    return dest;\n\t}, 'extend', 'Use `assign`.');\n\t\n\t/**\n\t * merge the values from src in the dest.\n\t * means that properties that exist in dest will not be overwritten by src\n\t * @param {Object} dest\n\t * @param {Object} src\n\t * @returns {Object} dest\n\t */\n\tvar merge = deprecate(function merge(dest, src) {\n\t    return extend(dest, src, true);\n\t}, 'merge', 'Use `assign`.');\n\t\n\t/**\n\t * simple class inheritance\n\t * @param {Function} child\n\t * @param {Function} base\n\t * @param {Object} [properties]\n\t */\n\tfunction inherit(child, base, properties) {\n\t    var baseP = base.prototype,\n\t        childP;\n\t\n\t    childP = child.prototype = Object.create(baseP);\n\t    childP.constructor = child;\n\t    childP._super = baseP;\n\t\n\t    if (properties) {\n\t        assign(childP, properties);\n\t    }\n\t}\n\t\n\t/**\n\t * simple function bind\n\t * @param {Function} fn\n\t * @param {Object} context\n\t * @returns {Function}\n\t */\n\tfunction bindFn(fn, context) {\n\t    return function boundFn() {\n\t        return fn.apply(context, arguments);\n\t    };\n\t}\n\t\n\t/**\n\t * let a boolean value also be a function that must return a boolean\n\t * this first item in args will be used as the context\n\t * @param {Boolean|Function} val\n\t * @param {Array} [args]\n\t * @returns {Boolean}\n\t */\n\tfunction boolOrFn(val, args) {\n\t    if (typeof val == TYPE_FUNCTION) {\n\t        return val.apply(args ? args[0] || undefined : undefined, args);\n\t    }\n\t    return val;\n\t}\n\t\n\t/**\n\t * use the val2 when val1 is undefined\n\t * @param {*} val1\n\t * @param {*} val2\n\t * @returns {*}\n\t */\n\tfunction ifUndefined(val1, val2) {\n\t    return (val1 === undefined) ? val2 : val1;\n\t}\n\t\n\t/**\n\t * addEventListener with multiple events at once\n\t * @param {EventTarget} target\n\t * @param {String} types\n\t * @param {Function} handler\n\t */\n\tfunction addEventListeners(target, types, handler) {\n\t    each(splitStr(types), function(type) {\n\t        target.addEventListener(type, handler, false);\n\t    });\n\t}\n\t\n\t/**\n\t * removeEventListener with multiple events at once\n\t * @param {EventTarget} target\n\t * @param {String} types\n\t * @param {Function} handler\n\t */\n\tfunction removeEventListeners(target, types, handler) {\n\t    each(splitStr(types), function(type) {\n\t        target.removeEventListener(type, handler, false);\n\t    });\n\t}\n\t\n\t/**\n\t * find if a node is in the given parent\n\t * @method hasParent\n\t * @param {HTMLElement} node\n\t * @param {HTMLElement} parent\n\t * @return {Boolean} found\n\t */\n\tfunction hasParent(node, parent) {\n\t    while (node) {\n\t        if (node == parent) {\n\t            return true;\n\t        }\n\t        node = node.parentNode;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * small indexOf wrapper\n\t * @param {String} str\n\t * @param {String} find\n\t * @returns {Boolean} found\n\t */\n\tfunction inStr(str, find) {\n\t    return str.indexOf(find) > -1;\n\t}\n\t\n\t/**\n\t * split string on whitespace\n\t * @param {String} str\n\t * @returns {Array} words\n\t */\n\tfunction splitStr(str) {\n\t    return str.trim().split(/\\s+/g);\n\t}\n\t\n\t/**\n\t * find if a array contains the object using indexOf or a simple polyFill\n\t * @param {Array} src\n\t * @param {String} find\n\t * @param {String} [findByKey]\n\t * @return {Boolean|Number} false when not found, or the index\n\t */\n\tfunction inArray(src, find, findByKey) {\n\t    if (src.indexOf && !findByKey) {\n\t        return src.indexOf(find);\n\t    } else {\n\t        var i = 0;\n\t        while (i < src.length) {\n\t            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n\t                return i;\n\t            }\n\t            i++;\n\t        }\n\t        return -1;\n\t    }\n\t}\n\t\n\t/**\n\t * convert array-like objects to real arrays\n\t * @param {Object} obj\n\t * @returns {Array}\n\t */\n\tfunction toArray(obj) {\n\t    return Array.prototype.slice.call(obj, 0);\n\t}\n\t\n\t/**\n\t * unique array with objects based on a key (like 'id') or just by the array's value\n\t * @param {Array} src [{id:1},{id:2},{id:1}]\n\t * @param {String} [key]\n\t * @param {Boolean} [sort=False]\n\t * @returns {Array} [{id:1},{id:2}]\n\t */\n\tfunction uniqueArray(src, key, sort) {\n\t    var results = [];\n\t    var values = [];\n\t    var i = 0;\n\t\n\t    while (i < src.length) {\n\t        var val = key ? src[i][key] : src[i];\n\t        if (inArray(values, val) < 0) {\n\t            results.push(src[i]);\n\t        }\n\t        values[i] = val;\n\t        i++;\n\t    }\n\t\n\t    if (sort) {\n\t        if (!key) {\n\t            results = results.sort();\n\t        } else {\n\t            results = results.sort(function sortUniqueArray(a, b) {\n\t                return a[key] > b[key];\n\t            });\n\t        }\n\t    }\n\t\n\t    return results;\n\t}\n\t\n\t/**\n\t * get the prefixed property\n\t * @param {Object} obj\n\t * @param {String} property\n\t * @returns {String|Undefined} prefixed\n\t */\n\tfunction prefixed(obj, property) {\n\t    var prefix, prop;\n\t    var camelProp = property[0].toUpperCase() + property.slice(1);\n\t\n\t    var i = 0;\n\t    while (i < VENDOR_PREFIXES.length) {\n\t        prefix = VENDOR_PREFIXES[i];\n\t        prop = (prefix) ? prefix + camelProp : property;\n\t\n\t        if (prop in obj) {\n\t            return prop;\n\t        }\n\t        i++;\n\t    }\n\t    return undefined;\n\t}\n\t\n\t/**\n\t * get a unique id\n\t * @returns {number} uniqueId\n\t */\n\tvar _uniqueId = 1;\n\tfunction uniqueId() {\n\t    return _uniqueId++;\n\t}\n\t\n\t/**\n\t * get the window object of an element\n\t * @param {HTMLElement} element\n\t * @returns {DocumentView|Window}\n\t */\n\tfunction getWindowForElement(element) {\n\t    var doc = element.ownerDocument || element;\n\t    return (doc.defaultView || doc.parentWindow || window);\n\t}\n\t\n\tvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\t\n\tvar SUPPORT_TOUCH = ('ontouchstart' in window);\n\tvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n\tvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\t\n\tvar INPUT_TYPE_TOUCH = 'touch';\n\tvar INPUT_TYPE_PEN = 'pen';\n\tvar INPUT_TYPE_MOUSE = 'mouse';\n\tvar INPUT_TYPE_KINECT = 'kinect';\n\t\n\tvar COMPUTE_INTERVAL = 25;\n\t\n\tvar INPUT_START = 1;\n\tvar INPUT_MOVE = 2;\n\tvar INPUT_END = 4;\n\tvar INPUT_CANCEL = 8;\n\t\n\tvar DIRECTION_NONE = 1;\n\tvar DIRECTION_LEFT = 2;\n\tvar DIRECTION_RIGHT = 4;\n\tvar DIRECTION_UP = 8;\n\tvar DIRECTION_DOWN = 16;\n\t\n\tvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n\tvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n\tvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\t\n\tvar PROPS_XY = ['x', 'y'];\n\tvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\t\n\t/**\n\t * create new input type manager\n\t * @param {Manager} manager\n\t * @param {Function} callback\n\t * @returns {Input}\n\t * @constructor\n\t */\n\tfunction Input(manager, callback) {\n\t    var self = this;\n\t    this.manager = manager;\n\t    this.callback = callback;\n\t    this.element = manager.element;\n\t    this.target = manager.options.inputTarget;\n\t\n\t    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n\t    // so when disabled the input events are completely bypassed.\n\t    this.domHandler = function(ev) {\n\t        if (boolOrFn(manager.options.enable, [manager])) {\n\t            self.handler(ev);\n\t        }\n\t    };\n\t\n\t    this.init();\n\t\n\t}\n\t\n\tInput.prototype = {\n\t    /**\n\t     * should handle the inputEvent data and trigger the callback\n\t     * @virtual\n\t     */\n\t    handler: function() { },\n\t\n\t    /**\n\t     * bind the events\n\t     */\n\t    init: function() {\n\t        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n\t        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n\t        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t    },\n\t\n\t    /**\n\t     * unbind the events\n\t     */\n\t    destroy: function() {\n\t        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n\t        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n\t        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t    }\n\t};\n\t\n\t/**\n\t * create new input type manager\n\t * called by the Manager constructor\n\t * @param {Hammer} manager\n\t * @returns {Input}\n\t */\n\tfunction createInputInstance(manager) {\n\t    var Type;\n\t    var inputClass = manager.options.inputClass;\n\t\n\t    if (inputClass) {\n\t        Type = inputClass;\n\t    } else if (SUPPORT_POINTER_EVENTS) {\n\t        Type = PointerEventInput;\n\t    } else if (SUPPORT_ONLY_TOUCH) {\n\t        Type = TouchInput;\n\t    } else if (!SUPPORT_TOUCH) {\n\t        Type = MouseInput;\n\t    } else {\n\t        Type = TouchMouseInput;\n\t    }\n\t    return new (Type)(manager, inputHandler);\n\t}\n\t\n\t/**\n\t * handle input events\n\t * @param {Manager} manager\n\t * @param {String} eventType\n\t * @param {Object} input\n\t */\n\tfunction inputHandler(manager, eventType, input) {\n\t    var pointersLen = input.pointers.length;\n\t    var changedPointersLen = input.changedPointers.length;\n\t    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n\t    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\t\n\t    input.isFirst = !!isFirst;\n\t    input.isFinal = !!isFinal;\n\t\n\t    if (isFirst) {\n\t        manager.session = {};\n\t    }\n\t\n\t    // source event is the normalized value of the domEvents\n\t    // like 'touchstart, mouseup, pointerdown'\n\t    input.eventType = eventType;\n\t\n\t    // compute scale, rotation etc\n\t    computeInputData(manager, input);\n\t\n\t    // emit secret event\n\t    manager.emit('hammer.input', input);\n\t\n\t    manager.recognize(input);\n\t    manager.session.prevInput = input;\n\t}\n\t\n\t/**\n\t * extend the data with some usable properties like scale, rotate, velocity etc\n\t * @param {Object} manager\n\t * @param {Object} input\n\t */\n\tfunction computeInputData(manager, input) {\n\t    var session = manager.session;\n\t    var pointers = input.pointers;\n\t    var pointersLength = pointers.length;\n\t\n\t    // store the first input to calculate the distance and direction\n\t    if (!session.firstInput) {\n\t        session.firstInput = simpleCloneInputData(input);\n\t    }\n\t\n\t    // to compute scale and rotation we need to store the multiple touches\n\t    if (pointersLength > 1 && !session.firstMultiple) {\n\t        session.firstMultiple = simpleCloneInputData(input);\n\t    } else if (pointersLength === 1) {\n\t        session.firstMultiple = false;\n\t    }\n\t\n\t    var firstInput = session.firstInput;\n\t    var firstMultiple = session.firstMultiple;\n\t    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\t\n\t    var center = input.center = getCenter(pointers);\n\t    input.timeStamp = now();\n\t    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\t\n\t    input.angle = getAngle(offsetCenter, center);\n\t    input.distance = getDistance(offsetCenter, center);\n\t\n\t    computeDeltaXY(session, input);\n\t    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\t\n\t    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n\t    input.overallVelocityX = overallVelocity.x;\n\t    input.overallVelocityY = overallVelocity.y;\n\t    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\t\n\t    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n\t    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\t\n\t    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n\t        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\t\n\t    computeIntervalInputData(session, input);\n\t\n\t    // find the correct target\n\t    var target = manager.element;\n\t    if (hasParent(input.srcEvent.target, target)) {\n\t        target = input.srcEvent.target;\n\t    }\n\t    input.target = target;\n\t}\n\t\n\tfunction computeDeltaXY(session, input) {\n\t    var center = input.center;\n\t    var offset = session.offsetDelta || {};\n\t    var prevDelta = session.prevDelta || {};\n\t    var prevInput = session.prevInput || {};\n\t\n\t    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n\t        prevDelta = session.prevDelta = {\n\t            x: prevInput.deltaX || 0,\n\t            y: prevInput.deltaY || 0\n\t        };\n\t\n\t        offset = session.offsetDelta = {\n\t            x: center.x,\n\t            y: center.y\n\t        };\n\t    }\n\t\n\t    input.deltaX = prevDelta.x + (center.x - offset.x);\n\t    input.deltaY = prevDelta.y + (center.y - offset.y);\n\t}\n\t\n\t/**\n\t * velocity is calculated every x ms\n\t * @param {Object} session\n\t * @param {Object} input\n\t */\n\tfunction computeIntervalInputData(session, input) {\n\t    var last = session.lastInterval || input,\n\t        deltaTime = input.timeStamp - last.timeStamp,\n\t        velocity, velocityX, velocityY, direction;\n\t\n\t    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n\t        var deltaX = input.deltaX - last.deltaX;\n\t        var deltaY = input.deltaY - last.deltaY;\n\t\n\t        var v = getVelocity(deltaTime, deltaX, deltaY);\n\t        velocityX = v.x;\n\t        velocityY = v.y;\n\t        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n\t        direction = getDirection(deltaX, deltaY);\n\t\n\t        session.lastInterval = input;\n\t    } else {\n\t        // use latest velocity info if it doesn't overtake a minimum period\n\t        velocity = last.velocity;\n\t        velocityX = last.velocityX;\n\t        velocityY = last.velocityY;\n\t        direction = last.direction;\n\t    }\n\t\n\t    input.velocity = velocity;\n\t    input.velocityX = velocityX;\n\t    input.velocityY = velocityY;\n\t    input.direction = direction;\n\t}\n\t\n\t/**\n\t * create a simple clone from the input used for storage of firstInput and firstMultiple\n\t * @param {Object} input\n\t * @returns {Object} clonedInputData\n\t */\n\tfunction simpleCloneInputData(input) {\n\t    // make a simple copy of the pointers because we will get a reference if we don't\n\t    // we only need clientXY for the calculations\n\t    var pointers = [];\n\t    var i = 0;\n\t    while (i < input.pointers.length) {\n\t        pointers[i] = {\n\t            clientX: round(input.pointers[i].clientX),\n\t            clientY: round(input.pointers[i].clientY)\n\t        };\n\t        i++;\n\t    }\n\t\n\t    return {\n\t        timeStamp: now(),\n\t        pointers: pointers,\n\t        center: getCenter(pointers),\n\t        deltaX: input.deltaX,\n\t        deltaY: input.deltaY\n\t    };\n\t}\n\t\n\t/**\n\t * get the center of all the pointers\n\t * @param {Array} pointers\n\t * @return {Object} center contains `x` and `y` properties\n\t */\n\tfunction getCenter(pointers) {\n\t    var pointersLength = pointers.length;\n\t\n\t    // no need to loop when only one touch\n\t    if (pointersLength === 1) {\n\t        return {\n\t            x: round(pointers[0].clientX),\n\t            y: round(pointers[0].clientY)\n\t        };\n\t    }\n\t\n\t    var x = 0, y = 0, i = 0;\n\t    while (i < pointersLength) {\n\t        x += pointers[i].clientX;\n\t        y += pointers[i].clientY;\n\t        i++;\n\t    }\n\t\n\t    return {\n\t        x: round(x / pointersLength),\n\t        y: round(y / pointersLength)\n\t    };\n\t}\n\t\n\t/**\n\t * calculate the velocity between two points. unit is in px per ms.\n\t * @param {Number} deltaTime\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Object} velocity `x` and `y`\n\t */\n\tfunction getVelocity(deltaTime, x, y) {\n\t    return {\n\t        x: x / deltaTime || 0,\n\t        y: y / deltaTime || 0\n\t    };\n\t}\n\t\n\t/**\n\t * get the direction between two points\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Number} direction\n\t */\n\tfunction getDirection(x, y) {\n\t    if (x === y) {\n\t        return DIRECTION_NONE;\n\t    }\n\t\n\t    if (abs(x) >= abs(y)) {\n\t        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t    }\n\t    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t}\n\t\n\t/**\n\t * calculate the absolute distance between two points\n\t * @param {Object} p1 {x, y}\n\t * @param {Object} p2 {x, y}\n\t * @param {Array} [props] containing x and y keys\n\t * @return {Number} distance\n\t */\n\tfunction getDistance(p1, p2, props) {\n\t    if (!props) {\n\t        props = PROPS_XY;\n\t    }\n\t    var x = p2[props[0]] - p1[props[0]],\n\t        y = p2[props[1]] - p1[props[1]];\n\t\n\t    return Math.sqrt((x * x) + (y * y));\n\t}\n\t\n\t/**\n\t * calculate the angle between two coordinates\n\t * @param {Object} p1\n\t * @param {Object} p2\n\t * @param {Array} [props] containing x and y keys\n\t * @return {Number} angle\n\t */\n\tfunction getAngle(p1, p2, props) {\n\t    if (!props) {\n\t        props = PROPS_XY;\n\t    }\n\t    var x = p2[props[0]] - p1[props[0]],\n\t        y = p2[props[1]] - p1[props[1]];\n\t    return Math.atan2(y, x) * 180 / Math.PI;\n\t}\n\t\n\t/**\n\t * calculate the rotation degrees between two pointersets\n\t * @param {Array} start array of pointers\n\t * @param {Array} end array of pointers\n\t * @return {Number} rotation\n\t */\n\tfunction getRotation(start, end) {\n\t    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n\t}\n\t\n\t/**\n\t * calculate the scale factor between two pointersets\n\t * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n\t * @param {Array} start array of pointers\n\t * @param {Array} end array of pointers\n\t * @return {Number} scale\n\t */\n\tfunction getScale(start, end) {\n\t    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n\t}\n\t\n\tvar MOUSE_INPUT_MAP = {\n\t    mousedown: INPUT_START,\n\t    mousemove: INPUT_MOVE,\n\t    mouseup: INPUT_END\n\t};\n\t\n\tvar MOUSE_ELEMENT_EVENTS = 'mousedown';\n\tvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\t\n\t/**\n\t * Mouse events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction MouseInput() {\n\t    this.evEl = MOUSE_ELEMENT_EVENTS;\n\t    this.evWin = MOUSE_WINDOW_EVENTS;\n\t\n\t    this.pressed = false; // mousedown state\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(MouseInput, Input, {\n\t    /**\n\t     * handle mouse events\n\t     * @param {Object} ev\n\t     */\n\t    handler: function MEhandler(ev) {\n\t        var eventType = MOUSE_INPUT_MAP[ev.type];\n\t\n\t        // on start we want to have the left mouse button down\n\t        if (eventType & INPUT_START && ev.button === 0) {\n\t            this.pressed = true;\n\t        }\n\t\n\t        if (eventType & INPUT_MOVE && ev.which !== 1) {\n\t            eventType = INPUT_END;\n\t        }\n\t\n\t        // mouse must be down\n\t        if (!this.pressed) {\n\t            return;\n\t        }\n\t\n\t        if (eventType & INPUT_END) {\n\t            this.pressed = false;\n\t        }\n\t\n\t        this.callback(this.manager, eventType, {\n\t            pointers: [ev],\n\t            changedPointers: [ev],\n\t            pointerType: INPUT_TYPE_MOUSE,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\tvar POINTER_INPUT_MAP = {\n\t    pointerdown: INPUT_START,\n\t    pointermove: INPUT_MOVE,\n\t    pointerup: INPUT_END,\n\t    pointercancel: INPUT_CANCEL,\n\t    pointerout: INPUT_CANCEL\n\t};\n\t\n\t// in IE10 the pointer types is defined as an enum\n\tvar IE10_POINTER_TYPE_ENUM = {\n\t    2: INPUT_TYPE_TOUCH,\n\t    3: INPUT_TYPE_PEN,\n\t    4: INPUT_TYPE_MOUSE,\n\t    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\t};\n\t\n\tvar POINTER_ELEMENT_EVENTS = 'pointerdown';\n\tvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\t\n\t// IE10 has prefixed support, and case-sensitive\n\tif (window.MSPointerEvent && !window.PointerEvent) {\n\t    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n\t    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n\t}\n\t\n\t/**\n\t * Pointer events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction PointerEventInput() {\n\t    this.evEl = POINTER_ELEMENT_EVENTS;\n\t    this.evWin = POINTER_WINDOW_EVENTS;\n\t\n\t    Input.apply(this, arguments);\n\t\n\t    this.store = (this.manager.session.pointerEvents = []);\n\t}\n\t\n\tinherit(PointerEventInput, Input, {\n\t    /**\n\t     * handle mouse events\n\t     * @param {Object} ev\n\t     */\n\t    handler: function PEhandler(ev) {\n\t        var store = this.store;\n\t        var removePointer = false;\n\t\n\t        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n\t        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n\t        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\t\n\t        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\t\n\t        // get index of the event in the store\n\t        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\t\n\t        // start and mouse must be down\n\t        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n\t            if (storeIndex < 0) {\n\t                store.push(ev);\n\t                storeIndex = store.length - 1;\n\t            }\n\t        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t            removePointer = true;\n\t        }\n\t\n\t        // it not found, so the pointer hasn't been down (so it's probably a hover)\n\t        if (storeIndex < 0) {\n\t            return;\n\t        }\n\t\n\t        // update the event in the store\n\t        store[storeIndex] = ev;\n\t\n\t        this.callback(this.manager, eventType, {\n\t            pointers: store,\n\t            changedPointers: [ev],\n\t            pointerType: pointerType,\n\t            srcEvent: ev\n\t        });\n\t\n\t        if (removePointer) {\n\t            // remove from the store\n\t            store.splice(storeIndex, 1);\n\t        }\n\t    }\n\t});\n\t\n\tvar SINGLE_TOUCH_INPUT_MAP = {\n\t    touchstart: INPUT_START,\n\t    touchmove: INPUT_MOVE,\n\t    touchend: INPUT_END,\n\t    touchcancel: INPUT_CANCEL\n\t};\n\t\n\tvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n\tvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t/**\n\t * Touch events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction SingleTouchInput() {\n\t    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n\t    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\t    this.started = false;\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(SingleTouchInput, Input, {\n\t    handler: function TEhandler(ev) {\n\t        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\t\n\t        // should we handle the touch events?\n\t        if (type === INPUT_START) {\n\t            this.started = true;\n\t        }\n\t\n\t        if (!this.started) {\n\t            return;\n\t        }\n\t\n\t        var touches = normalizeSingleTouches.call(this, ev, type);\n\t\n\t        // when done, reset the started state\n\t        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n\t            this.started = false;\n\t        }\n\t\n\t        this.callback(this.manager, type, {\n\t            pointers: touches[0],\n\t            changedPointers: touches[1],\n\t            pointerType: INPUT_TYPE_TOUCH,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\t/**\n\t * @this {TouchInput}\n\t * @param {Object} ev\n\t * @param {Number} type flag\n\t * @returns {undefined|Array} [all, changed]\n\t */\n\tfunction normalizeSingleTouches(ev, type) {\n\t    var all = toArray(ev.touches);\n\t    var changed = toArray(ev.changedTouches);\n\t\n\t    if (type & (INPUT_END | INPUT_CANCEL)) {\n\t        all = uniqueArray(all.concat(changed), 'identifier', true);\n\t    }\n\t\n\t    return [all, changed];\n\t}\n\t\n\tvar TOUCH_INPUT_MAP = {\n\t    touchstart: INPUT_START,\n\t    touchmove: INPUT_MOVE,\n\t    touchend: INPUT_END,\n\t    touchcancel: INPUT_CANCEL\n\t};\n\t\n\tvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t/**\n\t * Multi-user touch events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction TouchInput() {\n\t    this.evTarget = TOUCH_TARGET_EVENTS;\n\t    this.targetIds = {};\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(TouchInput, Input, {\n\t    handler: function MTEhandler(ev) {\n\t        var type = TOUCH_INPUT_MAP[ev.type];\n\t        var touches = getTouches.call(this, ev, type);\n\t        if (!touches) {\n\t            return;\n\t        }\n\t\n\t        this.callback(this.manager, type, {\n\t            pointers: touches[0],\n\t            changedPointers: touches[1],\n\t            pointerType: INPUT_TYPE_TOUCH,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\t/**\n\t * @this {TouchInput}\n\t * @param {Object} ev\n\t * @param {Number} type flag\n\t * @returns {undefined|Array} [all, changed]\n\t */\n\tfunction getTouches(ev, type) {\n\t    var allTouches = toArray(ev.touches);\n\t    var targetIds = this.targetIds;\n\t\n\t    // when there is only one touch, the process can be simplified\n\t    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n\t        targetIds[allTouches[0].identifier] = true;\n\t        return [allTouches, allTouches];\n\t    }\n\t\n\t    var i,\n\t        targetTouches,\n\t        changedTouches = toArray(ev.changedTouches),\n\t        changedTargetTouches = [],\n\t        target = this.target;\n\t\n\t    // get target touches from touches\n\t    targetTouches = allTouches.filter(function(touch) {\n\t        return hasParent(touch.target, target);\n\t    });\n\t\n\t    // collect touches\n\t    if (type === INPUT_START) {\n\t        i = 0;\n\t        while (i < targetTouches.length) {\n\t            targetIds[targetTouches[i].identifier] = true;\n\t            i++;\n\t        }\n\t    }\n\t\n\t    // filter changed touches to only contain touches that exist in the collected target ids\n\t    i = 0;\n\t    while (i < changedTouches.length) {\n\t        if (targetIds[changedTouches[i].identifier]) {\n\t            changedTargetTouches.push(changedTouches[i]);\n\t        }\n\t\n\t        // cleanup removed touches\n\t        if (type & (INPUT_END | INPUT_CANCEL)) {\n\t            delete targetIds[changedTouches[i].identifier];\n\t        }\n\t        i++;\n\t    }\n\t\n\t    if (!changedTargetTouches.length) {\n\t        return;\n\t    }\n\t\n\t    return [\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n\t        changedTargetTouches\n\t    ];\n\t}\n\t\n\t/**\n\t * Combined touch and mouse input\n\t *\n\t * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n\t * This because touch devices also emit mouse events while doing a touch.\n\t *\n\t * @constructor\n\t * @extends Input\n\t */\n\t\n\tvar DEDUP_TIMEOUT = 2500;\n\tvar DEDUP_DISTANCE = 25;\n\t\n\tfunction TouchMouseInput() {\n\t    Input.apply(this, arguments);\n\t\n\t    var handler = bindFn(this.handler, this);\n\t    this.touch = new TouchInput(this.manager, handler);\n\t    this.mouse = new MouseInput(this.manager, handler);\n\t\n\t    this.primaryTouch = null;\n\t    this.lastTouches = [];\n\t}\n\t\n\tinherit(TouchMouseInput, Input, {\n\t    /**\n\t     * handle mouse and touch events\n\t     * @param {Hammer} manager\n\t     * @param {String} inputEvent\n\t     * @param {Object} inputData\n\t     */\n\t    handler: function TMEhandler(manager, inputEvent, inputData) {\n\t        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n\t            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\t\n\t        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n\t            return;\n\t        }\n\t\n\t        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\t        if (isTouch) {\n\t            recordTouches.call(this, inputEvent, inputData);\n\t        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n\t            return;\n\t        }\n\t\n\t        this.callback(manager, inputEvent, inputData);\n\t    },\n\t\n\t    /**\n\t     * remove the event listeners\n\t     */\n\t    destroy: function destroy() {\n\t        this.touch.destroy();\n\t        this.mouse.destroy();\n\t    }\n\t});\n\t\n\tfunction recordTouches(eventType, eventData) {\n\t    if (eventType & INPUT_START) {\n\t        this.primaryTouch = eventData.changedPointers[0].identifier;\n\t        setLastTouch.call(this, eventData);\n\t    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t        setLastTouch.call(this, eventData);\n\t    }\n\t}\n\t\n\tfunction setLastTouch(eventData) {\n\t    var touch = eventData.changedPointers[0];\n\t\n\t    if (touch.identifier === this.primaryTouch) {\n\t        var lastTouch = {x: touch.clientX, y: touch.clientY};\n\t        this.lastTouches.push(lastTouch);\n\t        var lts = this.lastTouches;\n\t        var removeLastTouch = function() {\n\t            var i = lts.indexOf(lastTouch);\n\t            if (i > -1) {\n\t                lts.splice(i, 1);\n\t            }\n\t        };\n\t        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n\t    }\n\t}\n\t\n\tfunction isSyntheticEvent(eventData) {\n\t    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n\t    for (var i = 0; i < this.lastTouches.length; i++) {\n\t        var t = this.lastTouches[i];\n\t        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n\t        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\tvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n\tvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\t\n\t// magical touchAction value\n\tvar TOUCH_ACTION_COMPUTE = 'compute';\n\tvar TOUCH_ACTION_AUTO = 'auto';\n\tvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\tvar TOUCH_ACTION_NONE = 'none';\n\tvar TOUCH_ACTION_PAN_X = 'pan-x';\n\tvar TOUCH_ACTION_PAN_Y = 'pan-y';\n\tvar TOUCH_ACTION_MAP = getTouchActionProps();\n\t\n\t/**\n\t * Touch Action\n\t * sets the touchAction property or uses the js alternative\n\t * @param {Manager} manager\n\t * @param {String} value\n\t * @constructor\n\t */\n\tfunction TouchAction(manager, value) {\n\t    this.manager = manager;\n\t    this.set(value);\n\t}\n\t\n\tTouchAction.prototype = {\n\t    /**\n\t     * set the touchAction value on the element or enable the polyfill\n\t     * @param {String} value\n\t     */\n\t    set: function(value) {\n\t        // find out the touch-action by the event handlers\n\t        if (value == TOUCH_ACTION_COMPUTE) {\n\t            value = this.compute();\n\t        }\n\t\n\t        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n\t            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n\t        }\n\t        this.actions = value.toLowerCase().trim();\n\t    },\n\t\n\t    /**\n\t     * just re-set the touchAction value\n\t     */\n\t    update: function() {\n\t        this.set(this.manager.options.touchAction);\n\t    },\n\t\n\t    /**\n\t     * compute the value for the touchAction property based on the recognizer's settings\n\t     * @returns {String} value\n\t     */\n\t    compute: function() {\n\t        var actions = [];\n\t        each(this.manager.recognizers, function(recognizer) {\n\t            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n\t                actions = actions.concat(recognizer.getTouchAction());\n\t            }\n\t        });\n\t        return cleanTouchActions(actions.join(' '));\n\t    },\n\t\n\t    /**\n\t     * this method is called on each input cycle and provides the preventing of the browser behavior\n\t     * @param {Object} input\n\t     */\n\t    preventDefaults: function(input) {\n\t        var srcEvent = input.srcEvent;\n\t        var direction = input.offsetDirection;\n\t\n\t        // if the touch action did prevented once this session\n\t        if (this.manager.session.prevented) {\n\t            srcEvent.preventDefault();\n\t            return;\n\t        }\n\t\n\t        var actions = this.actions;\n\t        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\t\n\t        if (hasNone) {\n\t            //do not prevent defaults if this is a tap gesture\n\t\n\t            var isTapPointer = input.pointers.length === 1;\n\t            var isTapMovement = input.distance < 2;\n\t            var isTapTouchTime = input.deltaTime < 250;\n\t\n\t            if (isTapPointer && isTapMovement && isTapTouchTime) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        if (hasPanX && hasPanY) {\n\t            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n\t            return;\n\t        }\n\t\n\t        if (hasNone ||\n\t            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n\t            (hasPanX && direction & DIRECTION_VERTICAL)) {\n\t            return this.preventSrc(srcEvent);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n\t     * @param {Object} srcEvent\n\t     */\n\t    preventSrc: function(srcEvent) {\n\t        this.manager.session.prevented = true;\n\t        srcEvent.preventDefault();\n\t    }\n\t};\n\t\n\t/**\n\t * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n\t * @param {String} actions\n\t * @returns {*}\n\t */\n\tfunction cleanTouchActions(actions) {\n\t    // none\n\t    if (inStr(actions, TOUCH_ACTION_NONE)) {\n\t        return TOUCH_ACTION_NONE;\n\t    }\n\t\n\t    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t\n\t    // if both pan-x and pan-y are set (different recognizers\n\t    // for different directions, e.g. horizontal pan but vertical swipe?)\n\t    // we need none (as otherwise with pan-x pan-y combined none of these\n\t    // recognizers will work, since the browser would handle all panning\n\t    if (hasPanX && hasPanY) {\n\t        return TOUCH_ACTION_NONE;\n\t    }\n\t\n\t    // pan-x OR pan-y\n\t    if (hasPanX || hasPanY) {\n\t        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n\t    }\n\t\n\t    // manipulation\n\t    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n\t        return TOUCH_ACTION_MANIPULATION;\n\t    }\n\t\n\t    return TOUCH_ACTION_AUTO;\n\t}\n\t\n\tfunction getTouchActionProps() {\n\t    if (!NATIVE_TOUCH_ACTION) {\n\t        return false;\n\t    }\n\t    var touchMap = {};\n\t    var cssSupports = window.CSS && window.CSS.supports;\n\t    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\t\n\t        // If css.supports is not supported but there is native touch-action assume it supports\n\t        // all values. This is the case for IE 10 and 11.\n\t        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n\t    });\n\t    return touchMap;\n\t}\n\t\n\t/**\n\t * Recognizer flow explained; *\n\t * All recognizers have the initial state of POSSIBLE when a input session starts.\n\t * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n\t * Example session for mouse-input: mousedown -> mousemove -> mouseup\n\t *\n\t * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n\t * which determines with state it should be.\n\t *\n\t * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n\t * POSSIBLE to give it another change on the next cycle.\n\t *\n\t *               Possible\n\t *                  |\n\t *            +-----+---------------+\n\t *            |                     |\n\t *      +-----+-----+               |\n\t *      |           |               |\n\t *   Failed      Cancelled          |\n\t *                          +-------+------+\n\t *                          |              |\n\t *                      Recognized       Began\n\t *                                         |\n\t *                                      Changed\n\t *                                         |\n\t *                                  Ended/Recognized\n\t */\n\tvar STATE_POSSIBLE = 1;\n\tvar STATE_BEGAN = 2;\n\tvar STATE_CHANGED = 4;\n\tvar STATE_ENDED = 8;\n\tvar STATE_RECOGNIZED = STATE_ENDED;\n\tvar STATE_CANCELLED = 16;\n\tvar STATE_FAILED = 32;\n\t\n\t/**\n\t * Recognizer\n\t * Every recognizer needs to extend from this class.\n\t * @constructor\n\t * @param {Object} options\n\t */\n\tfunction Recognizer(options) {\n\t    this.options = assign({}, this.defaults, options || {});\n\t\n\t    this.id = uniqueId();\n\t\n\t    this.manager = null;\n\t\n\t    // default is enable true\n\t    this.options.enable = ifUndefined(this.options.enable, true);\n\t\n\t    this.state = STATE_POSSIBLE;\n\t\n\t    this.simultaneous = {};\n\t    this.requireFail = [];\n\t}\n\t\n\tRecognizer.prototype = {\n\t    /**\n\t     * @virtual\n\t     * @type {Object}\n\t     */\n\t    defaults: {},\n\t\n\t    /**\n\t     * set options\n\t     * @param {Object} options\n\t     * @return {Recognizer}\n\t     */\n\t    set: function(options) {\n\t        assign(this.options, options);\n\t\n\t        // also update the touchAction, in case something changed about the directions/enabled state\n\t        this.manager && this.manager.touchAction.update();\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * recognize simultaneous with an other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    recognizeWith: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n\t            return this;\n\t        }\n\t\n\t        var simultaneous = this.simultaneous;\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        if (!simultaneous[otherRecognizer.id]) {\n\t            simultaneous[otherRecognizer.id] = otherRecognizer;\n\t            otherRecognizer.recognizeWith(this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    dropRecognizeWith: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n\t            return this;\n\t        }\n\t\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        delete this.simultaneous[otherRecognizer.id];\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * recognizer can only run when an other is failing\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    requireFailure: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n\t            return this;\n\t        }\n\t\n\t        var requireFail = this.requireFail;\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        if (inArray(requireFail, otherRecognizer) === -1) {\n\t            requireFail.push(otherRecognizer);\n\t            otherRecognizer.requireFailure(this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * drop the requireFailure link. it does not remove the link on the other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    dropRequireFailure: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n\t            return this;\n\t        }\n\t\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        var index = inArray(this.requireFail, otherRecognizer);\n\t        if (index > -1) {\n\t            this.requireFail.splice(index, 1);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * has require failures boolean\n\t     * @returns {boolean}\n\t     */\n\t    hasRequireFailures: function() {\n\t        return this.requireFail.length > 0;\n\t    },\n\t\n\t    /**\n\t     * if the recognizer can recognize simultaneous with an other recognizer\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Boolean}\n\t     */\n\t    canRecognizeWith: function(otherRecognizer) {\n\t        return !!this.simultaneous[otherRecognizer.id];\n\t    },\n\t\n\t    /**\n\t     * You should use `tryEmit` instead of `emit` directly to check\n\t     * that all the needed recognizers has failed before emitting.\n\t     * @param {Object} input\n\t     */\n\t    emit: function(input) {\n\t        var self = this;\n\t        var state = this.state;\n\t\n\t        function emit(event) {\n\t            self.manager.emit(event, input);\n\t        }\n\t\n\t        // 'panstart' and 'panmove'\n\t        if (state < STATE_ENDED) {\n\t            emit(self.options.event + stateStr(state));\n\t        }\n\t\n\t        emit(self.options.event); // simple 'eventName' events\n\t\n\t        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n\t            emit(input.additionalEvent);\n\t        }\n\t\n\t        // panend and pancancel\n\t        if (state >= STATE_ENDED) {\n\t            emit(self.options.event + stateStr(state));\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Check that all the require failure recognizers has failed,\n\t     * if true, it emits a gesture event,\n\t     * otherwise, setup the state to FAILED.\n\t     * @param {Object} input\n\t     */\n\t    tryEmit: function(input) {\n\t        if (this.canEmit()) {\n\t            return this.emit(input);\n\t        }\n\t        // it's failing anyway\n\t        this.state = STATE_FAILED;\n\t    },\n\t\n\t    /**\n\t     * can we emit?\n\t     * @returns {boolean}\n\t     */\n\t    canEmit: function() {\n\t        var i = 0;\n\t        while (i < this.requireFail.length) {\n\t            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n\t                return false;\n\t            }\n\t            i++;\n\t        }\n\t        return true;\n\t    },\n\t\n\t    /**\n\t     * update the recognizer\n\t     * @param {Object} inputData\n\t     */\n\t    recognize: function(inputData) {\n\t        // make a new copy of the inputData\n\t        // so we can change the inputData without messing up the other recognizers\n\t        var inputDataClone = assign({}, inputData);\n\t\n\t        // is is enabled and allow recognizing?\n\t        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n\t            this.reset();\n\t            this.state = STATE_FAILED;\n\t            return;\n\t        }\n\t\n\t        // reset when we've reached the end\n\t        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n\t            this.state = STATE_POSSIBLE;\n\t        }\n\t\n\t        this.state = this.process(inputDataClone);\n\t\n\t        // the recognizer has recognized a gesture\n\t        // so trigger an event\n\t        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n\t            this.tryEmit(inputDataClone);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * return the state of the recognizer\n\t     * the actual recognizing happens in this method\n\t     * @virtual\n\t     * @param {Object} inputData\n\t     * @returns {Const} STATE\n\t     */\n\t    process: function(inputData) { }, // jshint ignore:line\n\t\n\t    /**\n\t     * return the preferred touch-action\n\t     * @virtual\n\t     * @returns {Array}\n\t     */\n\t    getTouchAction: function() { },\n\t\n\t    /**\n\t     * called when the gesture isn't allowed to recognize\n\t     * like when another is being recognized or it is disabled\n\t     * @virtual\n\t     */\n\t    reset: function() { }\n\t};\n\t\n\t/**\n\t * get a usable string, used as event postfix\n\t * @param {Const} state\n\t * @returns {String} state\n\t */\n\tfunction stateStr(state) {\n\t    if (state & STATE_CANCELLED) {\n\t        return 'cancel';\n\t    } else if (state & STATE_ENDED) {\n\t        return 'end';\n\t    } else if (state & STATE_CHANGED) {\n\t        return 'move';\n\t    } else if (state & STATE_BEGAN) {\n\t        return 'start';\n\t    }\n\t    return '';\n\t}\n\t\n\t/**\n\t * direction cons to string\n\t * @param {Const} direction\n\t * @returns {String}\n\t */\n\tfunction directionStr(direction) {\n\t    if (direction == DIRECTION_DOWN) {\n\t        return 'down';\n\t    } else if (direction == DIRECTION_UP) {\n\t        return 'up';\n\t    } else if (direction == DIRECTION_LEFT) {\n\t        return 'left';\n\t    } else if (direction == DIRECTION_RIGHT) {\n\t        return 'right';\n\t    }\n\t    return '';\n\t}\n\t\n\t/**\n\t * get a recognizer by name if it is bound to a manager\n\t * @param {Recognizer|String} otherRecognizer\n\t * @param {Recognizer} recognizer\n\t * @returns {Recognizer}\n\t */\n\tfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n\t    var manager = recognizer.manager;\n\t    if (manager) {\n\t        return manager.get(otherRecognizer);\n\t    }\n\t    return otherRecognizer;\n\t}\n\t\n\t/**\n\t * This recognizer is just used as a base for the simple attribute recognizers.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction AttrRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(AttrRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof AttrRecognizer\n\t     */\n\t    defaults: {\n\t        /**\n\t         * @type {Number}\n\t         * @default 1\n\t         */\n\t        pointers: 1\n\t    },\n\t\n\t    /**\n\t     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n\t     * @memberof AttrRecognizer\n\t     * @param {Object} input\n\t     * @returns {Boolean} recognized\n\t     */\n\t    attrTest: function(input) {\n\t        var optionPointers = this.options.pointers;\n\t        return optionPointers === 0 || input.pointers.length === optionPointers;\n\t    },\n\t\n\t    /**\n\t     * Process the input and return the state for the recognizer\n\t     * @memberof AttrRecognizer\n\t     * @param {Object} input\n\t     * @returns {*} State\n\t     */\n\t    process: function(input) {\n\t        var state = this.state;\n\t        var eventType = input.eventType;\n\t\n\t        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n\t        var isValid = this.attrTest(input);\n\t\n\t        // on cancel input and we've recognized before, return STATE_CANCELLED\n\t        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n\t            return state | STATE_CANCELLED;\n\t        } else if (isRecognized || isValid) {\n\t            if (eventType & INPUT_END) {\n\t                return state | STATE_ENDED;\n\t            } else if (!(state & STATE_BEGAN)) {\n\t                return STATE_BEGAN;\n\t            }\n\t            return state | STATE_CHANGED;\n\t        }\n\t        return STATE_FAILED;\n\t    }\n\t});\n\t\n\t/**\n\t * Pan\n\t * Recognized when the pointer is down and moved in the allowed direction.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction PanRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t\n\t    this.pX = null;\n\t    this.pY = null;\n\t}\n\t\n\tinherit(PanRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PanRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'pan',\n\t        threshold: 10,\n\t        pointers: 1,\n\t        direction: DIRECTION_ALL\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        var direction = this.options.direction;\n\t        var actions = [];\n\t        if (direction & DIRECTION_HORIZONTAL) {\n\t            actions.push(TOUCH_ACTION_PAN_Y);\n\t        }\n\t        if (direction & DIRECTION_VERTICAL) {\n\t            actions.push(TOUCH_ACTION_PAN_X);\n\t        }\n\t        return actions;\n\t    },\n\t\n\t    directionTest: function(input) {\n\t        var options = this.options;\n\t        var hasMoved = true;\n\t        var distance = input.distance;\n\t        var direction = input.direction;\n\t        var x = input.deltaX;\n\t        var y = input.deltaY;\n\t\n\t        // lock to axis?\n\t        if (!(direction & options.direction)) {\n\t            if (options.direction & DIRECTION_HORIZONTAL) {\n\t                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t                hasMoved = x != this.pX;\n\t                distance = Math.abs(input.deltaX);\n\t            } else {\n\t                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n\t                hasMoved = y != this.pY;\n\t                distance = Math.abs(input.deltaY);\n\t            }\n\t        }\n\t        input.direction = direction;\n\t        return hasMoved && distance > options.threshold && direction & options.direction;\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n\t            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n\t    },\n\t\n\t    emit: function(input) {\n\t\n\t        this.pX = input.deltaX;\n\t        this.pY = input.deltaY;\n\t\n\t        var direction = directionStr(input.direction);\n\t\n\t        if (direction) {\n\t            input.additionalEvent = this.options.event + direction;\n\t        }\n\t        this._super.emit.call(this, input);\n\t    }\n\t});\n\t\n\t/**\n\t * Pinch\n\t * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction PinchRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(PinchRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PinchRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'pinch',\n\t        threshold: 0,\n\t        pointers: 2\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_NONE];\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return this._super.attrTest.call(this, input) &&\n\t            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n\t    },\n\t\n\t    emit: function(input) {\n\t        if (input.scale !== 1) {\n\t            var inOut = input.scale < 1 ? 'in' : 'out';\n\t            input.additionalEvent = this.options.event + inOut;\n\t        }\n\t        this._super.emit.call(this, input);\n\t    }\n\t});\n\t\n\t/**\n\t * Press\n\t * Recognized when the pointer is down for x ms without any movement.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction PressRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t\n\t    this._timer = null;\n\t    this._input = null;\n\t}\n\t\n\tinherit(PressRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PressRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'press',\n\t        pointers: 1,\n\t        time: 251, // minimal time of the pointer to be pressed\n\t        threshold: 9 // a minimal movement is ok, but keep it low\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_AUTO];\n\t    },\n\t\n\t    process: function(input) {\n\t        var options = this.options;\n\t        var validPointers = input.pointers.length === options.pointers;\n\t        var validMovement = input.distance < options.threshold;\n\t        var validTime = input.deltaTime > options.time;\n\t\n\t        this._input = input;\n\t\n\t        // we only allow little movement\n\t        // and we've reached an end event, so a tap is possible\n\t        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n\t            this.reset();\n\t        } else if (input.eventType & INPUT_START) {\n\t            this.reset();\n\t            this._timer = setTimeoutContext(function() {\n\t                this.state = STATE_RECOGNIZED;\n\t                this.tryEmit();\n\t            }, options.time, this);\n\t        } else if (input.eventType & INPUT_END) {\n\t            return STATE_RECOGNIZED;\n\t        }\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    reset: function() {\n\t        clearTimeout(this._timer);\n\t    },\n\t\n\t    emit: function(input) {\n\t        if (this.state !== STATE_RECOGNIZED) {\n\t            return;\n\t        }\n\t\n\t        if (input && (input.eventType & INPUT_END)) {\n\t            this.manager.emit(this.options.event + 'up', input);\n\t        } else {\n\t            this._input.timeStamp = now();\n\t            this.manager.emit(this.options.event, this._input);\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Rotate\n\t * Recognized when two or more pointer are moving in a circular motion.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction RotateRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(RotateRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof RotateRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'rotate',\n\t        threshold: 0,\n\t        pointers: 2\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_NONE];\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return this._super.attrTest.call(this, input) &&\n\t            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n\t    }\n\t});\n\t\n\t/**\n\t * Swipe\n\t * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction SwipeRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(SwipeRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof SwipeRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'swipe',\n\t        threshold: 10,\n\t        velocity: 0.3,\n\t        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n\t        pointers: 1\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return PanRecognizer.prototype.getTouchAction.call(this);\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        var direction = this.options.direction;\n\t        var velocity;\n\t\n\t        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n\t            velocity = input.overallVelocity;\n\t        } else if (direction & DIRECTION_HORIZONTAL) {\n\t            velocity = input.overallVelocityX;\n\t        } else if (direction & DIRECTION_VERTICAL) {\n\t            velocity = input.overallVelocityY;\n\t        }\n\t\n\t        return this._super.attrTest.call(this, input) &&\n\t            direction & input.offsetDirection &&\n\t            input.distance > this.options.threshold &&\n\t            input.maxPointers == this.options.pointers &&\n\t            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n\t    },\n\t\n\t    emit: function(input) {\n\t        var direction = directionStr(input.offsetDirection);\n\t        if (direction) {\n\t            this.manager.emit(this.options.event + direction, input);\n\t        }\n\t\n\t        this.manager.emit(this.options.event, input);\n\t    }\n\t});\n\t\n\t/**\n\t * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n\t * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n\t * a single tap.\n\t *\n\t * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n\t * multi-taps being recognized.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction TapRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t\n\t    // previous time and center,\n\t    // used for tap counting\n\t    this.pTime = false;\n\t    this.pCenter = false;\n\t\n\t    this._timer = null;\n\t    this._input = null;\n\t    this.count = 0;\n\t}\n\t\n\tinherit(TapRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PinchRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'tap',\n\t        pointers: 1,\n\t        taps: 1,\n\t        interval: 300, // max time between the multi-tap taps\n\t        time: 250, // max time of the pointer to be down (like finger on the screen)\n\t        threshold: 9, // a minimal movement is ok, but keep it low\n\t        posThreshold: 10 // a multi-tap can be a bit off the initial position\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_MANIPULATION];\n\t    },\n\t\n\t    process: function(input) {\n\t        var options = this.options;\n\t\n\t        var validPointers = input.pointers.length === options.pointers;\n\t        var validMovement = input.distance < options.threshold;\n\t        var validTouchTime = input.deltaTime < options.time;\n\t\n\t        this.reset();\n\t\n\t        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n\t            return this.failTimeout();\n\t        }\n\t\n\t        // we only allow little movement\n\t        // and we've reached an end event, so a tap is possible\n\t        if (validMovement && validTouchTime && validPointers) {\n\t            if (input.eventType != INPUT_END) {\n\t                return this.failTimeout();\n\t            }\n\t\n\t            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n\t            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\t\n\t            this.pTime = input.timeStamp;\n\t            this.pCenter = input.center;\n\t\n\t            if (!validMultiTap || !validInterval) {\n\t                this.count = 1;\n\t            } else {\n\t                this.count += 1;\n\t            }\n\t\n\t            this._input = input;\n\t\n\t            // if tap count matches we have recognized it,\n\t            // else it has began recognizing...\n\t            var tapCount = this.count % options.taps;\n\t            if (tapCount === 0) {\n\t                // no failing requirements, immediately trigger the tap event\n\t                // or wait as long as the multitap interval to trigger\n\t                if (!this.hasRequireFailures()) {\n\t                    return STATE_RECOGNIZED;\n\t                } else {\n\t                    this._timer = setTimeoutContext(function() {\n\t                        this.state = STATE_RECOGNIZED;\n\t                        this.tryEmit();\n\t                    }, options.interval, this);\n\t                    return STATE_BEGAN;\n\t                }\n\t            }\n\t        }\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    failTimeout: function() {\n\t        this._timer = setTimeoutContext(function() {\n\t            this.state = STATE_FAILED;\n\t        }, this.options.interval, this);\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    reset: function() {\n\t        clearTimeout(this._timer);\n\t    },\n\t\n\t    emit: function() {\n\t        if (this.state == STATE_RECOGNIZED) {\n\t            this._input.tapCount = this.count;\n\t            this.manager.emit(this.options.event, this._input);\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Simple way to create a manager with a default set of recognizers.\n\t * @param {HTMLElement} element\n\t * @param {Object} [options]\n\t * @constructor\n\t */\n\tfunction Hammer(element, options) {\n\t    options = options || {};\n\t    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n\t    return new Manager(element, options);\n\t}\n\t\n\t/**\n\t * @const {string}\n\t */\n\tHammer.VERSION = '2.0.7';\n\t\n\t/**\n\t * default settings\n\t * @namespace\n\t */\n\tHammer.defaults = {\n\t    /**\n\t     * set if DOM events are being triggered.\n\t     * But this is slower and unused by simple implementations, so disabled by default.\n\t     * @type {Boolean}\n\t     * @default false\n\t     */\n\t    domEvents: false,\n\t\n\t    /**\n\t     * The value for the touchAction property/fallback.\n\t     * When set to `compute` it will magically set the correct value based on the added recognizers.\n\t     * @type {String}\n\t     * @default compute\n\t     */\n\t    touchAction: TOUCH_ACTION_COMPUTE,\n\t\n\t    /**\n\t     * @type {Boolean}\n\t     * @default true\n\t     */\n\t    enable: true,\n\t\n\t    /**\n\t     * EXPERIMENTAL FEATURE -- can be removed/changed\n\t     * Change the parent input target element.\n\t     * If Null, then it is being set the to main element.\n\t     * @type {Null|EventTarget}\n\t     * @default null\n\t     */\n\t    inputTarget: null,\n\t\n\t    /**\n\t     * force an input class\n\t     * @type {Null|Function}\n\t     * @default null\n\t     */\n\t    inputClass: null,\n\t\n\t    /**\n\t     * Default recognizer setup when calling `Hammer()`\n\t     * When creating a new Manager these will be skipped.\n\t     * @type {Array}\n\t     */\n\t    preset: [\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n\t        [RotateRecognizer, {enable: false}],\n\t        [PinchRecognizer, {enable: false}, ['rotate']],\n\t        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n\t        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n\t        [TapRecognizer],\n\t        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n\t        [PressRecognizer]\n\t    ],\n\t\n\t    /**\n\t     * Some CSS properties can be used to improve the working of Hammer.\n\t     * Add them to this method and they will be set when creating a new Manager.\n\t     * @namespace\n\t     */\n\t    cssProps: {\n\t        /**\n\t         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        userSelect: 'none',\n\t\n\t        /**\n\t         * Disable the Windows Phone grippers when pressing an element.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        touchSelect: 'none',\n\t\n\t        /**\n\t         * Disables the default callout shown when you touch and hold a touch target.\n\t         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n\t         * a callout containing information about the link. This property allows you to disable that callout.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        touchCallout: 'none',\n\t\n\t        /**\n\t         * Specifies whether zooming is enabled. Used by IE10>\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        contentZooming: 'none',\n\t\n\t        /**\n\t         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        userDrag: 'none',\n\t\n\t        /**\n\t         * Overrides the highlight color shown when the user taps a link or a JavaScript\n\t         * clickable element in iOS. This property obeys the alpha value, if specified.\n\t         * @type {String}\n\t         * @default 'rgba(0,0,0,0)'\n\t         */\n\t        tapHighlightColor: 'rgba(0,0,0,0)'\n\t    }\n\t};\n\t\n\tvar STOP = 1;\n\tvar FORCED_STOP = 2;\n\t\n\t/**\n\t * Manager\n\t * @param {HTMLElement} element\n\t * @param {Object} [options]\n\t * @constructor\n\t */\n\tfunction Manager(element, options) {\n\t    this.options = assign({}, Hammer.defaults, options || {});\n\t\n\t    this.options.inputTarget = this.options.inputTarget || element;\n\t\n\t    this.handlers = {};\n\t    this.session = {};\n\t    this.recognizers = [];\n\t    this.oldCssProps = {};\n\t\n\t    this.element = element;\n\t    this.input = createInputInstance(this);\n\t    this.touchAction = new TouchAction(this, this.options.touchAction);\n\t\n\t    toggleCssProps(this, true);\n\t\n\t    each(this.options.recognizers, function(item) {\n\t        var recognizer = this.add(new (item[0])(item[1]));\n\t        item[2] && recognizer.recognizeWith(item[2]);\n\t        item[3] && recognizer.requireFailure(item[3]);\n\t    }, this);\n\t}\n\t\n\tManager.prototype = {\n\t    /**\n\t     * set options\n\t     * @param {Object} options\n\t     * @returns {Manager}\n\t     */\n\t    set: function(options) {\n\t        assign(this.options, options);\n\t\n\t        // Options that need a little more setup\n\t        if (options.touchAction) {\n\t            this.touchAction.update();\n\t        }\n\t        if (options.inputTarget) {\n\t            // Clean up existing event listeners and reinitialize\n\t            this.input.destroy();\n\t            this.input.target = options.inputTarget;\n\t            this.input.init();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * stop recognizing for this session.\n\t     * This session will be discarded, when a new [input]start event is fired.\n\t     * When forced, the recognizer cycle is stopped immediately.\n\t     * @param {Boolean} [force]\n\t     */\n\t    stop: function(force) {\n\t        this.session.stopped = force ? FORCED_STOP : STOP;\n\t    },\n\t\n\t    /**\n\t     * run the recognizers!\n\t     * called by the inputHandler function on every movement of the pointers (touches)\n\t     * it walks through all the recognizers and tries to detect the gesture that is being made\n\t     * @param {Object} inputData\n\t     */\n\t    recognize: function(inputData) {\n\t        var session = this.session;\n\t        if (session.stopped) {\n\t            return;\n\t        }\n\t\n\t        // run the touch-action polyfill\n\t        this.touchAction.preventDefaults(inputData);\n\t\n\t        var recognizer;\n\t        var recognizers = this.recognizers;\n\t\n\t        // this holds the recognizer that is being recognized.\n\t        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n\t        // if no recognizer is detecting a thing, it is set to `null`\n\t        var curRecognizer = session.curRecognizer;\n\t\n\t        // reset when the last recognizer is recognized\n\t        // or when we're in a new session\n\t        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n\t            curRecognizer = session.curRecognizer = null;\n\t        }\n\t\n\t        var i = 0;\n\t        while (i < recognizers.length) {\n\t            recognizer = recognizers[i];\n\t\n\t            // find out if we are allowed try to recognize the input for this one.\n\t            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n\t            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n\t            //      that is being recognized.\n\t            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n\t            //      this can be setup with the `recognizeWith()` method on the recognizer.\n\t            if (session.stopped !== FORCED_STOP && ( // 1\n\t                    !curRecognizer || recognizer == curRecognizer || // 2\n\t                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n\t                recognizer.recognize(inputData);\n\t            } else {\n\t                recognizer.reset();\n\t            }\n\t\n\t            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n\t            // current active recognizer. but only if we don't already have an active recognizer\n\t            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n\t                curRecognizer = session.curRecognizer = recognizer;\n\t            }\n\t            i++;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * get a recognizer by its event name.\n\t     * @param {Recognizer|String} recognizer\n\t     * @returns {Recognizer|Null}\n\t     */\n\t    get: function(recognizer) {\n\t        if (recognizer instanceof Recognizer) {\n\t            return recognizer;\n\t        }\n\t\n\t        var recognizers = this.recognizers;\n\t        for (var i = 0; i < recognizers.length; i++) {\n\t            if (recognizers[i].options.event == recognizer) {\n\t                return recognizers[i];\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * add a recognizer to the manager\n\t     * existing recognizers with the same event name will be removed\n\t     * @param {Recognizer} recognizer\n\t     * @returns {Recognizer|Manager}\n\t     */\n\t    add: function(recognizer) {\n\t        if (invokeArrayArg(recognizer, 'add', this)) {\n\t            return this;\n\t        }\n\t\n\t        // remove existing\n\t        var existing = this.get(recognizer.options.event);\n\t        if (existing) {\n\t            this.remove(existing);\n\t        }\n\t\n\t        this.recognizers.push(recognizer);\n\t        recognizer.manager = this;\n\t\n\t        this.touchAction.update();\n\t        return recognizer;\n\t    },\n\t\n\t    /**\n\t     * remove a recognizer by name or instance\n\t     * @param {Recognizer|String} recognizer\n\t     * @returns {Manager}\n\t     */\n\t    remove: function(recognizer) {\n\t        if (invokeArrayArg(recognizer, 'remove', this)) {\n\t            return this;\n\t        }\n\t\n\t        recognizer = this.get(recognizer);\n\t\n\t        // let's make sure this recognizer exists\n\t        if (recognizer) {\n\t            var recognizers = this.recognizers;\n\t            var index = inArray(recognizers, recognizer);\n\t\n\t            if (index !== -1) {\n\t                recognizers.splice(index, 1);\n\t                this.touchAction.update();\n\t            }\n\t        }\n\t\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * bind event\n\t     * @param {String} events\n\t     * @param {Function} handler\n\t     * @returns {EventEmitter} this\n\t     */\n\t    on: function(events, handler) {\n\t        if (events === undefined) {\n\t            return;\n\t        }\n\t        if (handler === undefined) {\n\t            return;\n\t        }\n\t\n\t        var handlers = this.handlers;\n\t        each(splitStr(events), function(event) {\n\t            handlers[event] = handlers[event] || [];\n\t            handlers[event].push(handler);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * unbind event, leave emit blank to remove all handlers\n\t     * @param {String} events\n\t     * @param {Function} [handler]\n\t     * @returns {EventEmitter} this\n\t     */\n\t    off: function(events, handler) {\n\t        if (events === undefined) {\n\t            return;\n\t        }\n\t\n\t        var handlers = this.handlers;\n\t        each(splitStr(events), function(event) {\n\t            if (!handler) {\n\t                delete handlers[event];\n\t            } else {\n\t                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n\t            }\n\t        });\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * emit event to the listeners\n\t     * @param {String} event\n\t     * @param {Object} data\n\t     */\n\t    emit: function(event, data) {\n\t        // we also want to trigger dom events\n\t        if (this.options.domEvents) {\n\t            triggerDomEvent(event, data);\n\t        }\n\t\n\t        // no handlers, so skip it all\n\t        var handlers = this.handlers[event] && this.handlers[event].slice();\n\t        if (!handlers || !handlers.length) {\n\t            return;\n\t        }\n\t\n\t        data.type = event;\n\t        data.preventDefault = function() {\n\t            data.srcEvent.preventDefault();\n\t        };\n\t\n\t        var i = 0;\n\t        while (i < handlers.length) {\n\t            handlers[i](data);\n\t            i++;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * destroy the manager and unbinds all events\n\t     * it doesn't unbind dom events, that is the user own responsibility\n\t     */\n\t    destroy: function() {\n\t        this.element && toggleCssProps(this, false);\n\t\n\t        this.handlers = {};\n\t        this.session = {};\n\t        this.input.destroy();\n\t        this.element = null;\n\t    }\n\t};\n\t\n\t/**\n\t * add/remove the css properties as defined in manager.options.cssProps\n\t * @param {Manager} manager\n\t * @param {Boolean} add\n\t */\n\tfunction toggleCssProps(manager, add) {\n\t    var element = manager.element;\n\t    if (!element.style) {\n\t        return;\n\t    }\n\t    var prop;\n\t    each(manager.options.cssProps, function(value, name) {\n\t        prop = prefixed(element.style, name);\n\t        if (add) {\n\t            manager.oldCssProps[prop] = element.style[prop];\n\t            element.style[prop] = value;\n\t        } else {\n\t            element.style[prop] = manager.oldCssProps[prop] || '';\n\t        }\n\t    });\n\t    if (!add) {\n\t        manager.oldCssProps = {};\n\t    }\n\t}\n\t\n\t/**\n\t * trigger dom event\n\t * @param {String} event\n\t * @param {Object} data\n\t */\n\tfunction triggerDomEvent(event, data) {\n\t    var gestureEvent = document.createEvent('Event');\n\t    gestureEvent.initEvent(event, true, true);\n\t    gestureEvent.gesture = data;\n\t    data.target.dispatchEvent(gestureEvent);\n\t}\n\t\n\tassign(Hammer, {\n\t    INPUT_START: INPUT_START,\n\t    INPUT_MOVE: INPUT_MOVE,\n\t    INPUT_END: INPUT_END,\n\t    INPUT_CANCEL: INPUT_CANCEL,\n\t\n\t    STATE_POSSIBLE: STATE_POSSIBLE,\n\t    STATE_BEGAN: STATE_BEGAN,\n\t    STATE_CHANGED: STATE_CHANGED,\n\t    STATE_ENDED: STATE_ENDED,\n\t    STATE_RECOGNIZED: STATE_RECOGNIZED,\n\t    STATE_CANCELLED: STATE_CANCELLED,\n\t    STATE_FAILED: STATE_FAILED,\n\t\n\t    DIRECTION_NONE: DIRECTION_NONE,\n\t    DIRECTION_LEFT: DIRECTION_LEFT,\n\t    DIRECTION_RIGHT: DIRECTION_RIGHT,\n\t    DIRECTION_UP: DIRECTION_UP,\n\t    DIRECTION_DOWN: DIRECTION_DOWN,\n\t    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n\t    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n\t    DIRECTION_ALL: DIRECTION_ALL,\n\t\n\t    Manager: Manager,\n\t    Input: Input,\n\t    TouchAction: TouchAction,\n\t\n\t    TouchInput: TouchInput,\n\t    MouseInput: MouseInput,\n\t    PointerEventInput: PointerEventInput,\n\t    TouchMouseInput: TouchMouseInput,\n\t    SingleTouchInput: SingleTouchInput,\n\t\n\t    Recognizer: Recognizer,\n\t    AttrRecognizer: AttrRecognizer,\n\t    Tap: TapRecognizer,\n\t    Pan: PanRecognizer,\n\t    Swipe: SwipeRecognizer,\n\t    Pinch: PinchRecognizer,\n\t    Rotate: RotateRecognizer,\n\t    Press: PressRecognizer,\n\t\n\t    on: addEventListeners,\n\t    off: removeEventListeners,\n\t    each: each,\n\t    merge: merge,\n\t    extend: extend,\n\t    assign: assign,\n\t    inherit: inherit,\n\t    bindFn: bindFn,\n\t    prefixed: prefixed\n\t});\n\t\n\t// this prevents errors when Hammer is loaded in the presence of an AMD\n\t//  style loader but by script tag, not by the loader.\n\tvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\n\tfreeGlobal.Hammer = Hammer;\n\t\n\tif (true) {\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t        return Hammer;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if (typeof module != 'undefined' && module.exports) {\n\t    module.exports = Hammer;\n\t} else {\n\t    window[exportName] = Hammer;\n\t}\n\t\n\t})(window, document, 'Hammer');\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t\t true ? module.exports = factory() :\n\t\ttypeof define === 'function' && define.amd ? define(factory) :\n\t\tglobal.Ractive.events.tap = factory()\n\t}(this, function () { 'use strict';\n\t\n\t\t// maximum milliseconds between down and up before cancel\n\t\n\t\tvar ractive_events_tap = tap;\n\t\n\t\tvar DISTANCE_THRESHOLD = 5; // maximum pixels pointer can move before cancel\n\t\tvar TIME_THRESHOLD = 400;\n\t\tfunction tap(node, callback) {\n\t\t\treturn new ractive_events_tap__TapHandler(node, callback);\n\t\t}\n\t\n\t\tvar ractive_events_tap__TapHandler = function ractive_events_tap__TapHandler(node, callback) {\n\t\t\tthis.node = node;\n\t\t\tthis.callback = callback;\n\t\n\t\t\tthis.preventMousedownEvents = false;\n\t\n\t\t\tthis.bind(node);\n\t\t};\n\t\n\t\tractive_events_tap__TapHandler.prototype = {\n\t\t\tbind: function bind(node) {\n\t\t\t\t// listen for mouse/pointer events...\n\t\t\t\tif (window.navigator.pointerEnabled) {\n\t\t\t\t\tnode.addEventListener(\"pointerdown\", handleMousedown, false);\n\t\t\t\t} else if (window.navigator.msPointerEnabled) {\n\t\t\t\t\tnode.addEventListener(\"MSPointerDown\", handleMousedown, false);\n\t\t\t\t} else {\n\t\t\t\t\tnode.addEventListener(\"mousedown\", handleMousedown, false);\n\t\t\t\t}\n\t\n\t\t\t\t// ...and touch events\n\t\t\t\tnode.addEventListener(\"touchstart\", handleTouchstart, false);\n\t\n\t\t\t\t// native buttons, and <input type='button'> elements, should fire a tap event\n\t\t\t\t// when the space key is pressed\n\t\t\t\tif (node.tagName === \"BUTTON\" || node.type === \"button\") {\n\t\t\t\t\tnode.addEventListener(\"focus\", handleFocus, false);\n\t\t\t\t}\n\t\n\t\t\t\tnode.__tap_handler__ = this;\n\t\t\t},\n\t\n\t\t\tfire: function fire(event, x, y) {\n\t\t\t\tthis.callback({\n\t\t\t\t\tnode: this.node,\n\t\t\t\t\toriginal: event,\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t});\n\t\t\t},\n\t\n\t\t\tmousedown: function mousedown(event) {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tif (this.preventMousedownEvents) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif (event.which !== undefined && event.which !== 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar x = event.clientX;\n\t\t\t\tvar y = event.clientY;\n\t\n\t\t\t\t// This will be null for mouse events.\n\t\t\t\tvar pointerId = event.pointerId;\n\t\n\t\t\t\tvar handleMouseup = function (event) {\n\t\t\t\t\tif (event.pointerId != pointerId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t_this.fire(event, x, y);\n\t\t\t\t\tcancel();\n\t\t\t\t};\n\t\n\t\t\t\tvar handleMousemove = function (event) {\n\t\t\t\t\tif (event.pointerId != pointerId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (Math.abs(event.clientX - x) >= DISTANCE_THRESHOLD || Math.abs(event.clientY - y) >= DISTANCE_THRESHOLD) {\n\t\t\t\t\t\tcancel();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\tvar cancel = function () {\n\t\t\t\t\t_this.node.removeEventListener(\"MSPointerUp\", handleMouseup, false);\n\t\t\t\t\tdocument.removeEventListener(\"MSPointerMove\", handleMousemove, false);\n\t\t\t\t\tdocument.removeEventListener(\"MSPointerCancel\", cancel, false);\n\t\t\t\t\t_this.node.removeEventListener(\"pointerup\", handleMouseup, false);\n\t\t\t\t\tdocument.removeEventListener(\"pointermove\", handleMousemove, false);\n\t\t\t\t\tdocument.removeEventListener(\"pointercancel\", cancel, false);\n\t\t\t\t\t_this.node.removeEventListener(\"click\", handleMouseup, false);\n\t\t\t\t\tdocument.removeEventListener(\"mousemove\", handleMousemove, false);\n\t\t\t\t};\n\t\n\t\t\t\tif (window.navigator.pointerEnabled) {\n\t\t\t\t\tthis.node.addEventListener(\"pointerup\", handleMouseup, false);\n\t\t\t\t\tdocument.addEventListener(\"pointermove\", handleMousemove, false);\n\t\t\t\t\tdocument.addEventListener(\"pointercancel\", cancel, false);\n\t\t\t\t} else if (window.navigator.msPointerEnabled) {\n\t\t\t\t\tthis.node.addEventListener(\"MSPointerUp\", handleMouseup, false);\n\t\t\t\t\tdocument.addEventListener(\"MSPointerMove\", handleMousemove, false);\n\t\t\t\t\tdocument.addEventListener(\"MSPointerCancel\", cancel, false);\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.addEventListener(\"click\", handleMouseup, false);\n\t\t\t\t\tdocument.addEventListener(\"mousemove\", handleMousemove, false);\n\t\t\t\t}\n\t\n\t\t\t\tsetTimeout(cancel, TIME_THRESHOLD);\n\t\t\t},\n\t\n\t\t\ttouchdown: function touchdown() {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tvar touch = event.touches[0];\n\t\n\t\t\t\tvar x = touch.clientX;\n\t\t\t\tvar y = touch.clientY;\n\t\n\t\t\t\tvar finger = touch.identifier;\n\t\n\t\t\t\tvar handleTouchup = function (event) {\n\t\t\t\t\tvar touch = event.changedTouches[0];\n\t\n\t\t\t\t\tif (touch.identifier !== finger) {\n\t\t\t\t\t\tcancel();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tevent.preventDefault(); // prevent compatibility mouse event\n\t\n\t\t\t\t\t// for the benefit of mobile Firefox and old Android browsers, we need this absurd hack.\n\t\t\t\t\t_this.preventMousedownEvents = true;\n\t\t\t\t\tclearTimeout(_this.preventMousedownTimeout);\n\t\n\t\t\t\t\t_this.preventMousedownTimeout = setTimeout(function () {\n\t\t\t\t\t\t_this.preventMousedownEvents = false;\n\t\t\t\t\t}, 400);\n\t\n\t\t\t\t\t_this.fire(event, x, y);\n\t\t\t\t\tcancel();\n\t\t\t\t};\n\t\n\t\t\t\tvar handleTouchmove = function (event) {\n\t\t\t\t\tvar touch;\n\t\n\t\t\t\t\tif (event.touches.length !== 1 || event.touches[0].identifier !== finger) {\n\t\t\t\t\t\tcancel();\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttouch = event.touches[0];\n\t\t\t\t\tif (Math.abs(touch.clientX - x) >= DISTANCE_THRESHOLD || Math.abs(touch.clientY - y) >= DISTANCE_THRESHOLD) {\n\t\t\t\t\t\tcancel();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\tvar cancel = function () {\n\t\t\t\t\t_this.node.removeEventListener(\"touchend\", handleTouchup, false);\n\t\t\t\t\twindow.removeEventListener(\"touchmove\", handleTouchmove, false);\n\t\t\t\t\twindow.removeEventListener(\"touchcancel\", cancel, false);\n\t\t\t\t};\n\t\n\t\t\t\tthis.node.addEventListener(\"touchend\", handleTouchup, false);\n\t\t\t\twindow.addEventListener(\"touchmove\", handleTouchmove, false);\n\t\t\t\twindow.addEventListener(\"touchcancel\", cancel, false);\n\t\n\t\t\t\tsetTimeout(cancel, TIME_THRESHOLD);\n\t\t\t},\n\t\n\t\t\tteardown: function teardown() {\n\t\t\t\tvar node = this.node;\n\t\n\t\t\t\tnode.removeEventListener(\"pointerdown\", handleMousedown, false);\n\t\t\t\tnode.removeEventListener(\"MSPointerDown\", handleMousedown, false);\n\t\t\t\tnode.removeEventListener(\"mousedown\", handleMousedown, false);\n\t\t\t\tnode.removeEventListener(\"touchstart\", handleTouchstart, false);\n\t\t\t\tnode.removeEventListener(\"focus\", handleFocus, false);\n\t\t\t}\n\t\t};\n\t\n\t\tfunction handleMousedown(event) {\n\t\t\tthis.__tap_handler__.mousedown(event);\n\t\t}\n\t\n\t\tfunction handleTouchstart(event) {\n\t\t\tthis.__tap_handler__.touchdown(event);\n\t\t}\n\t\n\t\tfunction handleFocus() {\n\t\t\tthis.addEventListener(\"keydown\", handleKeydown, false);\n\t\t\tthis.addEventListener(\"blur\", handleBlur, false);\n\t\t}\n\t\n\t\tfunction handleBlur() {\n\t\t\tthis.removeEventListener(\"keydown\", handleKeydown, false);\n\t\t\tthis.removeEventListener(\"blur\", handleBlur, false);\n\t\t}\n\t\n\t\tfunction handleKeydown(event) {\n\t\t\tif (event.which === 32) {\n\t\t\t\t// space key\n\t\t\t\tthis.__tap_handler__.fire();\n\t\t\t}\n\t\t}\n\t\n\t\treturn ractive_events_tap;\n\t\n\t}));\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a0d7a85bd5170a56e286","import Root from './app/root';\n\n(function() {\n    new Root(document.getElementById('app'));\n})();\n\n\n// WEBPACK FOOTER //\n// ./app-client.js","module.exports = (function() {\n    'use strict';\n    var Ractive = require('ractive');\n    var template = require(\"ractive!./views/root.html\");\n    var headerComponent = require(\"./components/header\");\n    var EventBus = require('vertx3-eventbus-client');\n    require('ractive-touch');\n    require('../scss/main.scss');\n\n    function Root(root) {\n        let eb;\n        navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;\n        Ractive.DEBUG = false;\n        const view = new Ractive({\n            el: root,\n            template: template,\n            magic: true,\n            data: {\n                vibrate: {\n                    vibrate: false,\n                    speed: 500,\n                    recipient: \"\",\n                    sender: \"\",\n                },\n                signupOpen: false,\n                menuOpen: false,\n                user: \"\",\n                conn: false,\n                sending: false,\n                selectUser: false,\n            },\n            events: {\n                tap: require( 'ractive-events-tap' )\n            },\n            components: {\n                Header: headerComponent(),\n            },\n            oninit: function () {\n                this.on({\n                    handleInput: function(event) {\n                        this.set(event.original.target.name, event.original.target.value);\n                    },\n                    hideUserForm: function(event) {\n                        if(this.get(\"user\")) {\n                            this.set(\"sender\",this.get(\"user\"));\n                            this.toggle(\"selectUser\");\n                            eb = this.connect();\n                        }\n                    },\n                    startVibrate: function(event) {\n                        var  model = this.get(\"vibrate\");\n                        model.vibrate = true;\n                        model.sender = this.get(\"user\");\n                        this.set(\"sending\",true);\n                        this.sendMessage(model);\n                    },\n                    endVibrate: function(event) {\n                        var model = this.get(\"vibrate\");\n                        model.vibrate = false;\n                        model.sender = \"\";\n                        this.set(\"sending\",false);\n                        this.sendMessage(model);\n                    },\n                    selectSpeed: function(event) {\n                        var  model = this.get(\"vibrate\");\n                        model.speed = event.node.value;\n                        this.sendMessage(model);\n                    },\n                    changeUser: function(event) {\n                        this.set(\"vibrate.recipient\",event.node.value);\n                    },\n                    connect: function(event) {\n                        eb = this.connect();\n                    },\n                });\n            },\n            connect: function() {\n                const eventbusUrl = \"http://\"+window.location.hostname+':8080/eventbus';\n                let eb = new EventBus(eventbusUrl);\n\n                eb.onopen = function() {\n                    this.set(\"conn\", true);\n                    eb.registerHandler('chat.messageOut', function(error, msg) {\n                        this.set({\"vibrate.vibrate\": msg.body.vibrate,\n                            \"vibrate.speed\": msg.body.speed,\n                            \"vibrate.sender\": msg.body.sender});\n                        this.msgHandler();\n                    }.bind(this));\n                    eb.send(\"chat.user\",{ user: this.get(\"user\") });\n                }.bind(this);\n                eb.onclose = function() {\n                    this.set(\"conn\", false);\n                    eb.unregisterHandler('chat.messageOut');\n                    eb.unregisterHandler('chat.user');\n                }.bind(this);\n                return eb;\n            },\n            vibrate: function(speed) {\n                if (navigator.vibrate) {\n                    navigator.vibrate(speed);\n                }\n            },\n            sendMessage: function(msg) {\n                eb.send(\"chat.messageIn\",msg);\n            },\n            msgHandler: function() {\n                var model = this.get(\"vibrate\");\n                if(!model.vibrate) return;\n                this.vibrate(model.speed);\n                var start = null;\n                var step = function(timestamp) {\n                    if(!model.vibrate) {\n                        this.vibrate(0);\n                        return;\n                    }\n                    if (!start) start = timestamp;\n                    var progress = timestamp - start;\n                    if (progress <= model.speed) {\n                        window.requestAnimationFrame(step);\n                    } else {\n                        start = null;\n                        this.vibrate(model.speed);\n                        window.requestAnimationFrame(step);\n                    }\n                }.bind(this);\n                window.requestAnimationFrame(step);\n            }\n        });\n\n        return view;\n    }\n    return Root;\n\n})();\n\n\n// WEBPACK FOOTER //\n// ./app/root.js","/*\n\tRactive.js v0.8.5\n\tSun Nov 13 2016 17:56:27 GMT+0000 (UTC) - commit d533d91f155a4f042c1acc87136459141c2c8af9\n\n\thttp://ractivejs.org\n\thttp://twitter.com/RactiveJS\n\n\tReleased under the MIT License.\n*/\n\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  ((function() { var current = global.Ractive; var next = factory(); next.noConflict = function() { global.Ractive = current; return next; }; return global.Ractive = next; })());\n}(this, function () { 'use strict';\n\n  var defaults = {\n  \t// render placement:\n  \tel:                     void 0,\n  \tappend:\t\t\t\t    false,\n\n  \t// template:\n  \ttemplate:               null,\n\n  \t// parse:\n  \tdelimiters:             [ '{{', '}}' ],\n  \ttripleDelimiters:       [ '{{{', '}}}' ],\n  \tstaticDelimiters:       [ '[[', ']]' ],\n  \tstaticTripleDelimiters: [ '[[[', ']]]' ],\n  \tcsp: \t\t\t\t\ttrue,\n  \tinterpolate:            false,\n  \tpreserveWhitespace:     false,\n  \tsanitize:               false,\n  \tstripComments:          true,\n  \tcontextLines:           0,\n\n  \t// data & binding:\n  \tdata:                   {},\n  \tcomputed:               {},\n  \tmagic:                  false,\n  \tmodifyArrays:           false,\n  \tadapt:                  [],\n  \tisolated:               false,\n  \ttwoway:                 true,\n  \tlazy:                   false,\n\n  \t// transitions:\n  \tnoIntro:                false,\n  \ttransitionsEnabled:     true,\n  \tcomplete:               void 0,\n\n  \t// css:\n  \tcss:                    null,\n  \tnoCssTransform:         false\n  };\n\n  // These are a subset of the easing equations found at\n  // https://raw.github.com/danro/easing-js - license info\n  // follows:\n\n  // --------------------------------------------------\n  // easing.js v0.5.4\n  // Generic set of easing functions with AMD support\n  // https://github.com/danro/easing-js\n  // This code may be freely distributed under the MIT license\n  // http://danro.mit-license.org/\n  // --------------------------------------------------\n  // All functions adapted from Thomas Fuchs & Jeremy Kahn\n  // Easing Equations (c) 2003 Robert Penner, BSD license\n  // https://raw.github.com/danro/easing-js/master/LICENSE\n  // --------------------------------------------------\n\n  // In that library, the functions named easeIn, easeOut, and\n  // easeInOut below are named easeInCubic, easeOutCubic, and\n  // (you guessed it) easeInOutCubic.\n  //\n  // You can add additional easing functions to this list, and they\n  // will be globally available.\n\n\n  var easing = {\n  \tlinear: function ( pos ) { return pos; },\n  \teaseIn: function ( pos ) { return Math.pow( pos, 3 ); },\n  \teaseOut: function ( pos ) { return ( Math.pow( ( pos - 1 ), 3 ) + 1 ); },\n  \teaseInOut: function ( pos ) {\n  \t\tif ( ( pos /= 0.5 ) < 1 ) { return ( 0.5 * Math.pow( pos, 3 ) ); }\n  \t\treturn ( 0.5 * ( Math.pow( ( pos - 2 ), 3 ) + 2 ) );\n  \t}\n  };\n\n  var legacy = null;\n\n  /*global console, navigator */\n\n  var win = typeof window !== 'undefined' ? window : null;\n  var doc = win ? document : null;\n\n  var isClient = !!doc;\n  var isJsdom = ( typeof navigator !== 'undefined' && /jsDom/.test( navigator.appName ) );\n  var hasConsole = ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' );\n\n  var magicSupported;\n  try {\n  \tObject.defineProperty({}, 'test', { value: 0 });\n  \tmagicSupported = true;\n  } catch ( e ) {\n  \tmagicSupported = false;\n  }\n\n  var svg = doc ?\n  \tdoc.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' ) :\n  \tfalse;\n\n  var vendors = [ 'o', 'ms', 'moz', 'webkit' ];\n\n  var html   = 'http://www.w3.org/1999/xhtml';\n  var mathml = 'http://www.w3.org/1998/Math/MathML';\n  var svg$1    = 'http://www.w3.org/2000/svg';\n  var xlink  = 'http://www.w3.org/1999/xlink';\n  var xml    = 'http://www.w3.org/XML/1998/namespace';\n  var xmlns  = 'http://www.w3.org/2000/xmlns';\n\n  var namespaces = { html: html, mathml: mathml, svg: svg$1, xlink: xlink, xml: xml, xmlns: xmlns };\n\n  var createElement;\n  var matches;\n  var div;\n  var methodNames;\n  var unprefixed;\n  var prefixed;\n  var i;\n  var j;\n  var makeFunction;\n  // Test for SVG support\n  if ( !svg ) {\n  \tcreateElement = function ( type, ns, extend ) {\n  \t\tif ( ns && ns !== html ) {\n  \t\t\tthrow 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';\n  \t\t}\n\n  \t\treturn extend ?\n  \t\t\tdoc.createElement( type, extend ) :\n  \t\t\tdoc.createElement( type );\n  \t};\n  } else {\n  \tcreateElement = function ( type, ns, extend ) {\n  \t\tif ( !ns || ns === html ) {\n  \t\t\treturn extend ?\n  \t\t\t\tdoc.createElement( type, extend ) :\n  \t\t\t\tdoc.createElement( type );\n  \t\t}\n\n  \t\treturn extend ?\n  \t\t\tdoc.createElementNS( ns, type, extend ) :\n  \t\t\tdoc.createElementNS( ns, type );\n  \t};\n  }\n\n  function createDocumentFragment () {\n  \treturn doc.createDocumentFragment();\n  }\n\n  function getElement ( input ) {\n  \tvar output;\n\n  \tif ( !input || typeof input === 'boolean' ) { return; }\n\n  \tif ( !win || !doc || !input ) {\n  \t\treturn null;\n  \t}\n\n  \t// We already have a DOM node - no work to do. (Duck typing alert!)\n  \tif ( input.nodeType ) {\n  \t\treturn input;\n  \t}\n\n  \t// Get node from string\n  \tif ( typeof input === 'string' ) {\n  \t\t// try ID first\n  \t\toutput = doc.getElementById( input );\n\n  \t\t// then as selector, if possible\n  \t\tif ( !output && doc.querySelector ) {\n  \t\t\toutput = doc.querySelector( input );\n  \t\t}\n\n  \t\t// did it work?\n  \t\tif ( output && output.nodeType ) {\n  \t\t\treturn output;\n  \t\t}\n  \t}\n\n  \t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n  \tif ( input[0] && input[0].nodeType ) {\n  \t\treturn input[0];\n  \t}\n\n  \treturn null;\n  }\n\n  if ( !isClient ) {\n  \tmatches = null;\n  } else {\n  \tdiv = createElement( 'div' );\n  \tmethodNames = [ 'matches', 'matchesSelector' ];\n\n  \tmakeFunction = function ( methodName ) {\n  \t\treturn function ( node, selector ) {\n  \t\t\treturn node[ methodName ]( selector );\n  \t\t};\n  \t};\n\n  \ti = methodNames.length;\n\n  \twhile ( i-- && !matches ) {\n  \t\tunprefixed = methodNames[i];\n\n  \t\tif ( div[ unprefixed ] ) {\n  \t\t\tmatches = makeFunction( unprefixed );\n  \t\t} else {\n  \t\t\tj = vendors.length;\n  \t\t\twhile ( j-- ) {\n  \t\t\t\tprefixed = vendors[i] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );\n\n  \t\t\t\tif ( div[ prefixed ] ) {\n  \t\t\t\t\tmatches = makeFunction( prefixed );\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// IE8...\n  \tif ( !matches ) {\n  \t\tmatches = function ( node, selector ) {\n  \t\t\tvar nodes, parentNode, i;\n\n  \t\t\tparentNode = node.parentNode;\n\n  \t\t\tif ( !parentNode ) {\n  \t\t\t\t// empty dummy <div>\n  \t\t\t\tdiv.innerHTML = '';\n\n  \t\t\t\tparentNode = div;\n  \t\t\t\tnode = node.cloneNode();\n\n  \t\t\t\tdiv.appendChild( node );\n  \t\t\t}\n\n  \t\t\tnodes = parentNode.querySelectorAll( selector );\n\n  \t\t\ti = nodes.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tif ( nodes[i] === node ) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn false;\n  \t\t};\n  \t}\n  }\n\n  function detachNode ( node ) {\n  \tif ( node && typeof node.parentNode !== 'unknown' && node.parentNode ) {\n  \t\tnode.parentNode.removeChild( node );\n  \t}\n\n  \treturn node;\n  }\n\n  function safeToStringValue ( value ) {\n  \treturn ( value == null || !value.toString ) ? '' : '' + value;\n  }\n\n  function safeAttributeString ( string ) {\n  \treturn safeToStringValue( string )\n  \t\t.replace( /&/g, '&amp;' )\n  \t\t.replace( /\"/g, '&quot;' )\n  \t\t.replace( /'/g, '&#39;' );\n  }\n\n  var camel = /(-.)/g;\n  function camelize ( string ) {\n  \treturn string.replace( camel, function ( s ) { return s.charAt( 1 ).toUpperCase(); } );\n  }\n\n  var decamel = /[A-Z]/g;\n  function decamelize ( string ) {\n  \treturn string.replace( decamel, function ( s ) { return (\"-\" + (s.toLowerCase())); } );\n  }\n\n  var create;\n  var defineProperty;\n  var defineProperties;\n  try {\n  \tObject.defineProperty({}, 'test', { get: function() {}, set: function() {} });\n\n  \tif ( doc ) {\n  \t\tObject.defineProperty( createElement( 'div' ), 'test', { value: 0 });\n  \t}\n\n  \tdefineProperty = Object.defineProperty;\n  } catch ( err ) {\n  \t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n  \t// only use it with DOM objects (what were you smoking, MSFT?)\n  \tdefineProperty = function ( obj, prop, desc ) {\n  \t\tif ( desc.get ) obj[ prop ] = desc.get();\n  \t\telse obj[ prop ] = desc.value;\n  \t};\n  }\n\n  try {\n  \ttry {\n  \t\tObject.defineProperties({}, { test: { value: 0 } });\n  \t} catch ( err ) {\n  \t\t// TODO how do we account for this? noMagic = true;\n  \t\tthrow err;\n  \t}\n\n  \tif ( doc ) {\n  \t\tObject.defineProperties( createElement( 'div' ), { test: { value: 0 } });\n  \t}\n\n  \tdefineProperties = Object.defineProperties;\n  } catch ( err ) {\n  \tdefineProperties = function ( obj, props ) {\n  \t\tvar prop;\n\n  \t\tfor ( prop in props ) {\n  \t\t\tif ( props.hasOwnProperty( prop ) ) {\n  \t\t\t\tdefineProperty( obj, prop, props[ prop ] );\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  try {\n  \tObject.create( null );\n\n  \tcreate = Object.create;\n  } catch ( err ) {\n  \t// sigh\n  \tcreate = (function () {\n  \t\tvar F = function () {};\n\n  \t\treturn function ( proto, props ) {\n  \t\t\tvar obj;\n\n  \t\t\tif ( proto === null ) {\n  \t\t\t\treturn {};\n  \t\t\t}\n\n  \t\t\tF.prototype = proto;\n  \t\t\tobj = new F();\n\n  \t\t\tif ( props ) {\n  \t\t\t\tObject.defineProperties( obj, props );\n  \t\t\t}\n\n  \t\t\treturn obj;\n  \t\t};\n  \t}());\n  }\n\n  function extendObj ( target ) {\n  \tvar sources = [], len = arguments.length - 1;\n  \twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  \tvar prop;\n\n  \tsources.forEach( function ( source ) {\n  \t\tfor ( prop in source ) {\n  \t\t\tif ( hasOwn.call( source, prop ) ) {\n  \t\t\t\ttarget[ prop ] = source[ prop ];\n  \t\t\t}\n  \t\t}\n  \t});\n\n  \treturn target;\n  }\n\n  function fillGaps ( target ) {\n  \tvar sources = [], len = arguments.length - 1;\n  \twhile ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  \tsources.forEach( function ( s ) {\n  \t\tfor ( var key in s ) {\n  \t\t\tif ( hasOwn.call( s, key ) && !( key in target ) ) {\n  \t\t\t\ttarget[ key ] = s[ key ];\n  \t\t\t}\n  \t\t}\n  \t});\n\n  \treturn target;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  var toString = Object.prototype.toString;\n  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  function isArray ( thing ) {\n  \treturn toString.call( thing ) === '[object Array]';\n  }\n\n  function isEqual ( a, b ) {\n  \tif ( a === null && b === null ) {\n  \t\treturn true;\n  \t}\n\n  \tif ( typeof a === 'object' || typeof b === 'object' ) {\n  \t\treturn false;\n  \t}\n\n  \treturn a === b;\n  }\n\n  // http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric\n  function isNumeric ( thing ) {\n  \treturn !isNaN( parseFloat( thing ) ) && isFinite( thing );\n  }\n\n  function isObject ( thing ) {\n  \treturn ( thing && toString.call( thing ) === '[object Object]' );\n  }\n\n  function noop () {}\n\n  var alreadyWarned = {};\n  var log;\n  var printWarning;\n  var welcome;\n  if ( hasConsole ) {\n  \tvar welcomeIntro = [\n  \t\t(\"%cRactive.js %c0.8.5 %cin debug mode, %cmore...\"),\n  \t\t'color: rgb(114, 157, 52); font-weight: normal;',\n  \t\t'color: rgb(85, 85, 85); font-weight: normal;',\n  \t\t'color: rgb(85, 85, 85); font-weight: normal;',\n  \t\t'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;'\n  \t];\n  \tvar welcomeMessage = \"You're running Ractive 0.8.5 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n  \twelcome = function () {\n  \t\tif ( Ractive.WELCOME_MESSAGE === false ) {\n  \t\t\twelcome = noop;\n  \t\t\treturn;\n  \t\t}\n  \t\tvar message = 'WELCOME_MESSAGE' in Ractive ? Ractive.WELCOME_MESSAGE : welcomeMessage;\n  \t\tvar hasGroup = !!console.groupCollapsed;\n  \t\tif ( hasGroup ) console.groupCollapsed.apply( console, welcomeIntro );\n  \t\tconsole.log( message );\n  \t\tif ( hasGroup ) {\n  \t\t\tconsole.groupEnd( welcomeIntro );\n  \t\t}\n\n  \t\twelcome = noop;\n  \t};\n\n  \tprintWarning = function ( message, args ) {\n  \t\twelcome();\n\n  \t\t// extract information about the instance this message pertains to, if applicable\n  \t\tif ( typeof args[ args.length - 1 ] === 'object' ) {\n  \t\t\tvar options = args.pop();\n  \t\t\tvar ractive = options ? options.ractive : null;\n\n  \t\t\tif ( ractive ) {\n  \t\t\t\t// if this is an instance of a component that we know the name of, add\n  \t\t\t\t// it to the message\n  \t\t\t\tvar name;\n  \t\t\t\tif ( ractive.component && ( name = ractive.component.name ) ) {\n  \t\t\t\t\tmessage = \"<\" + name + \"> \" + message;\n  \t\t\t\t}\n\n  \t\t\t\tvar node;\n  \t\t\t\tif ( node = ( options.node || ( ractive.fragment && ractive.fragment.rendered && ractive.find( '*' ) ) ) ) {\n  \t\t\t\t\targs.push( node );\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tconsole.warn.apply( console, [ '%cRactive.js: %c' + message, 'color: rgb(114, 157, 52);', 'color: rgb(85, 85, 85);' ].concat( args ) );\n  \t};\n\n  \tlog = function () {\n  \t\tconsole.log.apply( console, arguments );\n  \t};\n  } else {\n  \tprintWarning = log = welcome = noop;\n  }\n\n  function format ( message, args ) {\n  \treturn message.replace( /%s/g, function () { return args.shift(); } );\n  }\n\n  function fatal ( message ) {\n  \tvar args = [], len = arguments.length - 1;\n  \twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  \tmessage = format( message, args );\n  \tthrow new Error( message );\n  }\n\n  function logIfDebug () {\n  \tif ( Ractive.DEBUG ) {\n  \t\tlog.apply( null, arguments );\n  \t}\n  }\n\n  function warn ( message ) {\n  \tvar args = [], len = arguments.length - 1;\n  \twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  \tmessage = format( message, args );\n  \tprintWarning( message, args );\n  }\n\n  function warnOnce ( message ) {\n  \tvar args = [], len = arguments.length - 1;\n  \twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  \tmessage = format( message, args );\n\n  \tif ( alreadyWarned[ message ] ) {\n  \t\treturn;\n  \t}\n\n  \talreadyWarned[ message ] = true;\n  \tprintWarning( message, args );\n  }\n\n  function warnIfDebug () {\n  \tif ( Ractive.DEBUG ) {\n  \t\twarn.apply( null, arguments );\n  \t}\n  }\n\n  function warnOnceIfDebug () {\n  \tif ( Ractive.DEBUG ) {\n  \t\twarnOnce.apply( null, arguments );\n  \t}\n  }\n\n  // Error messages that are used (or could be) in multiple places\n  var badArguments = 'Bad arguments';\n  var noRegistryFunctionReturn = 'A function was specified for \"%s\" %s, but no %s was returned';\n  var missingPlugin = function ( name, type ) { return (\"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#\" + type + \"s\"); };\n\n  function findInViewHierarchy ( registryName, ractive, name ) {\n  \tvar instance = findInstance( registryName, ractive, name );\n  \treturn instance ? instance[ registryName ][ name ] : null;\n  }\n\n  function findInstance ( registryName, ractive, name ) {\n  \twhile ( ractive ) {\n  \t\tif ( name in ractive[ registryName ] ) {\n  \t\t\treturn ractive;\n  \t\t}\n\n  \t\tif ( ractive.isolated ) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tractive = ractive.parent;\n  \t}\n  }\n\n  function interpolate ( from, to, ractive, type ) {\n  \tif ( from === to ) return null;\n\n  \tif ( type ) {\n  \t\tvar interpol = findInViewHierarchy( 'interpolators', ractive, type );\n  \t\tif ( interpol ) return interpol( from, to ) || null;\n\n  \t\tfatal( missingPlugin( type, 'interpolator' ) );\n  \t}\n\n  \treturn interpolators.number( from, to ) ||\n  \t       interpolators.array( from, to ) ||\n  \t       interpolators.object( from, to ) ||\n  \t       null;\n  }\n\n  function snap ( to ) {\n  \treturn function () { return to; };\n  }\n\n  var interpolators = {\n  \tnumber: function ( from, to ) {\n  \t\tvar delta;\n\n  \t\tif ( !isNumeric( from ) || !isNumeric( to ) ) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tfrom = +from;\n  \t\tto = +to;\n\n  \t\tdelta = to - from;\n\n  \t\tif ( !delta ) {\n  \t\t\treturn function () { return from; };\n  \t\t}\n\n  \t\treturn function ( t ) {\n  \t\t\treturn from + ( t * delta );\n  \t\t};\n  \t},\n\n  \tarray: function ( from, to ) {\n  \t\tvar intermediate, interpolators, len, i;\n\n  \t\tif ( !isArray( from ) || !isArray( to ) ) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tintermediate = [];\n  \t\tinterpolators = [];\n\n  \t\ti = len = Math.min( from.length, to.length );\n  \t\twhile ( i-- ) {\n  \t\t\tinterpolators[i] = interpolate( from[i], to[i] );\n  \t\t}\n\n  \t\t// surplus values - don't interpolate, but don't exclude them either\n  \t\tfor ( i=len; i<from.length; i+=1 ) {\n  \t\t\tintermediate[i] = from[i];\n  \t\t}\n\n  \t\tfor ( i=len; i<to.length; i+=1 ) {\n  \t\t\tintermediate[i] = to[i];\n  \t\t}\n\n  \t\treturn function ( t ) {\n  \t\t\tvar i = len;\n\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tintermediate[i] = interpolators[i]( t );\n  \t\t\t}\n\n  \t\t\treturn intermediate;\n  \t\t};\n  \t},\n\n  \tobject: function ( from, to ) {\n  \t\tvar properties, len, interpolators, intermediate, prop;\n\n  \t\tif ( !isObject( from ) || !isObject( to ) ) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tproperties = [];\n  \t\tintermediate = {};\n  \t\tinterpolators = {};\n\n  \t\tfor ( prop in from ) {\n  \t\t\tif ( hasOwn.call( from, prop ) ) {\n  \t\t\t\tif ( hasOwn.call( to, prop ) ) {\n  \t\t\t\t\tproperties.push( prop );\n  \t\t\t\t\tinterpolators[ prop ] = interpolate( from[ prop ], to[ prop ] ) || snap( to[ prop ] );\n  \t\t\t\t}\n\n  \t\t\t\telse {\n  \t\t\t\t\tintermediate[ prop ] = from[ prop ];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tfor ( prop in to ) {\n  \t\t\tif ( hasOwn.call( to, prop ) && !hasOwn.call( from, prop ) ) {\n  \t\t\t\tintermediate[ prop ] = to[ prop ];\n  \t\t\t}\n  \t\t}\n\n  \t\tlen = properties.length;\n\n  \t\treturn function ( t ) {\n  \t\t\tvar i = len, prop;\n\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tprop = properties[i];\n\n  \t\t\t\tintermediate[ prop ] = interpolators[ prop ]( t );\n  \t\t\t}\n\n  \t\t\treturn intermediate;\n  \t\t};\n  \t}\n  };\n\n  // TODO: deprecate in future release\n  var deprecations = {\n  \tconstruct: {\n  \t\tdeprecated: 'beforeInit',\n  \t\treplacement: 'onconstruct'\n  \t},\n  \trender: {\n  \t\tdeprecated: 'init',\n  \t\tmessage: 'The \"init\" method has been deprecated ' +\n  \t\t\t'and will likely be removed in a future release. ' +\n  \t\t\t'You can either use the \"oninit\" method which will fire ' +\n  \t\t\t'only once prior to, and regardless of, any eventual ractive ' +\n  \t\t\t'instance being rendered, or if you need to access the ' +\n  \t\t\t'rendered DOM, use \"onrender\" instead. ' +\n  \t\t\t'See http://docs.ractivejs.org/latest/migrating for more information.'\n  \t},\n  \tcomplete: {\n  \t\tdeprecated: 'complete',\n  \t\treplacement: 'oncomplete'\n  \t}\n  };\n\n  var Hook = function Hook ( event ) {\n  \tthis.event = event;\n  \tthis.method = 'on' + event;\n  \tthis.deprecate = deprecations[ event ];\n  };\n\n  Hook.prototype.call = function call ( method, ractive, arg ) {\n  \tif ( ractive[ method ] ) {\n  \t\targ ? ractive[ method ]( arg ) : ractive[ method ]();\n  \t\treturn true;\n  \t}\n  };\n\n  Hook.prototype.fire = function fire ( ractive, arg ) {\n  \tthis.call( this.method, ractive, arg );\n\n  \t// handle deprecations\n  \tif ( !ractive[ this.method ] && this.deprecate && this.call( this.deprecate.deprecated, ractive, arg ) ) {\n  \t\tif ( this.deprecate.message ) {\n  \t\t\twarnIfDebug( this.deprecate.message );\n  \t\t} else {\n  \t\t\twarnIfDebug( 'The method \"%s\" has been deprecated in favor of \"%s\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.', this.deprecate.deprecated, this.deprecate.replacement );\n  \t\t}\n  \t}\n\n  \t// TODO should probably use internal method, in case ractive.fire was overwritten\n  \targ ? ractive.fire( this.event, arg ) : ractive.fire( this.event );\n  };\n\n  function addToArray ( array, value ) {\n  \tvar index = array.indexOf( value );\n\n  \tif ( index === -1 ) {\n  \t\tarray.push( value );\n  \t}\n  }\n\n  function arrayContains ( array, value ) {\n  \tfor ( var i = 0, c = array.length; i < c; i++ ) {\n  \t\tif ( array[i] == value ) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n\n  \treturn false;\n  }\n\n  function arrayContentsMatch ( a, b ) {\n  \tvar i;\n\n  \tif ( !isArray( a ) || !isArray( b ) ) {\n  \t\treturn false;\n  \t}\n\n  \tif ( a.length !== b.length ) {\n  \t\treturn false;\n  \t}\n\n  \ti = a.length;\n  \twhile ( i-- ) {\n  \t\tif ( a[i] !== b[i] ) {\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \treturn true;\n  }\n\n  function ensureArray ( x ) {\n  \tif ( typeof x === 'string' ) {\n  \t\treturn [ x ];\n  \t}\n\n  \tif ( x === undefined ) {\n  \t\treturn [];\n  \t}\n\n  \treturn x;\n  }\n\n  function lastItem ( array ) {\n  \treturn array[ array.length - 1 ];\n  }\n\n  function removeFromArray ( array, member ) {\n  \tif ( !array ) {\n  \t\treturn;\n  \t}\n\n  \tvar index = array.indexOf( member );\n\n  \tif ( index !== -1 ) {\n  \t\tarray.splice( index, 1 );\n  \t}\n  }\n\n  function toArray ( arrayLike ) {\n  \tvar array = [], i = arrayLike.length;\n  \twhile ( i-- ) {\n  \t\tarray[i] = arrayLike[i];\n  \t}\n\n  \treturn array;\n  }\n\n  var _Promise;\n  var PENDING = {};\n  var FULFILLED = {};\n  var REJECTED = {};\n  if ( typeof Promise === 'function' ) {\n  \t// use native Promise\n  \t_Promise = Promise;\n  } else {\n  \t_Promise = function ( callback ) {\n  \t\tvar fulfilledHandlers = [],\n  \t\t\trejectedHandlers = [],\n  \t\t\tstate = PENDING,\n\n  \t\t\tresult,\n  \t\t\tdispatchHandlers,\n  \t\t\tmakeResolver,\n  \t\t\tfulfil,\n  \t\t\treject,\n\n  \t\t\tpromise;\n\n  \t\tmakeResolver = function ( newState ) {\n  \t\t\treturn function ( value ) {\n  \t\t\t\tif ( state !== PENDING ) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tresult = value;\n  \t\t\t\tstate = newState;\n\n  \t\t\t\tdispatchHandlers = makeDispatcher( ( state === FULFILLED ? fulfilledHandlers : rejectedHandlers ), result );\n\n  \t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n  \t\t\t\twait( dispatchHandlers );\n  \t\t\t};\n  \t\t};\n\n  \t\tfulfil = makeResolver( FULFILLED );\n  \t\treject = makeResolver( REJECTED );\n\n  \t\ttry {\n  \t\t\tcallback( fulfil, reject );\n  \t\t} catch ( err ) {\n  \t\t\treject( err );\n  \t\t}\n\n  \t\tpromise = {\n  \t\t\t// `then()` returns a Promise - 2.2.7\n  \t\t\tthen: function ( onFulfilled, onRejected ) {\n  \t\t\t\tvar promise2 = new _Promise( function ( fulfil, reject ) {\n\n  \t\t\t\t\tvar processResolutionHandler = function ( handler, handlers, forward ) {\n\n  \t\t\t\t\t\t// 2.2.1.1\n  \t\t\t\t\t\tif ( typeof handler === 'function' ) {\n  \t\t\t\t\t\t\thandlers.push( function ( p1result ) {\n  \t\t\t\t\t\t\t\tvar x;\n\n  \t\t\t\t\t\t\t\ttry {\n  \t\t\t\t\t\t\t\t\tx = handler( p1result );\n  \t\t\t\t\t\t\t\t\tresolve( promise2, x, fulfil, reject );\n  \t\t\t\t\t\t\t\t} catch ( err ) {\n  \t\t\t\t\t\t\t\t\treject( err );\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t});\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n  \t\t\t\t\t\t\t// are not given\n  \t\t\t\t\t\t\thandlers.push( forward );\n  \t\t\t\t\t\t}\n  \t\t\t\t\t};\n\n  \t\t\t\t\t// 2.2\n  \t\t\t\t\tprocessResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );\n  \t\t\t\t\tprocessResolutionHandler( onRejected, rejectedHandlers, reject );\n\n  \t\t\t\t\tif ( state !== PENDING ) {\n  \t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n  \t\t\t\t\t\twait( dispatchHandlers );\n  \t\t\t\t\t}\n\n  \t\t\t\t});\n\n  \t\t\t\treturn promise2;\n  \t\t\t}\n  \t\t};\n\n  \t\tpromise[ 'catch' ] = function ( onRejected ) {\n  \t\t\treturn this.then( null, onRejected );\n  \t\t};\n\n  \t\treturn promise;\n  \t};\n\n  \t_Promise.all = function ( promises ) {\n  \t\treturn new _Promise( function ( fulfil, reject ) {\n  \t\t\tvar result = [], pending, i, processPromise;\n\n  \t\t\tif ( !promises.length ) {\n  \t\t\t\tfulfil( result );\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tprocessPromise = function ( promise, i ) {\n  \t\t\t\tif ( promise && typeof promise.then === 'function' ) {\n  \t\t\t\t\tpromise.then( function ( value ) {\n  \t\t\t\t\t\tresult[i] = value;\n  \t\t\t\t\t\t--pending || fulfil( result );\n  \t\t\t\t\t}, reject );\n  \t\t\t\t}\n\n  \t\t\t\telse {\n  \t\t\t\t\tresult[i] = promise;\n  \t\t\t\t\t--pending || fulfil( result );\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\tpending = i = promises.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tprocessPromise( promises[i], i );\n  \t\t\t}\n  \t\t});\n  \t};\n\n  \t_Promise.resolve = function ( value ) {\n  \t\treturn new _Promise( function ( fulfil ) {\n  \t\t\tfulfil( value );\n  \t\t});\n  \t};\n\n  \t_Promise.reject = function ( reason ) {\n  \t\treturn new _Promise( function ( fulfil, reject ) {\n  \t\t\treject( reason );\n  \t\t});\n  \t};\n  }\n\n  var Promise$1 = _Promise;\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  function wait ( callback ) {\n  \tsetTimeout( callback, 0 );\n  }\n\n  function makeDispatcher ( handlers, result ) {\n  \treturn function () {\n  \t\tvar handler;\n\n  \t\twhile ( handler = handlers.shift() ) {\n  \t\t\thandler( result );\n  \t\t}\n  \t};\n  }\n\n  function resolve ( promise, x, fulfil, reject ) {\n  \t// Promise Resolution Procedure\n  \tvar then;\n\n  \t// 2.3.1\n  \tif ( x === promise ) {\n  \t\tthrow new TypeError( 'A promise\\'s fulfillment handler cannot return the same promise' );\n  \t}\n\n  \t// 2.3.2\n  \tif ( x instanceof _Promise ) {\n  \t\tx.then( fulfil, reject );\n  \t}\n\n  \t// 2.3.3\n  \telse if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {\n  \t\ttry {\n  \t\t\tthen = x.then; // 2.3.3.1\n  \t\t} catch ( e ) {\n  \t\t\treject( e ); // 2.3.3.2\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// 2.3.3.3\n  \t\tif ( typeof then === 'function' ) {\n  \t\t\tvar called, resolvePromise, rejectPromise;\n\n  \t\t\tresolvePromise = function ( y ) {\n  \t\t\t\tif ( called ) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t\tcalled = true;\n  \t\t\t\tresolve( promise, y, fulfil, reject );\n  \t\t\t};\n\n  \t\t\trejectPromise = function ( r ) {\n  \t\t\t\tif ( called ) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t\tcalled = true;\n  \t\t\t\treject( r );\n  \t\t\t};\n\n  \t\t\ttry {\n  \t\t\t\tthen.call( x, resolvePromise, rejectPromise );\n  \t\t\t} catch ( e ) {\n  \t\t\t\tif ( !called ) { // 2.3.3.3.4.1\n  \t\t\t\t\treject( e ); // 2.3.3.3.4.2\n  \t\t\t\t\tcalled = true;\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\telse {\n  \t\t\tfulfil( x );\n  \t\t}\n  \t}\n\n  \telse {\n  \t\tfulfil( x );\n  \t}\n  }\n\n  var TransitionManager = function TransitionManager ( callback, parent ) {\n  \tthis.callback = callback;\n  \tthis.parent = parent;\n\n  \tthis.intros = [];\n  \tthis.outros = [];\n\n  \tthis.children = [];\n  \tthis.totalChildren = this.outroChildren = 0;\n\n  \tthis.detachQueue = [];\n  \tthis.outrosComplete = false;\n\n  \tif ( parent ) {\n  \t\tparent.addChild( this );\n  \t}\n  };\n\n  TransitionManager.prototype.add = function add ( transition ) {\n  \tvar list = transition.isIntro ? this.intros : this.outros;\n  \tlist.push( transition );\n  };\n\n  TransitionManager.prototype.addChild = function addChild ( child ) {\n  \tthis.children.push( child );\n\n  \tthis.totalChildren += 1;\n  \tthis.outroChildren += 1;\n  };\n\n  TransitionManager.prototype.decrementOutros = function decrementOutros () {\n  \tthis.outroChildren -= 1;\n  \tcheck( this );\n  };\n\n  TransitionManager.prototype.decrementTotal = function decrementTotal () {\n  \tthis.totalChildren -= 1;\n  \tcheck( this );\n  };\n\n  TransitionManager.prototype.detachNodes = function detachNodes () {\n  \tthis.detachQueue.forEach( detach );\n  \tthis.children.forEach( _detachNodes );\n  };\n\n  TransitionManager.prototype.ready = function ready () {\n  \tdetachImmediate( this );\n  };\n\n  TransitionManager.prototype.remove = function remove ( transition ) {\n  \tvar list = transition.isIntro ? this.intros : this.outros;\n  \tremoveFromArray( list, transition );\n  \tcheck( this );\n  };\n\n  TransitionManager.prototype.start = function start () {\n  \tthis.children.forEach( function ( c ) { return c.start(); } );\n  \tthis.intros.concat( this.outros ).forEach( function ( t ) { return t.start(); } );\n  \tthis.ready = true;\n  \tcheck( this );\n  };\n\n  function detach ( element ) {\n  \telement.detach();\n  }\n\n  function _detachNodes ( tm ) { // _ to avoid transpiler quirk\n  \ttm.detachNodes();\n  }\n\n  function check ( tm ) {\n  \tif ( !tm.ready || tm.outros.length || tm.outroChildren ) return;\n\n  \t// If all outros are complete, and we haven't already done this,\n  \t// we notify the parent if there is one, otherwise\n  \t// start detaching nodes\n  \tif ( !tm.outrosComplete ) {\n  \t\ttm.outrosComplete = true;\n\n  \t\tif ( tm.parent && !tm.parent.outrosComplete ) {\n  \t\t\ttm.parent.decrementOutros( tm );\n  \t\t} else {\n  \t\t\ttm.detachNodes();\n  \t\t}\n  \t}\n\n  \t// Once everything is done, we can notify parent transition\n  \t// manager and call the callback\n  \tif ( !tm.intros.length && !tm.totalChildren ) {\n  \t\tif ( typeof tm.callback === 'function' ) {\n  \t\t\ttm.callback();\n  \t\t}\n\n  \t\tif ( tm.parent && !tm.notifiedTotal ) {\n  \t\t\ttm.notifiedTotal = true;\n  \t\t\ttm.parent.decrementTotal();\n  \t\t}\n  \t}\n  }\n\n  // check through the detach queue to see if a node is up or downstream from a\n  // transition and if not, go ahead and detach it\n  function detachImmediate ( manager ) {\n  \tvar queue = manager.detachQueue;\n  \tvar outros = collectAllOutros( manager );\n\n  \tvar i = queue.length, j = 0, node, trans;\n  \tstart: while ( i-- ) {\n  \t\tnode = queue[i].node;\n  \t\tj = outros.length;\n  \t\twhile ( j-- ) {\n  \t\t\ttrans = outros[j].element.node;\n  \t\t\t// check to see if the node is, contains, or is contained by the transitioning node\n  \t\t\tif ( trans === node || trans.contains( node ) || node.contains( trans ) ) continue start;\n  \t\t}\n\n  \t\t// no match, we can drop it\n  \t\tqueue[i].detach();\n  \t\tqueue.splice( i, 1 );\n  \t}\n  }\n\n  function collectAllOutros ( manager, list ) {\n  \tif ( !list ) {\n  \t\tlist = [];\n  \t\tvar parent = manager;\n  \t\twhile ( parent.parent ) parent = parent.parent;\n  \t\treturn collectAllOutros( parent, list );\n  \t} else {\n  \t\tvar i = manager.children.length;\n  \t\twhile ( i-- ) {\n  \t\t\tlist = collectAllOutros( manager.children[i], list );\n  \t\t}\n  \t\tlist = list.concat( manager.outros );\n  \t\treturn list;\n  \t}\n  }\n\n  var changeHook = new Hook( 'change' );\n\n  var batch;\n\n  var runloop = {\n  \tstart: function ( instance, returnPromise ) {\n  \t\tvar promise, fulfilPromise;\n\n  \t\tif ( returnPromise ) {\n  \t\t\tpromise = new Promise$1( function ( f ) { return ( fulfilPromise = f ); } );\n  \t\t}\n\n  \t\tbatch = {\n  \t\t\tpreviousBatch: batch,\n  \t\t\ttransitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),\n  \t\t\tfragments: [],\n  \t\t\ttasks: [],\n  \t\t\timmediateObservers: [],\n  \t\t\tdeferredObservers: [],\n  \t\t\tractives: [],\n  \t\t\tinstance: instance\n  \t\t};\n\n  \t\treturn promise;\n  \t},\n\n  \tend: function () {\n  \t\tflushChanges();\n\n  \t\tif ( !batch.previousBatch ) batch.transitionManager.start();\n\n  \t\tbatch = batch.previousBatch;\n  \t},\n\n  \taddFragment: function ( fragment ) {\n  \t\taddToArray( batch.fragments, fragment );\n  \t},\n\n  \t// TODO: come up with a better way to handle fragments that trigger their own update\n  \taddFragmentToRoot: function ( fragment ) {\n  \t\tif ( !batch ) return;\n\n  \t\tvar b = batch;\n  \t\twhile ( b.previousBatch ) {\n  \t\t\tb = b.previousBatch;\n  \t\t}\n\n  \t\taddToArray( b.fragments, fragment );\n  \t},\n\n  \taddInstance: function ( instance ) {\n  \t\tif ( batch ) addToArray( batch.ractives, instance );\n  \t},\n\n  \taddObserver: function ( observer, defer ) {\n  \t\taddToArray( defer ? batch.deferredObservers : batch.immediateObservers, observer );\n  \t},\n\n  \tregisterTransition: function ( transition ) {\n  \t\ttransition._manager = batch.transitionManager;\n  \t\tbatch.transitionManager.add( transition );\n  \t},\n\n  \t// synchronise node detachments with transition ends\n  \tdetachWhenReady: function ( thing ) {\n  \t\tbatch.transitionManager.detachQueue.push( thing );\n  \t},\n\n  \tscheduleTask: function ( task, postRender ) {\n  \t\tvar _batch;\n\n  \t\tif ( !batch ) {\n  \t\t\ttask();\n  \t\t} else {\n  \t\t\t_batch = batch;\n  \t\t\twhile ( postRender && _batch.previousBatch ) {\n  \t\t\t\t// this can't happen until the DOM has been fully updated\n  \t\t\t\t// otherwise in some situations (with components inside elements)\n  \t\t\t\t// transitions and decorators will initialise prematurely\n  \t\t\t\t_batch = _batch.previousBatch;\n  \t\t\t}\n\n  \t\t\t_batch.tasks.push( task );\n  \t\t}\n  \t}\n  };\n\n  function dispatch ( observer ) {\n  \tobserver.dispatch();\n  }\n\n  function flushChanges () {\n  \tvar which = batch.immediateObservers;\n  \tbatch.immediateObservers = [];\n  \twhich.forEach( dispatch );\n\n  \t// Now that changes have been fully propagated, we can update the DOM\n  \t// and complete other tasks\n  \tvar i = batch.fragments.length;\n  \tvar fragment;\n\n  \twhich = batch.fragments;\n  \tbatch.fragments = [];\n  \tvar ractives = batch.ractives;\n  \tbatch.ractives = [];\n\n  \twhile ( i-- ) {\n  \t\tfragment = which[i];\n\n  \t\t// TODO deprecate this. It's annoying and serves no useful function\n  \t\tvar ractive = fragment.ractive;\n  \t\tif ( Object.keys( ractive.viewmodel.changes ).length ) {\n  \t\t\tchangeHook.fire( ractive, ractive.viewmodel.changes );\n  \t\t}\n  \t\tractive.viewmodel.changes = {};\n  \t\tremoveFromArray( ractives, ractive );\n\n  \t\tfragment.update();\n  \t}\n\n  \ti = ractives.length;\n  \twhile ( i-- ) {\n  \t\tvar ractive$1 = ractives[i];\n  \t\tchangeHook.fire( ractive$1, ractive$1.viewmodel.changes );\n  \t\tractive$1.viewmodel.changes = {};\n  \t}\n\n  \tbatch.transitionManager.ready();\n\n  \twhich = batch.deferredObservers;\n  \tbatch.deferredObservers = [];\n  \twhich.forEach( dispatch );\n\n  \tvar tasks = batch.tasks;\n  \tbatch.tasks = [];\n\n  \tfor ( i = 0; i < tasks.length; i += 1 ) {\n  \t\ttasks[i]();\n  \t}\n\n  \t// If updating the view caused some model blowback - e.g. a triple\n  \t// containing <option> elements caused the binding on the <select>\n  \t// to update - then we start over\n  \tif ( batch.fragments.length || batch.immediateObservers.length || batch.deferredObservers.length || batch.ractives.length || batch.tasks.length ) return flushChanges();\n  }\n\n  var refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n  var splitPattern = /([^\\\\](?:\\\\\\\\)*)\\./;\n  var escapeKeyPattern = /\\\\|\\./g;\n  var unescapeKeyPattern = /((?:\\\\)+)\\1|\\\\(\\.)/g;\n\n  function escapeKey ( key ) {\n  \tif ( typeof key === 'string' ) {\n  \t\treturn key.replace( escapeKeyPattern, '\\\\$&' );\n  \t}\n\n  \treturn key;\n  }\n\n  function normalise ( ref ) {\n  \treturn ref ? ref.replace( refPattern, '.$1' ) : '';\n  }\n\n  function splitKeypathI ( keypath ) {\n  \tvar result = [],\n  \t\tmatch;\n\n  \tkeypath = normalise( keypath );\n\n  \twhile ( match = splitPattern.exec( keypath ) ) {\n  \t\tvar index = match.index + match[1].length;\n  \t\tresult.push( keypath.substr( 0, index ) );\n  \t\tkeypath = keypath.substr( index + 1 );\n  \t}\n\n  \tresult.push(keypath);\n\n  \treturn result;\n  }\n\n  function unescapeKey ( key ) {\n  \tif ( typeof key === 'string' ) {\n  \t\treturn key.replace( unescapeKeyPattern, '$1$2' );\n  \t}\n\n  \treturn key;\n  }\n\n  function bind ( fn, context ) {\n  \tif ( !/this/.test( fn.toString() ) ) return fn;\n\n  \tvar bound = fn.bind( context );\n  \tfor ( var prop in fn ) bound[ prop ] = fn[ prop ];\n\n  \treturn bound;\n  }\n\n  function set ( ractive, pairs ) {\n  \tvar promise = runloop.start( ractive, true );\n\n  \tvar i = pairs.length;\n  \twhile ( i-- ) {\n  \t\tvar ref = pairs[i], model = ref[0], value = ref[1];\n  \t\tif ( typeof value === 'function' ) value = bind( value, ractive );\n  \t\tmodel.set( value );\n  \t}\n\n  \trunloop.end();\n\n  \treturn promise;\n  }\n\n  var star = /\\*/;\n  function gather ( ractive, keypath, base ) {\n  \tif ( base === void 0 ) base = ractive.viewmodel;\n\n  \tif ( star.test( keypath ) ) {\n  \t\treturn base.findMatches( splitKeypathI( keypath ) );\n  \t} else {\n  \t\treturn [ base.joinAll( splitKeypathI( keypath ) ) ];\n  \t}\n  }\n\n  function build ( ractive, keypath, value ) {\n  \tvar sets = [];\n\n  \t// set multiple keypaths in one go\n  \tif ( isObject( keypath ) ) {\n  \t\tvar loop = function ( k ) {\n  \t\t\tif ( keypath.hasOwnProperty( k ) ) {\n  \t\t\t\tsets.push.apply( sets, gather( ractive, k ).map( function ( m ) { return [ m, keypath[k] ]; } ) );\n  \t\t\t}\n  \t\t};\n\n  \t\tfor ( var k in keypath ) loop( k );\n\n  \t}\n  \t// set a single keypath\n  \telse {\n  \t\tsets.push.apply( sets, gather( ractive, keypath ).map( function ( m ) { return [ m, value ]; } ) );\n  \t}\n\n  \treturn sets;\n  }\n\n  var errorMessage = 'Cannot add to a non-numeric value';\n\n  function add ( ractive, keypath, d ) {\n  \tif ( typeof keypath !== 'string' || !isNumeric( d ) ) {\n  \t\tthrow new Error( 'Bad arguments' );\n  \t}\n\n  \tvar sets = build( ractive, keypath, d );\n\n  \treturn set( ractive, sets.map( function ( pair ) {\n  \t\tvar model = pair[0], add = pair[1], value = model.get();\n  \t\tif ( !isNumeric( add ) || !isNumeric( value ) ) throw new Error( errorMessage );\n  \t\treturn [ model, value + add ];\n  \t}));\n  }\n\n  function Ractive$add ( keypath, d ) {\n  \treturn add( this, keypath, ( d === undefined ? 1 : +d ) );\n  }\n\n  var noAnimation = Promise$1.resolve();\n  defineProperty( noAnimation, 'stop', { value: noop });\n\n  var linear = easing.linear;\n\n  function getOptions ( options, instance ) {\n  \toptions = options || {};\n\n  \tvar easing;\n  \tif ( options.easing ) {\n  \t\teasing = typeof options.easing === 'function' ?\n  \t\t\toptions.easing :\n  \t\t\tinstance.easing[ options.easing ];\n  \t}\n\n  \treturn {\n  \t\teasing: easing || linear,\n  \t\tduration: 'duration' in options ? options.duration : 400,\n  \t\tcomplete: options.complete || noop,\n  \t\tstep: options.step || noop\n  \t};\n  }\n\n  function protoAnimate ( ractive, model, to, options ) {\n  \toptions = getOptions( options, ractive );\n  \tvar from = model.get();\n\n  \t// don't bother animating values that stay the same\n  \tif ( isEqual( from, to ) ) {\n  \t\toptions.complete( options.to );\n  \t\treturn noAnimation; // TODO should this have .then and .catch methods?\n  \t}\n\n  \tvar interpolator = interpolate( from, to, ractive, options.interpolator );\n\n  \t// if we can't interpolate the value, set it immediately\n  \tif ( !interpolator ) {\n  \t\trunloop.start();\n  \t\tmodel.set( to );\n  \t\trunloop.end();\n\n  \t\treturn noAnimation;\n  \t}\n\n  \treturn model.animate( from, to, options, interpolator );\n  }\n\n  function Ractive$animate ( keypath, to, options ) {\n  \tif ( typeof keypath === 'object' ) {\n  \t\tvar keys = Object.keys( keypath );\n\n  \t\tthrow new Error( (\"ractive.animate(...) no longer supports objects. Instead of ractive.animate({\\n  \" + (keys.map( function ( key ) { return (\"'\" + key + \"': \" + (keypath[ key ])); } ).join( '\\n  ' )) + \"\\n}, {...}), do\\n\\n\" + (keys.map( function ( key ) { return (\"ractive.animate('\" + key + \"', \" + (keypath[ key ]) + \", {...});\"); } ).join( '\\n' )) + \"\\n\") );\n  \t}\n\n\n  \treturn protoAnimate( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), to, options );\n  }\n\n  var detachHook = new Hook( 'detach' );\n\n  function Ractive$detach () {\n  \tif ( this.isDetached ) {\n  \t\treturn this.el;\n  \t}\n\n  \tif ( this.el ) {\n  \t\tremoveFromArray( this.el.__ractive_instances__, this );\n  \t}\n\n  \tthis.el = this.fragment.detach();\n  \tthis.isDetached = true;\n\n  \tdetachHook.fire( this );\n  \treturn this.el;\n  }\n\n  function Ractive$find ( selector ) {\n  \tif ( !this.el ) throw new Error( (\"Cannot call ractive.find('\" + selector + \"') unless instance is rendered to the DOM\") );\n\n  \treturn this.fragment.find( selector );\n  }\n\n  function sortByDocumentPosition ( node, otherNode ) {\n  \tif ( node.compareDocumentPosition ) {\n  \t\tvar bitmask = node.compareDocumentPosition( otherNode );\n  \t\treturn ( bitmask & 2 ) ? 1 : -1;\n  \t}\n\n  \t// In old IE, we can piggy back on the mechanism for\n  \t// comparing component positions\n  \treturn sortByItemPosition( node, otherNode );\n  }\n\n  function sortByItemPosition ( a, b ) {\n  \tvar ancestryA = getAncestry( a.component || a._ractive.proxy );\n  \tvar ancestryB = getAncestry( b.component || b._ractive.proxy );\n\n  \tvar oldestA = lastItem( ancestryA );\n  \tvar oldestB = lastItem( ancestryB );\n  \tvar mutualAncestor;\n\n  \t// remove items from the end of both ancestries as long as they are identical\n  \t// - the final one removed is the closest mutual ancestor\n  \twhile ( oldestA && ( oldestA === oldestB ) ) {\n  \t\tancestryA.pop();\n  \t\tancestryB.pop();\n\n  \t\tmutualAncestor = oldestA;\n\n  \t\toldestA = lastItem( ancestryA );\n  \t\toldestB = lastItem( ancestryB );\n  \t}\n\n  \t// now that we have the mutual ancestor, we can find which is earliest\n  \toldestA = oldestA.component || oldestA;\n  \toldestB = oldestB.component || oldestB;\n\n  \tvar fragmentA = oldestA.parentFragment;\n  \tvar fragmentB = oldestB.parentFragment;\n\n  \t// if both items share a parent fragment, our job is easy\n  \tif ( fragmentA === fragmentB ) {\n  \t\tvar indexA = fragmentA.items.indexOf( oldestA );\n  \t\tvar indexB = fragmentB.items.indexOf( oldestB );\n\n  \t\t// if it's the same index, it means one contains the other,\n  \t\t// so we see which has the longest ancestry\n  \t\treturn ( indexA - indexB ) || ancestryA.length - ancestryB.length;\n  \t}\n\n  \t// if mutual ancestor is a section, we first test to see which section\n  \t// fragment comes first\n  \tvar fragments = mutualAncestor.iterations;\n  \tif ( fragments ) {\n  \t\tvar indexA$1 = fragments.indexOf( fragmentA );\n  \t\tvar indexB$1 = fragments.indexOf( fragmentB );\n\n  \t\treturn ( indexA$1 - indexB$1 ) || ancestryA.length - ancestryB.length;\n  \t}\n\n  \tthrow new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/ractivejs/ractive/issues - thanks!' );\n  }\n\n  function getParent ( item ) {\n  \tvar parentFragment = item.parentFragment;\n\n  \tif ( parentFragment ) return parentFragment.owner;\n\n  \tif ( item.component && ( parentFragment = item.component.parentFragment ) ) {\n  \t\treturn parentFragment.owner;\n  \t}\n  }\n\n  function getAncestry ( item ) {\n  \tvar ancestry = [ item ];\n  \tvar ancestor = getParent( item );\n\n  \twhile ( ancestor ) {\n  \t\tancestry.push( ancestor );\n  \t\tancestor = getParent( ancestor );\n  \t}\n\n  \treturn ancestry;\n  }\n\n\n  var Query = function Query ( ractive, selector, live, isComponentQuery ) {\n  \tthis.ractive = ractive;\n  \tthis.selector = selector;\n  \tthis.live = live;\n  \tthis.isComponentQuery = isComponentQuery;\n\n  \tthis.result = [];\n\n  \tthis.dirty = true;\n  };\n\n  Query.prototype.add = function add ( item ) {\n  \tthis.result.push( item );\n  \tthis.makeDirty();\n  };\n\n  Query.prototype.cancel = function cancel () {\n  \tvar liveQueries = this._root[ this.isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];\n  \tvar selector = this.selector;\n\n  \tvar index = liveQueries.indexOf( selector );\n\n  \tif ( index !== -1 ) {\n  \t\tliveQueries.splice( index, 1 );\n  \t\tliveQueries[ selector ] = null;\n  \t}\n  };\n\n  Query.prototype.init = function init () {\n  \tthis.dirty = false;\n  };\n\n  Query.prototype.makeDirty = function makeDirty () {\n  \tvar this$1 = this;\n\n  \t\tif ( !this.dirty ) {\n  \t\tthis.dirty = true;\n\n  \t\t// Once the DOM has been updated, ensure the query\n  \t\t// is correctly ordered\n  \t\trunloop.scheduleTask( function () { return this$1.update(); } );\n  \t}\n  };\n\n  Query.prototype.remove = function remove ( nodeOrComponent ) {\n  \tvar index = this.result.indexOf( this.isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );\n  \tif ( index !== -1 ) this.result.splice( index, 1 );\n  };\n\n  Query.prototype.update = function update () {\n  \tthis.result.sort( this.isComponentQuery ? sortByItemPosition : sortByDocumentPosition );\n  \tthis.dirty = false;\n  };\n\n  Query.prototype.test = function test ( item ) {\n  \treturn this.isComponentQuery ?\n  \t\t( !this.selector || item.name === this.selector ) :\n  \t\t( item ? matches( item, this.selector ) : null );\n  };\n\n  function Ractive$findAll ( selector, options ) {\n  \tif ( !this.el ) throw new Error( (\"Cannot call ractive.findAll('\" + selector + \"', ...) unless instance is rendered to the DOM\") );\n\n  \toptions = options || {};\n  \tvar liveQueries = this._liveQueries;\n\n  \t// Shortcut: if we're maintaining a live query with this\n  \t// selector, we don't need to traverse the parallel DOM\n  \tvar query = liveQueries[ selector ];\n  \tif ( query ) {\n  \t\t// Either return the exact same query, or (if not live) a snapshot\n  \t\treturn ( options && options.live ) ? query : query.slice();\n  \t}\n\n  \tquery = new Query( this, selector, !!options.live, false );\n\n  \t// Add this to the list of live queries Ractive needs to maintain,\n  \t// if applicable\n  \tif ( query.live ) {\n  \t\tliveQueries.push( selector );\n  \t\tliveQueries[ '_' + selector ] = query;\n  \t}\n\n  \tthis.fragment.findAll( selector, query );\n\n  \tquery.init();\n  \treturn query.result;\n  }\n\n  function Ractive$findAllComponents ( selector, options ) {\n  \toptions = options || {};\n  \tvar liveQueries = this._liveComponentQueries;\n\n  \t// Shortcut: if we're maintaining a live query with this\n  \t// selector, we don't need to traverse the parallel DOM\n  \tvar query = liveQueries[ selector ];\n  \tif ( query ) {\n  \t\t// Either return the exact same query, or (if not live) a snapshot\n  \t\treturn ( options && options.live ) ? query : query.slice();\n  \t}\n\n  \tquery = new Query( this, selector, !!options.live, true );\n\n  \t// Add this to the list of live queries Ractive needs to maintain,\n  \t// if applicable\n  \tif ( query.live ) {\n  \t\tliveQueries.push( selector );\n  \t\tliveQueries[ '_' + selector ] = query;\n  \t}\n\n  \tthis.fragment.findAllComponents( selector, query );\n\n  \tquery.init();\n  \treturn query.result;\n  }\n\n  function Ractive$findComponent ( selector ) {\n  \treturn this.fragment.findComponent( selector );\n  }\n\n  function Ractive$findContainer ( selector ) {\n  \tif ( this.container ) {\n  \t\tif ( this.container.component && this.container.component.name === selector ) {\n  \t\t\treturn this.container;\n  \t\t} else {\n  \t\t\treturn this.container.findContainer( selector );\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  function Ractive$findParent ( selector ) {\n\n  \tif ( this.parent ) {\n  \t\tif ( this.parent.component && this.parent.component.name === selector ) {\n  \t\t\treturn this.parent;\n  \t\t} else {\n  \t\t\treturn this.parent.findParent ( selector );\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  function enqueue ( ractive, event ) {\n  \tif ( ractive.event ) {\n  \t\tractive._eventQueue.push( ractive.event );\n  \t}\n\n  \tractive.event = event;\n  }\n\n  function dequeue ( ractive ) {\n  \tif ( ractive._eventQueue.length ) {\n  \t\tractive.event = ractive._eventQueue.pop();\n  \t} else {\n  \t\tractive.event = null;\n  \t}\n  }\n\n  var starMaps = {};\n\n  // This function takes a keypath such as 'foo.bar.baz', and returns\n  // all the variants of that keypath that include a wildcard in place\n  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n  // These are then checked against the dependants map (ractive.viewmodel.depsMap)\n  // to see if any pattern observers are downstream of one or more of\n  // these wildcard keypaths (e.g. 'foo.bar.*.status')\n  function getPotentialWildcardMatches ( keypath ) {\n  \tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\n  \tkeys = splitKeypathI( keypath );\n  \tif( !( starMap = starMaps[ keys.length ]) ) {\n  \t\tstarMap = getStarMap( keys.length );\n  \t}\n\n  \tresult = [];\n\n  \tmapper = function ( star, i ) {\n  \t\treturn star ? '*' : keys[i];\n  \t};\n\n  \ti = starMap.length;\n  \twhile ( i-- ) {\n  \t\twildcardKeypath = starMap[i].map( mapper ).join( '.' );\n\n  \t\tif ( !result.hasOwnProperty( wildcardKeypath ) ) {\n  \t\t\tresult.push( wildcardKeypath );\n  \t\t\tresult[ wildcardKeypath ] = true;\n  \t\t}\n  \t}\n\n  \treturn result;\n  }\n\n  // This function returns all the possible true/false combinations for\n  // a given number - e.g. for two, the possible combinations are\n  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n  // It does so by getting all the binary values between 0 and e.g. 11\n  function getStarMap ( num ) {\n  \tvar ones = '', max, binary, starMap, mapper, i, j, l, map;\n\n  \tif ( !starMaps[ num ] ) {\n  \t\tstarMap = [];\n\n  \t\twhile ( ones.length < num ) {\n  \t\t\tones += 1;\n  \t\t}\n\n  \t\tmax = parseInt( ones, 2 );\n\n  \t\tmapper = function ( digit ) {\n  \t\t\treturn digit === '1';\n  \t\t};\n\n  \t\tfor ( i = 0; i <= max; i += 1 ) {\n  \t\t\tbinary = i.toString( 2 );\n  \t\t\twhile ( binary.length < num ) {\n  \t\t\t\tbinary = '0' + binary;\n  \t\t\t}\n\n  \t\t\tmap = [];\n  \t\t\tl = binary.length;\n  \t\t\tfor (j = 0; j < l; j++) {\n  \t\t\t\tmap.push( mapper( binary[j] ) );\n  \t\t\t}\n  \t\t\tstarMap[i] = map;\n  \t\t}\n\n  \t\tstarMaps[ num ] = starMap;\n  \t}\n\n  \treturn starMaps[ num ];\n  }\n\n  var wildcardCache = {};\n\n  function fireEvent ( ractive, eventName, options ) {\n  \tif ( options === void 0 ) options = {};\n\n  \tif ( !eventName ) { return; }\n\n  \tif ( !options.event ) {\n  \t\toptions.event = {\n  \t\t\tname: eventName,\n  \t\t\t// until event not included as argument default\n  \t\t\t_noArg: true\n  \t\t};\n  \t} else {\n  \t\toptions.event.name = eventName;\n  \t}\n\n  \tvar eventNames = getWildcardNames( eventName );\n\n  \treturn fireEventAs( ractive, eventNames, options.event, options.args, true );\n  }\n\n  function getWildcardNames ( eventName ) {\n  \tif ( wildcardCache.hasOwnProperty( eventName ) ) {\n  \t\treturn wildcardCache[ eventName ];\n  \t} else {\n  \t\treturn wildcardCache[ eventName ] = getPotentialWildcardMatches( eventName );\n  \t}\n  }\n\n  function fireEventAs  ( ractive, eventNames, event, args, initialFire ) {\n\n  \tif ( initialFire === void 0 ) initialFire = false;\n\n  \tvar subscribers, i, bubble = true;\n\n  \tenqueue( ractive, event );\n\n  \tfor ( i = eventNames.length; i >= 0; i-- ) {\n  \t\tsubscribers = ractive._subs[ eventNames[ i ] ];\n\n  \t\tif ( subscribers ) {\n  \t\t\tbubble = notifySubscribers( ractive, subscribers, event, args ) && bubble;\n  \t\t}\n  \t}\n\n  \tdequeue( ractive );\n\n  \tif ( ractive.parent && bubble ) {\n\n  \t\tif ( initialFire && ractive.component ) {\n  \t\t\tvar fullName = ractive.component.name + '.' + eventNames[ eventNames.length-1 ];\n  \t\t\teventNames = getWildcardNames( fullName );\n\n  \t\t\tif( event && !event.component ) {\n  \t\t\t\tevent.component = ractive;\n  \t\t\t}\n  \t\t}\n\n  \t\tfireEventAs( ractive.parent, eventNames, event, args );\n  \t}\n\n  \treturn bubble;\n  }\n\n  function notifySubscribers ( ractive, subscribers, event, args ) {\n  \tvar originalEvent = null, stopEvent = false;\n\n  \tif ( event && !event._noArg ) {\n  \t\targs = [ event ].concat( args );\n  \t}\n\n  \t// subscribers can be modified inflight, e.g. \"once\" functionality\n  \t// so we need to copy to make sure everyone gets called\n  \tsubscribers = subscribers.slice();\n\n  \tfor ( var i = 0, len = subscribers.length; i < len; i += 1 ) {\n  \t\tif ( !subscribers[ i ].off && subscribers[ i ].apply( ractive, args ) === false ) {\n  \t\t\tstopEvent = true;\n  \t\t}\n  \t}\n\n  \tif ( event && !event._noArg && stopEvent && ( originalEvent = event.original ) ) {\n  \t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n  \t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n  \t}\n\n  \treturn !stopEvent;\n  }\n\n  function Ractive$fire ( eventName ) {\n  \tvar args = [], len = arguments.length - 1;\n  \twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  \treturn fireEvent( this, eventName, { args: args });\n  }\n\n  function badReference ( key ) {\n  \tthrow new Error( (\"An index or key reference (\" + key + \") cannot have child properties\") );\n  }\n\n  function resolveAmbiguousReference ( fragment, ref ) {\n  \tvar localViewmodel = fragment.findContext().root;\n  \tvar keys = splitKeypathI( ref );\n  \tvar key = keys[0];\n\n  \tvar hasContextChain;\n  \tvar crossedComponentBoundary;\n  \tvar aliases;\n\n  \twhile ( fragment ) {\n  \t\t// repeated fragments\n  \t\tif ( fragment.isIteration ) {\n  \t\t\tif ( key === fragment.parent.keyRef ) {\n  \t\t\t\tif ( keys.length > 1 ) badReference( key );\n  \t\t\t\treturn fragment.context.getKeyModel( fragment.key );\n  \t\t\t}\n\n  \t\t\tif ( key === fragment.parent.indexRef ) {\n  \t\t\t\tif ( keys.length > 1 ) badReference( key );\n  \t\t\t\treturn fragment.context.getKeyModel( fragment.index );\n  \t\t\t}\n  \t\t}\n\n  \t\t// alias node or iteration\n  \t\tif ( ( ( aliases = fragment.owner.aliases ) || ( aliases = fragment.aliases ) ) && aliases.hasOwnProperty( key ) ) {\n  \t\t\tvar model = aliases[ key ];\n\n  \t\t\tif ( keys.length === 1 ) return model;\n  \t\t\telse if ( typeof model.joinAll === 'function' ) {\n  \t\t\t\treturn model.joinAll( keys.slice( 1 ) );\n  \t\t\t}\n  \t\t}\n\n  \t\tif ( fragment.context ) {\n  \t\t\t// TODO better encapsulate the component check\n  \t\t\tif ( !fragment.isRoot || fragment.ractive.component ) hasContextChain = true;\n\n  \t\t\tif ( fragment.context.has( key ) ) {\n  \t\t\t\tif ( crossedComponentBoundary ) {\n  \t\t\t\t\treturn localViewmodel.createLink( key, fragment.context.joinKey( keys.shift() ), key ).joinAll( keys );\n  \t\t\t\t}\n\n  \t\t\t\treturn fragment.context.joinAll( keys );\n  \t\t\t}\n  \t\t}\n\n  \t\tif ( fragment.componentParent && !fragment.ractive.isolated ) {\n  \t\t\t// ascend through component boundary\n  \t\t\tfragment = fragment.componentParent;\n  \t\t\tcrossedComponentBoundary = true;\n  \t\t} else {\n  \t\t\tfragment = fragment.parent;\n  \t\t}\n  \t}\n\n  \tif ( !hasContextChain ) {\n  \t\treturn localViewmodel.joinAll( keys );\n  \t}\n  }\n\n  var stack = [];\n  var captureGroup;\n\n  function startCapturing () {\n  \tstack.push( captureGroup = [] );\n  }\n\n  function stopCapturing () {\n  \tvar dependencies = stack.pop();\n  \tcaptureGroup = stack[ stack.length - 1 ];\n  \treturn dependencies;\n  }\n\n  function capture ( model ) {\n  \tif ( captureGroup ) {\n  \t\tcaptureGroup.push( model );\n  \t}\n  }\n\n  var KeyModel = function KeyModel ( key, parent ) {\n  \tthis.value = key;\n  \tthis.isReadonly = this.isKey = true;\n  \tthis.deps = [];\n  \tthis.links = [];\n  \tthis.parent = parent;\n  };\n\n  KeyModel.prototype.get = function get ( shouldCapture ) {\n  \tif ( shouldCapture ) capture( this );\n  \treturn unescapeKey( this.value );\n  };\n\n  KeyModel.prototype.getKeypath = function getKeypath () {\n  \treturn unescapeKey( this.value );\n  };\n\n  KeyModel.prototype.rebinding = function rebinding ( next, previous ) {\n  \tvar this$1 = this;\n\n  \t\tvar i = this.deps.length;\n  \twhile ( i-- ) this$1.deps[i].rebinding( next, previous, false );\n\n  \ti = this.links.length;\n  \twhile ( i-- ) this$1.links[i].rebinding( next, previous, false );\n  };\n\n  KeyModel.prototype.register = function register ( dependant ) {\n  \tthis.deps.push( dependant );\n  };\n\n  KeyModel.prototype.registerLink = function registerLink ( link ) {\n  \taddToArray( this.links, link );\n  };\n\n  KeyModel.prototype.unregister = function unregister ( dependant ) {\n  \tremoveFromArray( this.deps, dependant );\n  };\n\n  KeyModel.prototype.unregisterLink = function unregisterLink ( link ) {\n  \tremoveFromArray( this.links, link );\n  };\n\n  function bind$1               ( x ) { x.bind(); }\n  function cancel             ( x ) { x.cancel(); }\n  function handleChange       ( x ) { x.handleChange(); }\n  function mark               ( x ) { x.mark(); }\n  function marked             ( x ) { x.marked(); }\n  function notifiedUpstream   ( x ) { x.notifiedUpstream(); }\n  function render             ( x ) { x.render(); }\n  function teardown           ( x ) { x.teardown(); }\n  function unbind             ( x ) { x.unbind(); }\n  function unrender           ( x ) { x.unrender(); }\n  function unrenderAndDestroy ( x ) { x.unrender( true ); }\n  function update             ( x ) { x.update(); }\n  function toString$1           ( x ) { return x.toString(); }\n  function toEscapedString    ( x ) { return x.toString( true ); }\n\n  var KeypathModel = function KeypathModel ( parent, ractive ) {\n  \tthis.parent = parent;\n  \tthis.ractive = ractive;\n  \tthis.value = ractive ? parent.getKeypath( ractive ) : parent.getKeypath();\n  \tthis.deps = [];\n  \tthis.children = {};\n  \tthis.isReadonly = this.isKeypath = true;\n  };\n\n  KeypathModel.prototype.get = function get ( shouldCapture ) {\n  \tif ( shouldCapture ) capture( this );\n  \treturn this.value;\n  };\n\n  KeypathModel.prototype.getChild = function getChild ( ractive ) {\n  \tif ( !( ractive._guid in this.children ) ) {\n  \t\tvar model = new KeypathModel( this.parent, ractive );\n  \t\tthis.children[ ractive._guid ] = model;\n  \t\tmodel.owner = this;\n  \t}\n  \treturn this.children[ ractive._guid ];\n  };\n\n  KeypathModel.prototype.getKeypath = function getKeypath () {\n  \treturn this.value;\n  };\n\n  KeypathModel.prototype.handleChange = function handleChange$1 () {\n  \tvar this$1 = this;\n\n  \t\tvar keys = Object.keys( this.children );\n  \tvar i = keys.length;\n  \twhile ( i-- ) {\n  \t\tthis$1.children[ keys[i] ].handleChange();\n  \t}\n\n  \tthis.deps.forEach( handleChange );\n  };\n\n  KeypathModel.prototype.rebindChildren = function rebindChildren ( next ) {\n  \tvar this$1 = this;\n\n  \t\tvar keys = Object.keys( this.children );\n  \tvar i = keys.length;\n  \twhile ( i-- ) {\n  \t\tvar child = this$1.children[keys[i]];\n  \t\tchild.value = next.getKeypath( child.ractive );\n  \t\tchild.handleChange();\n  \t}\n  };\n\n  KeypathModel.prototype.rebinding = function rebinding ( next, previous ) {\n  \tvar this$1 = this;\n\n  \t\tvar model = next ? next.getKeypathModel( this.ractive ) : undefined;\n\n  \tvar keys = Object.keys( this.children );\n  \tvar i = keys.length;\n  \twhile ( i-- ) {\n  \t\tthis$1.children[ keys[i] ].rebinding( next, previous, false );\n  \t}\n\n  \ti = this.deps.length;\n  \twhile ( i-- ) {\n  \t\tthis$1.deps[i].rebinding( model, this$1, false );\n  \t}\n  };\n\n  KeypathModel.prototype.register = function register ( dep ) {\n  \tthis.deps.push( dep );\n  };\n\n  KeypathModel.prototype.removeChild = function removeChild( model ) {\n  \tif ( model.ractive ) delete this.children[ model.ractive._guid ];\n  };\n\n  KeypathModel.prototype.teardown = function teardown () {\n  \tvar this$1 = this;\n\n  \t\tif ( this.owner ) this.owner.removeChild( this );\n\n  \tvar keys = Object.keys( this.children );\n  \tvar i = keys.length;\n  \twhile ( i-- ) {\n  \t\tthis$1.children[ keys[i] ].teardown();\n  \t}\n  };\n\n  KeypathModel.prototype.unregister = function unregister ( dep ) {\n  \tremoveFromArray( this.deps, dep );\n  \tif ( !this.deps.length ) this.teardown();\n  };\n\n  var hasProp = Object.prototype.hasOwnProperty;\n\n  var shuffleTasks = { early: [], mark: [] };\n  var registerQueue = { early: [], mark: [] };\n\n  var ModelBase = function ModelBase ( parent ) {\n  \tthis.deps = [];\n\n  \tthis.children = [];\n  \tthis.childByKey = {};\n  \tthis.links = [];\n\n  \tthis.keyModels = {};\n\n  \tthis.unresolved = [];\n  \tthis.unresolvedByKey = {};\n\n  \tthis.bindings = [];\n  \tthis.patternObservers = [];\n\n  \tif ( parent ) {\n  \t\tthis.parent = parent;\n  \t\tthis.root = parent.root;\n  \t}\n  };\n\n  ModelBase.prototype.addUnresolved = function addUnresolved ( key, resolver ) {\n  \tif ( !this.unresolvedByKey[ key ] ) {\n  \t\tthis.unresolved.push( key );\n  \t\tthis.unresolvedByKey[ key ] = [];\n  \t}\n\n  \tthis.unresolvedByKey[ key ].push( resolver );\n  };\n\n  ModelBase.prototype.addShuffleTask = function addShuffleTask ( task, stage ) { if ( stage === void 0 ) stage = 'early';\n\n  \tshuffleTasks[stage].push( task ); };\n  ModelBase.prototype.addShuffleRegister = function addShuffleRegister ( item, stage ) { if ( stage === void 0 ) stage = 'early';\n\n  \tregisterQueue[stage].push({ model: this, item: item }); };\n\n  ModelBase.prototype.clearUnresolveds = function clearUnresolveds ( specificKey ) {\n  \tvar this$1 = this;\n\n  \t\tvar i = this.unresolved.length;\n\n  \twhile ( i-- ) {\n  \t\tvar key = this$1.unresolved[i];\n\n  \t\tif ( specificKey && key !== specificKey ) continue;\n\n  \t\tvar resolvers = this$1.unresolvedByKey[ key ];\n  \t\tvar hasKey = this$1.has( key );\n\n  \t\tvar j = resolvers.length;\n  \t\twhile ( j-- ) {\n  \t\t\tif ( hasKey ) resolvers[j].attemptResolution();\n  \t\t\tif ( resolvers[j].resolved ) resolvers.splice( j, 1 );\n  \t\t}\n\n  \t\tif ( !resolvers.length ) {\n  \t\t\tthis$1.unresolved.splice( i, 1 );\n  \t\t\tthis$1.unresolvedByKey[ key ] = null;\n  \t\t}\n  \t}\n  };\n\n  ModelBase.prototype.findMatches = function findMatches ( keys ) {\n  \tvar len = keys.length;\n\n  \tvar existingMatches = [ this ];\n  \tvar matches;\n  \tvar i;\n\n  \tvar loop = function (  ) {\n  \t\tvar key = keys[i];\n\n  \t\tif ( key === '*' ) {\n  \t\t\tmatches = [];\n  \t\t\texistingMatches.forEach( function ( model ) {\n  \t\t\t\tmatches.push.apply( matches, model.getValueChildren( model.get() ) );\n  \t\t\t});\n  \t\t} else {\n  \t\t\tmatches = existingMatches.map( function ( model ) { return model.joinKey( key ); } );\n  \t\t}\n\n  \t\texistingMatches = matches;\n  \t};\n\n  \t\tfor ( i = 0; i < len; i += 1 ) loop(  );\n\n  \treturn matches;\n  };\n\n  ModelBase.prototype.getKeyModel = function getKeyModel ( key, skip ) {\n  \tif ( key !== undefined && !skip ) return this.parent.getKeyModel( key, true );\n\n  \tif ( !( key in this.keyModels ) ) this.keyModels[ key ] = new KeyModel( escapeKey( key ), this );\n\n  \treturn this.keyModels[ key ];\n  };\n\n  ModelBase.prototype.getKeypath = function getKeypath ( ractive ) {\n  \tif ( ractive !== this.ractive && this._link ) return this._link.target.getKeypath( ractive );\n\n  \tif ( !this.keypath ) {\n  \t\tthis.keypath = this.parent.isRoot ? this.key : (\"\" + (this.parent.getKeypath( ractive )) + \".\" + (escapeKey( this.key )));\n  \t}\n\n  \treturn this.keypath;\n  };\n\n  ModelBase.prototype.getValueChildren = function getValueChildren ( value ) {\n  \tvar this$1 = this;\n\n  \t\tvar children;\n  \tif ( isArray( value ) ) {\n  \t\tchildren = [];\n  \t\tif ( 'length' in this && this.length !== value.length ) {\n  \t\t\tchildren.push( this.joinKey( 'length' ) );\n  \t\t}\n  \t\tvalue.forEach( function ( m, i ) {\n  \t\t\tchildren.push( this$1.joinKey( i ) );\n  \t\t});\n  \t}\n\n  \telse if ( isObject( value ) || typeof value === 'function' ) {\n  \t\tchildren = Object.keys( value ).map( function ( key ) { return this$1.joinKey( key ); } );\n  \t}\n\n  \telse if ( value != null ) {\n  \t\treturn [];\n  \t}\n\n  \treturn children;\n  };\n\n  ModelBase.prototype.getVirtual = function getVirtual ( shouldCapture ) {\n  \tvar this$1 = this;\n\n  \t\tvar value = this.get( shouldCapture, { virtual: false } );\n  \tif ( isObject( value ) ) {\n  \t\tvar result = isArray( value ) ? [] : {};\n\n  \t\tvar keys = Object.keys( value );\n  \t\tvar i = keys.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar child = this$1.childByKey[ keys[i] ];\n  \t\t\tif ( !child ) result[ keys[i] ] = value[ keys[i] ];\n  \t\t\telse if ( child._link ) result[ keys[i] ] = child._link.getVirtual();\n  \t\t\telse result[ keys[i] ] = child.getVirtual();\n  \t\t}\n\n  \t\ti = this.children.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar child$1 = this$1.children[i];\n  \t\t\tif ( !( child$1.key in result ) && child$1._link ) {\n  \t\t\t\tresult[ child$1.key ] = child$1._link.getVirtual();\n  \t\t\t}\n  \t\t}\n\n  \t\treturn result;\n  \t} else return value;\n  };\n\n  ModelBase.prototype.has = function has ( key ) {\n  \tif ( this._link ) return this._link.has( key );\n\n  \tvar value = this.get();\n  \tif ( !value ) return false;\n\n  \tkey = unescapeKey( key );\n  \tif ( hasProp.call( value, key ) ) return true;\n\n  \t// We climb up the constructor chain to find if one of them contains the key\n  \tvar constructor = value.constructor;\n  \twhile ( constructor !== Function && constructor !== Array && constructor !== Object ) {\n  \t\tif ( hasProp.call( constructor.prototype, key ) ) return true;\n  \t\tconstructor = constructor.constructor;\n  \t}\n\n  \treturn false;\n  };\n\n  ModelBase.prototype.joinAll = function joinAll ( keys, opts ) {\n  \tvar model = this;\n  \tfor ( var i = 0; i < keys.length; i += 1 ) {\n  \t\tif ( opts && opts.lastLink === false && i + 1 === keys.length && model.childByKey[keys[i]] && model.childByKey[keys[i]]._link ) return model.childByKey[keys[i]];\n  \t\tmodel = model.joinKey( keys[i], opts );\n  \t}\n\n  \treturn model;\n  };\n\n  ModelBase.prototype.notifyUpstream = function notifyUpstream () {\n  \tvar parent = this.parent, path = [ this.key ];\n  \twhile ( parent ) {\n  \t\tif ( parent.patternObservers.length ) parent.patternObservers.forEach( function ( o ) { return o.notify( path.slice() ); } );\n  \t\tpath.unshift( parent.key );\n  \t\tparent.links.forEach( notifiedUpstream );\n  \t\tparent.deps.forEach( handleChange );\n  \t\tparent = parent.parent;\n  \t}\n  };\n\n  ModelBase.prototype.rebinding = function rebinding ( next, previous, safe ) {\n  \t// tell the deps to move to the new target\n  \tvar this$1 = this;\n\n  \t\tvar i = this.deps.length;\n  \twhile ( i-- ) {\n  \t\tif ( this$1.deps[i].rebinding ) this$1.deps[i].rebinding( next, previous, safe );\n  \t}\n\n  \ti = this.links.length;\n  \twhile ( i-- ) {\n  \t\tvar link = this$1.links[i];\n  \t\t// only relink the root of the link tree\n  \t\tif ( link.owner._link ) link.relinking( next, true, safe );\n  \t}\n\n  \ti = this.children.length;\n  \twhile ( i-- ) {\n  \t\tvar child = this$1.children[i];\n  \t\tchild.rebinding( next ? next.joinKey( child.key ) : undefined, child, safe );\n  \t}\n\n  \ti = this.unresolved.length;\n  \twhile ( i-- ) {\n  \t\tvar unresolved = this$1.unresolvedByKey[ this$1.unresolved[i] ];\n  \t\tvar c = unresolved.length;\n  \t\twhile ( c-- ) {\n  \t\t\tunresolved[c].rebinding( next, previous );\n  \t\t}\n  \t}\n\n  \tif ( this.keypathModel ) this.keypathModel.rebinding( next, previous, false );\n\n  \ti = this.bindings.length;\n  \twhile ( i-- ) {\n  \t\tthis$1.bindings[i].rebinding( next, previous, safe );\n  \t}\n  };\n\n  ModelBase.prototype.register = function register ( dep ) {\n  \tthis.deps.push( dep );\n  };\n\n  ModelBase.prototype.registerChange = function registerChange ( key, value ) {\n  \tif ( !this.isRoot ) {\n  \t\tthis.root.registerChange( key, value );\n  \t} else {\n  \t\tthis.changes[ key ] = value;\n  \t\trunloop.addInstance( this.root.ractive );\n  \t}\n  };\n\n  ModelBase.prototype.registerLink = function registerLink ( link ) {\n  \taddToArray( this.links, link );\n  };\n\n  ModelBase.prototype.registerPatternObserver = function registerPatternObserver ( observer ) {\n  \tthis.patternObservers.push( observer );\n  \tthis.register( observer );\n  };\n\n  ModelBase.prototype.registerTwowayBinding = function registerTwowayBinding ( binding ) {\n  \tthis.bindings.push( binding );\n  };\n\n  ModelBase.prototype.removeUnresolved = function removeUnresolved ( key, resolver ) {\n  \tvar resolvers = this.unresolvedByKey[ key ];\n\n  \tif ( resolvers ) {\n  \t\tremoveFromArray( resolvers, resolver );\n  \t}\n  };\n\n  ModelBase.prototype.shuffled = function shuffled () {\n  \tvar this$1 = this;\n\n  \t\tvar i = this.children.length;\n  \twhile ( i-- ) {\n  \t\tthis$1.children[i].shuffled();\n  \t}\n  \tif ( this.wrapper ) {\n  \t\tthis.wrapper.teardown();\n  \t\tthis.wrapper = null;\n  \t\tthis.rewrap = true;\n  \t}\n  };\n\n  ModelBase.prototype.unregister = function unregister ( dependant ) {\n  \tremoveFromArray( this.deps, dependant );\n  };\n\n  ModelBase.prototype.unregisterLink = function unregisterLink ( link ) {\n  \tremoveFromArray( this.links, link );\n  };\n\n  ModelBase.prototype.unregisterPatternObserver = function unregisterPatternObserver ( observer ) {\n  \tremoveFromArray( this.patternObservers, observer );\n  \tthis.unregister( observer );\n  };\n\n  ModelBase.prototype.unregisterTwowayBinding = function unregisterTwowayBinding ( binding ) {\n  \tremoveFromArray( this.bindings, binding );\n  };\n\n  ModelBase.prototype.updateFromBindings = function updateFromBindings$1 ( cascade ) {\n  \tvar this$1 = this;\n\n  \t\tvar i = this.bindings.length;\n  \twhile ( i-- ) {\n  \t\tvar value = this$1.bindings[i].getValue();\n  \t\tif ( value !== this$1.value ) this$1.set( value );\n  \t}\n\n  \t// check for one-way bindings if there are no two-ways\n  \tif ( !this.bindings.length ) {\n  \t\tvar oneway = findBoundValue( this.deps );\n  \t\tif ( oneway && oneway.value !== this.value ) this.set( oneway.value );\n  \t}\n\n  \tif ( cascade ) {\n  \t\tthis.children.forEach( updateFromBindings );\n  \t\tthis.links.forEach( updateFromBindings );\n  \t\tif ( this._link ) this._link.updateFromBindings( cascade );\n  \t}\n  };\n\n  function updateFromBindings ( model ) {\n  \tmodel.updateFromBindings( true );\n  }\n\n  function findBoundValue( list ) {\n  \tvar i = list.length;\n  \twhile ( i-- ) {\n  \t\tif ( list[i].bound ) {\n  \t\t\tvar owner = list[i].owner;\n  \t\t\tif ( owner ) {\n  \t\t\t\tvar value = owner.name === 'checked' ?\n  \t\t\t\t\towner.node.checked :\n  \t\t\t\t\towner.node.value;\n  \t\t\t\treturn { value: value };\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  function fireShuffleTasks ( stage ) {\n  \tif ( !stage ) {\n  \t\tfireShuffleTasks( 'early' );\n  \t\tfireShuffleTasks( 'mark' );\n  \t} else {\n  \t\tvar tasks = shuffleTasks[stage];\n  \t\tshuffleTasks[stage] = [];\n  \t\tvar i = tasks.length;\n  \t\twhile ( i-- ) tasks[i]();\n\n  \t\tvar register = registerQueue[stage];\n  \t\tregisterQueue[stage] = [];\n  \t\ti = register.length;\n  \t\twhile ( i-- ) register[i].model.register( register[i].item );\n  \t}\n  }\n\n  KeyModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\n  KeyModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\n  KeypathModel.prototype.addShuffleTask = ModelBase.prototype.addShuffleTask;\n  KeypathModel.prototype.addShuffleRegister = ModelBase.prototype.addShuffleRegister;\n\n  // this is the dry method of checking to see if a rebind applies to\n  // a particular keypath because in some cases, a dep may be bound\n  // directly to a particular keypath e.g. foo.bars.0.baz and need\n  // to avoid getting kicked to foo.bars.1.baz if foo.bars is unshifted\n  function rebindMatch ( template, next, previous ) {\n  \tvar keypath = template.r || template;\n\n  \t// no valid keypath, go with next\n  \tif ( !keypath || typeof keypath !== 'string' ) return next;\n\n  \t// completely contextual ref, go with next\n  \tif ( keypath === '.' || keypath[0] === '@' || (next || previous).isKey || (next || previous).isKeypath ) return next;\n\n  \tvar parts = keypath.split( '/' );\n  \tvar keys = splitKeypathI( parts[ parts.length - 1 ] );\n\n  \t// check the keypath against the model keypath to see if it matches\n  \tvar model = next || previous;\n  \tvar i = keys.length;\n  \tvar match = true, shuffling = false;\n\n  \twhile ( model && i-- ) {\n  \t\tif ( model.shuffling ) shuffling = true;\n  \t\t// non-strict comparison to account for indices in keypaths\n  \t\tif ( keys[i] != model.key ) match = false;\n  \t\tmodel = model.parent;\n  \t}\n\n  \t// next is undefined, but keypath is shuffling and previous matches\n  \tif ( !next && match && shuffling ) return previous;\n  \t// next is defined, but doesn't match the keypath\n  \telse if ( next && !match && shuffling ) return previous;\n  \telse return next;\n  }\n\n  var LinkModel = (function (ModelBase) {\n  \tfunction LinkModel ( parent, owner, target, key ) {\n  \t\tModelBase.call( this, parent );\n\n  \t\tthis.owner = owner;\n  \t\tthis.target = target;\n  \t\tthis.key = key === undefined ? owner.key : key;\n  \t\tif ( owner.isLink ) this.sourcePath = \"\" + (owner.sourcePath) + \".\" + (this.key);\n\n  \t\ttarget.registerLink( this );\n\n  \t\tthis.isReadonly = parent.isReadonly;\n\n  \t\tthis.isLink = true;\n  \t}\n\n  \tLinkModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n  \tLinkModel.prototype.constructor = LinkModel;\n\n  \tLinkModel.prototype.animate = function animate ( from, to, options, interpolator ) {\n  \t\tthis.target.animate( from, to, options, interpolator );\n  \t};\n\n  \tLinkModel.prototype.applyValue = function applyValue ( value ) {\n  \t\tthis.target.applyValue( value );\n  \t};\n\n  \tLinkModel.prototype.get = function get ( shouldCapture, opts ) {\n  \t\tif ( shouldCapture ) {\n  \t\t\tcapture( this );\n\n  \t\t\t// may need to tell the target to unwrap\n  \t\t\topts = opts || {};\n  \t\t\topts.unwrap = true;\n  \t\t}\n\n  \t\treturn this.target.get( false, opts );\n  \t};\n\n  \tLinkModel.prototype.getKeypath = function getKeypath ( ractive ) {\n  \t\tif ( ractive && ractive !== this.root.ractive ) return this.target.getKeypath( ractive );\n\n  \t\treturn ModelBase.prototype.getKeypath.call( this, ractive );\n  \t};\n\n  \tLinkModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {\n  \t\tif ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );\n  \t\tif ( ractive && ractive !== this.root.ractive ) return this.keypathModel.getChild( ractive );\n  \t\treturn this.keypathModel;\n  \t};\n\n  \tLinkModel.prototype.handleChange = function handleChange$1 () {\n  \t\tthis.deps.forEach( handleChange );\n  \t\tthis.links.forEach( handleChange );\n  \t\tthis.notifyUpstream();\n  \t};\n\n  \tLinkModel.prototype.joinKey = function joinKey ( key ) {\n  \t\t// TODO: handle nested links\n  \t\tif ( key === undefined || key === '' ) return this;\n\n  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n  \t\t\tvar child = new LinkModel( this, this, this.target.joinKey( key ), key );\n  \t\t\tthis.children.push( child );\n  \t\t\tthis.childByKey[ key ] = child;\n  \t\t}\n\n  \t\treturn this.childByKey[ key ];\n  \t};\n\n  \tLinkModel.prototype.mark = function mark () {\n  \t\tthis.target.mark();\n  \t};\n\n  \tLinkModel.prototype.marked = function marked$1 () {\n  \t\tthis.links.forEach( marked );\n\n  \t\tthis.deps.forEach( handleChange );\n  \t\tthis.clearUnresolveds();\n  \t};\n\n  \tLinkModel.prototype.notifiedUpstream = function notifiedUpstream$1 () {\n  \t\tthis.links.forEach( notifiedUpstream );\n  \t\tthis.deps.forEach( handleChange );\n  \t};\n\n  \tLinkModel.prototype.relinked = function relinked () {\n  \t\tthis.target.registerLink( this );\n  \t\tthis.children.forEach( function ( c ) { return c.relinked(); } );\n  \t};\n\n  \tLinkModel.prototype.relinking = function relinking ( target, root, safe ) {\n  \t\tvar this$1 = this;\n\n  \t\tif ( root && this.sourcePath ) target = rebindMatch( this.sourcePath, target, this.target );\n  \t\tif ( !target || this.target === target ) return;\n\n  \t\tthis.target.unregisterLink( this );\n  \t\tif ( this.keypathModel ) this.keypathModel.rebindChildren( target );\n\n  \t\tthis.target = target;\n  \t\tthis.children.forEach( function ( c ) {\n  \t\t\tc.relinking( target.joinKey( c.key ), false, safe );\n  \t\t});\n\n  \t\tif ( root ) this.addShuffleTask( function () {\n  \t\t\tthis$1.relinked();\n  \t\t\tif ( !safe ) this$1.notifyUpstream();\n  \t\t});\n  \t};\n\n  \tLinkModel.prototype.set = function set ( value ) {\n  \t\tthis.target.set( value );\n  \t};\n\n  \tLinkModel.prototype.shuffle = function shuffle ( newIndices ) {\n  \t\t// watch for extra shuffles caused by a shuffle in a downstream link\n  \t\tvar this$1 = this;\n\n  \t\tif ( this.shuffling ) return;\n\n  \t\t// let the real model handle firing off shuffles\n  \t\tif ( !this.target.shuffling ) {\n  \t\t\tthis.target.shuffle( newIndices );\n  \t\t} else {\n  \t\t\tthis.shuffling = true;\n\n  \t\t\tvar i = newIndices.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tvar idx = newIndices[ i ];\n  \t\t\t\t// nothing is actually changing, so move in the index and roll on\n  \t\t\t\tif ( i === idx ) {\n  \t\t\t\t\tcontinue;\n  \t\t\t\t}\n\n  \t\t\t\t// rebind the children on i to idx\n  \t\t\t\tif ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );\n\n  \t\t\t\tif ( !~idx && this$1.keyModels[ i ] ) {\n  \t\t\t\t\tthis$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );\n  \t\t\t\t} else if ( ~idx && this$1.keyModels[ i ] ) {\n  \t\t\t\t\tif ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );\n  \t\t\t\t\tthis$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tvar upstream = this.source().length !== this.source().value.length;\n\n  \t\t\tthis.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );\n\n  \t\t\ti = this.deps.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tif ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );\n  \t\t\t}\n\n  \t\t\tthis.marked();\n\n  \t\t\tif ( upstream ) this.notifyUpstream();\n\n  \t\t\tthis.shuffling = false;\n  \t\t}\n\n  \t};\n\n  \tLinkModel.prototype.source = function source () {\n  \t\tif ( this.target.source ) return this.target.source();\n  \t\telse return this.target;\n  \t};\n\n  \tLinkModel.prototype.teardown = function teardown$1 () {\n  \t\tif ( this._link ) this._link.teardown();\n  \t\tthis.children.forEach( teardown );\n  \t};\n\n  \treturn LinkModel;\n  }(ModelBase));\n\n  ModelBase.prototype.link = function link ( model, keypath ) {\n  \tvar lnk = this._link || new LinkModel( this.parent, this, model, this.key );\n  \tlnk.sourcePath = keypath;\n  \tif ( this._link ) this._link.relinking( model, true, false );\n  \tthis.rebinding( lnk, this, false );\n  \tfireShuffleTasks();\n\n  \tvar unresolved = !this._link;\n  \tthis._link = lnk;\n  \tif ( unresolved ) this.parent.clearUnresolveds();\n  \tlnk.marked();\n  \treturn lnk;\n  };\n\n  ModelBase.prototype.unlink = function unlink () {\n  \tif ( this._link ) {\n  \t\tvar ln = this._link;\n  \t\tthis._link = undefined;\n  \t\tln.rebinding( this, this._link );\n  \t\tfireShuffleTasks();\n  \t\tln.teardown();\n  \t}\n  };\n\n  var requestAnimationFrame;\n\n  // If window doesn't exist, we don't need requestAnimationFrame\n  if ( !win ) {\n  \trequestAnimationFrame = null;\n  } else {\n  \t// https://gist.github.com/paulirish/1579671\n  \t(function(vendors, lastTime, win) {\n\n  \t\tvar x, setTimeout;\n\n  \t\tif ( win.requestAnimationFrame ) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor ( x = 0; x < vendors.length && !win.requestAnimationFrame; ++x ) {\n  \t\t\twin.requestAnimationFrame = win[vendors[x]+'RequestAnimationFrame'];\n  \t\t}\n\n  \t\tif ( !win.requestAnimationFrame ) {\n  \t\t\tsetTimeout = win.setTimeout;\n\n  \t\t\twin.requestAnimationFrame = function(callback) {\n  \t\t\t\tvar currTime, timeToCall, id;\n\n  \t\t\t\tcurrTime = Date.now();\n  \t\t\t\ttimeToCall = Math.max( 0, 16 - (currTime - lastTime ) );\n  \t\t\t\tid = setTimeout( function() { callback(currTime + timeToCall); }, timeToCall );\n\n  \t\t\t\tlastTime = currTime + timeToCall;\n  \t\t\t\treturn id;\n  \t\t\t};\n  \t\t}\n\n  \t}( vendors, 0, win ));\n\n  \trequestAnimationFrame = win.requestAnimationFrame;\n  }\n\n  var rAF = requestAnimationFrame;\n\n  var getTime = ( win && win.performance && typeof win.performance.now === 'function' ) ?\n  \tfunction () { return win.performance.now(); } :\n  \tfunction () { return Date.now(); };\n\n  // TODO what happens if a transition is aborted?\n\n  var tickers = [];\n  var running = false;\n\n  function tick () {\n  \trunloop.start();\n\n  \tvar now = getTime();\n\n  \tvar i;\n  \tvar ticker;\n\n  \tfor ( i = 0; i < tickers.length; i += 1 ) {\n  \t\tticker = tickers[i];\n\n  \t\tif ( !ticker.tick( now ) ) {\n  \t\t\t// ticker is complete, remove it from the stack, and decrement i so we don't miss one\n  \t\t\ttickers.splice( i--, 1 );\n  \t\t}\n  \t}\n\n  \trunloop.end();\n\n  \tif ( tickers.length ) {\n  \t\trAF( tick );\n  \t} else {\n  \t\trunning = false;\n  \t}\n  }\n\n  var Ticker = function Ticker ( options ) {\n  \tthis.duration = options.duration;\n  \tthis.step = options.step;\n  \tthis.complete = options.complete;\n  \tthis.easing = options.easing;\n\n  \tthis.start = getTime();\n  \tthis.end = this.start + this.duration;\n\n  \tthis.running = true;\n\n  \ttickers.push( this );\n  \tif ( !running ) rAF( tick );\n  };\n\n  Ticker.prototype.tick = function tick$1 ( now ) {\n  \tif ( !this.running ) return false;\n\n  \tif ( now > this.end ) {\n  \t\tif ( this.step ) this.step( 1 );\n  \t\tif ( this.complete ) this.complete( 1 );\n\n  \t\treturn false;\n  \t}\n\n  \tvar elapsed = now - this.start;\n  \tvar eased = this.easing( elapsed / this.duration );\n\n  \tif ( this.step ) this.step( eased );\n\n  \treturn true;\n  };\n\n  Ticker.prototype.stop = function stop () {\n  \tif ( this.abort ) this.abort();\n  \tthis.running = false;\n  };\n\n  var prefixers = {};\n\n  // TODO this is legacy. sooner we can replace the old adaptor API the better\n  function prefixKeypath ( obj, prefix ) {\n  \tvar prefixed = {}, key;\n\n  \tif ( !prefix ) {\n  \t\treturn obj;\n  \t}\n\n  \tprefix += '.';\n\n  \tfor ( key in obj ) {\n  \t\tif ( obj.hasOwnProperty( key ) ) {\n  \t\t\tprefixed[ prefix + key ] = obj[ key ];\n  \t\t}\n  \t}\n\n  \treturn prefixed;\n  }\n\n  function getPrefixer ( rootKeypath ) {\n  \tvar rootDot;\n\n  \tif ( !prefixers[ rootKeypath ] ) {\n  \t\trootDot = rootKeypath ? rootKeypath + '.' : '';\n\n  \t\tprefixers[ rootKeypath ] = function ( relativeKeypath, value ) {\n  \t\t\tvar obj;\n\n  \t\t\tif ( typeof relativeKeypath === 'string' ) {\n  \t\t\t\tobj = {};\n  \t\t\t\tobj[ rootDot + relativeKeypath ] = value;\n  \t\t\t\treturn obj;\n  \t\t\t}\n\n  \t\t\tif ( typeof relativeKeypath === 'object' ) {\n  \t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n  \t\t\t\treturn rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \treturn prefixers[ rootKeypath ];\n  }\n\n  var Model = (function (ModelBase) {\n  \tfunction Model ( parent, key ) {\n  \t\tModelBase.call( this, parent );\n\n  \t\tthis.ticker = null;\n\n  \t\tif ( parent ) {\n  \t\t\tthis.key = unescapeKey( key );\n  \t\t\tthis.isReadonly = parent.isReadonly;\n\n  \t\t\tif ( parent.value ) {\n  \t\t\t\tthis.value = parent.value[ this.key ];\n  \t\t\t\tif ( isArray( this.value ) ) this.length = this.value.length;\n  \t\t\t\tthis.adapt();\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tModel.prototype = Object.create( ModelBase && ModelBase.prototype );\n  \tModel.prototype.constructor = Model;\n\n  \tModel.prototype.adapt = function adapt () {\n  \t\tvar this$1 = this;\n\n  \t\tvar adaptors = this.root.adaptors;\n  \t\tvar len = adaptors.length;\n\n  \t\tthis.rewrap = false;\n\n  \t\t// Exit early if no adaptors\n  \t\tif ( len === 0 ) return;\n\n  \t\tvar value = this.wrapper ? ( 'newWrapperValue' in this ? this.newWrapperValue : this.wrapperValue ) : this.value;\n\n  \t\t// TODO remove this legacy nonsense\n  \t\tvar ractive = this.root.ractive;\n  \t\tvar keypath = this.getKeypath();\n\n  \t\t// tear previous adaptor down if present\n  \t\tif ( this.wrapper ) {\n  \t\t\tvar shouldTeardown = this.wrapperValue === value ? false : !this.wrapper.reset || this.wrapper.reset( value ) === false;\n\n  \t\t\tif ( shouldTeardown ) {\n  \t\t\t\tthis.wrapper.teardown();\n  \t\t\t\tthis.wrapper = null;\n\n  \t\t\t\t// don't branch for undefined values\n  \t\t\t\tif ( this.value !== undefined ) {\n  \t\t\t\t\tvar parentValue = this.parent.value || this.parent.createBranch( this.key );\n  \t\t\t\t\tif ( parentValue[ this.key ] !== value ) parentValue[ this.key ] = value;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tdelete this.newWrapperValue;\n  \t\t\t\tthis.wrapperValue = value;\n  \t\t\t\tthis.value = this.wrapper.get();\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n\n  \t\tvar i;\n\n  \t\tfor ( i = 0; i < len; i += 1 ) {\n  \t\t\tvar adaptor = adaptors[i];\n  \t\t\tif ( adaptor.filter( value, keypath, ractive ) ) {\n  \t\t\t\tthis$1.wrapper = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );\n  \t\t\t\tthis$1.wrapperValue = value;\n  \t\t\t\tthis$1.wrapper.__model = this$1; // massive temporary hack to enable array adaptor\n\n  \t\t\t\tthis$1.value = this$1.wrapper.get();\n\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \tModel.prototype.animate = function animate ( from, to, options, interpolator ) {\n  \t\tvar this$1 = this;\n\n  \t\tif ( this.ticker ) this.ticker.stop();\n\n  \t\tvar fulfilPromise;\n  \t\tvar promise = new Promise$1( function ( fulfil ) { return fulfilPromise = fulfil; } );\n\n  \t\tthis.ticker = new Ticker({\n  \t\t\tduration: options.duration,\n  \t\t\teasing: options.easing,\n  \t\t\tstep: function ( t ) {\n  \t\t\t\tvar value = interpolator( t );\n  \t\t\t\tthis$1.applyValue( value );\n  \t\t\t\tif ( options.step ) options.step( t, value );\n  \t\t\t},\n  \t\t\tcomplete: function () {\n  \t\t\t\tthis$1.applyValue( to );\n  \t\t\t\tif ( options.complete ) options.complete( to );\n\n  \t\t\t\tthis$1.ticker = null;\n  \t\t\t\tfulfilPromise();\n  \t\t\t}\n  \t\t});\n\n  \t\tpromise.stop = this.ticker.stop;\n  \t\treturn promise;\n  \t};\n\n  \tModel.prototype.applyValue = function applyValue ( value ) {\n  \t\tif ( isEqual( value, this.value ) ) return;\n\n  \t\t// TODO deprecate this nonsense\n  \t\tthis.registerChange( this.getKeypath(), value );\n\n  \t\tif ( this.parent.wrapper && this.parent.wrapper.set ) {\n  \t\t\tthis.parent.wrapper.set( this.key, value );\n  \t\t\tthis.parent.value = this.parent.wrapper.get();\n\n  \t\t\tthis.value = this.parent.value[ this.key ];\n  \t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n  \t\t\tthis.adapt();\n  \t\t} else if ( this.wrapper ) {\n  \t\t\tthis.newWrapperValue = value;\n  \t\t\tthis.adapt();\n  \t\t} else {\n  \t\t\tvar parentValue = this.parent.value || this.parent.createBranch( this.key );\n  \t\t\tparentValue[ this.key ] = value;\n\n  \t\t\tthis.value = value;\n  \t\t\tthis.adapt();\n  \t\t}\n\n  \t\tthis.parent.clearUnresolveds();\n  \t\tthis.clearUnresolveds();\n\n  \t\t// keep track of array length\n  \t\tif ( isArray( value ) ) this.length = value.length;\n\n  \t\t// notify dependants\n  \t\tthis.links.forEach( handleChange );\n  \t\tthis.children.forEach( mark );\n  \t\tthis.deps.forEach( handleChange );\n\n  \t\tthis.notifyUpstream();\n\n  \t\tif ( this.key === 'length' && isArray( this.parent.value ) ) this.parent.length = this.parent.value.length;\n  \t};\n\n  \tModel.prototype.createBranch = function createBranch ( key ) {\n  \t\tvar branch = isNumeric( key ) ? [] : {};\n  \t\tthis.set( branch );\n\n  \t\treturn branch;\n  \t};\n\n  \tModel.prototype.get = function get ( shouldCapture, opts ) {\n  \t\tif ( this._link ) return this._link.get( shouldCapture, opts );\n  \t\tif ( shouldCapture ) capture( this );\n  \t\t// if capturing, this value needs to be unwrapped because it's for external use\n  \t\tif ( opts && opts.virtual ) return this.getVirtual( false );\n  \t\treturn ( shouldCapture || ( opts && opts.unwrap ) ) && this.wrapper ? this.wrapperValue : this.value;\n  \t};\n\n  \tModel.prototype.getKeypathModel = function getKeypathModel ( ractive ) {\n  \t\tif ( !this.keypathModel ) this.keypathModel = new KeypathModel( this );\n  \t\treturn this.keypathModel;\n  \t};\n\n  \tModel.prototype.joinKey = function joinKey ( key, opts ) {\n  \t\tif ( this._link ) {\n  \t\t\tif ( opts && !opts.lastLink === false && ( key === undefined || key === '' ) ) return this;\n  \t\t\treturn this._link.joinKey( key );\n  \t\t}\n\n  \t\tif ( key === undefined || key === '' ) return this;\n\n\n  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n  \t\t\tvar child = new Model( this, key );\n  \t\t\tthis.children.push( child );\n  \t\t\tthis.childByKey[ key ] = child;\n  \t\t}\n\n  \t\tif ( this.childByKey[ key ]._link ) return this.childByKey[ key ]._link;\n  \t\treturn this.childByKey[ key ];\n  \t};\n\n  \tModel.prototype.mark = function mark$1 () {\n  \t\tif ( this._link ) return this._link.mark();\n\n  \t\tvar value = this.retrieve();\n\n  \t\tif ( !isEqual( value, this.value ) ) {\n  \t\t\tvar old = this.value;\n  \t\t\tthis.value = value;\n\n  \t\t\t// make sure the wrapper stays in sync\n  \t\t\tif ( old !== value || this.rewrap ) {\n  \t\t\t\tif ( this.wrapper ) this.newWrapperValue = value;\n  \t\t\t\tthis.adapt();\n  \t\t\t}\n\n  \t\t\t// keep track of array lengths\n  \t\t\tif ( isArray( value ) ) this.length = value.length;\n\n  \t\t\tthis.children.forEach( mark );\n  \t\t\tthis.links.forEach( marked );\n\n  \t\t\tthis.deps.forEach( handleChange );\n  \t\t\tthis.clearUnresolveds();\n  \t\t}\n  \t};\n\n  \tModel.prototype.merge = function merge ( array, comparator ) {\n  \t\tvar oldArray = this.value, newArray = array;\n  \t\tif ( oldArray === newArray ) oldArray = recreateArray( this );\n  \t\tif ( comparator ) {\n  \t\t\toldArray = oldArray.map( comparator );\n  \t\t\tnewArray = newArray.map( comparator );\n  \t\t}\n\n  \t\tvar oldLength = oldArray.length;\n\n  \t\tvar usedIndices = {};\n  \t\tvar firstUnusedIndex = 0;\n\n  \t\tvar newIndices = oldArray.map( function ( item ) {\n  \t\t\tvar index;\n  \t\t\tvar start = firstUnusedIndex;\n\n  \t\t\tdo {\n  \t\t\t\tindex = newArray.indexOf( item, start );\n\n  \t\t\t\tif ( index === -1 ) {\n  \t\t\t\t\treturn -1;\n  \t\t\t\t}\n\n  \t\t\t\tstart = index + 1;\n  \t\t\t} while ( ( usedIndices[ index ] === true ) && start < oldLength );\n\n  \t\t\t// keep track of the first unused index, so we don't search\n  \t\t\t// the whole of newArray for each item in oldArray unnecessarily\n  \t\t\tif ( index === firstUnusedIndex ) {\n  \t\t\t\tfirstUnusedIndex += 1;\n  \t\t\t}\n  \t\t\t// allow next instance of next \"equal\" to be found item\n  \t\t\tusedIndices[ index ] = true;\n  \t\t\treturn index;\n  \t\t});\n\n  \t\tthis.parent.value[ this.key ] = array;\n  \t\tthis.shuffle( newIndices );\n  \t};\n\n  \tModel.prototype.retrieve = function retrieve () {\n  \t\treturn this.parent.value ? this.parent.value[ this.key ] : undefined;\n  \t};\n\n  \tModel.prototype.set = function set ( value ) {\n  \t\tif ( this.ticker ) this.ticker.stop();\n  \t\tthis.applyValue( value );\n  \t};\n\n  \tModel.prototype.shuffle = function shuffle ( newIndices ) {\n  \t\tvar this$1 = this;\n\n  \t\tthis.shuffling = true;\n  \t\tvar i = newIndices.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar idx = newIndices[ i ];\n  \t\t\t// nothing is actually changing, so move in the index and roll on\n  \t\t\tif ( i === idx ) {\n  \t\t\t\tcontinue;\n  \t\t\t}\n\n  \t\t\t// rebind the children on i to idx\n  \t\t\tif ( i in this$1.childByKey ) this$1.childByKey[ i ].rebinding( !~idx ? undefined : this$1.joinKey( idx ), this$1.childByKey[ i ], true );\n\n  \t\t\tif ( !~idx && this$1.keyModels[ i ] ) {\n  \t\t\t\tthis$1.keyModels[i].rebinding( undefined, this$1.keyModels[i], false );\n  \t\t\t} else if ( ~idx && this$1.keyModels[ i ] ) {\n  \t\t\t\tif ( !this$1.keyModels[ idx ] ) this$1.childByKey[ idx ].getKeyModel( idx );\n  \t\t\t\tthis$1.keyModels[i].rebinding( this$1.keyModels[ idx ], this$1.keyModels[i], false );\n  \t\t\t}\n  \t\t}\n\n  \t\tvar upstream = this.length !== this.value.length;\n\n  \t\tthis.links.forEach( function ( l ) { return l.shuffle( newIndices ); } );\n  \t\tfireShuffleTasks( 'early' );\n\n  \t\ti = this.deps.length;\n  \t\twhile ( i-- ) {\n  \t\t\tif ( this$1.deps[i].shuffle ) this$1.deps[i].shuffle( newIndices );\n  \t\t}\n\n  \t\tthis.mark();\n  \t\tfireShuffleTasks( 'mark' );\n\n  \t\tif ( upstream ) this.notifyUpstream();\n  \t\tthis.shuffling = false;\n  \t};\n\n  \tModel.prototype.teardown = function teardown$1 () {\n  \t\tif ( this._link ) this._link.teardown();\n  \t\tthis.children.forEach( teardown );\n  \t\tif ( this.wrapper ) this.wrapper.teardown();\n  \t\tif ( this.keypathModel ) this.keypathModel.teardown();\n  \t};\n\n  \treturn Model;\n  }(ModelBase));\n\n  function recreateArray( model ) {\n  \tvar array = [];\n\n  \tfor ( var i = 0; i < model.length; i++ ) {\n  \t\tarray[ i ] = (model.childByKey[i] || {}).value;\n  \t}\n\n  \treturn array;\n  }\n\n  var GlobalModel = (function (Model) {\n  \tfunction GlobalModel ( ) {\n  \t\tModel.call( this, null, '@global' );\n  \t\tthis.value = typeof global !== 'undefined' ? global : window;\n  \t\tthis.isRoot = true;\n  \t\tthis.root = this;\n  \t\tthis.adaptors = [];\n  \t}\n\n  \tGlobalModel.prototype = Object.create( Model && Model.prototype );\n  \tGlobalModel.prototype.constructor = GlobalModel;\n\n  \tGlobalModel.prototype.getKeypath = function getKeypath() {\n  \t\treturn '@global';\n  \t};\n\n  \t// global model doesn't contribute changes events because it has no instance\n  \tGlobalModel.prototype.registerChange = function registerChange () {};\n\n  \treturn GlobalModel;\n  }(Model));\n\n  var GlobalModel$1 = new GlobalModel();\n\n  var keypathExpr = /^@[^\\(]+\\(([^\\)]+)\\)/;\n\n  function resolveReference ( fragment, ref ) {\n  \tvar context = fragment.findContext();\n\n  \t// special references\n  \t// TODO does `this` become `.` at parse time?\n  \tif ( ref === '.' || ref === 'this' ) return context;\n  \tif ( ref.indexOf( '@keypath' ) === 0 ) {\n  \t\tvar match = keypathExpr.exec( ref );\n  \t\tif ( match && match[1] ) {\n  \t\t\tvar model = resolveReference( fragment, match[1] );\n  \t\t\tif ( model ) return model.getKeypathModel();\n  \t\t}\n  \t\treturn context.getKeypathModel();\n  \t}\n  \tif ( ref.indexOf( '@rootpath' ) === 0 ) {\n  \t\t// check to see if this is an empty component root\n  \t\twhile ( context.isRoot && context.ractive.component ) {\n  \t\t\tcontext = context.ractive.component.parentFragment.findContext();\n  \t\t}\n\n  \t\tvar match$1 = keypathExpr.exec( ref );\n  \t\tif ( match$1 && match$1[1] ) {\n  \t\t\tvar model$1 = resolveReference( fragment, match$1[1] );\n  \t\t\tif ( model$1 ) return model$1.getKeypathModel( fragment.ractive.root );\n  \t\t}\n  \t\treturn context.getKeypathModel( fragment.ractive.root );\n  \t}\n  \tif ( ref === '@index' || ref === '@key' ) {\n  \t\tvar repeater = fragment.findRepeatingFragment();\n  \t\t// make sure the found fragment is actually an iteration\n  \t\tif ( !repeater.isIteration ) return;\n  \t\treturn repeater.context.getKeyModel( repeater[ ref[1] === 'i' ? 'index' : 'key' ] );\n  \t}\n  \tif ( ref === '@this' ) {\n  \t\treturn fragment.ractive.viewmodel.getRactiveModel();\n  \t}\n  \tif ( ref === '@global' ) {\n  \t\treturn GlobalModel$1;\n  \t}\n\n  \t// ancestor references\n  \tif ( ref[0] === '~' ) return fragment.ractive.viewmodel.joinAll( splitKeypathI( ref.slice( 2 ) ) );\n  \tif ( ref[0] === '.' ) {\n  \t\tvar parts = ref.split( '/' );\n\n  \t\twhile ( parts[0] === '.' || parts[0] === '..' ) {\n  \t\t\tvar part = parts.shift();\n\n  \t\t\tif ( part === '..' ) {\n  \t\t\t\tcontext = context.parent;\n  \t\t\t}\n  \t\t}\n\n  \t\tref = parts.join( '/' );\n\n  \t\t// special case - `{{.foo}}` means the same as `{{./foo}}`\n  \t\tif ( ref[0] === '.' ) ref = ref.slice( 1 );\n  \t\treturn context.joinAll( splitKeypathI( ref ) );\n  \t}\n\n  \treturn resolveAmbiguousReference( fragment, ref );\n  }\n\n  function Ractive$get ( keypath, opts ) {\n  \tif ( typeof keypath !== 'string' ) return this.viewmodel.get( true, keypath );\n\n  \tvar keys = splitKeypathI( keypath );\n  \tvar key = keys[0];\n\n  \tvar model;\n\n  \tif ( !this.viewmodel.has( key ) ) {\n  \t\t// if this is an inline component, we may need to create\n  \t\t// an implicit mapping\n  \t\tif ( this.component && !this.isolated ) {\n  \t\t\tmodel = resolveReference( this.component.parentFragment, key );\n\n  \t\t\tif ( model ) {\n  \t\t\t\tthis.viewmodel.map( key, model );\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tmodel = this.viewmodel.joinAll( keys );\n  \treturn model.get( true, opts );\n  }\n\n  function gatherRefs( fragment ) {\n  \tvar key = {}, index = {};\n\n  \t// walk up the template gather refs as we go\n  \twhile ( fragment ) {\n  \t\tif ( fragment.parent && ( fragment.parent.indexRef || fragment.parent.keyRef ) ) {\n  \t\t\tvar ref = fragment.parent.indexRef;\n  \t\t\tif ( ref && !( ref in index ) ) index[ref] = fragment.index;\n  \t\t\tref = fragment.parent.keyRef;\n  \t\t\tif ( ref && !( ref in key ) ) key[ref] = fragment.key;\n  \t\t}\n\n  \t\tif ( fragment.componentParent && !fragment.ractive.isolated ) {\n  \t\t\tfragment = fragment.componentParent;\n  \t\t} else {\n  \t\t\tfragment = fragment.parent;\n  \t\t}\n  \t}\n\n  \treturn { key: key, index: index };\n  }\n\n  // This function takes an array, the name of a mutator method, and the\n  // arguments to call that mutator method with, and returns an array that\n  // maps the old indices to their new indices.\n\n  // So if you had something like this...\n  //\n  //     array = [ 'a', 'b', 'c', 'd' ];\n  //     array.push( 'e' );\n  //\n  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n  // have changed. If you then did this...\n  //\n  //     array.unshift( 'z' );\n  //\n  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n  // one higher to make room for the 'z'. If you removed an item, the new index\n  // would be -1...\n  //\n  //     array.splice( 2, 2 );\n  //\n  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n  //\n  // This information is used to enable fast, non-destructive shuffling of list\n  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\n  function getNewIndices ( length, methodName, args ) {\n  \tvar spliceArguments, newIndices = [], removeStart, removeEnd, balance, i;\n\n  \tspliceArguments = getSpliceEquivalent( length, methodName, args );\n\n  \tif ( !spliceArguments ) {\n  \t\treturn null; // TODO support reverse and sort?\n  \t}\n\n  \tbalance = ( spliceArguments.length - 2 ) - spliceArguments[1];\n\n  \tremoveStart = Math.min( length, spliceArguments[0] );\n  \tremoveEnd = removeStart + spliceArguments[1];\n  \tnewIndices.startIndex = removeStart;\n\n  \tfor ( i = 0; i < removeStart; i += 1 ) {\n  \t\tnewIndices.push( i );\n  \t}\n\n  \tfor ( ; i < removeEnd; i += 1 ) {\n  \t\tnewIndices.push( -1 );\n  \t}\n\n  \tfor ( ; i < length; i += 1 ) {\n  \t\tnewIndices.push( i + balance );\n  \t}\n\n  \t// there is a net shift for the rest of the array starting with index + balance\n  \tif ( balance !== 0 ) {\n  \t\tnewIndices.touchedFrom = spliceArguments[0];\n  \t} else {\n  \t\tnewIndices.touchedFrom = length;\n  \t}\n\n  \treturn newIndices;\n  }\n\n\n  // The pop, push, shift an unshift methods can all be represented\n  // as an equivalent splice\n  function getSpliceEquivalent ( length, methodName, args ) {\n  \tswitch ( methodName ) {\n  \t\tcase 'splice':\n  \t\t\tif ( args[0] !== undefined && args[0] < 0 ) {\n  \t\t\t\targs[0] = length + Math.max( args[0], -length );\n  \t\t\t}\n\n  \t\t\tif ( args[0] === undefined ) args[0] = 0;\n\n  \t\t\twhile ( args.length < 2 ) {\n  \t\t\t\targs.push( length - args[0] );\n  \t\t\t}\n\n  \t\t\tif ( typeof args[1] !== 'number' ) {\n  \t\t\t\targs[1] = length - args[0];\n  \t\t\t}\n\n  \t\t\t// ensure we only remove elements that exist\n  \t\t\targs[1] = Math.min( args[1], length - args[0] );\n\n  \t\t\treturn args;\n\n  \t\tcase 'sort':\n  \t\tcase 'reverse':\n  \t\t\treturn null;\n\n  \t\tcase 'pop':\n  \t\t\tif ( length ) {\n  \t\t\t\treturn [ length - 1, 1 ];\n  \t\t\t}\n  \t\t\treturn [ 0, 0 ];\n\n  \t\tcase 'push':\n  \t\t\treturn [ length, 0 ].concat( args );\n\n  \t\tcase 'shift':\n  \t\t\treturn [ 0, length ? 1 : 0 ];\n\n  \t\tcase 'unshift':\n  \t\t\treturn [ 0, 0 ].concat( args );\n  \t}\n  }\n\n  var arrayProto = Array.prototype;\n\n  function makeArrayMethod ( methodName ) {\n  \tfunction path ( keypath ) {\n  \t\tvar args = [], len = arguments.length - 1;\n  \t\twhile ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n  \t\treturn model( this.viewmodel.joinAll( splitKeypathI( keypath ) ), args );\n  \t}\n\n  \tfunction model ( mdl, args ) {\n  \t\tvar array = mdl.get();\n\n  \t\tif ( !isArray( array ) ) {\n  \t\t\tif ( array === undefined ) {\n  \t\t\t\tarray = [];\n  \t\t\t\tvar result$1 = arrayProto[ methodName ].apply( array, args );\n  \t\t\t\tvar promise$1 = runloop.start( this, true ).then( function () { return result$1; } );\n  \t\t\t\tmdl.set( array );\n  \t\t\t\trunloop.end();\n  \t\t\t\treturn promise$1;\n  \t\t\t} else {\n  \t\t\t\tthrow new Error( (\"shuffle array method \" + methodName + \" called on non-array at \" + (mdl.getKeypath())) );\n  \t\t\t}\n  \t\t}\n\n  \t\tvar newIndices = getNewIndices( array.length, methodName, args );\n  \t\tvar result = arrayProto[ methodName ].apply( array, args );\n\n  \t\tvar promise = runloop.start( this, true ).then( function () { return result; } );\n  \t\tpromise.result = result;\n\n  \t\tif ( newIndices ) {\n  \t\t\tmdl.shuffle( newIndices );\n  \t\t} else {\n  \t\t\tmdl.set( result );\n  \t\t}\n\n  \t\trunloop.end();\n\n  \t\treturn promise;\n  \t}\n\n  \treturn { path: path, model: model };\n  }\n\n  var comparators = {};\n\n  function getComparator ( option ) {\n  \tif ( !option ) return null; // use existing arrays\n  \tif ( option === true ) return JSON.stringify;\n  \tif ( typeof option === 'function' ) return option;\n\n  \tif ( typeof option === 'string' ) {\n  \t\treturn comparators[ option ] || ( comparators[ option ] = function ( thing ) { return thing[ option ]; } );\n  \t}\n\n  \tthrow new Error( 'If supplied, options.compare must be a string, function, or `true`' ); // TODO link to docs\n  }\n\n  function merge$1 ( ractive, model, array, options ) {\n  \tvar promise = runloop.start( ractive, true );\n  \tvar value = model.get();\n\n  \tif ( !isArray( value ) || !isArray( array ) ) {\n  \t\tthrow new Error( 'You cannot merge an array with a non-array' );\n  \t}\n\n  \tvar comparator = getComparator( options && options.compare );\n  \tmodel.merge( array, comparator );\n\n  \trunloop.end();\n  \treturn promise;\n  }\n\n  function thisRactive$merge ( keypath, array, options ) {\n  \treturn merge$1( this, this.viewmodel.joinAll( splitKeypathI( keypath ) ), array, options );\n  }\n\n  var updateHook = new Hook( 'update' );\n\n  function update$2 ( ractive, model ) {\n  \t// if the parent is wrapped, the adaptor will need to be updated before\n  \t// updating on this keypath\n  \tif ( model.parent && model.parent.wrapper ) {\n  \t\tmodel.parent.adapt();\n  \t}\n\n  \tvar promise = runloop.start( ractive, true );\n\n  \tmodel.mark();\n  \tmodel.registerChange( model.getKeypath(), model.get() );\n\n  \tif ( !model.isRoot ) {\n  \t\t// there may be unresolved refs that are now resolvable up the context tree\n  \t\tvar parent = model.parent, key = model.key;\n  \t\twhile ( parent && !parent.isRoot ) {\n  \t\t\tif ( parent.clearUnresolveds ) parent.clearUnresolveds( key );\n  \t\t\tkey = parent.key;\n  \t\t\tparent = parent.parent;\n  \t\t}\n  \t}\n\n  \t// notify upstream of changes\n  \tmodel.notifyUpstream();\n\n  \trunloop.end();\n\n  \tupdateHook.fire( ractive, model );\n\n  \treturn promise;\n  }\n\n  function Ractive$update ( keypath ) {\n  \tif ( keypath ) keypath = splitKeypathI( keypath );\n\n  \treturn update$2( this, keypath ? this.viewmodel.joinAll( keypath ) : this.viewmodel );\n  }\n\n  var modelPush = makeArrayMethod( 'push' ).model;\n  var modelPop = makeArrayMethod( 'pop' ).model;\n  var modelShift = makeArrayMethod( 'shift' ).model;\n  var modelUnshift = makeArrayMethod( 'unshift' ).model;\n  var modelSort = makeArrayMethod( 'sort' ).model;\n  var modelSplice = makeArrayMethod( 'splice' ).model;\n  var modelReverse = makeArrayMethod( 'reverse' ).model;\n\n  // TODO: at some point perhaps this could support relative * keypaths?\n  function build$1 ( el, keypath, value ) {\n  \tvar sets = [];\n\n  \t// set multiple keypaths in one go\n  \tif ( isObject( keypath ) ) {\n  \t\tfor ( var k in keypath ) {\n  \t\t\tif ( keypath.hasOwnProperty( k ) ) {\n  \t\t\t\tsets.push( [ findModel( el, k ).model, keypath[k] ] );\n  \t\t\t}\n  \t\t}\n\n  \t}\n  \t// set a single keypath\n  \telse {\n  \t\tsets.push( [ findModel( el, keypath ).model, value ] );\n  \t}\n\n  \treturn sets;\n  }\n\n  // get relative keypaths and values\n  function get ( keypath ) {\n  \tif ( !keypath ) return this._element.parentFragment.findContext().get( true );\n\n  \tvar model = resolveReference( this._element.parentFragment, keypath );\n\n  \treturn model ? model.get( true ) : undefined;\n  }\n\n  function resolve$1 ( path, ractive ) {\n  \tvar ref = findModel( this, path ), model = ref.model, instance = ref.instance;\n  \treturn model ? model.getKeypath( ractive || instance ) : path;\n  }\n\n  function findModel ( el, path ) {\n  \tvar frag = el._element.parentFragment;\n\n  \tif ( typeof path !== 'string' ) {\n  \t\treturn { model: frag.findContext(), instance: path };\n  \t}\n\n  \treturn { model: resolveReference( frag, path ), instance: frag.ractive };\n  }\n\n  // the usual mutation suspects\n  function add$1 ( keypath, value ) {\n  \tif ( value === undefined ) value = 1;\n  \tif ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );\n  \treturn set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {\n  \t\tvar model = pair[0], val = pair[1], value = model.get();\n  \t\tif ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );\n  \t\treturn [ model, value + val ];\n  \t}) );\n  }\n\n  function animate ( keypath, value, options ) {\n  \tvar model = findModel( this, keypath ).model;\n  \treturn protoAnimate( this.ractive, model, value, options );\n  }\n\n  function link ( source, dest ) {\n  \tvar there = findModel( this, source ).model, here = findModel( this, dest ).model;\n  \tvar promise = runloop.start( this.ractive, true );\n  \there.link( there, source );\n  \trunloop.end();\n  \treturn promise;\n  }\n\n  function merge ( keypath, array, options ) {\n  \treturn merge$1( this.ractive, findModel( this, keypath ).model, array, options );\n  }\n\n  function pop ( keypath ) {\n  \treturn modelPop( findModel( this, keypath ).model, [] );\n  }\n\n  function push ( keypath ) {\n  \tvar values = [], len = arguments.length - 1;\n  \twhile ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n  \treturn modelPush( findModel( this, keypath ).model, values );\n  }\n\n  function reverse ( keypath ) {\n  \treturn modelReverse( findModel( this, keypath ).model, [] );\n  }\n\n  function set$1 ( keypath, value ) {\n  \treturn set( this.ractive, build$1( this, keypath, value ) );\n  }\n\n  function shift ( keypath ) {\n  \treturn modelShift( findModel( this, keypath ).model, [] );\n  }\n\n  function splice ( keypath, index, drop ) {\n  \tvar add = [], len = arguments.length - 3;\n  \twhile ( len-- > 0 ) add[ len ] = arguments[ len + 3 ];\n\n  \tadd.unshift( index, drop );\n  \treturn modelSplice( findModel( this, keypath ).model, add );\n  }\n\n  function sort ( keypath ) {\n  \treturn modelSort( findModel( this, keypath ).model, [] );\n  }\n\n  function subtract ( keypath, value ) {\n  \tif ( value === undefined ) value = 1;\n  \tif ( !isNumeric( value ) ) throw new Error( 'Bad arguments' );\n  \treturn set( this.ractive, build$1( this, keypath, value ).map( function ( pair ) {\n  \t\tvar model = pair[0], val = pair[1], value = model.get();\n  \t\tif ( !isNumeric( val ) || !isNumeric( value ) ) throw new Error( 'Cannot add non-numeric value' );\n  \t\treturn [ model, value - val ];\n  \t}) );\n  }\n\n  function toggle ( keypath ) {\n  \tvar ref = findModel( this, keypath ), model = ref.model;\n  \treturn set( this.ractive, [ [ model, !model.get() ] ] );\n  }\n\n  function unlink ( dest ) {\n  \tvar here = findModel( this, dest ).model;\n  \tvar promise = runloop.start( this.ractive, true );\n  \tif ( here.owner && here.owner._link ) here.owner.unlink();\n  \trunloop.end();\n  \treturn promise;\n  }\n\n  function unshift ( keypath ) {\n  \tvar add = [], len = arguments.length - 1;\n  \twhile ( len-- > 0 ) add[ len ] = arguments[ len + 1 ];\n\n  \treturn modelUnshift( findModel( this, keypath ).model, add );\n  }\n\n  function update$1 ( keypath ) {\n  \treturn update$2( this.ractive, findModel( this, keypath ).model );\n  }\n\n  function updateModel ( keypath, cascade ) {\n  \tvar ref = findModel( this, keypath ), model = ref.model;\n  \tvar promise = runloop.start( this.ractive, true );\n  \tmodel.updateFromBindings( cascade );\n  \trunloop.end();\n  \treturn promise;\n  }\n\n  // two-way binding related helpers\n  function isBound () {\n  \tvar ref = getBindingModel( this ), model = ref.model;\n  \treturn !!model;\n  }\n\n  function getBindingPath ( ractive ) {\n  \tvar ref = getBindingModel( this ), model = ref.model, instance = ref.instance;\n  \tif ( model ) return model.getKeypath( ractive || instance );\n  }\n\n  function getBinding () {\n  \tvar ref = getBindingModel( this ), model = ref.model;\n  \tif ( model ) return model.get( true );\n  }\n\n  function getBindingModel ( ctx ) {\n  \tvar el = ctx._element;\n  \treturn { model: el.binding && el.binding.model, instance: el.parentFragment.ractive };\n  }\n\n  function setBinding ( value ) {\n  \tvar ref = getBindingModel( this ), model = ref.model;\n  \treturn set( this.ractive, [ [ model, value ] ] );\n  }\n\n  // deprecated getters\n  function keypath () {\n  \twarnOnceIfDebug( (\"Object property keypath is deprecated, please use resolve() instead.\") );\n  \treturn this.resolve();\n  }\n\n  function rootpath () {\n  \twarnOnceIfDebug( (\"Object property rootpath is deprecated, please use resolve( ractive.root ) instead.\") );\n  \treturn this.resolve( this.ractive.root );\n  }\n\n  function context () {\n  \twarnOnceIfDebug( (\"Object property context is deprecated, please use get() instead.\") );\n  \treturn this.get();\n  }\n\n  function index () {\n  \twarnOnceIfDebug( (\"Object property index is deprecated, you can use get( \\\"indexName\\\" ) instead.\") );\n  \treturn gatherRefs( this._element.parentFragment ).index;\n  }\n\n  function key () {\n  \twarnOnceIfDebug( (\"Object property key is deprecated, you can use get( \\\"keyName\\\" ) instead.\") );\n  \treturn gatherRefs( this._element.parentFragment ).key;\n  }\n\n  function addHelpers ( obj, element ) {\n  \tdefineProperties( obj, {\n  \t\t_element: { value: element },\n  \t\tractive: { value: element.parentFragment.ractive },\n  \t\tresolve: { value: resolve$1 },\n  \t\tget: { value: get },\n\n  \t\tadd: { value: add$1 },\n  \t\tanimate: { value: animate },\n  \t\tlink: { value: link },\n  \t\tmerge: { value: merge },\n  \t\tpop: { value: pop },\n  \t\tpush: { value: push },\n  \t\treverse: { value: reverse },\n  \t\tset: { value: set$1 },\n  \t\tshift: { value: shift },\n  \t\tsort: { value: sort },\n  \t\tsplice: { value: splice },\n  \t\tsubtract: { value: subtract },\n  \t\ttoggle: { value: toggle },\n  \t\tunlink: { value: unlink },\n  \t\tunshift: { value: unshift },\n  \t\tupdate: { value: update$1 },\n  \t\tupdateModel: { value: updateModel },\n\n  \t\tisBound: { value: isBound },\n  \t\tgetBindingPath: { value: getBindingPath },\n  \t\tgetBinding: { value: getBinding },\n  \t\tsetBinding: { value: setBinding },\n\n  \t\tkeypath: { get: keypath },\n  \t\trootpath: { get: rootpath },\n  \t\tcontext: { get: context },\n  \t\tindex: { get: index },\n  \t\tkey: { get: key }\n  \t});\n\n  \treturn obj;\n  }\n\n  var query = doc && doc.querySelector;\n\n  function staticInfo( node ) {\n  \tif ( typeof node === 'string' && query ) {\n  \t\tnode = query.call( document, node );\n  \t}\n\n  \tif ( !node || !node._ractive ) return {};\n\n  \tvar storage = node._ractive;\n\n  \treturn addHelpers( {}, storage.proxy );\n  }\n\n  function getNodeInfo( node ) {\n  \tif ( typeof node === 'string' ) {\n  \t\tnode = this.find( node );\n  \t}\n\n  \treturn staticInfo( node );\n  }\n\n  var insertHook = new Hook( 'insert' );\n\n  function Ractive$insert ( target, anchor ) {\n  \tif ( !this.fragment.rendered ) {\n  \t\t// TODO create, and link to, documentation explaining this\n  \t\tthrow new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );\n  \t}\n\n  \ttarget = getElement( target );\n  \tanchor = getElement( anchor ) || null;\n\n  \tif ( !target ) {\n  \t\tthrow new Error( 'You must specify a valid target to insert into' );\n  \t}\n\n  \ttarget.insertBefore( this.detach(), anchor );\n  \tthis.el = target;\n\n  \t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );\n  \tthis.isDetached = false;\n\n  \tfireInsertHook( this );\n  }\n\n  function fireInsertHook( ractive ) {\n  \tinsertHook.fire( ractive );\n\n  \tractive.findAllComponents('*').forEach( function ( child ) {\n  \t\tfireInsertHook( child.instance );\n  \t});\n  }\n\n  function link$1( there, here ) {\n  \tif ( here === there || (there + '.').indexOf( here + '.' ) === 0 || (here + '.').indexOf( there + '.' ) === 0 ) {\n  \t\tthrow new Error( 'A keypath cannot be linked to itself.' );\n  \t}\n\n  \tvar promise = runloop.start();\n  \tvar model;\n\n  \t// may need to allow a mapping to resolve implicitly\n  \tvar sourcePath = splitKeypathI( there );\n  \tif ( !this.viewmodel.has( sourcePath[0] ) && this.component ) {\n  \t\tmodel = resolveReference( this.component.parentFragment, sourcePath[0] );\n  \t\tmodel = model.joinAll( sourcePath.slice( 1 ) );\n  \t}\n\n  \tthis.viewmodel.joinAll( splitKeypathI( here ) ).link( model || this.viewmodel.joinAll( sourcePath ), there );\n\n  \trunloop.end();\n\n  \treturn promise;\n  }\n\n  var ReferenceResolver = function ReferenceResolver ( fragment, reference, callback ) {\n  \tvar this$1 = this;\n\n  \t\tthis.fragment = fragment;\n  \tthis.reference = normalise( reference );\n  \tthis.callback = callback;\n\n  \tthis.keys = splitKeypathI( reference );\n  \tthis.resolved = false;\n\n  \tthis.contexts = [];\n\n  \t// TODO the consumer should take care of addUnresolved\n  \t// we attach to all the contexts between here and the root\n  \t// - whenever their values change, they can quickly\n  \t// check to see if we can resolve\n  \twhile ( fragment ) {\n  \t\tif ( fragment.context ) {\n  \t\t\tfragment.context.addUnresolved( this$1.keys[0], this$1 );\n  \t\t\tthis$1.contexts.push( fragment.context );\n  \t\t}\n\n  \t\tfragment = fragment.componentParent || fragment.parent;\n  \t}\n  };\n\n  ReferenceResolver.prototype.attemptResolution = function attemptResolution () {\n  \tif ( this.resolved ) return;\n\n  \tvar model = resolveAmbiguousReference( this.fragment, this.reference );\n\n  \tif ( model ) {\n  \t\tthis.resolved = true;\n  \t\tthis.callback( model );\n  \t}\n  };\n\n  ReferenceResolver.prototype.forceResolution = function forceResolution () {\n  \tif ( this.resolved ) return;\n\n  \tvar model = this.fragment.findContext().joinAll( this.keys );\n  \tthis.callback( model );\n  \tthis.resolved = true;\n  };\n\n  ReferenceResolver.prototype.rebinding = function rebinding ( next, previous ) {\n  \tvar this$1 = this;\n\n  \t\tif ( previous ) previous.removeUnresolved( this.keys[0], this );\n  \tif ( next ) runloop.scheduleTask( function () { return next.addUnresolved( this$1.keys[0], this$1 ); } );\n  };\n\n  ReferenceResolver.prototype.unbind = function unbind () {\n  \tvar this$1 = this;\n\n  \t\tif ( this.fragment ) removeFromArray( this.fragment.unresolved, this );\n\n  \tif ( this.resolved ) return;\n\n  \tthis.contexts.forEach( function ( c ) { return c.removeUnresolved( this$1.keys[0], this$1 ); } );\n  };\n\n  function observe ( keypath, callback, options ) {\n  \tvar this$1 = this;\n\n  \tvar observers = [];\n  \tvar map;\n\n  \tif ( isObject( keypath ) ) {\n  \t\tmap = keypath;\n  \t\toptions = callback || {};\n\n  \t\tObject.keys( map ).forEach( function ( keypath ) {\n  \t\t\tvar callback = map[ keypath ];\n\n  \t\t\tvar keypaths = keypath.split( ' ' );\n  \t\t\tif ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );\n\n  \t\t\tkeypaths.forEach( function ( keypath ) {\n  \t\t\t\tobservers.push( createObserver( this$1, keypath, callback, options ) );\n  \t\t\t});\n  \t\t});\n  \t}\n\n  \telse {\n  \t\tvar keypaths;\n\n  \t\tif ( typeof keypath === 'function' ) {\n  \t\t\toptions = callback;\n  \t\t\tcallback = keypath;\n  \t\t\tkeypaths = [ '' ];\n  \t\t} else {\n  \t\t\tkeypaths = keypath.split( ' ' );\n  \t\t}\n\n  \t\tif ( keypaths.length > 1 ) keypaths = keypaths.filter( function ( k ) { return k; } );\n\n  \t\tkeypaths.forEach( function ( keypath ) {\n  \t\t\tobservers.push( createObserver( this$1, keypath, callback, options || {} ) );\n  \t\t});\n  \t}\n\n  \t// add observers to the Ractive instance, so they can be\n  \t// cancelled on ractive.teardown()\n  \tthis._observers.push.apply( this._observers, observers );\n\n  \treturn {\n  \t\tcancel: function () {\n  \t\t\tobservers.forEach( function ( observer ) {\n  \t\t\t\tremoveFromArray ( this$1._observers, observer );\n  \t\t\t\tobserver.cancel();\n  \t\t\t} );\n  \t\t}\n  \t};\n  }\n\n  function createObserver ( ractive, keypath, callback, options ) {\n  \tvar viewmodel = ractive.viewmodel;\n\n  \tvar keys = splitKeypathI( keypath );\n  \tvar wildcardIndex = keys.indexOf( '*' );\n  \toptions.keypath = keypath;\n\n  \t// normal keypath - no wildcards\n  \tif ( !~wildcardIndex ) {\n  \t\tvar key = keys[0];\n  \t\tvar model;\n\n  \t\t// if not the root model itself, check if viewmodel has key.\n  \t\tif ( key !== '' && !viewmodel.has( key ) ) {\n  \t\t\t// if this is an inline component, we may need to create an implicit mapping\n  \t\t\tif ( ractive.component && !ractive.isolated ) {\n  \t\t\t\tmodel = resolveReference( ractive.component.parentFragment, key );\n  \t\t\t\tif ( model ) {\n  \t\t\t\t\tviewmodel.map( key, model );\n  \t\t\t\t\tmodel = viewmodel.joinAll( keys );\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tmodel = viewmodel.joinAll( keys );\n  \t\t}\n\n  \t\treturn new Observer( ractive, model, callback, options );\n  \t}\n\n  \t// pattern observers - more complex case\n  \tvar baseModel = wildcardIndex === 0 ?\n  \t\tviewmodel :\n  \t\tviewmodel.joinAll( keys.slice( 0, wildcardIndex ) );\n\n  \treturn new PatternObserver( ractive, baseModel, keys.splice( wildcardIndex ), callback, options );\n  }\n\n  var Observer = function Observer ( ractive, model, callback, options ) {\n  \tvar this$1 = this;\n\n  \t\tthis.context = options.context || ractive;\n  \tthis.callback = callback;\n  \tthis.ractive = ractive;\n\n  \tif ( model ) this.resolved( model );\n  \telse {\n  \t\tthis.keypath = options.keypath;\n  \t\tthis.resolver = new ReferenceResolver( ractive.fragment, options.keypath, function ( model ) {\n  \t\t\tthis$1.resolved( model );\n  \t\t});\n  \t}\n\n  \tif ( options.init !== false ) {\n  \t\tthis.dirty = true;\n  \t\tthis.dispatch();\n  \t} else {\n  \t\tthis.oldValue = this.newValue;\n  \t}\n\n  \tthis.defer = options.defer;\n  \tthis.once = options.once;\n  \tthis.strict = options.strict;\n\n  \tthis.dirty = false;\n  };\n\n  Observer.prototype.cancel = function cancel () {\n  \tthis.cancelled = true;\n  \tif ( this.model ) {\n  \t\tthis.model.unregister( this );\n  \t} else {\n  \t\tthis.resolver.unbind();\n  \t}\n  };\n\n  Observer.prototype.dispatch = function dispatch () {\n  \tif ( !this.cancelled ) {\n  \t\tthis.callback.call( this.context, this.newValue, this.oldValue, this.keypath );\n  \t\tthis.oldValue = this.model ? this.model.get() : this.newValue;\n  \t\tthis.dirty = false;\n  \t}\n  };\n\n  Observer.prototype.handleChange = function handleChange () {\n  \tvar this$1 = this;\n\n  \t\tif ( !this.dirty ) {\n  \t\tvar newValue = this.model.get();\n  \t\tif ( isEqual( newValue, this.oldValue ) ) return;\n\n  \t\tthis.newValue = newValue;\n\n  \t\tif ( this.strict && this.newValue === this.oldValue ) return;\n\n  \t\trunloop.addObserver( this, this.defer );\n  \t\tthis.dirty = true;\n\n  \t\tif ( this.once ) runloop.scheduleTask( function () { return this$1.cancel(); } );\n  \t}\n  };\n\n  Observer.prototype.rebinding = function rebinding ( next, previous ) {\n  \tvar this$1 = this;\n\n  \t\tnext = rebindMatch( this.keypath, next, previous );\n  \t// TODO: set up a resolver if next is undefined?\n  \tif ( next === this.model ) return false;\n\n  \tif ( this.model ) this.model.unregister( this );\n  \tif ( next ) next.addShuffleTask( function () { return this$1.resolved( next ); } );\n  };\n\n  Observer.prototype.resolved = function resolved ( model ) {\n  \tthis.model = model;\n  \tthis.keypath = model.getKeypath( this.ractive );\n\n  \tthis.oldValue = undefined;\n  \tthis.newValue = model.get();\n\n  \tmodel.register( this );\n  };\n\n  var PatternObserver = function PatternObserver ( ractive, baseModel, keys, callback, options ) {\n  \tvar this$1 = this;\n\n  \t\tthis.context = options.context || ractive;\n  \tthis.ractive = ractive;\n  \tthis.baseModel = baseModel;\n  \tthis.keys = keys;\n  \tthis.callback = callback;\n\n  \tvar pattern = keys.join( '\\\\.' ).replace( /\\*/g, '(.+)' );\n  \tvar baseKeypath = baseModel.getKeypath( ractive );\n  \tthis.pattern = new RegExp( (\"^\" + (baseKeypath ? baseKeypath + '\\\\.' : '') + \"\" + pattern + \"$\") );\n\n  \tthis.oldValues = {};\n  \tthis.newValues = {};\n\n  \tthis.defer = options.defer;\n  \tthis.once = options.once;\n  \tthis.strict = options.strict;\n\n  \tthis.dirty = false;\n  \tthis.changed = [];\n  \tthis.partial = false;\n\n  \tvar models = baseModel.findMatches( this.keys );\n\n  \tmodels.forEach( function ( model ) {\n  \t\tthis$1.newValues[ model.getKeypath( this$1.ractive ) ] = model.get();\n  \t});\n\n  \tif ( options.init !== false ) {\n  \t\tthis.dispatch();\n  \t} else {\n  \t\tthis.oldValues = this.newValues;\n  \t}\n\n  \tbaseModel.registerPatternObserver( this );\n  };\n\n  PatternObserver.prototype.cancel = function cancel () {\n  \tthis.baseModel.unregisterPatternObserver( this );\n  };\n\n  PatternObserver.prototype.dispatch = function dispatch () {\n  \tvar this$1 = this;\n\n  \t\tObject.keys( this.newValues ).forEach( function ( keypath ) {\n  \t\tif ( this$1.newKeys && !this$1.newKeys[ keypath ] ) return;\n\n  \t\tvar newValue = this$1.newValues[ keypath ];\n  \t\tvar oldValue = this$1.oldValues[ keypath ];\n\n  \t\tif ( this$1.strict && newValue === oldValue ) return;\n  \t\tif ( isEqual( newValue, oldValue ) ) return;\n\n  \t\tvar args = [ newValue, oldValue, keypath ];\n  \t\tif ( keypath ) {\n  \t\t\tvar wildcards = this$1.pattern.exec( keypath );\n  \t\t\tif ( wildcards ) {\n  \t\t\t\targs = args.concat( wildcards.slice( 1 ) );\n  \t\t\t}\n  \t\t}\n\n  \t\tthis$1.callback.apply( this$1.context, args );\n  \t});\n\n  \tif ( this.partial ) {\n  \t\tfor ( var k in this.newValues ) {\n  \t\t\tthis.oldValues[k] = this.newValues[k];\n  \t\t}\n  \t} else {\n  \t\tthis.oldValues = this.newValues;\n  \t}\n\n  \tthis.newKeys = null;\n  \tthis.dirty = false;\n  };\n\n  PatternObserver.prototype.notify = function notify ( key ) {\n  \tthis.changed.push( key );\n  };\n\n  PatternObserver.prototype.shuffle = function shuffle ( newIndices ) {\n  \tvar this$1 = this;\n\n  \t\tif ( !isArray( this.baseModel.value ) ) return;\n\n  \tvar base = this.baseModel.getKeypath( this.ractive );\n  \tvar max = this.baseModel.value.length;\n  \tvar suffix = this.keys.length > 1 ? '.' + this.keys.slice( 1 ).join( '.' ) : '';\n\n  \tthis.newKeys = {};\n  \tfor ( var i = 0; i < newIndices.length; i++ ) {\n  \t\tif ( newIndices[ i ] === -1 || newIndices[ i ] === i ) continue;\n  \t\tthis$1.newKeys[ (\"\" + base + \".\" + i + \"\" + suffix) ] = true;\n  \t}\n\n  \tfor ( var i$1 = newIndices.touchedFrom; i$1 < max; i$1++ ) {\n  \t\tthis$1.newKeys[ (\"\" + base + \".\" + i$1 + \"\" + suffix) ] = true;\n  \t}\n  };\n\n  PatternObserver.prototype.handleChange = function handleChange () {\n  \tvar this$1 = this;\n\n  \t\tif ( !this.dirty || this.changed.length ) {\n  \t\tif ( !this.dirty ) this.newValues = {};\n\n  \t\t// handle case where previously extant keypath no longer exists -\n  \t\t// observer should still fire, with undefined as new value\n  \t\t// TODO huh. according to the test suite that's not the case...\n  \t\t// NOTE: I don't think this will work with partial updates\n  \t\t// Object.keys( this.oldValues ).forEach( keypath => {\n  \t\t// this.newValues[ keypath ] = undefined;\n  \t\t// });\n\n  \t\tif ( !this.changed.length ) {\n  \t\t\tthis.baseModel.findMatches( this.keys ).forEach( function ( model ) {\n  \t\t\t\tvar keypath = model.getKeypath( this$1.ractive );\n  \t\t\t\tthis$1.newValues[ keypath ] = model.get();\n  \t\t\t});\n  \t\t\tthis.partial = false;\n  \t\t} else {\n  \t\t\tvar count = 0;\n  \t\t\tvar ok = this.baseModel.isRoot ?\n  \t\t\t\tthis.changed.map( function ( keys ) { return keys.map( escapeKey ).join( '.' ); } ) :\n  \t\t\t\tthis.changed.map( function ( keys ) { return this$1.baseModel.getKeypath( this$1.ractive ) + '.' + keys.map( escapeKey ).join( '.' ); } );\n\n  \t\t\tthis.baseModel.findMatches( this.keys ).forEach( function ( model ) {\n  \t\t\t\tvar keypath = model.getKeypath( this$1.ractive );\n  \t\t\t\t// is this model on a changed keypath?\n  \t\t\t\tif ( ok.filter( function ( k ) { return keypath.indexOf( k ) === 0 || k.indexOf( keypath ) === 0; } ).length ) {\n  \t\t\t\t\tcount++;\n  \t\t\t\t\tthis$1.newValues[ keypath ] = model.get();\n  \t\t\t\t}\n  \t\t\t});\n\n  \t\t\t// no valid change triggered, so bail to avoid breakage\n  \t\t\tif ( !count ) return;\n\n  \t\t\tthis.partial = true;\n  \t\t}\n\n  \t\trunloop.addObserver( this, this.defer );\n  \t\tthis.dirty = true;\n  \t\tthis.changed.length = 0;\n\n  \t\tif ( this.once ) this.cancel();\n  \t}\n  };\n\n  function observeList ( keypath, callback, options ) {\n  \tif ( typeof keypath !== 'string' ) {\n  \t\tthrow new Error( 'ractive.observeList() must be passed a string as its first argument' );\n  \t}\n\n  \tvar model = this.viewmodel.joinAll( splitKeypathI( keypath ) );\n  \tvar observer = new ListObserver( this, model, callback, options || {} );\n\n  \t// add observer to the Ractive instance, so it can be\n  \t// cancelled on ractive.teardown()\n  \tthis._observers.push( observer );\n\n  \treturn {\n  \t\tcancel: function () {\n  \t\t\tobserver.cancel();\n  \t\t}\n  \t};\n  }\n\n  function negativeOne () {\n  \treturn -1;\n  }\n\n  var ListObserver = function ListObserver ( context, model, callback, options ) {\n  \tthis.context = context;\n  \tthis.model = model;\n  \tthis.keypath = model.getKeypath();\n  \tthis.callback = callback;\n\n  \tthis.pending = null;\n\n  \tmodel.register( this );\n\n  \tif ( options.init !== false ) {\n  \t\tthis.sliced = [];\n  \t\tthis.shuffle([]);\n  \t\tthis.handleChange();\n  \t} else {\n  \t\tthis.sliced = this.slice();\n  \t}\n  };\n\n  ListObserver.prototype.handleChange = function handleChange () {\n  \tif ( this.pending ) {\n  \t\t// post-shuffle\n  \t\tthis.callback( this.pending );\n  \t\tthis.pending = null;\n  \t}\n\n  \telse {\n  \t\t// entire array changed\n  \t\tthis.shuffle( this.sliced.map( negativeOne ) );\n  \t\tthis.handleChange();\n  \t}\n  };\n\n  ListObserver.prototype.shuffle = function shuffle ( newIndices ) {\n  \tvar this$1 = this;\n\n  \t\tvar newValue = this.slice();\n\n  \tvar inserted = [];\n  \tvar deleted = [];\n  \tvar start;\n\n  \tvar hadIndex = {};\n\n  \tnewIndices.forEach( function ( newIndex, oldIndex ) {\n  \t\thadIndex[ newIndex ] = true;\n\n  \t\tif ( newIndex !== oldIndex && start === undefined ) {\n  \t\t\tstart = oldIndex;\n  \t\t}\n\n  \t\tif ( newIndex === -1 ) {\n  \t\t\tdeleted.push( this$1.sliced[ oldIndex ] );\n  \t\t}\n  \t});\n\n  \tif ( start === undefined ) start = newIndices.length;\n\n  \tvar len = newValue.length;\n  \tfor ( var i = 0; i < len; i += 1 ) {\n  \t\tif ( !hadIndex[i] ) inserted.push( newValue[i] );\n  \t}\n\n  \tthis.pending = { inserted: inserted, deleted: deleted, start: start };\n  \tthis.sliced = newValue;\n  };\n\n  ListObserver.prototype.slice = function slice () {\n  \tvar value = this.model.get();\n  \treturn isArray( value ) ? value.slice() : [];\n  };\n\n  var onceOptions = { init: false, once: true };\n\n  function observeOnce ( keypath, callback, options ) {\n  \tif ( isObject( keypath ) || typeof keypath === 'function' ) {\n  \t\toptions = extendObj( callback || {}, onceOptions );\n  \t\treturn this.observe( keypath, options );\n  \t}\n\n  \toptions = extendObj( options || {}, onceOptions );\n  \treturn this.observe( keypath, callback, options );\n  }\n\n  function trim ( str ) { return str.trim(); };\n\n  function notEmptyString ( str ) { return str !== ''; };\n\n  function Ractive$off ( eventName, callback ) {\n  \t// if no arguments specified, remove all callbacks\n  \tvar this$1 = this;\n\n  \tif ( !eventName ) {\n  \t\t// TODO use this code instead, once the following issue has been resolved\n  \t\t// in PhantomJS (tests are unpassable otherwise!)\n  \t\t// https://github.com/ariya/phantomjs/issues/11856\n  \t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n  \t\tfor ( eventName in this._subs ) {\n  \t\t\tdelete this._subs[ eventName ];\n  \t\t}\n  \t}\n\n  \telse {\n  \t\t// Handle multiple space-separated event names\n  \t\tvar eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\n  \t\teventNames.forEach( function ( eventName ) {\n  \t\t\tvar subscribers = this$1._subs[ eventName ];\n\n  \t\t\t// If we have subscribers for this event...\n  \t\t\tif ( subscribers ) {\n  \t\t\t\t// ...if a callback was specified, only remove that\n  \t\t\t\tif ( callback ) {\n  \t\t\t\t\t// flag this callback as off so that any in-flight firings don't call\n  \t\t\t\t\t// a cancelled handler - this is _slightly_ hacky\n  \t\t\t\t\tcallback.off = true;\n  \t\t\t\t\tvar index = subscribers.indexOf( callback );\n  \t\t\t\t\tif ( index !== -1 ) {\n  \t\t\t\t\t\tsubscribers.splice( index, 1 );\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// ...otherwise remove all callbacks\n  \t\t\t\telse {\n  \t\t\t\t\tthis$1._subs[ eventName ] = [];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \treturn this;\n  }\n\n  function Ractive$on ( eventName, callback ) {\n  \t// allow multiple listeners to be bound in one go\n  \tvar this$1 = this;\n\n  \tif ( typeof eventName === 'object' ) {\n  \t\tvar listeners = [];\n  \t\tvar n;\n\n  \t\tfor ( n in eventName ) {\n  \t\t\tif ( eventName.hasOwnProperty( n ) ) {\n  \t\t\t\tlisteners.push( this.on( n, eventName[ n ] ) );\n  \t\t\t}\n  \t\t}\n\n  \t\treturn {\n  \t\t\tcancel: function () {\n  \t\t\t\tvar listener;\n  \t\t\t\twhile ( listener = listeners.pop() ) listener.cancel();\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \t// Handle multiple space-separated event names\n  \tvar eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );\n\n  \teventNames.forEach( function ( eventName ) {\n  \t\t( this$1._subs[ eventName ] || ( this$1._subs[ eventName ] = [] ) ).push( callback );\n  \t});\n\n  \treturn {\n  \t\tcancel: function () { return this$1.off( eventName, callback ); }\n  \t};\n  }\n\n  function Ractive$once ( eventName, handler ) {\n  \tvar listener = this.on( eventName, function () {\n  \t\thandler.apply( this, arguments );\n  \t\tlistener.cancel();\n  \t});\n\n  \t// so we can still do listener.cancel() manually\n  \treturn listener;\n  }\n\n  var pop$1 = makeArrayMethod( 'pop' ).path;\n\n  var push$1 = makeArrayMethod( 'push' ).path;\n\n  var PREFIX = '/* Ractive.js component styles */';\n\n  // Holds current definitions of styles.\n  var styleDefinitions = [];\n\n  // Flag to tell if we need to update the CSS\n  var isDirty = false;\n\n  // These only make sense on the browser. See additional setup below.\n  var styleElement = null;\n  var useCssText = null;\n\n  function addCSS( styleDefinition ) {\n  \tstyleDefinitions.push( styleDefinition );\n  \tisDirty = true;\n  }\n\n  function applyCSS() {\n\n  \t// Apply only seems to make sense when we're in the DOM. Server-side renders\n  \t// can call toCSS to get the updated CSS.\n  \tif ( !doc || !isDirty ) return;\n\n  \tif ( useCssText ) {\n  \t\tstyleElement.styleSheet.cssText = getCSS( null );\n  \t} else {\n  \t\tstyleElement.innerHTML = getCSS( null );\n  \t}\n\n  \tisDirty = false;\n  }\n\n  function getCSS( cssIds ) {\n\n  \tvar filteredStyleDefinitions = cssIds ? styleDefinitions.filter( function ( style ) { return ~cssIds.indexOf( style.id ); } ) : styleDefinitions;\n\n  \treturn filteredStyleDefinitions.reduce( function ( styles, style ) { return (\"\" + styles + \"\\n\\n/* {\" + (style.id) + \"} */\\n\" + (style.styles)); }, PREFIX );\n\n  }\n\n  // If we're on the browser, additional setup needed.\n  if ( doc && ( !styleElement || !styleElement.parentNode ) ) {\n\n  \tstyleElement = doc.createElement( 'style' );\n  \tstyleElement.type = 'text/css';\n\n  \tdoc.getElementsByTagName( 'head' )[ 0 ].appendChild( styleElement );\n\n  \tuseCssText = !!styleElement.styleSheet;\n  }\n\n  var renderHook = new Hook( 'render' );\n  var completeHook = new Hook( 'complete' );\n\n  function render$1 ( ractive, target, anchor, occupants ) {\n  \t// if `noIntro` is `true`, temporarily disable transitions\n  \tvar transitionsEnabled = ractive.transitionsEnabled;\n  \tif ( ractive.noIntro ) ractive.transitionsEnabled = false;\n\n  \tvar promise = runloop.start( ractive, true );\n  \trunloop.scheduleTask( function () { return renderHook.fire( ractive ); }, true );\n\n  \tif ( ractive.fragment.rendered ) {\n  \t\tthrow new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );\n  \t}\n\n  \tanchor = getElement( anchor ) || ractive.anchor;\n\n  \tractive.el = target;\n  \tractive.anchor = anchor;\n\n  \t// ensure encapsulated CSS is up-to-date\n  \tif ( ractive.cssId ) applyCSS();\n\n  \tif ( target ) {\n  \t\t( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( ractive );\n\n  \t\tif ( anchor ) {\n  \t\t\tvar docFrag = doc.createDocumentFragment();\n  \t\t\tractive.fragment.render( docFrag );\n  \t\t\ttarget.insertBefore( docFrag, anchor );\n  \t\t} else {\n  \t\t\tractive.fragment.render( target, occupants );\n  \t\t}\n  \t}\n\n  \trunloop.end();\n  \tractive.transitionsEnabled = transitionsEnabled;\n\n  \treturn promise.then( function () { return completeHook.fire( ractive ); } );\n  }\n\n  function Ractive$render ( target, anchor ) {\n  \tif ( this.torndown ) {\n  \t\twarnIfDebug( 'ractive.render() was called on a Ractive instance that was already torn down' );\n  \t\treturn Promise.resolve();\n  \t}\n\n  \ttarget = getElement( target ) || this.el;\n\n  \tif ( !this.append && target ) {\n  \t\t// Teardown any existing instances *before* trying to set up the new one -\n  \t\t// avoids certain weird bugs\n  \t\tvar others = target.__ractive_instances__;\n  \t\tif ( others ) others.forEach( teardown );\n\n  \t\t// make sure we are the only occupants\n  \t\tif ( !this.enhance ) {\n  \t\t\ttarget.innerHTML = ''; // TODO is this quicker than removeChild? Initial research inconclusive\n  \t\t}\n  \t}\n\n  \tvar occupants = this.enhance ? toArray( target.childNodes ) : null;\n  \tvar promise = render$1( this, target, anchor, occupants );\n\n  \tif ( occupants ) {\n  \t\twhile ( occupants.length ) target.removeChild( occupants.pop() );\n  \t}\n\n  \treturn promise;\n  }\n\n  var adaptConfigurator = {\n  \textend: function ( Parent, proto, options ) {\n  \t\tproto.adapt = combine( proto.adapt, ensureArray( options.adapt ) );\n  \t},\n\n  \tinit: function () {}\n  };\n\n  function combine ( a, b ) {\n  \tvar c = a.slice();\n  \tvar i = b.length;\n\n  \twhile ( i-- ) {\n  \t\tif ( !~c.indexOf( b[i] ) ) {\n  \t\t\tc.push( b[i] );\n  \t\t}\n  \t}\n\n  \treturn c;\n  }\n\n  var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g;\n  var commentsPattern = /\\/\\*[\\s\\S]*?\\*\\//g;\n  var selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>~:]))+)((?:::?[^\\s\\+\\>\\~\\(:]+(?:\\([^\\)]+\\))?)*\\s*[\\s\\+\\>\\~]?)\\s*/g;\n  var excludePattern = /^(?:@|\\d+%)/;\n  var dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n\n  function trim$1 ( str ) {\n  \treturn str.trim();\n  }\n\n  function extractString ( unit ) {\n  \treturn unit.str;\n  }\n\n  function transformSelector ( selector, parent ) {\n  \tvar selectorUnits = [];\n  \tvar match;\n\n  \twhile ( match = selectorUnitPattern.exec( selector ) ) {\n  \t\tselectorUnits.push({\n  \t\t\tstr: match[0],\n  \t\t\tbase: match[1],\n  \t\t\tmodifiers: match[2]\n  \t\t});\n  \t}\n\n  \t// For each simple selector within the selector, we need to create a version\n  \t// that a) combines with the id, and b) is inside the id\n  \tvar base = selectorUnits.map( extractString );\n\n  \tvar transformed = [];\n  \tvar i = selectorUnits.length;\n\n  \twhile ( i-- ) {\n  \t\tvar appended = base.slice();\n\n  \t\t// Pseudo-selectors should go after the attribute selector\n  \t\tvar unit = selectorUnits[i];\n  \t\tappended[i] = unit.base + parent + unit.modifiers || '';\n\n  \t\tvar prepended = base.slice();\n  \t\tprepended[i] = parent + ' ' + prepended[i];\n\n  \t\ttransformed.push( appended.join( ' ' ), prepended.join( ' ' ) );\n  \t}\n\n  \treturn transformed.join( ', ' );\n  }\n\n  function transformCss ( css, id ) {\n  \tvar dataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\n  \tvar transformed;\n\n  \tif ( dataRvcGuidPattern.test( css ) ) {\n  \t\ttransformed = css.replace( dataRvcGuidPattern, dataAttr );\n  \t} else {\n  \t\ttransformed = css\n  \t\t.replace( commentsPattern, '' )\n  \t\t.replace( selectorsPattern, function ( match, $1 ) {\n  \t\t\t// don't transform at-rules and keyframe declarations\n  \t\t\tif ( excludePattern.test( $1 ) ) return match;\n\n  \t\t\tvar selectors = $1.split( ',' ).map( trim$1 );\n  \t\t\tvar transformed = selectors\n  \t\t\t\t.map( function ( selector ) { return transformSelector( selector, dataAttr ); } )\n  \t\t\t\t.join( ', ' ) + ' ';\n\n  \t\t\treturn match.replace( $1, transformed );\n  \t\t});\n  \t}\n\n  \treturn transformed;\n  }\n\n  function s4() {\n  \treturn Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n\n  function uuid() {\n  \treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  }\n\n  var cssConfigurator = {\n  \tname: 'css',\n\n  \t// Called when creating a new component definition\n  \textend: function ( Parent, proto, options ) {\n  \t\tif ( !options.css ) return;\n\n  \t\tvar id = uuid();\n  \t\tvar styles = options.noCssTransform ? options.css : transformCss( options.css, id );\n\n  \t\tproto.cssId = id;\n\n  \t\taddCSS( { id: id, styles: styles } );\n\n  \t},\n\n  \t// Called when creating a new component instance\n  \tinit: function ( Parent, target, options ) {\n  \t\tif ( !options.css ) return;\n\n  \t\twarnIfDebug( (\"\\nThe css option is currently not supported on a per-instance basis and will be discarded. Instead, we recommend instantiating from a component definition with a css option.\\n\\nconst Component = Ractive.extend({\\n\\t...\\n\\tcss: '/* your css */',\\n\\t...\\n});\\n\\nconst componentInstance = new Component({ ... })\\n\\t\\t\") );\n  \t}\n\n  };\n\n  function validate ( data ) {\n  \t// Warn if userOptions.data is a non-POJO\n  \tif ( data && data.constructor !== Object ) {\n  \t\tif ( typeof data === 'function' ) {\n  \t\t\t// TODO do we need to support this in the new Ractive() case?\n  \t\t} else if ( typeof data !== 'object' ) {\n  \t\t\tfatal( (\"data option must be an object or a function, `\" + data + \"` is not valid\") );\n  \t\t} else {\n  \t\t\twarnIfDebug( 'If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged' );\n  \t\t}\n  \t}\n  }\n\n  var dataConfigurator = {\n  \tname: 'data',\n\n  \textend: function ( Parent, proto, options ) {\n  \t\tvar key;\n  \t\tvar value;\n\n  \t\t// check for non-primitives, which could cause mutation-related bugs\n  \t\tif ( options.data && isObject( options.data ) ) {\n  \t\t\tfor ( key in options.data ) {\n  \t\t\t\tvalue = options.data[ key ];\n\n  \t\t\t\tif ( value && typeof value === 'object' ) {\n  \t\t\t\t\tif ( isObject( value ) || isArray( value ) ) {\n  \t\t\t\t\t\twarnIfDebug( (\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\") );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tproto.data = combine$1( proto.data, options.data );\n  \t},\n\n  \tinit: function ( Parent, ractive, options ) {\n  \t\tvar result = combine$1( Parent.prototype.data, options.data );\n\n  \t\tif ( typeof result === 'function' ) result = result.call( ractive );\n\n  \t\t// bind functions to the ractive instance at the top level,\n  \t\t// unless it's a non-POJO (in which case alarm bells should ring)\n  \t\tif ( result && result.constructor === Object ) {\n  \t\t\tfor ( var prop in result ) {\n  \t\t\t\tif ( typeof result[ prop ] === 'function' ) result[ prop ] = bind( result[ prop ], ractive );\n  \t\t\t}\n  \t\t}\n\n  \t\treturn result || {};\n  \t},\n\n  \treset: function ( ractive ) {\n  \t\tvar result = this.init( ractive.constructor, ractive, ractive.viewmodel );\n  \t\tractive.viewmodel.root.set( result );\n  \t\treturn true;\n  \t}\n  };\n\n  function combine$1 ( parentValue, childValue ) {\n  \tvalidate( childValue );\n\n  \tvar parentIsFn = typeof parentValue === 'function';\n  \tvar childIsFn = typeof childValue === 'function';\n\n  \t// Very important, otherwise child instance can become\n  \t// the default data object on Ractive or a component.\n  \t// then ractive.set() ends up setting on the prototype!\n  \tif ( !childValue && !parentIsFn ) {\n  \t\tchildValue = {};\n  \t}\n\n  \t// Fast path, where we just need to copy properties from\n  \t// parent to child\n  \tif ( !parentIsFn && !childIsFn ) {\n  \t\treturn fromProperties( childValue, parentValue );\n  \t}\n\n  \treturn function () {\n  \t\tvar child = childIsFn ? callDataFunction( childValue, this ) : childValue;\n  \t\tvar parent = parentIsFn ? callDataFunction( parentValue, this ) : parentValue;\n\n  \t\treturn fromProperties( child, parent );\n  \t};\n  }\n\n  function callDataFunction ( fn, context ) {\n  \tvar data = fn.call( context );\n\n  \tif ( !data ) return;\n\n  \tif ( typeof data !== 'object' ) {\n  \t\tfatal( 'Data function must return an object' );\n  \t}\n\n  \tif ( data.constructor !== Object ) {\n  \t\twarnOnceIfDebug( 'Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged' );\n  \t}\n\n  \treturn data;\n  }\n\n  function fromProperties ( primary, secondary ) {\n  \tif ( primary && secondary ) {\n  \t\tfor ( var key in secondary ) {\n  \t\t\tif ( !( key in primary ) ) {\n  \t\t\t\tprimary[ key ] = secondary[ key ];\n  \t\t\t}\n  \t\t}\n\n  \t\treturn primary;\n  \t}\n\n  \treturn primary || secondary;\n  }\n\n  var TEMPLATE_VERSION = 4;\n\n  var pattern = /\\$\\{([^\\}]+)\\}/g;\n\n  function fromExpression ( body, length ) {\n  \tif ( length === void 0 ) length = 0;\n\n  \tvar args = new Array( length );\n\n  \twhile ( length-- ) {\n  \t\targs[length] = \"_\" + length;\n  \t}\n\n  \t// Functions created directly with new Function() look like this:\n  \t//     function anonymous (_0 /**/) { return _0*2 }\n  \t//\n  \t// With this workaround, we get a little more compact:\n  \t//     function (_0){return _0*2}\n  \treturn new Function( [], (\"return function (\" + (args.join(',')) + \"){return(\" + body + \");};\") )();\n  }\n\n  function fromComputationString ( str, bindTo ) {\n  \tvar hasThis;\n\n  \tvar functionBody = 'return (' + str.replace( pattern, function ( match, keypath ) {\n  \t\thasThis = true;\n  \t\treturn (\"__ractive.get(\\\"\" + keypath + \"\\\")\");\n  \t}) + ');';\n\n  \tif ( hasThis ) functionBody = \"var __ractive = this; \" + functionBody;\n  \tvar fn = new Function( functionBody );\n  \treturn hasThis ? fn.bind( bindTo ) : fn;\n  }\n\n  var functions = create( null );\n\n  function getFunction ( str, i ) {\n  \tif ( functions[ str ] ) return functions[ str ];\n  \treturn functions[ str ] = createFunction( str, i );\n  }\n\n  function addFunctions( template ) {\n  \tif ( !template ) return;\n\n  \tvar exp = template.e;\n\n  \tif ( !exp ) return;\n\n  \tObject.keys( exp ).forEach( function ( str ) {\n  \t\tif ( functions[ str ] ) return;\n  \t\tfunctions[ str ] = exp[ str ];\n  \t});\n  }\n\n  var Parser;\n  var ParseError;\n  var leadingWhitespace = /^\\s+/;\n  ParseError = function ( message ) {\n  \tthis.name = 'ParseError';\n  \tthis.message = message;\n  \ttry {\n  \t\tthrow new Error(message);\n  \t} catch (e) {\n  \t\tthis.stack = e.stack;\n  \t}\n  };\n\n  ParseError.prototype = Error.prototype;\n\n  Parser = function ( str, options ) {\n  \tvar this$1 = this;\n\n  \tvar items, item, lineStart = 0;\n\n  \tthis.str = str;\n  \tthis.options = options || {};\n  \tthis.pos = 0;\n\n  \tthis.lines = this.str.split( '\\n' );\n  \tthis.lineEnds = this.lines.map( function ( line ) {\n  \t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n  \t\tlineStart = lineEnd;\n  \t\treturn lineEnd;\n  \t}, 0 );\n\n  \t// Custom init logic\n  \tif ( this.init ) this.init( str, options );\n\n  \titems = [];\n\n  \twhile ( ( this$1.pos < this$1.str.length ) && ( item = this$1.read() ) ) {\n  \t\titems.push( item );\n  \t}\n\n  \tthis.leftover = this.remaining();\n  \tthis.result = this.postProcess ? this.postProcess( items, options ) : items;\n  };\n\n  Parser.prototype = {\n  \tread: function ( converters ) {\n  \t\tvar this$1 = this;\n\n  \t\tvar pos, i, len, item;\n\n  \t\tif ( !converters ) converters = this.converters;\n\n  \t\tpos = this.pos;\n\n  \t\tlen = converters.length;\n  \t\tfor ( i = 0; i < len; i += 1 ) {\n  \t\t\tthis$1.pos = pos; // reset for each attempt\n\n  \t\t\tif ( item = converters[i]( this$1 ) ) {\n  \t\t\t\treturn item;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t},\n\n  \tgetContextMessage: function ( pos, message ) {\n  \t\tvar ref = this.getLinePos( pos ), lineNum = ref[0], columnNum = ref[1];\n  \t\tif ( this.options.contextLines === -1 ) {\n  \t\t\treturn [ lineNum, columnNum, (\"\" + message + \" at line \" + lineNum + \" character \" + columnNum) ];\n  \t\t}\n\n  \t\tvar line = this.lines[ lineNum - 1 ];\n\n  \t\tvar contextUp = '';\n  \t\tvar contextDown = '';\n  \t\tif ( this.options.contextLines ) {\n  \t\t\tvar start = lineNum - 1 - this.options.contextLines < 0 ? 0 : lineNum - 1 - this.options.contextLines;\n  \t\t\tcontextUp = this.lines.slice( start, lineNum - 1 - start ).join( '\\n' ).replace( /\\t/g, '  ' );\n  \t\t\tcontextDown = this.lines.slice( lineNum, lineNum + this.options.contextLines ).join( '\\n' ).replace( /\\t/g, '  ' );\n  \t\t\tif ( contextUp ) {\n  \t\t\t\tcontextUp += '\\n';\n  \t\t\t}\n  \t\t\tif ( contextDown ) {\n  \t\t\t\tcontextDown = '\\n' + contextDown;\n  \t\t\t}\n  \t\t}\n\n  \t\tvar numTabs = 0;\n  \t\tvar annotation = contextUp + line.replace( /\\t/g, function ( match, char ) {\n  \t\t\tif ( char < columnNum ) {\n  \t\t\t\tnumTabs += 1;\n  \t\t\t}\n\n  \t\t\treturn '  ';\n  \t\t}) + '\\n' + new Array( columnNum + numTabs ).join( ' ' ) + '^----' + contextDown;\n\n  \t\treturn [ lineNum, columnNum, (\"\" + message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation) ];\n  \t},\n\n  \tgetLinePos: function ( char ) {\n  \t\tvar this$1 = this;\n\n  \t\tvar lineNum = 0, lineStart = 0, columnNum;\n\n  \t\twhile ( char >= this$1.lineEnds[ lineNum ] ) {\n  \t\t\tlineStart = this$1.lineEnds[ lineNum ];\n  \t\t\tlineNum += 1;\n  \t\t}\n\n  \t\tcolumnNum = char - lineStart;\n  \t\treturn [ lineNum + 1, columnNum + 1, char ]; // line/col should be one-based, not zero-based!\n  \t},\n\n  \terror: function ( message ) {\n  \t\tvar ref = this.getContextMessage( this.pos, message ), lineNum = ref[0], columnNum = ref[1], msg = ref[2];\n\n  \t\tvar error = new ParseError( msg );\n\n  \t\terror.line = lineNum;\n  \t\terror.character = columnNum;\n  \t\terror.shortMessage = message;\n\n  \t\tthrow error;\n  \t},\n\n  \tmatchString: function ( string ) {\n  \t\tif ( this.str.substr( this.pos, string.length ) === string ) {\n  \t\t\tthis.pos += string.length;\n  \t\t\treturn string;\n  \t\t}\n  \t},\n\n  \tmatchPattern: function ( pattern ) {\n  \t\tvar match;\n\n  \t\tif ( match = pattern.exec( this.remaining() ) ) {\n  \t\t\tthis.pos += match[0].length;\n  \t\t\treturn match[1] || match[0];\n  \t\t}\n  \t},\n\n  \tallowWhitespace: function () {\n  \t\tthis.matchPattern( leadingWhitespace );\n  \t},\n\n  \tremaining: function () {\n  \t\treturn this.str.substring( this.pos );\n  \t},\n\n  \tnextChar: function () {\n  \t\treturn this.str.charAt( this.pos );\n  \t}\n  };\n\n  Parser.extend = function ( proto ) {\n  \tvar Parent = this, Child, key;\n\n  \tChild = function ( str, options ) {\n  \t\tParser.call( this, str, options );\n  \t};\n\n  \tChild.prototype = create( Parent.prototype );\n\n  \tfor ( key in proto ) {\n  \t\tif ( hasOwn.call( proto, key ) ) {\n  \t\t\tChild.prototype[ key ] = proto[ key ];\n  \t\t}\n  \t}\n\n  \tChild.extend = Parser.extend;\n  \treturn Child;\n  };\n\n  var Parser$1 = Parser;\n\n  var TEXT              = 1;\n  var INTERPOLATOR      = 2;\n  var TRIPLE            = 3;\n  var SECTION           = 4;\n  var INVERTED          = 5;\n  var CLOSING           = 6;\n  var ELEMENT           = 7;\n  var PARTIAL           = 8;\n  var COMMENT           = 9;\n  var DELIMCHANGE       = 10;\n  var ATTRIBUTE         = 13;\n  var CLOSING_TAG       = 14;\n  var COMPONENT         = 15;\n  var YIELDER           = 16;\n  var INLINE_PARTIAL    = 17;\n  var DOCTYPE           = 18;\n  var ALIAS             = 19;\n\n  var NUMBER_LITERAL    = 20;\n  var STRING_LITERAL    = 21;\n  var ARRAY_LITERAL     = 22;\n  var OBJECT_LITERAL    = 23;\n  var BOOLEAN_LITERAL   = 24;\n  var REGEXP_LITERAL    = 25;\n\n  var GLOBAL            = 26;\n  var KEY_VALUE_PAIR    = 27;\n\n\n  var REFERENCE         = 30;\n  var REFINEMENT        = 31;\n  var MEMBER            = 32;\n  var PREFIX_OPERATOR   = 33;\n  var BRACKETED         = 34;\n  var CONDITIONAL       = 35;\n  var INFIX_OPERATOR    = 36;\n\n  var INVOCATION        = 40;\n\n  var SECTION_IF        = 50;\n  var SECTION_UNLESS    = 51;\n  var SECTION_EACH      = 52;\n  var SECTION_WITH      = 53;\n  var SECTION_IF_WITH   = 54;\n\n  var ELSE              = 60;\n  var ELSEIF            = 61;\n\n  var EVENT             = 70;\n  var DECORATOR         = 71;\n  var TRANSITION        = 72;\n  var BINDING_FLAG      = 73;\n\n  var delimiterChangePattern = /^[^\\s=]+/;\n  var whitespacePattern = /^\\s+/;\n  function readDelimiterChange ( parser ) {\n  \tvar start, opening, closing;\n\n  \tif ( !parser.matchString( '=' ) ) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace before new opening delimiter\n  \tparser.allowWhitespace();\n\n  \topening = parser.matchPattern( delimiterChangePattern );\n  \tif ( !opening ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace (in fact, it's necessary...)\n  \tif ( !parser.matchPattern( whitespacePattern ) ) {\n  \t\treturn null;\n  \t}\n\n  \tclosing = parser.matchPattern( delimiterChangePattern );\n  \tif ( !closing ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace before closing '='\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( '=' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn [ opening, closing ];\n  }\n\n  var regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n\n  function readNumberLiteral ( parser ) {\n  \tvar result;\n\n  \tif ( result = parser.matchPattern( regexpPattern ) ) {\n  \t\treturn {\n  \t\t\tt: REGEXP_LITERAL,\n  \t\t\tv: result\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var pattern$1 = /[-/\\\\^$*+?.()|[\\]{}]/g;\n\n  function escapeRegExp ( str ) {\n  \treturn str.replace( pattern$1, '\\\\$&' );\n  }\n\n  var regExpCache = {};\n\n  function getLowestIndex ( haystack, needles ) {\n  \treturn haystack.search( regExpCache[needles.join()] || ( regExpCache[needles.join()] = new RegExp( needles.map( escapeRegExp ).join( '|' ) ) ) );\n  }\n\n  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n  var booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n  var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\n  var htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, 'int': 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830\t};\n  var controlCharacters = [ 8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376 ];\n  var entityPattern = new RegExp( '&(#?(?:x[\\\\w\\\\d]+|\\\\d+|' + Object.keys( htmlEntities ).join( '|' ) + '));?', 'g' );\n  var codePointSupport = typeof String.fromCodePoint === 'function';\n  var codeToChar = codePointSupport ? String.fromCodePoint : String.fromCharCode;\n\n  function decodeCharacterReferences ( html ) {\n  \treturn html.replace( entityPattern, function ( match, entity ) {\n  \t\tvar code;\n\n  \t\t// Handle named entities\n  \t\tif ( entity[0] !== '#' ) {\n  \t\t\tcode = htmlEntities[ entity ];\n  \t\t} else if ( entity[1] === 'x' ) {\n  \t\t\tcode = parseInt( entity.substring( 2 ), 16 );\n  \t\t} else {\n  \t\t\tcode = parseInt( entity.substring( 1 ), 10 );\n  \t\t}\n\n  \t\tif ( !code ) {\n  \t\t\treturn match;\n  \t\t}\n\n  \t\treturn codeToChar( validateCode( code ) );\n  \t});\n  }\n\n  var lessThan = /</g;\n  var greaterThan = />/g;\n  var amp = /&/g;\n  var invalid = 65533;\n\n  function escapeHtml ( str ) {\n  \treturn str\n  \t\t.replace( amp, '&amp;' )\n  \t\t.replace( lessThan, '&lt;' )\n  \t\t.replace( greaterThan, '&gt;' );\n  }\n\n  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n  // code points with alternatives in some cases - since we're bypassing that mechanism, we need\n  // to replace them ourselves\n  //\n  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n  function validateCode ( code ) {\n  \tif ( !code ) {\n  \t\treturn invalid;\n  \t}\n\n  \t// line feed becomes generic whitespace\n  \tif ( code === 10 ) {\n  \t\treturn 32;\n  \t}\n\n  \t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n  \tif ( code < 128 ) {\n  \t\treturn code;\n  \t}\n\n  \t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n  \t// to correct the mistake or we'll end up with missing € signs and so on\n  \tif ( code <= 159 ) {\n  \t\treturn controlCharacters[ code - 128 ];\n  \t}\n\n  \t// basic multilingual plane\n  \tif ( code < 55296 ) {\n  \t\treturn code;\n  \t}\n\n  \t// UTF-16 surrogate halves\n  \tif ( code <= 57343 ) {\n  \t\treturn invalid;\n  \t}\n\n  \t// rest of the basic multilingual plane\n  \tif ( code <= 65535 ) {\n  \t\treturn code;\n  \t} else if ( !codePointSupport ) {\n  \t\treturn invalid;\n  \t}\n\n  \t// supplementary multilingual plane 0x10000 - 0x1ffff\n  \tif ( code >= 65536 && code <= 131071 ) {\n  \t\treturn code;\n  \t}\n\n  \t// supplementary ideographic plane 0x20000 - 0x2ffff\n  \tif ( code >= 131072 && code <= 196607 ) {\n  \t\treturn code;\n  \t}\n\n  \treturn invalid;\n  }\n\n  var expectedExpression = 'Expected a JavaScript expression';\n  var expectedParen = 'Expected closing paren';\n\n  // bulletproof number regex from https://gist.github.com/Rich-Harris/7544330\n  var numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n\n  function readNumberLiteral$1 ( parser ) {\n  \tvar result;\n\n  \tif ( result = parser.matchPattern( numberPattern ) ) {\n  \t\treturn {\n  \t\t\tt: NUMBER_LITERAL,\n  \t\t\tv: result\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  function readBooleanLiteral ( parser ) {\n  \tvar remaining = parser.remaining();\n\n  \tif ( remaining.substr( 0, 4 ) === 'true' ) {\n  \t\tparser.pos += 4;\n  \t\treturn {\n  \t\t\tt: BOOLEAN_LITERAL,\n  \t\t\tv: 'true'\n  \t\t};\n  \t}\n\n  \tif ( remaining.substr( 0, 5 ) === 'false' ) {\n  \t\tparser.pos += 5;\n  \t\treturn {\n  \t\t\tt: BOOLEAN_LITERAL,\n  \t\t\tv: 'false'\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var stringMiddlePattern;\n  var escapeSequencePattern;\n  var lineContinuationPattern;\n  // Match one or more characters until: \", ', \\, or EOL/EOF.\n  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n  stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n  // Match one escape sequence, including the backslash.\n  escapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n  // Match one ES5 line continuation (backslash + line terminator).\n  lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n  // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n  function makeQuotedStringMatcher ( okQuote ) {\n  \treturn function ( parser ) {\n  \t\tvar literal = '\"';\n  \t\tvar done = false;\n  \t\tvar next;\n\n  \t\twhile ( !done ) {\n  \t\t\tnext = ( parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) ||\n  \t\t\t\tparser.matchString( okQuote ) );\n  \t\t\tif ( next ) {\n  \t\t\t\tif ( next === (\"\\\"\") ) {\n  \t\t\t\t\tliteral += \"\\\\\\\"\";\n  \t\t\t\t} else if ( next === (\"\\\\'\") ) {\n  \t\t\t\t\tliteral += \"'\";\n  \t\t\t\t} else {\n  \t\t\t\t\tliteral += next;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tnext = parser.matchPattern( lineContinuationPattern );\n  \t\t\t\tif ( next ) {\n  \t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n  \t\t\t\t\tliteral += '\\\\u' + ( '000' + next.charCodeAt(1).toString(16) ).slice( -4 );\n  \t\t\t\t} else {\n  \t\t\t\t\tdone = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tliteral += '\"';\n\n  \t\t// use JSON.parse to interpret escapes\n  \t\treturn JSON.parse( literal );\n  \t};\n  }\n\n  var getSingleQuotedString = makeQuotedStringMatcher( (\"\\\"\") );\n  var getDoubleQuotedString = makeQuotedStringMatcher( (\"'\") );\n\n  function readStringLiteral ( parser ) {\n  \tvar start, string;\n\n  \tstart = parser.pos;\n\n  \tif ( parser.matchString( '\"' ) ) {\n  \t\tstring = getDoubleQuotedString( parser );\n\n  \t\tif ( !parser.matchString( '\"' ) ) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: STRING_LITERAL,\n  \t\t\tv: string\n  \t\t};\n  \t}\n\n  \tif ( parser.matchString( (\"'\") ) ) {\n  \t\tstring = getSingleQuotedString( parser );\n\n  \t\tif ( !parser.matchString( (\"'\") ) ) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: STRING_LITERAL,\n  \t\t\tv: string\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var namePattern = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\n  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\n  // http://mathiasbynens.be/notes/javascript-properties\n  // can be any name, string literal, or number literal\n  function readKey ( parser ) {\n  \tvar token;\n\n  \tif ( token = readStringLiteral( parser ) ) {\n  \t\treturn identifier.test( token.v ) ? token.v : '\"' + token.v.replace( /\"/g, '\\\\\"' ) + '\"';\n  \t}\n\n  \tif ( token = readNumberLiteral$1( parser ) ) {\n  \t\treturn token.v;\n  \t}\n\n  \tif ( token = parser.matchPattern( namePattern ) ) {\n  \t\treturn token;\n  \t}\n\n  \treturn null;\n  }\n\n  function readKeyValuePair ( parser ) {\n  \tvar start, key, value;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace between '{' and key\n  \tparser.allowWhitespace();\n\n  \tvar refKey = parser.nextChar() !== '\\'' && parser.nextChar() !== '\"';\n\n  \tkey = readKey( parser );\n  \tif ( key === null ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace between key and ':'\n  \tparser.allowWhitespace();\n\n  \t// es2015 shorthand property\n  \tif ( refKey && ( parser.nextChar() === ',' || parser.nextChar() === '}' ) ) {\n  \t\tif ( !namePattern.test( key ) ) {\n  \t\t\tparser.error( (\"Expected a valid reference, but found '\" + key + \"' instead.\") );\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: KEY_VALUE_PAIR,\n  \t\t\tk: key,\n  \t\t\tv: {\n  \t\t\t\tt: REFERENCE,\n  \t\t\t\tn: key\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \t// next character must be ':'\n  \tif ( !parser.matchString( ':' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace between ':' and value\n  \tparser.allowWhitespace();\n\n  \t// next expression must be a, well... expression\n  \tvalue = readExpression( parser );\n  \tif ( value === null ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: KEY_VALUE_PAIR,\n  \t\tk: key,\n  \t\tv: value\n  \t};\n  }\n\n  function readKeyValuePairs ( parser ) {\n  \tvar start, pairs, pair, keyValuePairs;\n\n  \tstart = parser.pos;\n\n  \tpair = readKeyValuePair( parser );\n  \tif ( pair === null ) {\n  \t\treturn null;\n  \t}\n\n  \tpairs = [ pair ];\n\n  \tif ( parser.matchString( ',' ) ) {\n  \t\tkeyValuePairs = readKeyValuePairs( parser );\n\n  \t\tif ( !keyValuePairs ) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn pairs.concat( keyValuePairs );\n  \t}\n\n  \treturn pairs;\n  }\n\n  function readObjectLiteral ( parser ) {\n  \tvar start, keyValuePairs;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( '{' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tkeyValuePairs = readKeyValuePairs( parser );\n\n  \t// allow whitespace between final value and '}'\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( '}' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: OBJECT_LITERAL,\n  \t\tm: keyValuePairs\n  \t};\n  }\n\n  function readExpressionList ( parser ) {\n  \tparser.allowWhitespace();\n\n  \tvar expr = readExpression( parser );\n\n  \tif ( expr === null ) return null;\n\n  \tvar expressions = [ expr ];\n\n  \t// allow whitespace between expression and ','\n  \tparser.allowWhitespace();\n\n  \tif ( parser.matchString( ',' ) ) {\n  \t\tvar next = readExpressionList( parser );\n  \t\tif ( next === null ) parser.error( expectedExpression );\n\n  \t\texpressions.push.apply( expressions, next );\n  \t}\n\n  \treturn expressions;\n  }\n\n  function readArrayLiteral ( parser ) {\n  \tvar start, expressionList;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace before '['\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( '[' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \texpressionList = readExpressionList( parser );\n\n  \tif ( !parser.matchString( ']' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: ARRAY_LITERAL,\n  \t\tm: expressionList\n  \t};\n  }\n\n  function readLiteral ( parser ) {\n  \treturn readNumberLiteral$1( parser )  ||\n  \t       readBooleanLiteral( parser ) ||\n  \t       readStringLiteral( parser )  ||\n  \t       readObjectLiteral( parser )  ||\n  \t       readArrayLiteral( parser )   ||\n  \t       readNumberLiteral( parser );\n  }\n\n  var prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/;\n  var globals;\n  var keywords;\n  // if a reference is a browser global, we don't deference it later, so it needs special treatment\n  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null|Object|Number|String|Boolean)\\b/;\n\n  // keywords are not valid references, with the exception of `this`\n  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\n  var legalReference = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:\\.(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\n  var relaxedName = /^[a-zA-Z_$][-\\/a-zA-Z_$0-9]*/;\n  var specials = /^@(?:keypath|rootpath|index|key|this|global)/;\n  var specialCall = /^\\s*\\(/;\n  var spreadPattern = /^\\s*\\.{3}/;\n\n  function readReference ( parser ) {\n  \tvar startPos, prefix, name, global, reference, fullLength, lastDotIndex, spread;\n\n  \tstartPos = parser.pos;\n\n  \tname = parser.matchPattern( specials );\n\n  \tif ( name === '@keypath' || name === '@rootpath' ) {\n  \t\tif ( parser.matchPattern( specialCall ) ) {\n  \t\t\tvar ref = readReference( parser );\n  \t\t\tif ( !ref ) parser.error( (\"Expected a valid reference for a keypath expression\") );\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif ( !parser.matchString( ')' ) ) parser.error( (\"Unclosed keypath expression\") );\n  \t\t\tname += \"(\" + (ref.n) + \")\";\n  \t\t}\n  \t}\n\n  \tspread = !name && parser.spreadArgs && parser.matchPattern( spreadPattern );\n\n  \tif ( !name ) {\n  \t\tprefix = parser.matchPattern( prefixPattern ) || '';\n  \t\tname = ( !prefix && parser.relaxedNames && parser.matchPattern( relaxedName ) ) ||\n  \t\t       parser.matchPattern( legalReference );\n\n  \t\tif ( !name && prefix === '.' ) {\n  \t\t\tprefix = '';\n  \t\t\tname = '.';\n  \t\t} else if ( !name && prefix ) {\n  \t\t\tname = prefix;\n  \t\t\tprefix = '';\n  \t\t}\n  \t}\n\n  \tif ( !name ) {\n  \t\treturn null;\n  \t}\n\n  \t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  \tif ( !prefix && !parser.relaxedNames && keywords.test( name ) ) {\n  \t\tparser.pos = startPos;\n  \t\treturn null;\n  \t}\n\n  \t// if this is a browser global, stop here\n  \tif ( !prefix && globals.test( name ) ) {\n  \t\tglobal = globals.exec( name )[0];\n  \t\tparser.pos = startPos + global.length;\n\n  \t\treturn {\n  \t\t\tt: GLOBAL,\n  \t\t\tv: ( spread ? '...' : '' ) + global\n  \t\t};\n  \t}\n\n  \tfullLength = ( spread ? 3 : 0 ) + ( prefix || '' ).length + name.length;\n  \treference = ( prefix || '' ) + normalise( name );\n\n  \tif ( parser.matchString( '(' ) ) {\n  \t\t// if this is a method invocation (as opposed to a function) we need\n  \t\t// to strip the method name from the reference combo, else the context\n  \t\t// will be wrong\n  \t\t// but only if the reference was actually a member and not a refinement\n  \t\tlastDotIndex = reference.lastIndexOf( '.' );\n  \t\tif ( lastDotIndex !== -1 && name[ name.length - 1 ] !== ']' ) {\n  \t\t\tvar refLength = reference.length;\n  \t\t\treference = reference.substr( 0, lastDotIndex );\n  \t\t\tparser.pos = startPos + (fullLength - ( refLength - lastDotIndex ) );\n  \t\t} else {\n  \t\t\tparser.pos -= 1;\n  \t\t}\n  \t}\n\n  \treturn {\n  \t\tt: REFERENCE,\n  \t\tn: ( spread ? '...' : '' ) + reference.replace( /^this\\./, './' ).replace( /^this$/, '.' )\n  \t};\n  }\n\n  function readBracketedExpression ( parser ) {\n  \tif ( !parser.matchString( '(' ) ) return null;\n\n  \tparser.allowWhitespace();\n\n  \tvar expr = readExpression( parser );\n\n  \tif ( !expr ) parser.error( expectedExpression );\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( ')' ) ) parser.error( expectedParen );\n\n  \treturn {\n  \t\tt: BRACKETED,\n  \t\tx: expr\n  \t};\n  }\n\n  function readPrimary ( parser ) {\n  \treturn readLiteral( parser )\n  \t\t|| readReference( parser )\n  \t\t|| readBracketedExpression( parser );\n  }\n\n  function readRefinement ( parser ) {\n  \t// some things call for strict refinement (partial names), meaning no space between reference and refinement\n  \tif ( !parser.strictRefinement ) {\n  \t\tparser.allowWhitespace();\n  \t}\n\n  \t// \".\" name\n  \tif ( parser.matchString( '.' ) ) {\n  \t\tparser.allowWhitespace();\n\n  \t\tvar name = parser.matchPattern( namePattern );\n  \t\tif ( name ) {\n  \t\t\treturn {\n  \t\t\t\tt: REFINEMENT,\n  \t\t\t\tn: name\n  \t\t\t};\n  \t\t}\n\n  \t\tparser.error( 'Expected a property name' );\n  \t}\n\n  \t// \"[\" expression \"]\"\n  \tif ( parser.matchString( '[' ) ) {\n  \t\tparser.allowWhitespace();\n\n  \t\tvar expr = readExpression( parser );\n  \t\tif ( !expr ) parser.error( expectedExpression );\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif ( !parser.matchString( ']' ) ) parser.error( (\"Expected ']'\") );\n\n  \t\treturn {\n  \t\t\tt: REFINEMENT,\n  \t\t\tx: expr\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  function readMemberOrInvocation ( parser ) {\n  \tvar expression = readPrimary( parser );\n\n  \tif ( !expression ) return null;\n\n  \twhile ( expression ) {\n  \t\tvar refinement = readRefinement( parser );\n  \t\tif ( refinement ) {\n  \t\t\texpression = {\n  \t\t\t\tt: MEMBER,\n  \t\t\t\tx: expression,\n  \t\t\t\tr: refinement\n  \t\t\t};\n  \t\t}\n\n  \t\telse if ( parser.matchString( '(' ) ) {\n  \t\t\tparser.allowWhitespace();\n  \t\t\tvar start = parser.spreadArgs;\n  \t\t\tparser.spreadArgs = true;\n  \t\t\tvar expressionList = readExpressionList( parser );\n  \t\t\tparser.spreadArgs = start;\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif ( !parser.matchString( ')' ) ) {\n  \t\t\t\tparser.error( expectedParen );\n  \t\t\t}\n\n  \t\t\texpression = {\n  \t\t\t\tt: INVOCATION,\n  \t\t\t\tx: expression\n  \t\t\t};\n\n  \t\t\tif ( expressionList ) expression.o = expressionList;\n  \t\t}\n\n  \t\telse {\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \treturn expression;\n  }\n\n  var readTypeOf;\n  var makePrefixSequenceMatcher;\n  makePrefixSequenceMatcher = function ( symbol, fallthrough ) {\n  \treturn function ( parser ) {\n  \t\tvar expression;\n\n  \t\tif ( expression = fallthrough( parser ) ) {\n  \t\t\treturn expression;\n  \t\t}\n\n  \t\tif ( !parser.matchString( symbol ) ) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n\n  \t\texpression = readExpression( parser );\n  \t\tif ( !expression ) {\n  \t\t\tparser.error( expectedExpression );\n  \t\t}\n\n  \t\treturn {\n  \t\t\ts: symbol,\n  \t\t\to: expression,\n  \t\t\tt: PREFIX_OPERATOR\n  \t\t};\n  \t};\n  };\n\n  // create all prefix sequence matchers, return readTypeOf\n  (function() {\n  \tvar i, len, matcher, prefixOperators, fallthrough;\n\n  \tprefixOperators = '! ~ + - typeof'.split( ' ' );\n\n  \tfallthrough = readMemberOrInvocation;\n  \tfor ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {\n  \t\tmatcher = makePrefixSequenceMatcher( prefixOperators[i], fallthrough );\n  \t\tfallthrough = matcher;\n  \t}\n\n  \t// typeof operator is higher precedence than multiplication, so provides the\n  \t// fallthrough for the multiplication sequence matcher we're about to create\n  \t// (we're skipping void and delete)\n  \treadTypeOf = fallthrough;\n  }());\n\n  var readTypeof = readTypeOf;\n\n  var readLogicalOr;\n  var makeInfixSequenceMatcher;\n  makeInfixSequenceMatcher = function ( symbol, fallthrough ) {\n  \treturn function ( parser ) {\n  \t\tvar start, left, right;\n\n  \t\tleft = fallthrough( parser );\n  \t\tif ( !left ) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n  \t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n  \t\t// to parse `left` because that would be infinite regress.\n  \t\twhile ( true ) {\n  \t\t\tstart = parser.pos;\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif ( !parser.matchString( symbol ) ) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n  \t\t\tif ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\t// right operand must also consist of only higher-precedence operators\n  \t\t\tright = fallthrough( parser );\n  \t\t\tif ( !right ) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\tleft = {\n  \t\t\t\tt: INFIX_OPERATOR,\n  \t\t\t\ts: symbol,\n  \t\t\t\to: [ left, right ]\n  \t\t\t};\n\n  \t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n  \t\t\t// we'll return left.\n  \t\t}\n  \t};\n  };\n\n  // create all infix sequence matchers, and return readLogicalOr\n  (function() {\n  \tvar i, len, matcher, infixOperators, fallthrough;\n\n  \t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  \t// Each sequence matcher will initially fall through to its higher precedence\n  \t// neighbour, and only attempt to match if one of the higher precedence operators\n  \t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n  \tinfixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );\n\n  \t// A typeof operator is higher precedence than multiplication\n  \tfallthrough = readTypeof;\n  \tfor ( i = 0, len = infixOperators.length; i < len; i += 1 ) {\n  \t\tmatcher = makeInfixSequenceMatcher( infixOperators[i], fallthrough );\n  \t\tfallthrough = matcher;\n  \t}\n\n  \t// Logical OR is the fallthrough for the conditional matcher\n  \treadLogicalOr = fallthrough;\n  }());\n\n  var readLogicalOr$1 = readLogicalOr;\n\n  // The conditional operator is the lowest precedence operator, so we start here\n  function getConditional ( parser ) {\n  \tvar start, expression, ifTrue, ifFalse;\n\n  \texpression = readLogicalOr$1( parser );\n  \tif ( !expression ) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( '?' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn expression;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tifTrue = readExpression( parser );\n  \tif ( !ifTrue ) {\n  \t\tparser.error( expectedExpression );\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( ':' ) ) {\n  \t\tparser.error( 'Expected \":\"' );\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tifFalse = readExpression( parser );\n  \tif ( !ifFalse ) {\n  \t\tparser.error( expectedExpression );\n  \t}\n\n  \treturn {\n  \t\tt: CONDITIONAL,\n  \t\to: [ expression, ifTrue, ifFalse ]\n  \t};\n  }\n\n  function readExpression ( parser ) {\n  \t// The conditional operator is the lowest precedence operator (except yield,\n  \t// assignment operators, and commas, none of which are supported), so we\n  \t// start there. If it doesn't match, it 'falls through' to progressively\n  \t// higher precedence operators, until it eventually matches (or fails to\n  \t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n  \t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  \treturn getConditional( parser );\n  }\n\n  function flattenExpression ( expression ) {\n  \tvar refs, count = 0, stringified;\n\n  \textractRefs( expression, refs = [] );\n  \tstringified = stringify( expression );\n\n  \trefs = refs.map( function ( r ) { return r.indexOf( '...' ) === 0 ? r.substr( 3 ) : r; } );\n\n  \treturn {\n  \t\tr: refs,\n  \t\ts: getVars(stringified)\n  \t};\n\n  \tfunction getVars(expr) {\n  \t\tvar vars = [];\n  \t\tfor ( var i = count - 1; i >= 0; i-- ) {\n  \t\t\tvars.push( (\"spread$\" + i) );\n  \t\t}\n  \t\treturn vars.length ? (\"(function(){var \" + (vars.join(',')) + \";return(\" + expr + \");})()\") : expr;\n  \t}\n\n  \tfunction stringify ( node ) {\n  \t\tswitch ( node.t ) {\n  \t\t\tcase BOOLEAN_LITERAL:\n  \t\t\tcase GLOBAL:\n  \t\t\tcase NUMBER_LITERAL:\n  \t\t\tcase REGEXP_LITERAL:\n  \t\t\t\treturn node.v;\n\n  \t\t\tcase STRING_LITERAL:\n  \t\t\t\treturn JSON.stringify( String( node.v ) );\n\n  \t\t\tcase ARRAY_LITERAL:\n  \t\t\t\treturn '[' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + ']';\n\n  \t\t\tcase OBJECT_LITERAL:\n  \t\t\t\treturn '{' + ( node.m ? node.m.map( stringify ).join( ',' ) : '' ) + '}';\n\n  \t\t\tcase KEY_VALUE_PAIR:\n  \t\t\t\treturn node.k + ':' + stringify( node.v );\n\n  \t\t\tcase PREFIX_OPERATOR:\n  \t\t\t\treturn ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( node.o );\n\n  \t\t\tcase INFIX_OPERATOR:\n  \t\t\t\treturn stringify( node.o[0] ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( node.o[1] );\n\n  \t\t\tcase INVOCATION:\n  \t\t\t\tif ( node.spread ) {\n  \t\t\t\t\tvar id = count++;\n  \t\t\t\t\treturn (\"(spread$\" + id + \" = \" + (stringify(node.x)) + \").apply(spread$\" + id + \", [].concat(\" + (node.o ? node.o.map( function ( a ) { return a.n && a.n.indexOf( '...' ) === 0 ? stringify( a ) : '[' + stringify(a) + ']'; } ).join( ',' ) : '') + \") )\");\n  \t\t\t\t} else {\n  \t\t\t\t\treturn stringify( node.x ) + '(' + ( node.o ? node.o.map( stringify ).join( ',' ) : '' ) + ')';\n  \t\t\t\t}\n\n  \t\t\tcase BRACKETED:\n  \t\t\t\treturn '(' + stringify( node.x ) + ')';\n\n  \t\t\tcase MEMBER:\n  \t\t\t\treturn stringify( node.x ) + stringify( node.r );\n\n  \t\t\tcase REFINEMENT:\n  \t\t\t\treturn ( node.n ? '.' + node.n : '[' + stringify( node.x ) + ']' );\n\n  \t\t\tcase CONDITIONAL:\n  \t\t\t\treturn stringify( node.o[0] ) + '?' + stringify( node.o[1] ) + ':' + stringify( node.o[2] );\n\n  \t\t\tcase REFERENCE:\n  \t\t\t\treturn '_' + refs.indexOf( node.n );\n\n  \t\t\tdefault:\n  \t\t\t\tthrow new Error( 'Expected legal JavaScript' );\n  \t\t}\n  \t}\n  }\n\n  // TODO maybe refactor this?\n  function extractRefs ( node, refs ) {\n  \tvar i, list;\n\n  \tif ( node.t === REFERENCE ) {\n  \t\tif ( refs.indexOf( node.n ) === -1 ) {\n  \t\t\trefs.unshift( node.n );\n  \t\t}\n  \t}\n\n  \tlist = node.o || node.m;\n  \tif ( list ) {\n  \t\tif ( isObject( list ) ) {\n  \t\t\textractRefs( list, refs );\n  \t\t} else {\n  \t\t\ti = list.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tif ( list[i].n && list[i].n.indexOf('...') === 0 ) {\n  \t\t\t\t\tnode.spread = true;\n  \t\t\t\t}\n  \t\t\t\textractRefs( list[i], refs );\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif ( node.x ) {\n  \t\textractRefs( node.x, refs );\n  \t}\n\n  \tif ( node.r ) {\n  \t\textractRefs( node.r, refs );\n  \t}\n\n  \tif ( node.v ) {\n  \t\textractRefs( node.v, refs );\n  \t}\n  }\n\n  // simple JSON parser, without the restrictions of JSON parse\n  // (i.e. having to double-quote keys).\n  //\n  // If passed a hash of values as the second argument, ${placeholders}\n  // will be replaced with those values\n\n  var specials$1 = {\n  \t'true': true,\n  \t'false': false,\n  \t'null': null,\n  \tundefined: undefined\n  };\n\n  var specialsPattern = new RegExp( '^(?:' + Object.keys( specials$1 ).join( '|' ) + ')' );\n  var numberPattern$1 = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  var placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n  var placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n  var onlyWhitespace = /^\\s*$/;\n\n  var JsonParser = Parser$1.extend({\n  \tinit: function ( str, options ) {\n  \t\tthis.values = options.values;\n  \t\tthis.allowWhitespace();\n  \t},\n\n  \tpostProcess: function ( result ) {\n  \t\tif ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn { value: result[0].v };\n  \t},\n\n  \tconverters: [\n  \t\tfunction getPlaceholder ( parser ) {\n  \t\t\tif ( !parser.values ) return null;\n\n  \t\t\tvar placeholder = parser.matchPattern( placeholderAtStartPattern );\n\n  \t\t\tif ( placeholder && ( parser.values.hasOwnProperty( placeholder ) ) ) {\n  \t\t\t\treturn { v: parser.values[ placeholder ] };\n  \t\t\t}\n  \t\t},\n\n  \t\tfunction getSpecial ( parser ) {\n  \t\t\tvar special = parser.matchPattern( specialsPattern );\n  \t\t\tif ( special ) return { v: specials$1[ special ] };\n  \t\t},\n\n  \t\tfunction getNumber ( parser ) {\n  \t\t\tvar number = parser.matchPattern( numberPattern$1 );\n  \t\t\tif ( number ) return { v: +number };\n  \t\t},\n\n  \t\tfunction getString ( parser ) {\n  \t\t\tvar stringLiteral = readStringLiteral( parser );\n  \t\t\tvar values = parser.values;\n\n  \t\t\tif ( stringLiteral && values ) {\n  \t\t\t\treturn {\n  \t\t\t\t\tv: stringLiteral.v.replace( placeholderPattern, function ( match, $1 ) { return ( $1 in values ? values[ $1 ] : $1 ); } )\n  \t\t\t\t};\n  \t\t\t}\n\n  \t\t\treturn stringLiteral;\n  \t\t},\n\n  \t\tfunction getObject ( parser ) {\n  \t\t\tif ( !parser.matchString( '{' ) ) return null;\n\n  \t\t\tvar result = {};\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif ( parser.matchString( '}' ) ) {\n  \t\t\t\treturn { v: result };\n  \t\t\t}\n\n  \t\t\tvar pair;\n  \t\t\twhile ( pair = getKeyValuePair( parser ) ) {\n  \t\t\t\tresult[ pair.key ] = pair.value;\n\n  \t\t\t\tparser.allowWhitespace();\n\n  \t\t\t\tif ( parser.matchString( '}' ) ) {\n  \t\t\t\t\treturn { v: result };\n  \t\t\t\t}\n\n  \t\t\t\tif ( !parser.matchString( ',' ) ) {\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn null;\n  \t\t},\n\n  \t\tfunction getArray ( parser ) {\n  \t\t\tif ( !parser.matchString( '[' ) ) return null;\n\n  \t\t\tvar result = [];\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif ( parser.matchString( ']' ) ) {\n  \t\t\t\treturn { v: result };\n  \t\t\t}\n\n  \t\t\tvar valueToken;\n  \t\t\twhile ( valueToken = parser.read() ) {\n  \t\t\t\tresult.push( valueToken.v );\n\n  \t\t\t\tparser.allowWhitespace();\n\n  \t\t\t\tif ( parser.matchString( ']' ) ) {\n  \t\t\t\t\treturn { v: result };\n  \t\t\t\t}\n\n  \t\t\t\tif ( !parser.matchString( ',' ) ) {\n  \t\t\t\t\treturn null;\n  \t\t\t\t}\n\n  \t\t\t\tparser.allowWhitespace();\n  \t\t\t}\n\n  \t\t\treturn null;\n  \t\t}\n  \t]\n  });\n\n  function getKeyValuePair ( parser ) {\n  \tparser.allowWhitespace();\n\n  \tvar key = readKey( parser );\n\n  \tif ( !key ) return null;\n\n  \tvar pair = { key: key };\n\n  \tparser.allowWhitespace();\n  \tif ( !parser.matchString( ':' ) ) {\n  \t\treturn null;\n  \t}\n  \tparser.allowWhitespace();\n\n  \tvar valueToken = parser.read();\n\n  \tif ( !valueToken ) return null;\n\n  \tpair.value = valueToken.v;\n  \treturn pair;\n  }\n\n  function parseJSON ( str, values ) {\n  \tvar parser = new JsonParser( str, { values: values });\n  \treturn parser.result;\n  }\n\n  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(.*\\)\\s*$/;\n  var ExpressionParser;\n  ExpressionParser = Parser$1.extend({\n  \tconverters: [ readExpression ],\n  \tspreadArgs: true\n  });\n\n  // TODO clean this up, it's shocking\n  function processDirective ( tokens, parentParser, type ) {\n  \tvar result,\n  \t\tmatch,\n  \t\ttoken,\n  \t\tcolonIndex,\n  \t\tdirectiveName,\n  \t\tdirectiveArgs,\n  \t\tparsed;\n\n  \tif ( typeof tokens === 'string' ) {\n  \t\tvar pos = parentParser.pos - tokens.length;\n  \t\tif ( type === DECORATOR || type === TRANSITION ) {\n  \t\t\tvar parser = new ExpressionParser( (\"[\" + tokens + \"]\") );\n  \t\t\treturn { a: flattenExpression( parser.result[0] ) };\n  \t\t}\n\n  \t\tif ( type === EVENT && ( match = methodCallPattern.exec( tokens ) ) ) {\n  \t\t\twarnIfDebug( parentParser.getContextMessage( pos, (\"Unqualified method events are deprecated. Prefix methods with '@this.' to call methods on the current Ractive instance.\") )[2] );\n  \t\t\ttokens = \"@this.\" + (match[1]) + \"\" + (tokens.substr(match[1].length));\n  \t\t}\n\n  \t\tif ( type === EVENT && ~tokens.indexOf( '(' ) ) {\n  \t\t\tvar parser$1 = new ExpressionParser( '[' + tokens + ']' );\n  \t\t\tif ( parser$1.result && parser$1.result[0] ) {\n  \t\t\t\tif ( parser$1.remaining().length ) {\n  \t\t\t\t\tparentParser.pos = pos + tokens.length - parser$1.remaining().length;\n  \t\t\t\t\tparentParser.error( (\"Invalid input after event expression '\" + (parser$1.remaining()) + \"'\") );\n  \t\t\t\t}\n  \t\t\t\treturn { x: flattenExpression( parser$1.result[0] ) };\n  \t\t\t}\n\n  \t\t\tif ( tokens.indexOf( ':' ) > tokens.indexOf( '(' ) || !~tokens.indexOf( ':' ) ) {\n  \t\t\t\tparentParser.pos = pos;\n  \t\t\t\tparentParser.error( (\"Invalid input in event expression '\" + tokens + \"'\") );\n  \t\t\t}\n\n  \t\t}\n\n  \t\tif ( tokens.indexOf( ':' ) === -1 ) {\n  \t\t\treturn tokens.trim();\n  \t\t}\n\n  \t\ttokens = [ tokens ];\n  \t}\n\n  \tresult = {};\n\n  \tdirectiveName = [];\n  \tdirectiveArgs = [];\n\n  \tif ( tokens ) {\n  \t\twhile ( tokens.length ) {\n  \t\t\ttoken = tokens.shift();\n\n  \t\t\tif ( typeof token === 'string' ) {\n  \t\t\t\tcolonIndex = token.indexOf( ':' );\n\n  \t\t\t\tif ( colonIndex === -1 ) {\n  \t\t\t\t\tdirectiveName.push( token );\n  \t\t\t\t} else {\n  \t\t\t\t\t// is the colon the first character?\n  \t\t\t\t\tif ( colonIndex ) {\n  \t\t\t\t\t\t// no\n  \t\t\t\t\t\tdirectiveName.push( token.substr( 0, colonIndex ) );\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// if there is anything after the colon in this token, treat\n  \t\t\t\t\t// it as the first token of the directiveArgs fragment\n  \t\t\t\t\tif ( token.length > colonIndex + 1 ) {\n  \t\t\t\t\t\tdirectiveArgs[0] = token.substring( colonIndex + 1 );\n  \t\t\t\t\t}\n\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\telse {\n  \t\t\t\tdirectiveName.push( token );\n  \t\t\t}\n  \t\t}\n\n  \t\tdirectiveArgs = directiveArgs.concat( tokens );\n  \t}\n\n  \tif ( !directiveName.length ) {\n  \t\tresult = '';\n  \t} else if ( directiveArgs.length || typeof directiveName !== 'string' ) {\n  \t\tresult = {\n  \t\t\t// TODO is this really necessary? just use the array\n  \t\t\tn: ( directiveName.length === 1 && typeof directiveName[0] === 'string' ? directiveName[0] : directiveName )\n  \t\t};\n\n  \t\tif ( directiveArgs.length === 1 && typeof directiveArgs[0] === 'string' ) {\n  \t\t\tparsed = parseJSON( '[' + directiveArgs[0] + ']' );\n  \t\t\tresult.a = parsed ? parsed.value : [ directiveArgs[0].trim() ];\n  \t\t}\n\n  \t\telse {\n  \t\t\tresult.d = directiveArgs;\n  \t\t}\n  \t} else {\n  \t\tresult = directiveName;\n  \t}\n\n  \tif ( directiveArgs.length && type ) {\n  \t\twarnIfDebug( parentParser.getContextMessage( parentParser.pos, (\"Proxy events with arguments are deprecated. You can fire events with arguments using \\\"@this.fire('eventName', arg1, arg2, ...)\\\".\") )[2] );\n  \t}\n\n  \treturn result;\n  }\n\n  var attributeNamePattern = /^[^\\s\"'>\\/=]+/;\n  var onPattern = /^on/;\n  var proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/;\n  var reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/;\n  var decoratorPattern = /^as-([a-z-A-Z][-a-zA-Z_0-9]*)$/;\n  var transitionPattern = /^([a-zA-Z](?:(?!-in-out)[-a-zA-Z_0-9])*)-(in|out|in-out)$/;\n  var directives = {\n  \t\t\t\t   'intro-outro': { t: TRANSITION, v: 't0' },\n  \t\t\t\t   intro: { t: TRANSITION, v: 't1' },\n  \t\t\t\t   outro: { t: TRANSITION, v: 't2' },\n  \t\t\t\t   lazy: { t: BINDING_FLAG, v: 'l' },\n  \t\t\t\t   twoway: { t: BINDING_FLAG, v: 't' },\n  \t\t\t\t   decorator: { t: DECORATOR }\n  \t\t\t\t };\n  var unquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n  function readAttribute ( parser ) {\n  \tvar attr, name, value, i, nearest, idx;\n\n  \tparser.allowWhitespace();\n\n  \tname = parser.matchPattern( attributeNamePattern );\n  \tif ( !name ) {\n  \t\treturn null;\n  \t}\n\n  \t// check for accidental delimiter consumption e.g. <tag bool{{>attrs}} />\n  \tnearest = name.length;\n  \tfor ( i = 0; i < parser.tags.length; i++ ) {\n  \t\tif ( ~( idx = name.indexOf( parser.tags[ i ].open ) ) ) {\n  \t\t\tif ( idx < nearest ) nearest = idx;\n  \t\t}\n  \t}\n  \tif ( nearest < name.length ) {\n  \t\tparser.pos -= name.length - nearest;\n  \t\tname = name.substr( 0, nearest );\n  \t\treturn { n: name };\n  \t}\n\n  \tattr = { n: name };\n\n  \tvalue = readAttributeValue( parser );\n  \tif ( value != null ) { // not null/undefined\n  \t\tattr.f = value;\n  \t}\n\n  \treturn attr;\n  }\n\n  function readAttributeValue ( parser ) {\n  \tvar start, valueStart, startDepth, value;\n\n  \tstart = parser.pos;\n\n  \t// next character must be `=`, `/`, `>` or whitespace\n  \tif ( !/[=\\/>\\s]/.test( parser.nextChar() ) ) {\n  \t\tparser.error( 'Expected `=`, `/`, `>` or whitespace' );\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( '=' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tvalueStart = parser.pos;\n  \tstartDepth = parser.sectionDepth;\n\n  \tvalue = readQuotedAttributeValue( parser, (\"'\") ) ||\n  \t\t\treadQuotedAttributeValue( parser, (\"\\\"\") ) ||\n  \t\t\treadUnquotedAttributeValue( parser );\n\n  \tif ( value === null ) {\n  \t\tparser.error( 'Expected valid attribute value' );\n  \t}\n\n  \tif ( parser.sectionDepth !== startDepth ) {\n  \t\tparser.pos = valueStart;\n  \t\tparser.error( 'An attribute value must contain as many opening section tags as closing section tags' );\n  \t}\n\n  \tif ( !value.length ) {\n  \t\treturn '';\n  \t}\n\n  \tif ( value.length === 1 && typeof value[0] === 'string' ) {\n  \t\treturn decodeCharacterReferences( value[0] );\n  \t}\n\n  \treturn value;\n  }\n\n  function readUnquotedAttributeValueToken ( parser ) {\n  \tvar start, text, haystack, needles, index;\n\n  \tstart = parser.pos;\n\n  \ttext = parser.matchPattern( unquotedAttributeValueTextPattern );\n\n  \tif ( !text ) {\n  \t\treturn null;\n  \t}\n\n  \thaystack = text;\n  \tneedles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well\n\n  \tif ( ( index = getLowestIndex( haystack, needles ) ) !== -1 ) {\n  \t\ttext = text.substr( 0, index );\n  \t\tparser.pos = start + text.length;\n  \t}\n\n  \treturn text;\n  }\n\n  function readUnquotedAttributeValue ( parser ) {\n  \tvar tokens, token;\n\n  \tparser.inAttribute = true;\n\n  \ttokens = [];\n\n  \ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n  \twhile ( token ) {\n  \t\ttokens.push( token );\n  \t\ttoken = readMustache( parser ) || readUnquotedAttributeValueToken( parser );\n  \t}\n\n  \tif ( !tokens.length ) {\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = false;\n  \treturn tokens;\n  }\n\n  function readQuotedAttributeValue ( parser, quoteMark ) {\n  \tvar start, tokens, token;\n\n  \tstart = parser.pos;\n\n  \tif ( !parser.matchString( quoteMark ) ) {\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = quoteMark;\n\n  \ttokens = [];\n\n  \ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n  \twhile ( token !== null ) {\n  \t\ttokens.push( token );\n  \t\ttoken = readMustache( parser ) || readQuotedStringToken( parser, quoteMark );\n  \t}\n\n  \tif ( !parser.matchString( quoteMark ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = false;\n\n  \treturn tokens;\n  }\n\n  function readQuotedStringToken ( parser, quoteMark ) {\n  \tvar haystack = parser.remaining();\n\n  \tvar needles = parser.tags.map( function ( t ) { return t.open; } ); // TODO refactor... we do this in readText.js as well\n  \tneedles.push( quoteMark );\n\n  \tvar index = getLowestIndex( haystack, needles );\n\n  \tif ( index === -1 ) {\n  \t\tparser.error( 'Quoted attribute value must have a closing quote' );\n  \t}\n\n  \tif ( !index ) {\n  \t\treturn null;\n  \t}\n\n  \tparser.pos += index;\n  \treturn haystack.substr( 0, index );\n  }\n\n  function readAttributeOrDirective ( parser ) {\n  \t\tvar match,\n  \t\t\tattribute,\n  \t\t    directive;\n\n  \t\tattribute = readAttribute( parser );\n\n  \t\tif ( !attribute ) return null;\n\n  \t\t// intro, outro, decorator\n  \t\tif ( directive = directives[ attribute.n ] ) {\n  \t\t\tattribute.t = directive.t;\n  \t\t\tif ( directive.v ) attribute.v = directive.v;\n  \t\t\tdelete attribute.n; // no name necessary\n\n  \t\t\tif ( directive.t === TRANSITION || directive.t === DECORATOR ) attribute.f = processDirective( attribute.f, parser );\n\n  \t\t\tif ( directive.t === TRANSITION ) {\n  \t\t\t\twarnOnceIfDebug( (\"\" + (directive.v === 't0' ? 'intro-outro' : directive.v === 't1' ? 'intro' : 'outro') + \" is deprecated. To specify tranisitions, use the transition name suffixed with '-in', '-out', or '-in-out' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.\") );\n  \t\t\t} else if ( directive.t === DECORATOR ) {\n  \t\t\t\twarnOnceIfDebug( (\"decorator is deprecated. To specify decorators, use the decorator name prefixed with 'as-' as an attribute. Arguments can be specified in the attribute value as a simple list of expressions without mustaches.\") );\n  \t\t\t}\n  \t\t}\n\n  \t\t// decorators\n  \t\telse if ( match = decoratorPattern.exec( attribute.n ) ) {\n  \t\t\tdelete attribute.n;\n  \t\t\tattribute.t = DECORATOR;\n  \t\t\tattribute.f = processDirective( attribute.f, parser, DECORATOR );\n  \t\t\tif ( typeof attribute.f === 'object' ) attribute.f.n = match[1];\n  \t\t\telse attribute.f = match[1];\n  \t\t}\n\n  \t\t// transitions\n  \t\telse if ( match = transitionPattern.exec( attribute.n ) ) {\n  \t\t\tdelete attribute.n;\n  \t\t\tattribute.t = TRANSITION;\n  \t\t\tattribute.f = processDirective( attribute.f, parser, TRANSITION );\n  \t\t\tif ( typeof attribute.f === 'object' ) attribute.f.n = match[1];\n  \t\t\telse attribute.f = match[1];\n  \t\t\tattribute.v = match[2] === 'in-out' ? 't0' : match[2] === 'in' ? 't1' : 't2';\n  \t\t}\n\n  \t\t// on-click etc\n  \t\telse if ( match = proxyEventPattern.exec( attribute.n ) ) {\n  \t\t\tattribute.n = match[1];\n  \t\t\tattribute.t = EVENT;\n  \t\t\tattribute.f = processDirective( attribute.f, parser, EVENT );\n\n  \t\t\tif ( reservedEventNames.test( attribute.f.n || attribute.f ) ) {\n  \t\t\t\tparser.pos -= ( attribute.f.n || attribute.f ).length;\n  \t\t\t\tparser.error( 'Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)' );\n  \t\t\t}\n  \t\t}\n\n  \t\telse {\n  \t\t\tif ( parser.sanitizeEventAttributes && onPattern.test( attribute.n ) ) {\n  \t\t\t\treturn { exclude: true };\n  \t\t\t} else {\n  \t\t\t\tattribute.f = attribute.f || ( attribute.f === '' ? '' : 0 );\n  \t\t\t\tattribute.t = ATTRIBUTE;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn attribute;\n  }\n\n  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n\n  function readMustache ( parser ) {\n  \tvar mustache, i;\n\n  \t// If we're inside a <script> or <style> tag, and we're not\n  \t// interpolating, bug out\n  \tif ( parser.interpolate[ parser.inside ] === false ) {\n  \t\treturn null;\n  \t}\n\n  \tfor ( i = 0; i < parser.tags.length; i += 1 ) {\n  \t\tif ( mustache = readMustacheOfType( parser, parser.tags[i] ) ) {\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n\n  \tif ( parser.inTag && !parser.inAttribute ) {\n  \t\tmustache = readAttributeOrDirective( parser );\n  \t\tif ( mustache ) {\n  \t\t\tparser.allowWhitespace();\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n  }\n\n  function readMustacheOfType ( parser, tag ) {\n  \tvar start, mustache, reader, i;\n\n  \tstart = parser.pos;\n\n  \tif ( parser.matchString( '\\\\' + tag.open ) ) {\n  \t\tif ( start === 0 || parser.str[ start - 1 ] !== '\\\\' ) {\n  \t\t\treturn tag.open;\n  \t\t}\n  \t} else if ( !parser.matchString( tag.open ) ) {\n  \t\treturn null;\n  \t}\n\n  \t// delimiter change?\n  \tif ( mustache = readDelimiterChange( parser ) ) {\n  \t\t// find closing delimiter or abort...\n  \t\tif ( !parser.matchString( tag.close ) ) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\t// ...then make the switch\n  \t\ttag.open = mustache[0];\n  \t\ttag.close = mustache[1];\n  \t\tparser.sortMustacheTags();\n\n  \t\treturn delimiterChangeToken;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \t// illegal section closer\n  \tif ( parser.matchString( '/' ) ) {\n  \t\tparser.pos -= 1;\n  \t\tvar rewind = parser.pos;\n  \t\tif ( !readNumberLiteral( parser ) ) {\n  \t\t\tparser.pos = rewind - ( tag.close.length );\n  \t\t\tif ( parser.inAttribute ) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn null;\n  \t\t\t} else {\n  \t\t\t\tparser.error( 'Attempted to close a section that wasn\\'t open' );\n  \t\t\t}\n  \t\t} else {\n  \t\t\tparser.pos = rewind;\n  \t\t}\n  \t}\n\n  \tfor ( i = 0; i < tag.readers.length; i += 1 ) {\n  \t\treader = tag.readers[i];\n\n  \t\tif ( mustache = reader( parser, tag ) ) {\n  \t\t\tif ( tag.isStatic ) {\n  \t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n  \t\t\t}\n\n  \t\t\tif ( parser.includeLinePositions ) {\n  \t\t\t\tmustache.p = parser.getLinePos( start );\n  \t\t\t}\n\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  function refineExpression ( expression, mustache ) {\n  \tvar referenceExpression;\n\n  \tif ( expression ) {\n  \t\twhile ( expression.t === BRACKETED && expression.x ) {\n  \t\t\texpression = expression.x;\n  \t\t}\n\n  \t\tif ( expression.t === REFERENCE ) {\n  \t\t\tmustache.r = expression.n;\n  \t\t} else {\n  \t\t\tif ( referenceExpression = getReferenceExpression( expression ) ) {\n  \t\t\t\tmustache.rx = referenceExpression;\n  \t\t\t} else {\n  \t\t\t\tmustache.x = flattenExpression( expression );\n  \t\t\t}\n  \t\t}\n\n  \t\treturn mustache;\n  \t}\n  }\n\n  // TODO refactor this! it's bewildering\n  function getReferenceExpression ( expression ) {\n  \tvar members = [], refinement;\n\n  \twhile ( expression.t === MEMBER && expression.r.t === REFINEMENT ) {\n  \t\trefinement = expression.r;\n\n  \t\tif ( refinement.x ) {\n  \t\t\tif ( refinement.x.t === REFERENCE ) {\n  \t\t\t\tmembers.unshift( refinement.x );\n  \t\t\t} else {\n  \t\t\t\tmembers.unshift( flattenExpression( refinement.x ) );\n  \t\t\t}\n  \t\t} else {\n  \t\t\tmembers.unshift( refinement.n );\n  \t\t}\n\n  \t\texpression = expression.x;\n  \t}\n\n  \tif ( expression.t !== REFERENCE ) {\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tr: expression.n,\n  \t\tm: members\n  \t};\n  }\n\n  function readTriple ( parser, tag ) {\n  \tvar expression = readExpression( parser ), triple;\n\n  \tif ( !expression ) {\n  \t\treturn null;\n  \t}\n\n  \tif ( !parser.matchString( tag.close ) ) {\n  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n  \t}\n\n  \ttriple = { t: TRIPLE };\n  \trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\n  \treturn triple;\n  }\n\n  function readUnescaped ( parser, tag ) {\n  \tvar expression, triple;\n\n  \tif ( !parser.matchString( '&' ) ) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpression = readExpression( parser );\n\n  \tif ( !expression ) {\n  \t\treturn null;\n  \t}\n\n  \tif ( !parser.matchString( tag.close ) ) {\n  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n  \t}\n\n  \ttriple = { t: TRIPLE };\n  \trefineExpression( expression, triple ); // TODO handle this differently - it's mysterious\n\n  \treturn triple;\n  }\n\n  var legalAlias = /^(?:[a-zA-Z$_0-9]|\\\\\\.)+(?:(?:(?:[a-zA-Z$_0-9]|\\\\\\.)+)|(?:\\[[0-9]+\\]))*/;\n  var asRE = /^as/i;\n\n  function readAliases( parser ) {\n  \tvar aliases = [], alias, start = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \talias = readAlias( parser );\n\n  \tif ( alias ) {\n  \t\talias.x = refineExpression( alias.x, {} );\n  \t\taliases.push( alias );\n\n  \t\tparser.allowWhitespace();\n\n  \t\twhile ( parser.matchString(',') ) {\n  \t\t\talias = readAlias( parser );\n\n  \t\t\tif ( !alias ) {\n  \t\t\t\tparser.error( 'Expected another alias.' );\n  \t\t\t}\n\n  \t\t\talias.x = refineExpression( alias.x, {} );\n  \t\t\taliases.push( alias );\n\n  \t\t\tparser.allowWhitespace();\n  \t\t}\n\n  \t\treturn aliases;\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  function readAlias( parser ) {\n  \tvar expr, alias, start = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \texpr = readExpression( parser, [] );\n\n  \tif ( !expr ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchPattern( asRE ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \talias = parser.matchPattern( legalAlias );\n\n  \tif ( !alias ) {\n  \t\tparser.error( 'Expected a legal alias name.' );\n  \t}\n\n  \treturn { n: alias, x: expr };\n  }\n\n  function readPartial ( parser, tag ) {\n  \tif ( !parser.matchString( '>' ) ) return null;\n\n  \tparser.allowWhitespace();\n\n  \t// Partial names can include hyphens, so we can't use readExpression\n  \t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n  \t// `foo-bar` should be read as a single name, rather than 'subtract\n  \t// bar from foo'\n  \tparser.relaxedNames = parser.strictRefinement = true;\n  \tvar expression = readExpression( parser );\n  \tparser.relaxedNames = parser.strictRefinement = false;\n\n  \tif ( !expression ) return null;\n\n  \tvar partial = { t: PARTIAL };\n  \trefineExpression( expression, partial ); // TODO...\n\n  \tparser.allowWhitespace();\n\n  \t// check for alias context e.g. `{{>foo bar as bat, bip as bop}}` then\n  \t// turn it into `{{#with bar as bat, bip as bop}}{{>foo}}{{/with}}`\n  \tvar aliases = readAliases( parser );\n  \tif ( aliases ) {\n  \t\tpartial = {\n  \t\t\tt: ALIAS,\n  \t\t\tz: aliases,\n  \t\t\tf: [ partial ]\n  \t\t};\n  \t}\n\n  \t// otherwise check for literal context e.g. `{{>foo bar}}` then\n  \t// turn it into `{{#with bar}}{{>foo}}{{/with}}`\n  \telse {\n  \t\tvar context = readExpression( parser );\n  \t\tif ( context) {\n  \t\t\tpartial = {\n  \t\t\t\tt: SECTION,\n  \t\t\t\tn: SECTION_WITH,\n  \t\t\t\tf: [ partial ]\n  \t\t\t};\n\n  \t\t\trefineExpression( context, partial );\n  \t\t}\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( tag.close ) ) {\n  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n  \t}\n\n  \treturn partial;\n  }\n\n  function readComment ( parser, tag ) {\n  \tvar index;\n\n  \tif ( !parser.matchString( '!' ) ) {\n  \t\treturn null;\n  \t}\n\n  \tindex = parser.remaining().indexOf( tag.close );\n\n  \tif ( index !== -1 ) {\n  \t\tparser.pos += index + tag.close.length;\n  \t\treturn { t: COMMENT };\n  \t}\n  }\n\n  function readExpressionOrReference ( parser, expectedFollowers ) {\n  \tvar start, expression, i;\n\n  \tstart = parser.pos;\n  \texpression = readExpression( parser );\n\n  \tif ( !expression ) {\n  \t\t// valid reference but invalid expression e.g. `{{new}}`?\n  \t\tvar ref = parser.matchPattern( /^(\\w+)/ );\n  \t\tif ( ref ) {\n  \t\t\treturn {\n  \t\t\t\tt: REFERENCE,\n  \t\t\t\tn: ref\n  \t\t\t};\n  \t\t}\n\n  \t\treturn null;\n  \t}\n\n  \tfor ( i = 0; i < expectedFollowers.length; i += 1 ) {\n  \t\tif ( parser.remaining().substr( 0, expectedFollowers[i].length ) === expectedFollowers[i] ) {\n  \t\t\treturn expression;\n  \t\t}\n  \t}\n\n  \tparser.pos = start;\n  \treturn readReference( parser );\n  }\n\n  function readInterpolator ( parser, tag ) {\n  \tvar start, expression, interpolator, err;\n\n  \tstart = parser.pos;\n\n  \t// TODO would be good for perf if we could do away with the try-catch\n  \ttry {\n  \t\texpression = readExpressionOrReference( parser, [ tag.close ]);\n  \t} catch ( e ) {\n  \t\terr = e;\n  \t}\n\n  \tif ( !expression ) {\n  \t\tif ( parser.str.charAt( start ) === '!' ) {\n  \t\t\t// special case - comment\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tif ( err ) {\n  \t\t\tthrow err;\n  \t\t}\n  \t}\n\n  \tif ( !parser.matchString( tag.close ) ) {\n  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"' after reference\") );\n\n  \t\tif ( !expression ) {\n  \t\t\t// special case - comment\n  \t\t\tif ( parser.nextChar() === '!' ) {\n  \t\t\t\treturn null;\n  \t\t\t}\n\n  \t\t\tparser.error( (\"Expected expression or legal reference\") );\n  \t\t}\n  \t}\n\n  \tinterpolator = { t: INTERPOLATOR };\n  \trefineExpression( expression, interpolator ); // TODO handle this differently - it's mysterious\n\n  \treturn interpolator;\n  }\n\n  var yieldPattern = /^yield\\s*/;\n\n  function readYielder ( parser, tag ) {\n  \tif ( !parser.matchPattern( yieldPattern ) ) return null;\n\n  \tvar name = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/ );\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( tag.close ) ) {\n  \t\tparser.error( (\"expected legal partial name\") );\n  \t}\n\n  \tvar yielder = { t: YIELDER };\n  \tif ( name ) yielder.n = name;\n\n  \treturn yielder;\n  }\n\n  function readClosing ( parser, tag ) {\n  \tvar start, remaining, index, closing;\n\n  \tstart = parser.pos;\n\n  \tif ( !parser.matchString( tag.open ) ) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( '/' ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tremaining = parser.remaining();\n  \tindex = remaining.indexOf( tag.close );\n\n  \tif ( index !== -1 ) {\n  \t\tclosing = {\n  \t\t\tt: CLOSING,\n  \t\t\tr: remaining.substr( 0, index ).split( ' ' )[0]\n  \t\t};\n\n  \t\tparser.pos += index;\n\n  \t\tif ( !parser.matchString( tag.close ) ) {\n  \t\t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n  \t\t}\n\n  \t\treturn closing;\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  var elsePattern = /^\\s*else\\s*/;\n\n  function readElse ( parser, tag ) {\n  \tvar start = parser.pos;\n\n  \tif ( !parser.matchString( tag.open ) ) {\n  \t\treturn null;\n  \t}\n\n  \tif ( !parser.matchPattern( elsePattern ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tif ( !parser.matchString( tag.close ) ) {\n  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n  \t}\n\n  \treturn {\n  \t\tt: ELSE\n  \t};\n  }\n\n  var elsePattern$1 = /^\\s*elseif\\s+/;\n\n  function readElseIf ( parser, tag ) {\n  \tvar start = parser.pos;\n\n  \tif ( !parser.matchString( tag.open ) ) {\n  \t\treturn null;\n  \t}\n\n  \tif ( !parser.matchPattern( elsePattern$1 ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tvar expression = readExpression( parser );\n\n  \tif ( !parser.matchString( tag.close ) ) {\n  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n  \t}\n\n  \treturn {\n  \t\tt: ELSEIF,\n  \t\tx: expression\n  \t};\n  }\n\n  var handlebarsBlockCodes = {\n  \t'each':    SECTION_EACH,\n  \t'if':      SECTION_IF,\n  \t'with':    SECTION_IF_WITH,\n  \t'unless':  SECTION_UNLESS\n  };\n\n  var indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\n  var keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/;\n  var handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\\\b' );\n  function readSection ( parser, tag ) {\n  \tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose, aliasOnly = false;\n\n  \tstart = parser.pos;\n\n  \tif ( parser.matchString( '^' ) ) {\n  \t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n  \t} else if ( parser.matchString( '#' ) ) {\n  \t\tsection = { t: SECTION, f: [] };\n\n  \t\tif ( parser.matchString( 'partial' ) ) {\n  \t\t\tparser.pos = start - parser.standardDelimiters[0].length;\n  \t\t\tparser.error( 'Partial definitions can only be at the top level of the template, or immediately inside components' );\n  \t\t}\n\n  \t\tif ( block = parser.matchPattern( handlebarsBlockPattern ) ) {\n  \t\t\texpectedClose = block;\n  \t\t\tsection.n = handlebarsBlockCodes[ block ];\n  \t\t}\n  \t} else {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif ( block === 'with' ) {\n  \t\tvar aliases = readAliases( parser );\n  \t\tif ( aliases ) {\n  \t\t\taliasOnly = true;\n  \t\t\tsection.z = aliases;\n  \t\t\tsection.t = ALIAS;\n  \t\t}\n  \t} else if ( block === 'each' ) {\n  \t\tvar alias = readAlias( parser );\n  \t\tif ( alias ) {\n  \t\t\tsection.z = [ { n: alias.n, x: { r: '.' } } ];\n  \t\t\texpression = alias.x;\n  \t\t}\n  \t}\n\n  \tif ( !aliasOnly ) {\n  \t\tif ( !expression ) expression = readExpression( parser );\n\n  \t\tif ( !expression ) {\n  \t\t\tparser.error( 'Expected expression' );\n  \t\t}\n\n  \t\t// optional index and key references\n  \t\tif ( i = parser.matchPattern( indexRefPattern ) ) {\n  \t\t\tvar extra;\n\n  \t\t\tif ( extra = parser.matchPattern( keyIndexRefPattern ) ) {\n  \t\t\t\tsection.i = i + ',' + extra;\n  \t\t\t} else {\n  \t\t\t\tsection.i = i;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif ( !parser.matchString( tag.close ) ) {\n  \t\tparser.error( (\"Expected closing delimiter '\" + (tag.close) + \"'\") );\n  \t}\n\n  \tparser.sectionDepth += 1;\n  \tchildren = section.f;\n\n  \tconditions = [];\n\n  \tvar pos;\n  \tdo {\n  \t\tpos = parser.pos;\n  \t\tif ( child = readClosing( parser, tag ) ) {\n  \t\t\tif ( expectedClose && child.r !== expectedClose ) {\n  \t\t\t\tparser.pos = pos;\n  \t\t\t\tparser.error( (\"Expected \" + (tag.open) + \"/\" + expectedClose + \"\" + (tag.close)) );\n  \t\t\t}\n\n  \t\t\tparser.sectionDepth -= 1;\n  \t\t\tclosed = true;\n  \t\t}\n\n  \t\telse if ( !aliasOnly && ( child = readElseIf( parser, tag ) ) ) {\n  \t\t\tif ( section.n === SECTION_UNLESS ) {\n  \t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n  \t\t\t}\n\n  \t\t\tif ( hasElse ) {\n  \t\t\t\tparser.error( 'illegal {{elseif...}} after {{else}}' );\n  \t\t\t}\n\n  \t\t\tif ( !unlessBlock ) {\n  \t\t\t\tunlessBlock = [];\n  \t\t\t}\n\n  \t\t\tvar mustache = {\n  \t\t\t\tt: SECTION,\n  \t\t\t\tn: SECTION_IF,\n  \t\t\t\tf: children = []\n  \t\t\t};\n  \t\t\trefineExpression( child.x, mustache );\n\n  \t\t\tunlessBlock.push( mustache );\n  \t\t}\n\n  \t\telse if ( !aliasOnly && ( child = readElse( parser, tag ) ) ) {\n  \t\t\tif ( section.n === SECTION_UNLESS ) {\n  \t\t\t\tparser.error( '{{else}} not allowed in {{#unless}}' );\n  \t\t\t}\n\n  \t\t\tif ( hasElse ) {\n  \t\t\t\tparser.error( 'there can only be one {{else}} block, at the end of a section' );\n  \t\t\t}\n\n  \t\t\thasElse = true;\n\n  \t\t\t// use an unless block if there's no elseif\n  \t\t\tif ( !unlessBlock ) {\n  \t\t\t\tunlessBlock = [];\n  \t\t\t}\n\n  \t\t\tunlessBlock.push({\n  \t\t\t\tt: SECTION,\n  \t\t\t\tn: SECTION_UNLESS,\n  \t\t\t\tf: children = []\n  \t\t\t});\n  \t\t}\n\n  \t\telse {\n  \t\t\tchild = parser.read( READERS );\n\n  \t\t\tif ( !child ) {\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tchildren.push( child );\n  \t\t}\n  \t} while ( !closed );\n\n  \tif ( unlessBlock ) {\n  \t\tsection.l = unlessBlock;\n  \t}\n\n  \tif ( !aliasOnly ) {\n  \t\trefineExpression( expression, section );\n  \t}\n\n  \t// TODO if a section is empty it should be discarded. Don't do\n  \t// that here though - we need to clean everything up first, as\n  \t// it may contain removeable whitespace. As a temporary measure,\n  \t// to pass the existing tests, remove empty `f` arrays\n  \tif ( !section.f.length ) {\n  \t\tdelete section.f;\n  \t}\n\n  \treturn section;\n  }\n\n  var OPEN_COMMENT = '<!--';\n  var CLOSE_COMMENT = '-->';\n  function readHtmlComment ( parser ) {\n  \tvar start, content, remaining, endIndex, comment;\n\n  \tstart = parser.pos;\n\n  \tif ( parser.textOnlyMode || !parser.matchString( OPEN_COMMENT ) ) {\n  \t\treturn null;\n  \t}\n\n  \tremaining = parser.remaining();\n  \tendIndex = remaining.indexOf( CLOSE_COMMENT );\n\n  \tif ( endIndex === -1 ) {\n  \t\tparser.error( 'Illegal HTML - expected closing comment sequence (\\'-->\\')' );\n  \t}\n\n  \tcontent = remaining.substr( 0, endIndex );\n  \tparser.pos += endIndex + 3;\n\n  \tcomment = {\n  \t\tt: COMMENT,\n  \t\tc: content\n  \t};\n\n  \tif ( parser.includeLinePositions ) {\n  \t\tcomment.p = parser.getLinePos( start );\n  \t}\n\n  \treturn comment;\n  }\n\n  var leadingLinebreak = /^[ \\t\\f\\r\\n]*\\r?\\n/;\n  var trailingLinebreak = /\\r?\\n[ \\t\\f\\r\\n]*$/;\n  function stripStandalones ( items ) {\n  \tvar i, current, backOne, backTwo, lastSectionItem;\n\n  \tfor ( i=1; i<items.length; i+=1 ) {\n  \t\tcurrent = items[i];\n  \t\tbackOne = items[i-1];\n  \t\tbackTwo = items[i-2];\n\n  \t\t// if we're at the end of a [text][comment][text] sequence...\n  \t\tif ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {\n\n  \t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n  \t\t\tif ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {\n\n  \t\t\t\t// ... then we want to remove the whitespace after the first line break\n  \t\t\t\titems[i-2] = backTwo.replace( trailingLinebreak, '\\n' );\n\n  \t\t\t\t// and the leading line break of the second text token\n  \t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n  \t\t\t}\n  \t\t}\n\n  \t\t// if the current item is a section, and it is preceded by a linebreak, and\n  \t\t// its first item is a linebreak...\n  \t\tif ( isSection( current ) && isString( backOne ) ) {\n  \t\t\tif ( trailingLinebreak.test( backOne ) && isString( current.f[0] ) && leadingLinebreak.test( current.f[0] ) ) {\n  \t\t\t\titems[i-1] = backOne.replace( trailingLinebreak, '\\n' );\n  \t\t\t\tcurrent.f[0] = current.f[0].replace( leadingLinebreak, '' );\n  \t\t\t}\n  \t\t}\n\n  \t\t// if the last item was a section, and it is followed by a linebreak, and\n  \t\t// its last item is a linebreak...\n  \t\tif ( isString( current ) && isSection( backOne ) ) {\n  \t\t\tlastSectionItem = lastItem( backOne.f );\n\n  \t\t\tif ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {\n  \t\t\t\tbackOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\\n' );\n  \t\t\t\titems[i] = current.replace( leadingLinebreak, '' );\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn items;\n  }\n\n  function isString ( item ) {\n  \treturn typeof item === 'string';\n  }\n\n  function isComment ( item ) {\n  \treturn item.t === COMMENT || item.t === DELIMCHANGE;\n  }\n\n  function isSection ( item ) {\n  \treturn ( item.t === SECTION || item.t === INVERTED ) && item.f;\n  }\n\n  function trimWhitespace ( items, leadingPattern, trailingPattern ) {\n  \tvar item;\n\n  \tif ( leadingPattern ) {\n  \t\titem = items[0];\n  \t\tif ( typeof item === 'string' ) {\n  \t\t\titem = item.replace( leadingPattern, '' );\n\n  \t\t\tif ( !item ) {\n  \t\t\t\titems.shift();\n  \t\t\t} else {\n  \t\t\t\titems[0] = item;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif ( trailingPattern ) {\n  \t\titem = lastItem( items );\n  \t\tif ( typeof item === 'string' ) {\n  \t\t\titem = item.replace( trailingPattern, '' );\n\n  \t\t\tif ( !item ) {\n  \t\t\t\titems.pop();\n  \t\t\t} else {\n  \t\t\t\titems[ items.length - 1 ] = item;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n  var leadingWhitespace$1 = /^[ \\t\\f\\r\\n]+/;\n  var trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n  var leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\n  var trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n\n  function cleanup ( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace ) {\n  \tif ( typeof items === 'string' ) return;\n\n  \tvar i,\n  \t\titem,\n  \t\tpreviousItem,\n  \t\tnextItem,\n  \t\tpreserveWhitespaceInsideFragment,\n  \t\tremoveLeadingWhitespaceInsideFragment,\n  \t\tremoveTrailingWhitespaceInsideFragment,\n  \t\tkey;\n\n  \t// First pass - remove standalones and comments etc\n  \tstripStandalones( items );\n\n  \ti = items.length;\n  \twhile ( i-- ) {\n  \t\titem = items[i];\n\n  \t\t// Remove delimiter changes, unsafe elements etc\n  \t\tif ( item.exclude ) {\n  \t\t\titems.splice( i, 1 );\n  \t\t}\n\n  \t\t// Remove comments, unless we want to keep them\n  \t\telse if ( stripComments && item.t === COMMENT ) {\n  \t\t\titems.splice( i, 1 );\n  \t\t}\n  \t}\n\n  \t// If necessary, remove leading and trailing whitespace\n  \ttrimWhitespace( items, removeLeadingWhitespace ? leadingWhitespace$1 : null, removeTrailingWhitespace ? trailingWhitespace : null );\n\n  \ti = items.length;\n  \twhile ( i-- ) {\n  \t\titem = items[i];\n\n  \t\t// Recurse\n  \t\tif ( item.f ) {\n  \t\t\tvar isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test( item.e );\n  \t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n  \t\t\tif ( !preserveWhitespace && isPreserveWhitespaceElement ) {\n  \t\t\t\ttrimWhitespace( item.f, leadingNewLine, trailingNewLine );\n  \t\t\t}\n\n  \t\t\tif ( !preserveWhitespaceInsideFragment ) {\n  \t\t\t\tpreviousItem = items[ i - 1 ];\n  \t\t\t\tnextItem = items[ i + 1 ];\n\n  \t\t\t\t// if the previous item was a text item with trailing whitespace,\n  \t\t\t\t// remove leading whitespace inside the fragment\n  \t\t\t\tif ( !previousItem || ( typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) ) {\n  \t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n  \t\t\t\t}\n\n  \t\t\t\t// and vice versa\n  \t\t\t\tif ( !nextItem || ( typeof nextItem === 'string' && leadingWhitespace$1.test( nextItem ) ) ) {\n  \t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tcleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\n  \t\t\t// clean up name templates (events, decorators, etc)\n  \t\t\tif ( isArray( item.f.n ) ) {\n  \t\t\t\tcleanup( item.f.n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );\n  \t\t\t}\n\n  \t\t\t// clean up arg templates (events, decorators, etc)\n  \t\t\tif ( isArray( item.f.d ) ) {\n  \t\t\t\tcleanup( item.f.d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespace );\n  \t\t\t}\n  \t\t}\n\n  \t\t// Split if-else blocks into two (an if, and an unless)\n  \t\tif ( item.l ) {\n  \t\t\tcleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n\n  \t\t\titem.l.forEach( function ( s ) { return s.l = 1; } );\n  \t\t\titem.l.unshift( i + 1, 0 );\n  \t\t\titems.splice.apply( items, item.l );\n  \t\t\tdelete item.l; // TODO would be nice if there was a way around this\n  \t\t}\n\n  \t\t// Clean up element attributes\n  \t\tif ( item.a ) {\n  \t\t\tfor ( key in item.a ) {\n  \t\t\t\tif ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {\n  \t\t\t\t\tcleanup( item.a[ key ], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\t// Clean up conditional attributes\n  \t\tif ( item.m ) {\n  \t\t\tcleanup( item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment );\n  \t\t\tif ( item.m.length < 1 ) delete item.m;\n  \t\t}\n  \t}\n\n  \t// final pass - fuse text nodes together\n  \ti = items.length;\n  \twhile ( i-- ) {\n  \t\tif ( typeof items[i] === 'string' ) {\n  \t\t\tif ( typeof items[i+1] === 'string' ) {\n  \t\t\t\titems[i] = items[i] + items[i+1];\n  \t\t\t\titems.splice( i + 1, 1 );\n  \t\t\t}\n\n  \t\t\tif ( !preserveWhitespace ) {\n  \t\t\t\titems[i] = items[i].replace( contiguousWhitespace, ' ' );\n  \t\t\t}\n\n  \t\t\tif ( items[i] === '' ) {\n  \t\t\t\titems.splice( i, 1 );\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n\n  function readClosingTag ( parser ) {\n  \tvar start, tag;\n\n  \tstart = parser.pos;\n\n  \t// are we looking at a closing tag?\n  \tif ( !parser.matchString( '</' ) ) {\n  \t\treturn null;\n  \t}\n\n  \tif ( tag = parser.matchPattern( closingTagPattern ) ) {\n  \t\tif ( parser.inside && tag !== parser.inside ) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: CLOSING_TAG,\n  \t\t\te: tag\n  \t\t};\n  \t}\n\n  \t// We have an illegal closing tag, report it\n  \tparser.pos -= 2;\n  \tparser.error( 'Illegal closing tag' );\n  }\n\n  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/;\n  var validTagNameFollower = /^[\\s\\n\\/>]/;\n  var exclude = { exclude: true };\n  var disallowedContents;\n  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n  disallowedContents = {\n  \tli: [ 'li' ],\n  \tdt: [ 'dt', 'dd' ],\n  \tdd: [ 'dt', 'dd' ],\n  \tp: 'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split( ' ' ),\n  \trt: [ 'rt', 'rp' ],\n  \trp: [ 'rt', 'rp' ],\n  \toptgroup: [ 'optgroup' ],\n  \toption: [ 'option', 'optgroup' ],\n  \tthead: [ 'tbody', 'tfoot' ],\n  \ttbody: [ 'tbody', 'tfoot' ],\n  \ttfoot: [ 'tbody' ],\n  \ttr: [ 'tr', 'tbody' ],\n  \ttd: [ 'td', 'th', 'tr' ],\n  \tth: [ 'td', 'th', 'tr' ]\n  };\n\n  function readElement ( parser ) {\n  \tvar start,\n  \t\telement,\n  \t\tattribute,\n  \t\tselfClosing,\n  \t\tchildren,\n  \t\tpartials,\n  \t\thasPartials,\n  \t\tchild,\n  \t\tclosed,\n  \t\tpos,\n  \t\tremaining,\n  \t\tclosingTag;\n\n  \tstart = parser.pos;\n\n  \tif ( parser.inside || parser.inAttribute || parser.textOnlyMode ) {\n  \t\treturn null;\n  \t}\n\n  \tif ( !parser.matchString( '<' ) ) {\n  \t\treturn null;\n  \t}\n\n  \t// if this is a closing tag, abort straight away\n  \tif ( parser.nextChar() === '/' ) {\n  \t\treturn null;\n  \t}\n\n  \telement = {};\n  \tif ( parser.includeLinePositions ) {\n  \t\telement.p = parser.getLinePos( start );\n  \t}\n\n  \tif ( parser.matchString( '!' ) ) {\n  \t\telement.t = DOCTYPE;\n  \t\tif ( !parser.matchPattern( /^doctype/i ) ) {\n  \t\t\tparser.error( 'Expected DOCTYPE declaration' );\n  \t\t}\n\n  \t\telement.a = parser.matchPattern( /^(.+?)>/ );\n  \t\treturn element;\n  \t}\n\n  \telement.t = ELEMENT;\n\n  \t// element name\n  \telement.e = parser.matchPattern( tagNamePattern );\n  \tif ( !element.e ) {\n  \t\treturn null;\n  \t}\n\n  \t// next character must be whitespace, closing solidus or '>'\n  \tif ( !validTagNameFollower.test( parser.nextChar() ) ) {\n  \t\tparser.error( 'Illegal tag name' );\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tparser.inTag = true;\n\n  \t// directives and attributes\n  \twhile ( attribute = readMustache( parser ) ) {\n  \t\tif ( attribute !== false ) {\n  \t\t\tif ( !element.m ) element.m = [];\n  \t\t\telement.m.push( attribute );\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n  \t}\n\n  \tparser.inTag = false;\n\n  \t// allow whitespace before closing solidus\n  \tparser.allowWhitespace();\n\n  \t// self-closing solidus?\n  \tif ( parser.matchString( '/' ) ) {\n  \t\tselfClosing = true;\n  \t}\n\n  \t// closing angle bracket\n  \tif ( !parser.matchString( '>' ) ) {\n  \t\treturn null;\n  \t}\n\n  \tvar lowerCaseName = element.e.toLowerCase();\n  \tvar preserveWhitespace = parser.preserveWhitespace;\n\n  \tif ( !selfClosing && !voidElementNames.test( element.e ) ) {\n  \t\tparser.elementStack.push( lowerCaseName );\n\n  \t\t// Special case - if we open a script element, further tags should\n  \t\t// be ignored unless they're a closing script element\n  \t\tif ( lowerCaseName === 'script' || lowerCaseName === 'style' || lowerCaseName === 'textarea' ) {\n  \t\t\tparser.inside = lowerCaseName;\n  \t\t}\n\n  \t\tchildren = [];\n  \t\tpartials = create( null );\n\n  \t\tdo {\n  \t\t\tpos = parser.pos;\n  \t\t\tremaining = parser.remaining();\n\n  \t\t\tif ( !remaining ) {\n  \t\t\t\tparser.error( (\"Missing end \" + (parser.elementStack.length > 1 ? 'tags' : 'tag') + \" (\" + (parser.elementStack.reverse().map( function ( x ) { return (\"</\" + x + \">\"); } ).join( '' )) + \")\") );\n  \t\t\t}\n\n  \t\t\t// if for example we're in an <li> element, and we see another\n  \t\t\t// <li> tag, close the first so they become siblings\n  \t\t\tif ( !canContain( lowerCaseName, remaining ) ) {\n  \t\t\t\tclosed = true;\n  \t\t\t}\n\n  \t\t\t// closing tag\n  \t\t\telse if ( closingTag = readClosingTag( parser ) ) {\n  \t\t\t\tclosed = true;\n\n  \t\t\t\tvar closingTagName = closingTag.e.toLowerCase();\n\n  \t\t\t\t// if this *isn't* the closing tag for the current element...\n  \t\t\t\tif ( closingTagName !== lowerCaseName ) {\n  \t\t\t\t\t// rewind parser\n  \t\t\t\t\tparser.pos = pos;\n\n  \t\t\t\t\t// if it doesn't close a parent tag, error\n  \t\t\t\t\tif ( !~parser.elementStack.indexOf( closingTagName ) ) {\n  \t\t\t\t\t\tvar errorMessage = 'Unexpected closing tag';\n\n  \t\t\t\t\t\t// add additional help for void elements, since component names\n  \t\t\t\t\t\t// might clash with them\n  \t\t\t\t\t\tif ( voidElementNames.test( closingTagName ) ) {\n  \t\t\t\t\t\t\terrorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\tparser.error( errorMessage );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// implicit close by closing section tag. TODO clean this up\n  \t\t\telse if ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] } ) ) {\n  \t\t\t\tclosed = true;\n  \t\t\t\tparser.pos = pos;\n  \t\t\t}\n\n  \t\t\telse {\n  \t\t\t\tif ( child = parser.read( PARTIAL_READERS ) ) {\n  \t\t\t\t\tif ( partials[ child.n ] ) {\n  \t\t\t\t\t\tparser.pos = pos;\n  \t\t\t\t\t\tparser.error( 'Duplicate partial definition' );\n  \t\t\t\t\t}\n\n  \t\t\t\t\tcleanup( child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\n  \t\t\t\t\tpartials[ child.n ] = child.f;\n  \t\t\t\t\thasPartials = true;\n  \t\t\t\t}\n\n  \t\t\t\telse {\n  \t\t\t\t\tif ( child = parser.read( READERS ) ) {\n  \t\t\t\t\t\tchildren.push( child );\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tclosed = true;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} while ( !closed );\n\n  \t\tif ( children.length ) {\n  \t\t\telement.f = children;\n  \t\t}\n\n  \t\tif ( hasPartials ) {\n  \t\t\telement.p = partials;\n  \t\t}\n\n  \t\tparser.elementStack.pop();\n  \t}\n\n  \tparser.inside = null;\n\n  \tif ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {\n  \t\treturn exclude;\n  \t}\n\n  \treturn element;\n  }\n\n  function canContain ( name, remaining ) {\n  \tvar match, disallowed;\n\n  \tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec( remaining );\n  \tdisallowed = disallowedContents[ name ];\n\n  \tif ( !match || !disallowed ) {\n  \t\treturn true;\n  \t}\n\n  \treturn !~disallowed.indexOf( match[1].toLowerCase() );\n  }\n\n  function readText ( parser ) {\n  \tvar index, remaining, disallowed, barrier;\n\n  \tremaining = parser.remaining();\n\n  \tif ( parser.textOnlyMode ) {\n  \t\tdisallowed = parser.tags.map( function ( t ) { return t.open; } );\n  \t\tdisallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\\\' + t.open; } ) );\n\n  \t\tindex = getLowestIndex( remaining, disallowed );\n  \t} else {\n  \t\tbarrier = parser.inside ? '</' + parser.inside : '<';\n\n  \t\tif ( parser.inside && !parser.interpolate[ parser.inside ] ) {\n  \t\t\tindex = remaining.indexOf( barrier );\n  \t\t} else {\n  \t\t\tdisallowed = parser.tags.map( function ( t ) { return t.open; } );\n  \t\t\tdisallowed = disallowed.concat( parser.tags.map( function ( t ) { return '\\\\' + t.open; } ) );\n\n  \t\t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n  \t\t\tif ( parser.inAttribute === true ) {\n  \t\t\t\t// we're inside an unquoted attribute value\n  \t\t\t\tdisallowed.push( (\"\\\"\"), (\"'\"), (\"=\"), (\"<\"), (\">\"), '`' );\n  \t\t\t} else if ( parser.inAttribute ) {\n  \t\t\t\t// quoted attribute value\n  \t\t\t\tdisallowed.push( parser.inAttribute );\n  \t\t\t} else {\n  \t\t\t\tdisallowed.push( barrier );\n  \t\t\t}\n\n  \t\t\tindex = getLowestIndex( remaining, disallowed );\n  \t\t}\n  \t}\n\n  \tif ( !index ) {\n  \t\treturn null;\n  \t}\n\n  \tif ( index === -1 ) {\n  \t\tindex = remaining.length;\n  \t}\n\n  \tparser.pos += index;\n\n  \tif ( ( parser.inside && parser.inside !== 'textarea' ) || parser.textOnlyMode ) {\n  \t\treturn remaining.substr( 0, index );\n  \t} else {\n  \t\treturn decodeCharacterReferences( remaining.substr( 0, index ) );\n  \t}\n  }\n\n  var startPattern = /^<!--\\s*/;\n  var namePattern$1 = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/;\n  var finishPattern = /\\s*-->/;\n\n  function readPartialDefinitionComment ( parser ) {\n  \tvar start = parser.pos;\n  \tvar open = parser.standardDelimiters[0];\n  \tvar close = parser.standardDelimiters[1];\n\n  \tif ( !parser.matchPattern( startPattern ) || !parser.matchString( open ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tvar name = parser.matchPattern( namePattern$1 );\n\n  \twarnOnceIfDebug( (\"Inline partial comments are deprecated.\\nUse this...\\n  {{#partial \" + name + \"}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>\" + name + \"}} --> ... <!-- {{/\" + name + \"}} -->'\") );\n\n  \t// make sure the rest of the comment is in the correct place\n  \tif ( !parser.matchString( close ) || !parser.matchPattern( finishPattern ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tvar content = [];\n  \tvar closed;\n\n  \tvar endPattern = new RegExp('^<!--\\\\s*' + escapeRegExp( open ) + '\\\\s*\\\\/\\\\s*' + name + '\\\\s*' + escapeRegExp( close ) + '\\\\s*-->');\n\n  \tdo {\n  \t\tif ( parser.matchPattern( endPattern ) ) {\n  \t\t\tclosed = true;\n  \t\t}\n\n  \t\telse {\n  \t\t\tvar child = parser.read( READERS );\n  \t\t\tif ( !child ) {\n  \t\t\t\tparser.error( (\"expected closing comment ('<!-- \" + open + \"/\" + name + \"\" + close + \" -->')\") );\n  \t\t\t}\n\n  \t\t\tcontent.push( child );\n  \t\t}\n  \t} while ( !closed );\n\n  \treturn {\n  \t\tt: INLINE_PARTIAL,\n  \t\tf: content,\n  \t\tn: name\n  \t};\n  }\n\n  var partialDefinitionSectionPattern = /^\\s*#\\s*partial\\s+/;\n\n  function readPartialDefinitionSection ( parser ) {\n  \tvar start, name, content, child, closed;\n\n  \tstart = parser.pos;\n\n  \tvar delimiters = parser.standardDelimiters;\n\n  \tif ( !parser.matchString( delimiters[0] ) ) {\n  \t\treturn null;\n  \t}\n\n  \tif ( !parser.matchPattern( partialDefinitionSectionPattern ) ) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tname = parser.matchPattern( /^[a-zA-Z_$][a-zA-Z_$0-9\\-\\/]*/ );\n\n  \tif ( !name ) {\n  \t\tparser.error( 'expected legal partial name' );\n  \t}\n\n  \tparser.allowWhitespace();\n  \tif ( !parser.matchString( delimiters[1] ) ) {\n  \t\tparser.error( (\"Expected closing delimiter '\" + (delimiters[1]) + \"'\") );\n  \t}\n\n  \tcontent = [];\n\n  \tdo {\n  \t\t// TODO clean this up\n  \t\tif ( child = readClosing( parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] }) ) {\n  \t\t\tif ( !child.r === 'partial' ) {\n  \t\t\t\tparser.error( (\"Expected \" + (delimiters[0]) + \"/partial\" + (delimiters[1])) );\n  \t\t\t}\n\n  \t\t\tclosed = true;\n  \t\t}\n\n  \t\telse {\n  \t\t\tchild = parser.read( READERS );\n\n  \t\t\tif ( !child ) {\n  \t\t\t\tparser.error( (\"Expected \" + (delimiters[0]) + \"/partial\" + (delimiters[1])) );\n  \t\t\t}\n\n  \t\t\tcontent.push( child );\n  \t\t}\n  \t} while ( !closed );\n\n  \treturn {\n  \t\tt: INLINE_PARTIAL,\n  \t\tn: name,\n  \t\tf: content\n  \t};\n  }\n\n  function readTemplate ( parser ) {\n  \tvar fragment = [];\n  \tvar partials = create( null );\n  \tvar hasPartials = false;\n\n  \tvar preserveWhitespace = parser.preserveWhitespace;\n\n  \twhile ( parser.pos < parser.str.length ) {\n  \t\tvar pos = parser.pos, item, partial;\n\n  \t\tif ( partial = parser.read( PARTIAL_READERS ) ) {\n  \t\t\tif ( partials[ partial.n ] ) {\n  \t\t\t\tparser.pos = pos;\n  \t\t\t\tparser.error( 'Duplicated partial definition' );\n  \t\t\t}\n\n  \t\t\tcleanup( partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace );\n\n  \t\t\tpartials[ partial.n ] = partial.f;\n  \t\t\thasPartials = true;\n  \t\t} else if ( item = parser.read( READERS ) ) {\n  \t\t\tfragment.push( item );\n  \t\t} else  {\n  \t\t\tparser.error( 'Unexpected template content' );\n  \t\t}\n  \t}\n\n  \tvar result = {\n  \t\tv: TEMPLATE_VERSION,\n  \t\tt: fragment\n  \t};\n\n  \tif ( hasPartials ) {\n  \t\tresult.p = partials;\n  \t}\n\n  \treturn result;\n  }\n\n  function insertExpressions ( obj, expr ) {\n\n  \tObject.keys( obj ).forEach( function ( key ) {\n  \t\tif  ( isExpression( key, obj ) ) return addTo( obj, expr );\n\n  \t\tvar ref = obj[ key ];\n  \t\tif ( hasChildren( ref ) ) insertExpressions( ref, expr );\n   \t});\n  }\n\n  function isExpression( key, obj ) {\n  \treturn key === 's' && isArray( obj.r );\n  }\n\n  function addTo( obj, expr ) {\n  \tvar s = obj.s, r = obj.r;\n  \tif ( !expr[ s ] ) expr[ s ] = fromExpression( s, r.length );\n  }\n\n  function hasChildren( ref ) {\n  \treturn isArray( ref ) || isObject( ref );\n  }\n\n  // See https://github.com/ractivejs/template-spec for information\n  // about the Ractive template specification\n\n  var STANDARD_READERS = [ readPartial, readUnescaped, readSection, readYielder, readInterpolator, readComment ];\n  var TRIPLE_READERS = [ readTriple ];\n  var STATIC_READERS = [ readUnescaped, readSection, readInterpolator ]; // TODO does it make sense to have a static section?\n\n  var StandardParser;\n\n  function parse ( template, options ) {\n  \treturn new StandardParser( template, options || {} ).result;\n  }\n\n  parse.computedStrings = function( computed ) {\n  \tif ( !computed ) return [];\n\n  \tObject.keys( computed ).forEach( function ( key ) {\n  \t\tvar value = computed[ key ];\n  \t\tif ( typeof value === 'string' ) {\n  \t\t\tcomputed[ key ] = fromComputationString( value );\n  \t\t}\n  \t});\n  };\n\n\n  var READERS = [ readMustache, readHtmlComment, readElement, readText ];\n  var PARTIAL_READERS = [ readPartialDefinitionComment, readPartialDefinitionSection ];\n\n  StandardParser = Parser$1.extend({\n  \tinit: function ( str, options ) {\n  \t\tvar tripleDelimiters = options.tripleDelimiters || [ '{{{', '}}}' ],\n  \t\t\tstaticDelimiters = options.staticDelimiters || [ '[[', ']]' ],\n  \t\t\tstaticTripleDelimiters = options.staticTripleDelimiters || [ '[[[', ']]]' ];\n\n  \t\tthis.standardDelimiters = options.delimiters || [ '{{', '}}' ];\n\n  \t\tthis.tags = [\n  \t\t\t{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS },\n  \t\t\t{ isStatic: false, isTriple: true,  open: tripleDelimiters[0],        close: tripleDelimiters[1],        readers: TRIPLE_READERS },\n  \t\t\t{ isStatic: true,  isTriple: false, open: staticDelimiters[0],        close: staticDelimiters[1],        readers: STATIC_READERS },\n  \t\t\t{ isStatic: true,  isTriple: true,  open: staticTripleDelimiters[0],  close: staticTripleDelimiters[1],  readers: TRIPLE_READERS }\n  \t\t];\n\n  \t\tthis.contextLines = options.contextLines || 0;\n\n  \t\tthis.sortMustacheTags();\n\n  \t\tthis.sectionDepth = 0;\n  \t\tthis.elementStack = [];\n\n  \t\tthis.interpolate = {\n  \t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n  \t\t\tstyle: !options.interpolate || options.interpolate.style !== false,\n  \t\t\ttextarea: true\n  \t\t};\n\n  \t\tif ( options.sanitize === true ) {\n  \t\t\toptions.sanitize = {\n  \t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n  \t\t\t\telements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),\n  \t\t\t\teventAttributes: true\n  \t\t\t};\n  \t\t}\n\n  \t\tthis.stripComments = options.stripComments !== false;\n  \t\tthis.preserveWhitespace = options.preserveWhitespace;\n  \t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n  \t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n  \t\tthis.includeLinePositions = options.includeLinePositions;\n  \t\tthis.textOnlyMode = options.textOnlyMode;\n  \t\tthis.csp = options.csp;\n  \t},\n\n  \tpostProcess: function ( result ) {\n  \t\t// special case - empty string\n  \t\tif ( !result.length ) {\n  \t\t\treturn { t: [], v: TEMPLATE_VERSION };\n  \t\t}\n\n  \t\tif ( this.sectionDepth > 0 ) {\n  \t\t\tthis.error( 'A section was left open' );\n  \t\t}\n\n  \t\tcleanup( result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace );\n\n  \t\tif ( this.csp !== false ) {\n  \t\t\tvar expr = {};\n  \t\t\tinsertExpressions( result[0].t, expr );\n  \t\t\tif ( Object.keys( expr ).length ) result[0].e = expr;\n  \t\t}\n\n  \t\treturn result[0];\n  \t},\n\n  \tconverters: [\n  \t\treadTemplate\n  \t],\n\n  \tsortMustacheTags: function () {\n  \t\t// Sort in order of descending opening delimiter length (longer first),\n  \t\t// to protect against opening delimiters being substrings of each other\n  \t\tthis.tags.sort( function ( a, b ) {\n  \t\t\treturn b.open.length - a.open.length;\n  \t\t});\n  \t}\n  });\n\n  var parseOptions = [\n  \t'delimiters',\n  \t'tripleDelimiters',\n  \t'staticDelimiters',\n  \t'staticTripleDelimiters',\n  \t'csp',\n  \t'interpolate',\n  \t'preserveWhitespace',\n  \t'sanitize',\n  \t'stripComments',\n  \t'contextLines'\n  ];\n\n  var TEMPLATE_INSTRUCTIONS = \"Either preparse or use a ractive runtime source that includes the parser. \";\n\n  var COMPUTATION_INSTRUCTIONS = \"Either use:\\n\\n\\tRactive.parse.computedStrings( component.computed )\\n\\nat build time to pre-convert the strings to functions, or use functions instead of strings in computed properties.\";\n\n\n  function throwNoParse ( method, error, instructions ) {\n  \tif ( !method ) {\n  \t\tfatal( (\"Missing Ractive.parse - cannot parse \" + error + \". \" + instructions) );\n  \t}\n  }\n\n  function createFunction ( body, length ) {\n  \tthrowNoParse( fromExpression, 'new expression function', TEMPLATE_INSTRUCTIONS );\n  \treturn fromExpression( body, length );\n  }\n\n  function createFunctionFromString ( str, bindTo ) {\n  \tthrowNoParse( fromComputationString, 'compution string \"${str}\"', COMPUTATION_INSTRUCTIONS );\n  \treturn fromComputationString( str, bindTo );\n  }\n\n  var parser = {\n\n  \tfromId: function ( id, options ) {\n  \t\tif ( !doc ) {\n  \t\t\tif ( options && options.noThrow ) { return; }\n  \t\t\tthrow new Error( (\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\") );\n  \t\t}\n\n  \t\tif ( id ) id = id.replace( /^#/, '' );\n\n  \t\tvar template;\n\n  \t\tif ( !( template = doc.getElementById( id ) )) {\n  \t\t\tif ( options && options.noThrow ) { return; }\n  \t\t\tthrow new Error( (\"Could not find template element with id #\" + id) );\n  \t\t}\n\n  \t\tif ( template.tagName.toUpperCase() !== 'SCRIPT' ) {\n  \t\t\tif ( options && options.noThrow ) { return; }\n  \t\t\tthrow new Error( (\"Template element with id #\" + id + \", must be a <script> element\") );\n  \t\t}\n\n  \t\treturn ( 'textContent' in template ? template.textContent : template.innerHTML );\n\n  \t},\n\n  \tisParsed: function ( template) {\n  \t\treturn !( typeof template === 'string' );\n  \t},\n\n  \tgetParseOptions: function ( ractive ) {\n  \t\t// Could be Ractive or a Component\n  \t\tif ( ractive.defaults ) { ractive = ractive.defaults; }\n\n  \t\treturn parseOptions.reduce( function ( val, key ) {\n  \t\t\tval[ key ] = ractive[ key ];\n  \t\t\treturn val;\n  \t\t}, {});\n  \t},\n\n  \tparse: function ( template, options ) {\n  \t\tthrowNoParse( parse, 'template', TEMPLATE_INSTRUCTIONS );\n  \t\tvar parsed = parse( template, options );\n  \t\taddFunctions( parsed );\n  \t\treturn parsed;\n  \t},\n\n  \tparseFor: function( template, ractive ) {\n  \t\treturn this.parse( template, this.getParseOptions( ractive ) );\n  \t}\n  };\n\n  var templateConfigurator = {\n  \tname: 'template',\n\n  \textend: function ( Parent, proto, options ) {\n  \t\t// only assign if exists\n  \t\tif ( 'template' in options ) {\n  \t\t\tvar template = options.template;\n\n  \t\t\tif ( typeof template === 'function' ) {\n  \t\t\t\tproto.template = template;\n  \t\t\t} else {\n  \t\t\t\tproto.template = parseTemplate( template, proto );\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tinit: function ( Parent, ractive, options ) {\n  \t\t// TODO because of prototypal inheritance, we might just be able to use\n  \t\t// ractive.template, and not bother passing through the Parent object.\n  \t\t// At present that breaks the test mocks' expectations\n  \t\tvar template = 'template' in options ? options.template : Parent.prototype.template;\n  \t\ttemplate = template || { v: TEMPLATE_VERSION, t: [] };\n\n  \t\tif ( typeof template === 'function' ) {\n  \t\t\tvar fn = template;\n  \t\t\ttemplate = getDynamicTemplate( ractive, fn );\n\n  \t\t\tractive._config.template = {\n  \t\t\t\tfn: fn,\n  \t\t\t\tresult: template\n  \t\t\t};\n  \t\t}\n\n  \t\ttemplate = parseTemplate( template, ractive );\n\n  \t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n  \t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n  \t\t// it's unnecessary, because the developer never needs to access\n  \t\t// ractive.template\n  \t\tractive.template = template.t;\n\n  \t\tif ( template.p ) {\n  \t\t\textendPartials( ractive.partials, template.p );\n  \t\t}\n  \t},\n\n  \treset: function ( ractive ) {\n  \t\tvar result = resetValue( ractive );\n\n  \t\tif ( result ) {\n  \t\t\tvar parsed = parseTemplate( result, ractive );\n\n  \t\t\tractive.template = parsed.t;\n  \t\t\textendPartials( ractive.partials, parsed.p, true );\n\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  };\n\n  function resetValue ( ractive ) {\n  \tvar initial = ractive._config.template;\n\n  \t// If this isn't a dynamic template, there's nothing to do\n  \tif ( !initial || !initial.fn ) {\n  \t\treturn;\n  \t}\n\n  \tvar result = getDynamicTemplate( ractive, initial.fn );\n\n  \t// TODO deep equality check to prevent unnecessary re-rendering\n  \t// in the case of already-parsed templates\n  \tif ( result !== initial.result ) {\n  \t\tinitial.result = result;\n  \t\treturn result;\n  \t}\n  }\n\n  function getDynamicTemplate ( ractive, fn ) {\n  \treturn fn.call( ractive, {\n  \t\tfromId: parser.fromId,\n  \t\tisParsed: parser.isParsed,\n  \t\tparse: function ( template, options ) {\n  \t\t\tif ( options === void 0 ) options = parser.getParseOptions( ractive );\n\n  \t\t\treturn parser.parse( template, options );\n  \t\t}\n  \t});\n  }\n\n  function parseTemplate ( template, ractive ) {\n  \tif ( typeof template === 'string' ) {\n  \t\t// parse will validate and add expression functions\n  \t\ttemplate = parseAsString( template, ractive );\n  \t}\n  \telse {\n  \t\t// need to validate and add exp for already parsed template\n  \t\tvalidate$1( template );\n  \t\taddFunctions( template );\n  \t}\n\n  \treturn template;\n  }\n\n  function parseAsString ( template, ractive ) {\n  \t// ID of an element containing the template?\n  \tif ( template[0] === '#' ) {\n  \t\ttemplate = parser.fromId( template );\n  \t}\n\n  \treturn parser.parseFor( template, ractive );\n  }\n\n  function validate$1( template ) {\n\n  \t// Check that the template even exists\n  \tif ( template == undefined ) {\n  \t\tthrow new Error( (\"The template cannot be \" + template + \".\") );\n  \t}\n\n  \t// Check the parsed template has a version at all\n  \telse if ( typeof template.v !== 'number' ) {\n  \t\tthrow new Error( 'The template parser was passed a non-string template, but the template doesn\\'t have a version.  Make sure you\\'re passing in the template you think you are.' );\n  \t}\n\n  \t// Check we're using the correct version\n  \telse if ( template.v !== TEMPLATE_VERSION ) {\n  \t\tthrow new Error( (\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + (template.v) + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\") );\n  \t}\n  }\n\n  function extendPartials ( existingPartials, newPartials, overwrite ) {\n  \tif ( !newPartials ) return;\n\n  \t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n  \t// case, but not initially...\n\n  \tfor ( var key in newPartials ) {\n  \t\tif ( overwrite || !existingPartials.hasOwnProperty( key ) ) {\n  \t\t\texistingPartials[ key ] = newPartials[ key ];\n  \t\t}\n  \t}\n  }\n\n  var registryNames = [\n  \t'adaptors',\n  \t'components',\n  \t'computed',\n  \t'decorators',\n  \t'easing',\n  \t'events',\n  \t'interpolators',\n  \t'partials',\n  \t'transitions'\n  ];\n\n  var Registry = function Registry ( name, useDefaults ) {\n  \tthis.name = name;\n  \tthis.useDefaults = useDefaults;\n  };\n\n  Registry.prototype.extend = function extend ( Parent, proto, options ) {\n  \tthis.configure(\n  \t\tthis.useDefaults ? Parent.defaults : Parent,\n  \t\tthis.useDefaults ? proto : proto.constructor,\n  \t\toptions );\n  };\n\n  Registry.prototype.init = function init () {\n  \t// noop\n  };\n\n  Registry.prototype.configure = function configure ( Parent, target, options ) {\n  \tvar name = this.name;\n  \tvar option = options[ name ];\n\n  \tvar registry = create( Parent[name] );\n\n  \tfor ( var key in option ) {\n  \t\tregistry[ key ] = option[ key ];\n  \t}\n\n  \ttarget[ name ] = registry;\n  };\n\n  Registry.prototype.reset = function reset ( ractive ) {\n  \tvar registry = ractive[ this.name ];\n  \tvar changed = false;\n\n  \tObject.keys( registry ).forEach( function ( key ) {\n  \t\tvar item = registry[ key ];\n  \t\t\t\n  \t\tif ( item._fn ) {\n  \t\t\tif ( item._fn.isOwner ) {\n  \t\t\t\tregistry[key] = item._fn;\n  \t\t\t} else {\n  \t\t\t\tdelete registry[key];\n  \t\t\t}\n  \t\t\tchanged = true;\n  \t\t}\n  \t});\n\n  \treturn changed;\n  };\n\n  var registries = registryNames.map( function ( name ) { return new Registry( name, name === 'computed' ); } );\n\n  function wrap ( parent, name, method ) {\n  \tif ( !/_super/.test( method ) ) return method;\n\n  \tfunction wrapper () {\n  \t\tvar superMethod = getSuperMethod( wrapper._parent, name );\n  \t\tvar hasSuper = '_super' in this;\n  \t\tvar oldSuper = this._super;\n\n  \t\tthis._super = superMethod;\n\n  \t\tvar result = method.apply( this, arguments );\n\n  \t\tif ( hasSuper ) {\n  \t\t\tthis._super = oldSuper;\n  \t\t} else {\n  \t\t\tdelete this._super;\n  \t\t}\n\n  \t\treturn result;\n  \t}\n\n  \twrapper._parent = parent;\n  \twrapper._method = method;\n\n  \treturn wrapper;\n  }\n\n  function getSuperMethod ( parent, name ) {\n  \tif ( name in parent ) {\n  \t\tvar value = parent[ name ];\n\n  \t\treturn typeof value === 'function' ?\n  \t\t\tvalue :\n  \t\t\tfunction () { return value; };\n  \t}\n\n  \treturn noop;\n  }\n\n  function getMessage( deprecated, correct, isError ) {\n  \treturn \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\"\n  \t\t+ ( isError ? (\" You cannot specify both options, please use options.\" + correct + \".\") : '' );\n  }\n\n  function deprecateOption ( options, deprecatedOption, correct ) {\n  \tif ( deprecatedOption in options ) {\n  \t\tif( !( correct in options ) ) {\n  \t\t\twarnIfDebug( getMessage( deprecatedOption, correct ) );\n  \t\t\toptions[ correct ] = options[ deprecatedOption ];\n  \t\t} else {\n  \t\t\tthrow new Error( getMessage( deprecatedOption, correct, true ) );\n  \t\t}\n  \t}\n  }\n\n  function deprecate ( options ) {\n  \tdeprecateOption( options, 'beforeInit', 'onconstruct' );\n  \tdeprecateOption( options, 'init', 'onrender' );\n  \tdeprecateOption( options, 'complete', 'oncomplete' );\n  \tdeprecateOption( options, 'eventDefinitions', 'events' );\n\n  \t// Using extend with Component instead of options,\n  \t// like Human.extend( Spider ) means adaptors as a registry\n  \t// gets copied to options. So we have to check if actually an array\n  \tif ( isArray( options.adaptors ) ) {\n  \t\tdeprecateOption( options, 'adaptors', 'adapt' );\n  \t}\n  }\n\n  var custom = {\n  \tadapt: adaptConfigurator,\n  \tcss: cssConfigurator,\n  \tdata: dataConfigurator,\n  \ttemplate: templateConfigurator\n  };\n\n  var defaultKeys = Object.keys( defaults );\n\n  var isStandardKey = makeObj( defaultKeys.filter( function ( key ) { return !custom[ key ]; } ) );\n\n  // blacklisted keys that we don't double extend\n  var isBlacklisted = makeObj( defaultKeys.concat( registries.map( function ( r ) { return r.name; } ) ) );\n\n  var order = [].concat(\n  \tdefaultKeys.filter( function ( key ) { return !registries[ key ] && !custom[ key ]; } ),\n  \tregistries,\n  \t//custom.data,\n  \tcustom.template,\n  \tcustom.css\n  );\n\n  var config = {\n  \textend: function ( Parent, proto, options ) { return configure( 'extend', Parent, proto, options ); },\n\n  \tinit: function ( Parent, ractive, options ) { return configure( 'init', Parent, ractive, options ); },\n\n  \treset: function ( ractive ) {\n  \t\treturn order.filter( function ( c ) {\n  \t\t\treturn c.reset && c.reset( ractive );\n  \t\t}).map( function ( c ) { return c.name; } );\n  \t},\n\n  \t// this defines the order. TODO this isn't used anywhere in the codebase,\n  \t// only in the test suite - should get rid of it\n  \torder: order\n  };\n\n  function configure ( method, Parent, target, options ) {\n  \tdeprecate( options );\n\n  \tfor ( var key in options ) {\n  \t\tif ( isStandardKey.hasOwnProperty( key ) ) {\n  \t\t\tvar value = options[ key ];\n\n  \t\t\t// warn the developer if they passed a function and ignore its value\n\n  \t\t\t// NOTE: we allow some functions on \"el\" because we duck type element lists\n  \t\t\t// and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n  \t\t\t// function object as the result of querySelector methods\n  \t\t\tif ( key !== 'el' && typeof value === 'function' ) {\n  \t\t\t\twarnIfDebug( (\"\" + key + \" is a Ractive option that does not expect a function and will be ignored\"),\n  \t\t\t\t\tmethod === 'init' ? target : null );\n  \t\t\t}\n  \t\t\telse {\n  \t\t\t\ttarget[ key ] = value;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// disallow combination of `append` and `enhance`\n  \tif ( options.append && options.enhance ) {\n  \t\tthrow new Error( 'Cannot use append and enhance at the same time' );\n  \t}\n\n  \tregistries.forEach( function ( registry ) {\n  \t\tregistry[ method ]( Parent, target, options );\n  \t});\n\n  \tadaptConfigurator[ method ]( Parent, target, options );\n  \ttemplateConfigurator[ method ]( Parent, target, options );\n  \tcssConfigurator[ method ]( Parent, target, options );\n\n  \textendOtherMethods( Parent.prototype, target, options );\n  }\n\n  function extendOtherMethods ( parent, target, options ) {\n  \tfor ( var key in options ) {\n  \t\tif ( !isBlacklisted[ key ] && options.hasOwnProperty( key ) ) {\n  \t\t\tvar member = options[ key ];\n\n  \t\t\t// if this is a method that overwrites a method, wrap it:\n  \t\t\tif ( typeof member === 'function' ) {\n  \t\t\t\tmember = wrap( parent, key, member );\n  \t\t\t}\n\n  \t\t\ttarget[ key ] = member;\n  \t\t}\n  \t}\n  }\n\n  function makeObj ( array ) {\n  \tvar obj = {};\n  \tarray.forEach( function ( x ) { return obj[x] = true; } );\n  \treturn obj;\n  }\n\n  var shouldRerender = [ 'template', 'partials', 'components', 'decorators', 'events' ];\n\n  var completeHook$1 = new Hook( 'complete' );\n  var resetHook = new Hook( 'reset' );\n  var renderHook$1 = new Hook( 'render' );\n  var unrenderHook = new Hook( 'unrender' );\n\n  function Ractive$reset ( data ) {\n  \tdata = data || {};\n\n  \tif ( typeof data !== 'object' ) {\n  \t\tthrow new Error( 'The reset method takes either no arguments, or an object containing new data' );\n  \t}\n\n  \t// TEMP need to tidy this up\n  \tdata = dataConfigurator.init( this.constructor, this, { data: data });\n\n  \tvar promise = runloop.start( this, true );\n\n  \t// If the root object is wrapped, try and use the wrapper's reset value\n  \tvar wrapper = this.viewmodel.wrapper;\n  \tif ( wrapper && wrapper.reset ) {\n  \t\tif ( wrapper.reset( data ) === false ) {\n  \t\t\t// reset was rejected, we need to replace the object\n  \t\t\tthis.viewmodel.set( data );\n  \t\t}\n  \t} else {\n  \t\tthis.viewmodel.set( data );\n  \t}\n\n  \t// reset config items and track if need to rerender\n  \tvar changes = config.reset( this );\n  \tvar rerender;\n\n  \tvar i = changes.length;\n  \twhile ( i-- ) {\n  \t\tif ( shouldRerender.indexOf( changes[i] ) > -1 ) {\n  \t\t\trerender = true;\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tif ( rerender ) {\n  \t\tunrenderHook.fire( this );\n  \t\tthis.fragment.resetTemplate( this.template );\n  \t\trenderHook$1.fire( this );\n  \t\tcompleteHook$1.fire( this );\n  \t}\n\n  \trunloop.end();\n\n  \tresetHook.fire( this, data );\n\n  \treturn promise;\n  }\n\n  function collect( source, name, attr, dest ) {\n  \tsource.forEach( function ( item ) {\n  \t\t// queue to rerender if the item is a partial and the current name matches\n  \t\tif ( item.type === PARTIAL && ( item.refName ===  name || item.name === name ) ) {\n  \t\t\titem.inAttribute = attr;\n  \t\t\tdest.push( item );\n  \t\t\treturn; // go no further\n  \t\t}\n\n  \t\t// if it has a fragment, process its items\n  \t\tif ( item.fragment ) {\n  \t\t\tcollect( item.fragment.iterations || item.fragment.items, name, attr, dest );\n  \t\t}\n\n  \t\t// or if it is itself a fragment, process its items\n  \t\telse if ( isArray( item.items ) ) {\n  \t\t\tcollect( item.items, name, attr, dest );\n  \t\t}\n\n  \t\t// or if it is a component, step in and process its items\n  \t\telse if ( item.type === COMPONENT && item.instance ) {\n  \t\t\t// ...unless the partial is shadowed\n  \t\t\tif ( item.instance.partials[ name ] ) return;\n  \t\t\tcollect( item.instance.fragment.items, name, attr, dest );\n  \t\t}\n\n  \t\t// if the item is an element, process its attributes too\n  \t\tif ( item.type === ELEMENT ) {\n  \t\t\tif ( isArray( item.attributes ) ) {\n  \t\t\t\tcollect( item.attributes, name, true, dest );\n  \t\t\t}\n  \t\t}\n  \t});\n  }\n\n  function forceResetTemplate ( partial ) {\n  \tpartial.forceResetTemplate();\n  }\n\n  function resetPartial ( name, partial ) {\n  \tvar collection = [];\n  \tcollect( this.fragment.items, name, false, collection );\n\n  \tvar promise = runloop.start( this, true );\n\n  \tthis.partials[ name ] = partial;\n  \tcollection.forEach( forceResetTemplate );\n\n  \trunloop.end();\n\n  \treturn promise;\n  }\n\n  var Item = function Item ( options ) {\n  \tthis.parentFragment = options.parentFragment;\n  \tthis.ractive = options.parentFragment.ractive;\n\n  \tthis.template = options.template;\n  \tthis.index = options.index;\n  \tthis.type = options.template.t;\n\n  \tthis.dirty = false;\n  };\n\n  Item.prototype.bubble = function bubble () {\n  \tif ( !this.dirty ) {\n  \t\tthis.dirty = true;\n  \t\tthis.parentFragment.bubble();\n  \t}\n  };\n\n  Item.prototype.destroyed = function destroyed () {\n  \tif ( this.fragment ) this.fragment.destroyed();\n  };\n\n  Item.prototype.find = function find () {\n  \treturn null;\n  };\n\n  Item.prototype.findAll = function findAll () {\n  \t// noop\n  };\n\n  Item.prototype.findComponent = function findComponent () {\n  \treturn null;\n  };\n\n  Item.prototype.findAllComponents = function findAllComponents () {\n  \t// noop;\n  };\n\n  Item.prototype.findNextNode = function findNextNode () {\n  \treturn this.parentFragment.findNextNode( this );\n  };\n\n  Item.prototype.shuffled = function shuffled () {\n  \tif ( this.fragment ) this.fragment.shuffled();\n  };\n\n  Item.prototype.valueOf = function valueOf () {\n  \treturn this.toString();\n  };\n\n  var ComputationChild = (function (Model) {\n  \tfunction ComputationChild () {\n  \t\tModel.apply(this, arguments);\n  \t}\n\n  \tComputationChild.prototype = Object.create( Model && Model.prototype );\n  \tComputationChild.prototype.constructor = ComputationChild;\n\n  \tComputationChild.prototype.get = function get ( shouldCapture ) {\n  \t\tif ( shouldCapture ) capture( this );\n\n  \t\tvar parentValue = this.parent.get();\n  \t\treturn parentValue ? parentValue[ this.key ] : undefined;\n  \t};\n\n  \tComputationChild.prototype.handleChange = function handleChange$1 () {\n  \t\tthis.dirty = true;\n\n  \t\tthis.links.forEach( marked );\n  \t\tthis.deps.forEach( handleChange );\n  \t\tthis.children.forEach( handleChange );\n  \t\tthis.clearUnresolveds(); // TODO is this necessary?\n  \t};\n\n  \tComputationChild.prototype.joinKey = function joinKey ( key ) {\n  \t\tif ( key === undefined || key === '' ) return this;\n\n  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n  \t\t\tvar child = new ComputationChild( this, key );\n  \t\t\tthis.children.push( child );\n  \t\t\tthis.childByKey[ key ] = child;\n  \t\t}\n\n  \t\treturn this.childByKey[ key ];\n  \t};\n\n  \treturn ComputationChild;\n  }(Model));\n\n  function createResolver ( proxy, ref, index ) {\n  \tvar resolver = proxy.fragment.resolve( ref, function ( model ) {\n  \t\tremoveFromArray( proxy.resolvers, resolver );\n  \t\tproxy.models[ index ] = model;\n  \t\tproxy.bubble();\n  \t});\n\n  \tproxy.resolvers.push( resolver );\n  }\n\n  var ExpressionProxy = (function (Model) {\n  \tfunction ExpressionProxy ( fragment, template ) {\n  \t\tvar this$1 = this;\n\n  \t\tModel.call( this, fragment.ractive.viewmodel, null );\n\n  \t\tthis.fragment = fragment;\n  \t\tthis.template = template;\n\n  \t\tthis.isReadonly = true;\n  \t\tthis.dirty = true;\n\n  \t\tthis.fn = getFunction( template.s, template.r.length );\n\n  \t\tthis.resolvers = [];\n  \t\tthis.models = this.template.r.map( function ( ref, index ) {\n  \t\t\tvar model = resolveReference( this$1.fragment, ref );\n\n  \t\t\tif ( !model ) {\n  \t\t\t\tcreateResolver( this$1, ref, index );\n  \t\t\t}\n\n  \t\t\treturn model;\n  \t\t});\n  \t\tthis.dependencies = [];\n\n  \t\tthis.shuffle = undefined;\n\n  \t\tthis.bubble();\n  \t}\n\n  \tExpressionProxy.prototype = Object.create( Model && Model.prototype );\n  \tExpressionProxy.prototype.constructor = ExpressionProxy;\n\n  \tExpressionProxy.prototype.bubble = function bubble ( actuallyChanged ) {\n  \t\t// refresh the keypath\n  \t\tif ( actuallyChanged === void 0 ) actuallyChanged = true;\n\n  \t\tif ( this.registered ) delete this.root.expressions[ this.keypath ];\n  \t\tthis.keypath = undefined;\n\n  \t\tif ( actuallyChanged ) {\n  \t\t\tthis.dirty = true;\n  \t\t\tthis.handleChange();\n  \t\t}\n  \t};\n\n  \tExpressionProxy.prototype.get = function get ( shouldCapture ) {\n  \t\tif ( shouldCapture ) capture( this );\n\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n  \t\t\tthis.value = this.getValue();\n  \t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n  \t\t\tthis.adapt();\n  \t\t}\n\n  \t\treturn shouldCapture && this.wrapper ? this.wrapperValue : this.value;\n  \t};\n\n  \tExpressionProxy.prototype.getKeypath = function getKeypath () {\n  \t\tvar this$1 = this;\n\n  \t\tif ( !this.template ) return '@undefined';\n  \t\tif ( !this.keypath ) {\n  \t\t\tthis.keypath = '@' + this.template.s.replace( /_(\\d+)/g, function ( match, i ) {\n  \t\t\t\tif ( i >= this$1.models.length ) return match;\n\n  \t\t\t\tvar model = this$1.models[i];\n  \t\t\t\treturn model ? model.getKeypath() : '@undefined';\n  \t\t\t});\n\n  \t\t\tthis.root.expressions[ this.keypath ] = this;\n  \t\t\tthis.registered = true;\n  \t\t}\n\n  \t\treturn this.keypath;\n  \t};\n\n  \tExpressionProxy.prototype.getValue = function getValue () {\n  \t\tvar this$1 = this;\n\n  \t\tstartCapturing();\n  \t\tvar result;\n\n  \t\ttry {\n  \t\t\tvar params = this.models.map( function ( m ) { return m ? m.get( true ) : undefined; } );\n  \t\t\tresult = this.fn.apply( this.fragment.ractive, params );\n  \t\t} catch ( err ) {\n  \t\t\twarnIfDebug( (\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)) );\n  \t\t}\n\n  \t\tvar dependencies = stopCapturing();\n  \t\t// remove missing deps\n  \t\tthis.dependencies.filter( function ( d ) { return !~dependencies.indexOf( d ); } ).forEach( function ( d ) {\n  \t\t\td.unregister( this$1 );\n  \t\t\tremoveFromArray( this$1.dependencies, d );\n  \t\t});\n  \t\t// register new deps\n  \t\tdependencies.filter( function ( d ) { return !~this$1.dependencies.indexOf( d ); } ).forEach( function ( d ) {\n  \t\t\td.register( this$1 );\n  \t\t\tthis$1.dependencies.push( d );\n  \t\t});\n\n  \t\treturn result;\n  \t};\n\n  \tExpressionProxy.prototype.handleChange = function handleChange$1 () {\n  \t\tthis.dirty = true;\n\n  \t\tthis.links.forEach( marked );\n  \t\tthis.deps.forEach( handleChange );\n  \t\tthis.children.forEach( handleChange );\n\n  \t\tthis.clearUnresolveds();\n  \t};\n\n  \tExpressionProxy.prototype.joinKey = function joinKey ( key ) {\n  \t\tif ( key === undefined || key === '' ) return this;\n\n  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n  \t\t\tvar child = new ComputationChild( this, key );\n  \t\t\tthis.children.push( child );\n  \t\t\tthis.childByKey[ key ] = child;\n  \t\t}\n\n  \t\treturn this.childByKey[ key ];\n  \t};\n\n  \tExpressionProxy.prototype.mark = function mark () {\n  \t\tthis.handleChange();\n  \t};\n\n  \tExpressionProxy.prototype.rebinding = function rebinding ( next, previous, safe ) {\n  \t\tvar idx = this.models.indexOf( previous );\n\n  \t\tif ( ~idx ) {\n  \t\t\tnext = rebindMatch( this.template.r[idx], next, previous );\n  \t\t\tif ( next !== previous ) {\n  \t\t\t\tprevious.unregister( this );\n  \t\t\t\tthis.models.splice( idx, 1, next );\n  \t\t\t\t// TODO: set up a resolver if there is no next?\n  \t\t\t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n  \t\t\t}\n  \t\t}\n  \t\tthis.bubble( !safe );\n  \t};\n\n  \tExpressionProxy.prototype.retrieve = function retrieve () {\n  \t\treturn this.get();\n  \t};\n\n  \tExpressionProxy.prototype.teardown = function teardown () {\n  \t\tvar this$1 = this;\n\n  \t\tthis.unbind();\n  \t\tthis.fragment = undefined;\n  \t\tif ( this.dependencies ) this.dependencies.forEach( function ( d ) { return d.unregister( this$1 ); } );\n  \t\tModel.prototype.teardown.call(this);\n  \t};\n\n  \tExpressionProxy.prototype.unregister = function unregister( dep ) {\n  \t\tModel.prototype.unregister.call( this, dep );\n  \t\tif ( !this.deps.length ) this.teardown();\n  \t};\n\n  \tExpressionProxy.prototype.unbind = function unbind$1 () {\n  \t\tthis.resolvers.forEach( unbind );\n  \t};\n\n  \treturn ExpressionProxy;\n  }(Model));\n\n  var ReferenceExpressionChild = (function (Model) {\n  \tfunction ReferenceExpressionChild ( parent, key ) {\n  \t\tModel.call ( this, parent, key );\n  \t}\n\n  \tReferenceExpressionChild.prototype = Object.create( Model && Model.prototype );\n  \tReferenceExpressionChild.prototype.constructor = ReferenceExpressionChild;\n\n  \tReferenceExpressionChild.prototype.applyValue = function applyValue ( value ) {\n  \t\tif ( isEqual( value, this.value ) ) return;\n\n  \t\tvar parent = this.parent, keys = [ this.key ];\n  \t\twhile ( parent ) {\n  \t\t\tif ( parent.base ) {\n  \t\t\t\tvar target = parent.model.joinAll( keys );\n  \t\t\t\ttarget.applyValue( value );\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tkeys.unshift( parent.key );\n\n  \t\t\tparent = parent.parent;\n  \t\t}\n  \t};\n\n  \tReferenceExpressionChild.prototype.joinKey = function joinKey ( key ) {\n  \t\tif ( key === undefined || key === '' ) return this;\n\n  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n  \t\t\tvar child = new ReferenceExpressionChild( this, key );\n  \t\t\tthis.children.push( child );\n  \t\t\tthis.childByKey[ key ] = child;\n  \t\t}\n\n  \t\treturn this.childByKey[ key ];\n  \t};\n\n  \tReferenceExpressionChild.prototype.retrieve = function retrieve () {\n  \t\tvar parent = this.parent.get();\n  \t\treturn parent && this.key in parent ? parent[ this.key ] : undefined;\n  \t};\n\n  \treturn ReferenceExpressionChild;\n  }(Model));\n\n  var ReferenceExpressionProxy = (function (Model) {\n  \tfunction ReferenceExpressionProxy ( fragment, template ) {\n  \t\tvar this$1 = this;\n\n  \t\tModel.call( this, null, null );\n  \t\tthis.dirty = true;\n  \t\tthis.root = fragment.ractive.viewmodel;\n  \t\tthis.template = template;\n\n  \t\tthis.resolvers = [];\n\n  \t\tthis.base = resolve$2( fragment, template );\n  \t\tvar baseResolver;\n\n  \t\tif ( !this.base ) {\n  \t\t\tbaseResolver = fragment.resolve( template.r, function ( model ) {\n  \t\t\t\tthis$1.base = model;\n  \t\t\t\tthis$1.bubble();\n\n  \t\t\t\tremoveFromArray( this$1.resolvers, baseResolver );\n  \t\t\t});\n\n  \t\t\tthis.resolvers.push( baseResolver );\n  \t\t}\n\n  \t\tvar intermediary = this.intermediary = {\n  \t\t\thandleChange: function () { return this$1.handleChange(); },\n  \t\t\trebinding: function ( next, previous ) {\n  \t\t\t\tif ( previous === this$1.base ) {\n  \t\t\t\t\tnext = rebindMatch( template, next, previous );\n  \t\t\t\t\tif ( next !== this$1.base ) {\n  \t\t\t\t\t\tthis$1.base.unregister( intermediary );\n  \t\t\t\t\t\tthis$1.base = next;\n  \t\t\t\t\t\t// TODO: if there is no next, set up a resolver?\n  \t\t\t\t\t}\n  \t\t\t\t} else {\n  \t\t\t\t\tvar idx = this$1.members.indexOf( previous );\n  \t\t\t\t\tif ( ~idx ) {\n  \t\t\t\t\t\t// only direct references will rebind... expressions handle themselves\n  \t\t\t\t\t\tnext = rebindMatch( template.m[idx].n, next, previous );\n  \t\t\t\t\t\tif ( next !== this$1.members[idx] ) {\n  \t\t\t\t\t\t\tthis$1.members.splice( idx, 1, next );\n  \t\t\t\t\t\t\t// TODO: if there is no next, set up a resolver?\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\tif ( next !== previous ) previous.unregister( intermediary );\n  \t\t\t\tif ( next ) next.addShuffleTask( function () { return next.register( intermediary ); } );\n\n  \t\t\t\tthis$1.bubble();\n  \t\t\t}\n  \t\t};\n\n  \t\tthis.members = template.m.map( function ( template, i ) {\n  \t\t\tif ( typeof template === 'string' ) {\n  \t\t\t\treturn { get: function () { return template; } };\n  \t\t\t}\n\n  \t\t\tvar model;\n  \t\t\tvar resolver;\n\n  \t\t\tif ( template.t === REFERENCE ) {\n  \t\t\t\tmodel = resolveReference( fragment, template.n );\n\n  \t\t\t\tif ( model ) {\n  \t\t\t\t\tmodel.register( intermediary );\n  \t\t\t\t} else {\n  \t\t\t\t\tresolver = fragment.resolve( template.n, function ( model ) {\n  \t\t\t\t\t\tthis$1.members[i] = model;\n\n  \t\t\t\t\t\tmodel.register( intermediary );\n  \t\t\t\t\t\tthis$1.handleChange();\n\n  \t\t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n  \t\t\t\t\t});\n\n  \t\t\t\t\tthis$1.resolvers.push( resolver );\n  \t\t\t\t}\n\n  \t\t\t\treturn model;\n  \t\t\t}\n\n  \t\t\tmodel = new ExpressionProxy( fragment, template );\n  \t\t\tmodel.register( intermediary );\n  \t\t\treturn model;\n  \t\t});\n\n  \t\tthis.isUnresolved = true;\n  \t\tthis.bubble();\n  \t}\n\n  \tReferenceExpressionProxy.prototype = Object.create( Model && Model.prototype );\n  \tReferenceExpressionProxy.prototype.constructor = ReferenceExpressionProxy;\n\n  \tReferenceExpressionProxy.prototype.bubble = function bubble () {\n  \t\tif ( !this.base ) return;\n  \t\tif ( !this.dirty ) this.handleChange();\n  \t};\n\n  \tReferenceExpressionProxy.prototype.forceResolution = function forceResolution () {\n  \t\tthis.resolvers.forEach( function ( resolver ) { return resolver.forceResolution(); } );\n  \t\tthis.dirty = true;\n  \t\tthis.bubble();\n  \t};\n\n  \tReferenceExpressionProxy.prototype.get = function get ( shouldCapture ) {\n  \t\tvar this$1 = this;\n\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.bubble();\n\n  \t\t\tvar i = this.members.length, resolved = true;\n  \t\t\twhile ( resolved && i-- ) {\n  \t\t\t\tif ( !this$1.members[i] ) resolved = false;\n  \t\t\t}\n\n  \t\t\tif ( this.base && resolved ) {\n  \t\t\t\tvar keys = this.members.map( function ( m ) { return escapeKey( String( m.get() ) ); } );\n  \t\t\t\tvar model = this.base.joinAll( keys );\n\n  \t\t\t\tif ( model !== this.model ) {\n  \t\t\t\t\tif ( this.model ) {\n  \t\t\t\t\t\tthis.model.unregister( this );\n  \t\t\t\t\t\tthis.model.unregisterTwowayBinding( this );\n  \t\t\t\t\t}\n\n  \t\t\t\t\tthis.model = model;\n  \t\t\t\t\tthis.parent = model.parent;\n  \t\t\t\t\tthis.model.register( this );\n  \t\t\t\t\tthis.model.registerTwowayBinding( this );\n\n  \t\t\t\t\tif ( this.keypathModel ) this.keypathModel.handleChange();\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis.value = this.model ? this.model.get( shouldCapture ) : undefined;\n  \t\t\tthis.dirty = false;\n  \t\t\tthis.mark();\n  \t\t\treturn this.value;\n  \t\t} else {\n  \t\t\treturn this.model ? this.model.get( shouldCapture ) : undefined;\n  \t\t}\n  \t};\n\n  \t// indirect two-way bindings\n  \tReferenceExpressionProxy.prototype.getValue = function getValue () {\n  \t\tvar this$1 = this;\n\n  \t\tthis.value = this.model ? this.model.get() : undefined;\n\n  \t\tvar i = this.bindings.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar value = this$1.bindings[i].getValue();\n  \t\t\tif ( value !== this$1.value ) return value;\n  \t\t}\n\n  \t\t// check one-way bindings\n  \t\tvar oneway = findBoundValue( this.deps );\n  \t\tif ( oneway ) return oneway.value;\n\n  \t\treturn this.value;\n  \t};\n\n  \tReferenceExpressionProxy.prototype.getKeypath = function getKeypath () {\n  \t\treturn this.model ? this.model.getKeypath() : '@undefined';\n  \t};\n\n  \tReferenceExpressionProxy.prototype.handleChange = function handleChange$1 () {\n  \t\tthis.dirty = true;\n  \t\tthis.mark();\n  \t};\n\n  \tReferenceExpressionProxy.prototype.joinKey = function joinKey ( key ) {\n  \t\tif ( key === undefined || key === '' ) return this;\n\n  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n  \t\t\tvar child = new ReferenceExpressionChild( this, key );\n  \t\t\tthis.children.push( child );\n  \t\t\tthis.childByKey[ key ] = child;\n  \t\t}\n\n  \t\treturn this.childByKey[ key ];\n  \t};\n\n  \tReferenceExpressionProxy.prototype.mark = function mark$1 () {\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.deps.forEach( handleChange );\n  \t\t}\n\n  \t\tthis.links.forEach( marked );\n  \t\tthis.children.forEach( mark );\n  \t\tthis.clearUnresolveds();\n  \t};\n\n  \tReferenceExpressionProxy.prototype.retrieve = function retrieve () {\n  \t\treturn this.value;\n  \t};\n\n  \tReferenceExpressionProxy.prototype.rebinding = function rebinding () { }; // NOOP\n\n  \tReferenceExpressionProxy.prototype.set = function set ( value ) {\n  \t\tif ( !this.model ) throw new Error( 'Unresolved reference expression. This should not happen!' );\n  \t\tthis.model.set( value );\n  \t};\n\n  \tReferenceExpressionProxy.prototype.unbind = function unbind$1 () {\n  \t\tthis.resolvers.forEach( unbind );\n  \t\tif ( this.model ) {\n  \t\t\tthis.model.unregister( this );\n  \t\t\tthis.model.unregisterTwowayBinding( this );\n  \t\t}\n  \t};\n\n  \treturn ReferenceExpressionProxy;\n  }(Model));\n\n  function resolve$2 ( fragment, template ) {\n  \tif ( template.r ) {\n  \t\treturn resolveReference( fragment, template.r );\n  \t}\n\n  \telse if ( template.x ) {\n  \t\treturn new ExpressionProxy( fragment, template.x );\n  \t}\n\n  \telse if ( template.rx ) {\n  \t\treturn new ReferenceExpressionProxy( fragment, template.rx );\n  \t}\n  }\n\n  function resolveAliases( section ) {\n  \tif ( section.template.z ) {\n  \t\tsection.aliases = {};\n\n  \t\tvar refs = section.template.z;\n  \t\tfor ( var i = 0; i < refs.length; i++ ) {\n  \t\t\tsection.aliases[ refs[i].n ] = resolve$2( section.parentFragment, refs[i].x );\n  \t\t}\n  \t}\n  }\n\n  var Alias = (function (Item) {\n  \tfunction Alias ( options ) {\n  \t\tItem.call( this, options );\n\n  \t\tthis.fragment = null;\n  \t}\n\n  \tAlias.prototype = Object.create( Item && Item.prototype );\n  \tAlias.prototype.constructor = Alias;\n\n  \tAlias.prototype.bind = function bind () {\n  \t\tresolveAliases( this );\n\n  \t\tthis.fragment = new Fragment({\n  \t\t\towner: this,\n  \t\t\ttemplate: this.template.f\n  \t\t}).bind();\n  \t};\n\n  \tAlias.prototype.detach = function detach () {\n  \t\treturn this.fragment ? this.fragment.detach() : createDocumentFragment();\n  \t};\n\n  \tAlias.prototype.find = function find ( selector ) {\n  \t\tif ( this.fragment ) {\n  \t\t\treturn this.fragment.find( selector );\n  \t\t}\n  \t};\n\n  \tAlias.prototype.findAll = function findAll ( selector, query ) {\n  \t\tif ( this.fragment ) {\n  \t\t\tthis.fragment.findAll( selector, query );\n  \t\t}\n  \t};\n\n  \tAlias.prototype.findComponent = function findComponent ( name ) {\n  \t\tif ( this.fragment ) {\n  \t\t\treturn this.fragment.findComponent( name );\n  \t\t}\n  \t};\n\n  \tAlias.prototype.findAllComponents = function findAllComponents ( name, query ) {\n  \t\tif ( this.fragment ) {\n  \t\t\tthis.fragment.findAllComponents( name, query );\n  \t\t}\n  \t};\n\n  \tAlias.prototype.firstNode = function firstNode ( skipParent ) {\n  \t\treturn this.fragment && this.fragment.firstNode( skipParent );\n  \t};\n\n  \tAlias.prototype.rebinding = function rebinding () {\n  \t\tvar this$1 = this;\n\n  \t\tif ( this.locked ) return;\n  \t\tthis.locked = true;\n  \t\trunloop.scheduleTask( function () {\n  \t\t\tthis$1.locked = false;\n  \t\t\tresolveAliases( this$1 );\n  \t\t});\n  \t};\n\n  \tAlias.prototype.render = function render ( target ) {\n  \t\tthis.rendered = true;\n  \t\tif ( this.fragment ) this.fragment.render( target );\n  \t};\n\n  \tAlias.prototype.toString = function toString ( escape ) {\n  \t\treturn this.fragment ? this.fragment.toString( escape ) : '';\n  \t};\n\n  \tAlias.prototype.unbind = function unbind () {\n  \t\tthis.aliases = {};\n  \t\tif ( this.fragment ) this.fragment.unbind();\n  \t};\n\n  \tAlias.prototype.unrender = function unrender ( shouldDestroy ) {\n  \t\tif ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );\n  \t\tthis.rendered = false;\n  \t};\n\n  \tAlias.prototype.update = function update () {\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n  \t\t\tthis.fragment.update();\n  \t\t}\n  \t};\n\n  \treturn Alias;\n  }(Item));\n\n  function findElement( start, orComponent, name ) {\n  \tif ( orComponent === void 0 ) orComponent = true;\n\n  \twhile ( start && ( start.type !== ELEMENT || ( name && start.name !== name ) ) && ( !orComponent || start.type !== COMPONENT ) ) {\n  \t\t// start is a fragment - look at the owner\n  \t\tif ( start.owner ) start = start.owner;\n  \t\t// start is a component or yielder - look at the container\n  \t\telse if ( start.component ) start = start.containerFragment || start.component.parentFragment;\n  \t\t// start is an item - look at the parent\n  \t\telse if ( start.parent ) start = start.parent;\n  \t\t// start is an item without a parent - look at the parent fragment\n  \t\telse if ( start.parentFragment ) start = start.parentFragment;\n\n  \t\telse start = undefined;\n  \t}\n\n  \treturn start;\n  }\n\n  function camelCase ( hyphenatedStr ) {\n  \treturn hyphenatedStr.replace( /-([a-zA-Z])/g, function ( match, $1 ) {\n  \t\treturn $1.toUpperCase();\n  \t});\n  }\n\n  var space = /\\s+/;\n  var specials$2 = { 'float': 'cssFloat' };\n  var remove = /\\/\\*(?:[\\s\\S]*?)\\*\\//g;\n  var escape = /url\\(\\s*(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\1\\s*\\)|url\\((?:\\\\[\\s\\S]|[^)])*\\)|(['\"])(?:\\\\[\\s\\S]|(?!\\1).)*\\2/gi;\n  var value = /\\0(\\d+)/g;\n\n  function readStyle ( css ) {\n      var values = [];\n\n      if ( typeof css !== 'string' ) return {};\n\n      return css.replace( escape, function ( match ) { return (\"\\u0000\" + (values.push( match ) - 1)); })\n          .replace( remove, '' )\n          .split( ';' )\n          .filter( function ( rule ) { return !!rule.trim(); } )\n          .map( function ( rule ) { return rule.replace( value, function ( match, n ) { return values[ n ]; } ); } )\n          .reduce(function ( rules, rule ) {\n              var i = rule.indexOf(':');\n              var name = camelCase( rule.substr( 0, i ).trim() );\n              rules[ specials$2[ name ] || name ] = rule.substr( i + 1 ).trim();\n              return rules;\n          }, {});\n  }\n\n  function readClass ( str ) {\n    var list = str.split( space );\n\n    // remove any empty entries\n    var i = list.length;\n    while ( i-- ) {\n      if ( !list[i] ) list.splice( i, 1 );\n    }\n\n    return list;\n  }\n\n  var textTypes = [ undefined, 'text', 'search', 'url', 'email', 'hidden', 'password', 'search', 'reset', 'submit' ];\n\n  function getUpdateDelegate ( attribute ) {\n  \tvar element = attribute.element, name = attribute.name;\n\n  \tif ( name === 'id' ) return updateId;\n\n  \tif ( name === 'value' ) {\n  \t\tif ( attribute.interpolator ) attribute.interpolator.bound = true;\n\n  \t\t// special case - selects\n  \t\tif ( element.name === 'select' && name === 'value' ) {\n  \t\t\treturn element.getAttribute( 'multiple' ) ? updateMultipleSelectValue : updateSelectValue;\n  \t\t}\n\n  \t\tif ( element.name === 'textarea' ) return updateStringValue;\n\n  \t\t// special case - contenteditable\n  \t\tif ( element.getAttribute( 'contenteditable' ) != null ) return updateContentEditableValue;\n\n  \t\t// special case - <input>\n  \t\tif ( element.name === 'input' ) {\n  \t\t\tvar type = element.getAttribute( 'type' );\n\n  \t\t\t// type='file' value='{{fileList}}'>\n  \t\t\tif ( type === 'file' ) return noop; // read-only\n\n  \t\t\t// type='radio' name='{{twoway}}'\n  \t\t\tif ( type === 'radio' && element.binding && element.binding.attribute.name === 'name' ) return updateRadioValue;\n\n  \t\t\tif ( ~textTypes.indexOf( type ) ) return updateStringValue;\n  \t\t}\n\n  \t\treturn updateValue;\n  \t}\n\n  \tvar node = element.node;\n\n  \t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n  \tif ( attribute.isTwoway && name === 'name' ) {\n  \t\tif ( node.type === 'radio' ) return updateRadioName;\n  \t\tif ( node.type === 'checkbox' ) return updateCheckboxName;\n  \t}\n\n  \tif ( name === 'style' ) return updateStyleAttribute;\n\n  \tif ( name.indexOf( 'style-' ) === 0 ) return updateInlineStyle;\n\n  \t// special case - class names. IE fucks things up, again\n  \tif ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === html ) ) return updateClassName;\n\n  \tif ( name.indexOf( 'class-' ) === 0 ) return updateInlineClass;\n\n  \tif ( attribute.isBoolean ) {\n  \t\tvar type$1 = element.getAttribute( 'type' );\n  \t\tif ( attribute.interpolator && name === 'checked' && ( type$1 === 'checkbox' || type$1 === 'radio' ) ) attribute.interpolator.bound = true;\n  \t\treturn updateBoolean;\n  \t}\n\n  \tif ( attribute.namespace && attribute.namespace !== attribute.node.namespaceURI ) return updateNamespacedAttribute;\n\n  \treturn updateAttribute;\n  }\n\n  function updateId ( reset ) {\n  \tvar ref = this, node = ref.node;\n  \tvar value = this.getValue();\n\n  \t// remove the mapping to this node if it hasn't already been replaced\n  \tif ( this.ractive.nodes[ node.id ] === node ) delete this.ractive.nodes[ node.id ];\n  \tif ( reset ) return node.removeAttribute( 'id' );\n\n  \tthis.ractive.nodes[ value ] = node;\n\n  \tnode.id = value;\n  }\n\n  function updateMultipleSelectValue ( reset ) {\n  \tvar value = this.getValue();\n\n  \tif ( !isArray( value ) ) value = [ value ];\n\n  \tvar options = this.node.options;\n  \tvar i = options.length;\n\n  \tif ( reset ) {\n  \t\twhile ( i-- ) options[i].selected = false;\n  \t} else {\n  \t\twhile ( i-- ) {\n  \t\t\tvar option = options[i];\n  \t\t\tvar optionValue = option._ractive ?\n  \t\t\t\toption._ractive.value :\n  \t\t\t\toption.value; // options inserted via a triple don't have _ractive\n\n  \t\t\toption.selected = arrayContains( value, optionValue );\n  \t\t}\n  \t}\n  }\n\n  function updateSelectValue ( reset ) {\n  \tvar value = this.getValue();\n\n  \tif ( !this.locked ) { // TODO is locked still a thing?\n  \t\tthis.node._ractive.value = value;\n\n  \t\tvar options = this.node.options;\n  \t\tvar i = options.length;\n  \t\tvar wasSelected = false;\n\n  \t\tif ( reset ) {\n  \t\t\twhile ( i-- ) options[i].selected = false;\n  \t\t} else {\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tvar option = options[i];\n  \t\t\t\tvar optionValue = option._ractive ?\n  \t\t\t\t\toption._ractive.value :\n  \t\t\t\t\toption.value; // options inserted via a triple don't have _ractive\n  \t\t\t\tif ( option.disabled && option.selected ) wasSelected = true;\n\n  \t\t\t\tif ( optionValue == value ) { // double equals as we may be comparing numbers with strings\n  \t\t\t\t\toption.selected = true;\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tif ( !wasSelected ) this.node.selectedIndex = -1;\n  \t}\n  }\n\n\n  function updateContentEditableValue ( reset ) {\n  \tvar value = this.getValue();\n\n  \tif ( !this.locked ) {\n  \t\tif ( reset ) this.node.innerHTML = '';\n  \t\telse this.node.innerHTML = value === undefined ? '' : value;\n  \t}\n  }\n\n  function updateRadioValue ( reset ) {\n  \tvar node = this.node;\n  \tvar wasChecked = node.checked;\n\n  \tvar value = this.getValue();\n\n  \tif ( reset ) return node.checked = false;\n\n  \t//node.value = this.element.getAttribute( 'value' );\n  \tnode.value = this.node._ractive.value = value;\n  \tnode.checked = value === this.element.getAttribute( 'name' );\n\n  \t// This is a special case - if the input was checked, and the value\n  \t// changed so that it's no longer checked, the twoway binding is\n  \t// most likely out of date. To fix it we have to jump through some\n  \t// hoops... this is a little kludgy but it works\n  \tif ( wasChecked && !node.checked && this.element.binding && this.element.binding.rendered ) {\n  \t\tthis.element.binding.group.model.set( this.element.binding.group.getValue() );\n  \t}\n  }\n\n  function updateValue ( reset ) {\n  \tif ( !this.locked ) {\n  \t\tif ( reset ) {\n  \t\t\tthis.node.removeAttribute( 'value' );\n  \t\t\tthis.node.value = this.node._ractive.value = null;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar value = this.getValue();\n\n  \t\tthis.node.value = this.node._ractive.value = value;\n  \t\tthis.node.setAttribute( 'value', value );\n  \t}\n  }\n\n  function updateStringValue ( reset ) {\n  \tif ( !this.locked ) {\n  \t\tif ( reset ) {\n  \t\t\tthis.node._ractive.value = '';\n  \t\t\tthis.node.removeAttribute( 'value' );\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar value = this.getValue();\n\n  \t\tthis.node._ractive.value = value;\n\n  \t\tthis.node.value = safeToStringValue( value );\n  \t\tthis.node.setAttribute( 'value', safeToStringValue( value ) );\n  \t}\n  }\n\n  function updateRadioName ( reset ) {\n  \tif ( reset ) this.node.checked = false;\n  \telse this.node.checked = ( this.getValue() == this.node._ractive.value );\n  }\n\n  function updateCheckboxName ( reset ) {\n  \tvar ref = this, element = ref.element, node = ref.node;\n  \tvar binding = element.binding;\n\n  \tvar value = this.getValue();\n  \tvar valueAttribute = element.getAttribute( 'value' );\n\n  \tif ( reset ) {\n  \t\t// TODO: WAT?\n  \t}\n\n  \tif ( !isArray( value ) ) {\n  \t\tbinding.isChecked = node.checked = ( value == valueAttribute );\n  \t} else {\n  \t\tvar i = value.length;\n  \t\twhile ( i-- ) {\n  \t\t\tif ( valueAttribute == value[i] ) {\n  \t\t\t\tbinding.isChecked = node.checked = true;\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t\tbinding.isChecked = node.checked = false;\n  \t}\n  }\n\n  function updateStyleAttribute ( reset ) {\n  \tvar props = reset ? {} : readStyle( this.getValue() || '' );\n  \tvar style = this.node.style;\n  \tvar keys = Object.keys( props );\n  \tvar prev = this.previous || [];\n\n  \tvar i = 0;\n  \twhile ( i < keys.length ) {\n  \t\tif ( keys[i] in style ) style[ keys[i] ] = props[ keys[i] ];\n  \t\ti++;\n  \t}\n\n  \t// remove now-missing attrs\n  \ti = prev.length;\n  \twhile ( i-- ) {\n  \t\tif ( !~keys.indexOf( prev[i] ) && prev[i] in style ) style[ prev[i] ] = '';\n  \t}\n\n  \tthis.previous = keys;\n  }\n\n  function updateInlineStyle ( reset ) {\n  \tif ( !this.styleName ) {\n  \t\tthis.styleName = camelize( this.name.substr( 6 ) );\n  \t}\n\n  \tthis.node.style[ this.styleName ] = reset ? '' : this.getValue();\n  }\n\n  function updateClassName ( reset ) {\n  \tvar value = reset ? [] : readClass( safeToStringValue( this.getValue() ) );\n  \tvar attr = readClass( this.node.className );\n  \tvar prev = this.previous || attr.slice( 0 );\n\n  \tvar i = 0;\n  \twhile ( i < value.length ) {\n  \t\tif ( !~attr.indexOf( value[i] ) ) attr.push( value[i] );\n  \t\ti++;\n  \t}\n\n  \t// remove now-missing classes\n  \ti = prev.length;\n  \twhile ( i-- ) {\n  \t\tif ( !~value.indexOf( prev[i] ) ) {\n  \t\t\tvar idx = attr.indexOf( prev[i] );\n  \t\t\tif ( ~idx ) attr.splice( idx, 1 );\n  \t\t}\n  \t}\n\n  \tvar className = attr.join( ' ' );\n\n  \tif ( className !== this.node.className ) {\n  \t\tthis.node.className = className;\n  \t}\n\n  \tthis.previous = value;\n  }\n\n  function updateInlineClass ( reset ) {\n  \tvar name = this.name.substr( 6 );\n  \tvar attr = readClass( this.node.className );\n  \tvar value = reset ? false : this.getValue();\n\n  \tif ( !this.inlineClass ) this.inlineClass = name;\n\n  \tif ( value && !~attr.indexOf( name ) ) attr.push( name );\n  \telse if ( !value && ~attr.indexOf( name ) ) attr.splice( attr.indexOf( name ), 1 );\n\n  \tthis.node.className = attr.join( ' ' );\n  }\n\n  function updateBoolean ( reset ) {\n  \t// with two-way binding, only update if the change wasn't initiated by the user\n  \t// otherwise the cursor will often be sent to the wrong place\n  \tif ( !this.locked ) {\n  \t\tif ( reset ) {\n  \t\t\tif ( this.useProperty ) this.node[ this.propertyName ] = false;\n  \t\t\tthis.node.removeAttribute( this.propertyName );\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif ( this.useProperty ) {\n  \t\t\tthis.node[ this.propertyName ] = this.getValue();\n  \t\t} else {\n  \t\t\tif ( this.getValue() ) {\n  \t\t\t\tthis.node.setAttribute( this.propertyName, '' );\n  \t\t\t} else {\n  \t\t\t\tthis.node.removeAttribute( this.propertyName );\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  function updateAttribute ( reset ) {\n  \tif ( reset ) this.node.removeAttribute( this.name );\n  \telse this.node.setAttribute( this.name, safeToStringValue( this.getString() ) );\n  }\n\n  function updateNamespacedAttribute ( reset ) {\n  \tif ( reset ) this.node.removeAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ) );\n  \telse this.node.setAttributeNS( this.namespace, this.name.slice( this.name.indexOf( ':' ) + 1 ), safeToStringValue( this.getString() ) );\n  }\n\n  var propertyNames = {\n  \t'accept-charset': 'acceptCharset',\n  \taccesskey: 'accessKey',\n  \tbgcolor: 'bgColor',\n  \t'class': 'className',\n  \tcodebase: 'codeBase',\n  \tcolspan: 'colSpan',\n  \tcontenteditable: 'contentEditable',\n  \tdatetime: 'dateTime',\n  \tdirname: 'dirName',\n  \t'for': 'htmlFor',\n  \t'http-equiv': 'httpEquiv',\n  \tismap: 'isMap',\n  \tmaxlength: 'maxLength',\n  \tnovalidate: 'noValidate',\n  \tpubdate: 'pubDate',\n  \treadonly: 'readOnly',\n  \trowspan: 'rowSpan',\n  \ttabindex: 'tabIndex',\n  \tusemap: 'useMap'\n  };\n\n  function lookupNamespace ( node, prefix ) {\n  \tvar qualified = \"xmlns:\" + prefix;\n\n  \twhile ( node ) {\n  \t\tif ( node.hasAttribute && node.hasAttribute( qualified ) ) return node.getAttribute( qualified );\n  \t\tnode = node.parentNode;\n  \t}\n\n  \treturn namespaces[ prefix ];\n  }\n\n  var Attribute = (function (Item) {\n  \tfunction Attribute ( options ) {\n  \t\tItem.call( this, options );\n\n  \t\tthis.name = options.template.n;\n  \t\tthis.namespace = null;\n\n  \t\tthis.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );\n  \t\tthis.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );\n  \t\tthis.parentFragment = options.parentFragment; // shared\n  \t\tthis.ractive = this.parentFragment.ractive;\n\n  \t\tthis.rendered = false;\n  \t\tthis.updateDelegate = null;\n  \t\tthis.fragment = null;\n\n  \t\tthis.element.attributeByName[ this.name ] = this;\n\n  \t\tif ( !isArray( options.template.f ) ) {\n  \t\t\tthis.value = options.template.f;\n  \t\t\tif ( this.value === 0 ) {\n  \t\t\t\tthis.value = '';\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis.fragment = new Fragment({\n  \t\t\t\towner: this,\n  \t\t\t\ttemplate: options.template.f\n  \t\t\t});\n  \t\t}\n\n  \t\tthis.interpolator = this.fragment &&\n  \t\t\tthis.fragment.items.length === 1 &&\n  \t\t\tthis.fragment.items[0].type === INTERPOLATOR &&\n  \t\t\tthis.fragment.items[0];\n\n  \t\tif ( this.interpolator ) this.interpolator.owner = this;\n  \t}\n\n  \tAttribute.prototype = Object.create( Item && Item.prototype );\n  \tAttribute.prototype.constructor = Attribute;\n\n  \tAttribute.prototype.bind = function bind () {\n  \t\tif ( this.fragment ) {\n  \t\t\tthis.fragment.bind();\n  \t\t}\n  \t};\n\n  \tAttribute.prototype.bubble = function bubble () {\n  \t\tif ( !this.dirty ) {\n  \t\t\tthis.parentFragment.bubble();\n  \t\t\tthis.element.bubble();\n  \t\t\tthis.dirty = true;\n  \t\t}\n  \t};\n\n  \tAttribute.prototype.destroyed = function destroyed () {\n  \t\tthis.updateDelegate( true );\n  \t};\n\n  \tAttribute.prototype.getString = function getString () {\n  \t\treturn this.fragment ?\n  \t\t\tthis.fragment.toString() :\n  \t\t\tthis.value != null ? '' + this.value : '';\n  \t};\n\n  \t// TODO could getValue ever be called for a static attribute,\n  \t// or can we assume that this.fragment exists?\n  \tAttribute.prototype.getValue = function getValue () {\n  \t\treturn this.fragment ? this.fragment.valueOf() : booleanAttributes.test( this.name ) ? true : this.value;\n  \t};\n\n  \tAttribute.prototype.render = function render () {\n  \t\tvar node = this.element.node;\n  \t\tthis.node = node;\n\n  \t\t// should we use direct property access, or setAttribute?\n  \t\tif ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {\n  \t\t\tthis.propertyName = propertyNames[ this.name ] || this.name;\n\n  \t\t\tif ( node[ this.propertyName ] !== undefined ) {\n  \t\t\t\tthis.useProperty = true;\n  \t\t\t}\n\n  \t\t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n  \t\t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n  \t\t\tif ( booleanAttributes.test( this.name ) || this.isTwoway ) {\n  \t\t\t\tthis.isBoolean = true;\n  \t\t\t}\n\n  \t\t\tif ( this.propertyName === 'value' ) {\n  \t\t\t\tnode._ractive.value = this.value;\n  \t\t\t}\n  \t\t}\n\n  \t\tif ( node.namespaceURI ) {\n  \t\t\tvar index = this.name.indexOf( ':' );\n  \t\t\tif ( index !== -1 ) {\n  \t\t\t\tthis.namespace = lookupNamespace( node, this.name.slice( 0, index ) );\n  \t\t\t} else {\n  \t\t\t\tthis.namespace = node.namespaceURI;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.rendered = true;\n  \t\tthis.updateDelegate = getUpdateDelegate( this );\n  \t\tthis.updateDelegate();\n  \t};\n\n  \tAttribute.prototype.toString = function toString () {\n  \t\tvar value = this.getValue();\n\n  \t\t// Special case - select and textarea values (should not be stringified)\n  \t\tif ( this.name === 'value' && ( this.element.getAttribute( 'contenteditable' ) !== undefined || ( this.element.name === 'select' || this.element.name === 'textarea' ) ) ) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// Special case – bound radio `name` attributes\n  \t\tif ( this.name === 'name' && this.element.name === 'input' && this.interpolator && this.element.getAttribute( 'type' ) === 'radio' ) {\n  \t\t\treturn (\"name=\\\"{{\" + (this.interpolator.model.getKeypath()) + \"}}\\\"\");\n  \t\t}\n\n  \t\t// Special case - style and class attributes and directives\n  \t\tif ( this.owner === this.element && ( this.name === 'style' || this.name === 'class' || this.styleName || this.inlineClass ) ) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif ( !this.rendered && this.owner === this.element && ( !this.name.indexOf( 'style-' ) || !this.name.indexOf( 'class-' ) ) ) {\n  \t\t\tif ( !this.name.indexOf( 'style-' ) ) {\n  \t\t\t\tthis.styleName = camelize( this.name.substr( 6 ) );\n  \t\t\t} else {\n  \t\t\t\tthis.inlineClass = this.name.substr( 6 );\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif ( booleanAttributes.test( this.name ) ) return value ? this.name : '';\n  \t\tif ( value == null ) return '';\n\n  \t\tvar str = safeAttributeString( this.getString() );\n  \t\treturn str ?\n  \t\t\t(\"\" + (this.name) + \"=\\\"\" + str + \"\\\"\") :\n  \t\t\tthis.name;\n  \t};\n\n  \tAttribute.prototype.unbind = function unbind () {\n  \t\tif ( this.fragment ) this.fragment.unbind();\n  \t};\n\n  \tAttribute.prototype.unrender = function unrender () {\n  \t\tthis.updateDelegate( true );\n\n  \t\tthis.rendered = false;\n  \t};\n\n  \tAttribute.prototype.update = function update () {\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n  \t\t\tif ( this.fragment ) this.fragment.update();\n  \t\t\tif ( this.rendered ) this.updateDelegate();\n  \t\t\tif ( this.isTwoway && !this.locked ) {\n  \t\t\t\tthis.interpolator.twowayBinding.lastVal( true, this.interpolator.model.get() );\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \treturn Attribute;\n  }(Item));\n\n  var BindingFlag = (function (Item) {\n  \tfunction BindingFlag ( options ) {\n  \t\tItem.call( this, options );\n\n  \t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n  \t\tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n  \t\tthis.flag = options.template.v === 'l' ? 'lazy' : 'twoway';\n\n  \t\tif ( this.element.type === ELEMENT ) {\n  \t\t\tif ( isArray( options.template.f ) ) {\n  \t\t\t\tthis.fragment = new Fragment({\n  \t\t\t\t\towner: this,\n  \t\t\t\t\ttemplate: options.template.f\n  \t\t\t\t});\n  \t\t\t}\n\n  \t\t\tthis.interpolator = this.fragment &&\n  \t\t\t\t\t\t\t\tthis.fragment.items.length === 1 &&\n  \t\t\t\t\t\t\t\tthis.fragment.items[0].type === INTERPOLATOR &&\n  \t\t\t\t\t\t\t\tthis.fragment.items[0];\n  \t\t}\n  \t}\n\n  \tBindingFlag.prototype = Object.create( Item && Item.prototype );\n  \tBindingFlag.prototype.constructor = BindingFlag;\n\n  \tBindingFlag.prototype.bind = function bind () {\n  \t\tif ( this.fragment ) this.fragment.bind();\n  \t\tset$2( this, this.getValue(), true );\n  \t};\n\n  \tBindingFlag.prototype.bubble = function bubble () {\n  \t\tif ( !this.dirty ) {\n  \t\t\tthis.element.bubble();\n  \t\t\tthis.dirty = true;\n  \t\t}\n  \t};\n\n  \tBindingFlag.prototype.getValue = function getValue () {\n  \t\tif ( this.fragment ) return this.fragment.valueOf();\n  \t\telse if ( 'value' in this ) return this.value;\n  \t\telse if ( 'f' in this.template ) return this.template.f;\n  \t\telse return true;\n  \t};\n\n  \tBindingFlag.prototype.render = function render () {\n  \t\tset$2( this, this.getValue(), true );\n  \t};\n\n  \tBindingFlag.prototype.toString = function toString () { return ''; };\n\n  \tBindingFlag.prototype.unbind = function unbind () {\n  \t\tif ( this.fragment ) this.fragment.unbind();\n\n  \t\tdelete this.element[ this.flag ];\n  \t};\n\n  \tBindingFlag.prototype.unrender = function unrender () {\n  \t\tif ( this.element.rendered ) this.element.recreateTwowayBinding();\n  \t};\n\n  \tBindingFlag.prototype.update = function update () {\n  \t\tif ( this.dirty ) {\n  \t\t\tif ( this.fragment ) this.fragment.update();\n  \t\t\tset$2( this, this.getValue(), true );\n  \t\t}\n  \t};\n\n  \treturn BindingFlag;\n  }(Item));\n\n  function set$2 ( flag, value, update ) {\n  \tif ( value === 0 ) {\n  \t\tflag.value = true;\n  \t} else if ( value === 'true' ) {\n  \t\tflag.value = true;\n  \t} else if ( value === 'false' || value === '0' ) {\n  \t\tflag.value = false;\n  \t} else {\n  \t\tflag.value = value;\n  \t}\n\n  \tvar current = flag.element[ flag.flag ];\n  \tflag.element[ flag.flag ] = flag.value;\n  \tif ( update && !flag.element.attributes.binding && current !== flag.value ) {\n  \t\tflag.element.recreateTwowayBinding();\n  \t}\n\n  \treturn flag.value;\n  }\n\n  var div$1 = doc ? createElement( 'div' ) : null;\n\n  var attributes = false;\n  function inAttributes() { return attributes; }\n  function doInAttributes( fn ) {\n  \tattributes = true;\n  \tfn();\n  \tattributes = false;\n  }\n\n  var ConditionalAttribute = (function (Item) {\n  \tfunction ConditionalAttribute ( options ) {\n  \t\tItem.call( this, options );\n\n  \t\tthis.attributes = [];\n\n  \t\tthis.owner = options.owner;\n\n  \t\tthis.fragment = new Fragment({\n  \t\t\tractive: this.ractive,\n  \t\t\towner: this,\n  \t\t\ttemplate: this.template\n  \t\t});\n  \t\t// this fragment can't participate in node-y things\n  \t\tthis.fragment.findNextNode = noop;\n\n  \t\tthis.dirty = false;\n  \t}\n\n  \tConditionalAttribute.prototype = Object.create( Item && Item.prototype );\n  \tConditionalAttribute.prototype.constructor = ConditionalAttribute;\n\n  \tConditionalAttribute.prototype.bind = function bind () {\n  \t\tthis.fragment.bind();\n  \t};\n\n  \tConditionalAttribute.prototype.bubble = function bubble () {\n  \t\tif ( !this.dirty ) {\n  \t\t\tthis.dirty = true;\n  \t\t\tthis.owner.bubble();\n  \t\t}\n  \t};\n\n  \tConditionalAttribute.prototype.render = function render () {\n  \t\tthis.node = this.owner.node;\n  \t\tif ( this.node ) {\n  \t\t\tthis.isSvg = this.node.namespaceURI === svg$1;\n  \t\t}\n\n  \t\tattributes = true;\n  \t\tif ( !this.rendered ) this.fragment.render();\n  \t\tattributes = false;\n\n  \t\tthis.rendered = true;\n  \t\tthis.dirty = true; // TODO this seems hacky, but necessary for tests to pass in browser AND node.js\n  \t\tthis.update();\n  \t};\n\n  \tConditionalAttribute.prototype.toString = function toString () {\n  \t\treturn this.fragment.toString();\n  \t};\n\n  \tConditionalAttribute.prototype.unbind = function unbind () {\n  \t\tthis.fragment.unbind();\n  \t};\n\n  \tConditionalAttribute.prototype.unrender = function unrender () {\n  \t\tthis.rendered = false;\n  \t\tthis.fragment.unrender();\n  \t};\n\n  \tConditionalAttribute.prototype.update = function update () {\n  \t\tvar this$1 = this;\n\n  \t\tvar str;\n  \t\tvar attrs;\n\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n\n  \t\t\tattributes = true;\n  \t\t\tthis.fragment.update();\n  \t\t\tattributes = false;\n\n  \t\t\tif ( this.rendered && this.node ) {\n  \t\t\t\tstr = this.fragment.toString();\n  \t\t\t\tattrs = parseAttributes( str, this.isSvg );\n\n  \t\t\t\t// any attributes that previously existed but no longer do\n  \t\t\t\t// must be removed\n  \t\t\t\tthis.attributes.filter( function ( a ) { return notIn( attrs, a ); } ).forEach( function ( a ) {\n  \t\t\t\t\tthis$1.node.removeAttribute( a.name );\n  \t\t\t\t});\n\n  \t\t\t\tattrs.forEach( function ( a ) {\n  \t\t\t\t\tthis$1.node.setAttribute( a.name, a.value );\n  \t\t\t\t});\n\n  \t\t\t\tthis.attributes = attrs;\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \treturn ConditionalAttribute;\n  }(Item));\n\n  function parseAttributes ( str, isSvg ) {\n  \tvar tagName = isSvg ? 'svg' : 'div';\n  \treturn str\n  \t\t? (div$1.innerHTML = \"<\" + tagName + \" \" + str + \"></\" + tagName + \">\") &&\n  \t\t\ttoArray(div$1.childNodes[0].attributes)\n  \t\t: [];\n  }\n\n  function notIn ( haystack, needle ) {\n  \tvar i = haystack.length;\n\n  \twhile ( i-- ) {\n  \t\tif ( haystack[i].name === needle.name ) {\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \treturn true;\n  }\n\n  function processWrapper ( wrapper, array, methodName, newIndices ) {\n  \tvar __model = wrapper.__model;\n\n  \tif ( newIndices ) {\n  \t\t__model.shuffle( newIndices );\n  \t} else {\n  \t\t// If this is a sort or reverse, we just do root.set()...\n  \t\t// TODO use merge logic?\n  \t\t//root.viewmodel.mark( keypath );\n  \t}\n  }\n\n  var mutatorMethods = [ 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift' ];\n  var patchedArrayProto = [];\n\n  mutatorMethods.forEach( function ( methodName ) {\n  \tvar method = function () {\n  \t\tvar this$1 = this;\n  \t\tvar args = [], len = arguments.length;\n  \t\twhile ( len-- ) args[ len ] = arguments[ len ];\n\n  \t\tvar newIndices = getNewIndices( this.length, methodName, args );\n\n  \t\t// lock any magic array wrappers, so that things don't get fudged\n  \t\tthis._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = true; } );\n\n  \t\t// apply the underlying method\n  \t\tvar result = Array.prototype[ methodName ].apply( this, arguments );\n\n  \t\t// trigger changes\n  \t\trunloop.start();\n\n  \t\tthis._ractive.setting = true;\n  \t\tvar i = this._ractive.wrappers.length;\n  \t\twhile ( i-- ) {\n  \t\t\tprocessWrapper( this$1._ractive.wrappers[i], this$1, methodName, newIndices );\n  \t\t}\n\n  \t\trunloop.end();\n\n  \t\tthis._ractive.setting = false;\n\n  \t\t// unlock the magic arrays... magic... bah\n  \t\tthis._ractive.wrappers.forEach( function ( r ) { if ( r.magic ) r.magic.locked = false; } );\n\n  \t\treturn result;\n  \t};\n\n  \tdefineProperty( patchedArrayProto, methodName, {\n  \t\tvalue: method,\n  \t\tconfigurable: true\n  \t});\n  });\n\n  var patchArrayMethods;\n  var unpatchArrayMethods;\n\n  // can we use prototype chain injection?\n  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n  if ( ({}).__proto__ ) {\n  \t// yes, we can\n  \tpatchArrayMethods = function ( array ) { return array.__proto__ = patchedArrayProto; };\n  \tunpatchArrayMethods = function ( array ) { return array.__proto__ = Array.prototype; };\n  }\n\n  else {\n  \t// no, we can't\n  \tpatchArrayMethods = function ( array ) {\n  \t\tvar i = mutatorMethods.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar methodName = mutatorMethods[i];\n  \t\t\tdefineProperty( array, methodName, {\n  \t\t\t\tvalue: patchedArrayProto[ methodName ],\n  \t\t\t\tconfigurable: true\n  \t\t\t});\n  \t\t}\n  \t};\n\n  \tunpatchArrayMethods = function ( array ) {\n  \t\tvar i = mutatorMethods.length;\n  \t\twhile ( i-- ) {\n  \t\t\tdelete array[ mutatorMethods[i] ];\n  \t\t}\n  \t};\n  }\n\n  patchArrayMethods.unpatch = unpatchArrayMethods; // TODO export separately?\n  var patch = patchArrayMethods;\n\n  var errorMessage$1 = 'Something went wrong in a rather interesting way';\n\n  var arrayAdaptor = {\n  \tfilter: function ( object ) {\n  \t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n  \t\t// or the array didn't trigger the get() itself\n  \t\treturn isArray( object ) && ( !object._ractive || !object._ractive.setting );\n  \t},\n  \twrap: function ( ractive, array, keypath ) {\n  \t\treturn new ArrayWrapper( ractive, array, keypath );\n  \t}\n  };\n\n  var ArrayWrapper = function ArrayWrapper ( ractive, array ) {\n  \tthis.root = ractive;\n  \tthis.value = array;\n  \tthis.__model = null; // filled in later\n\n  \t// if this array hasn't already been ractified, ractify it\n  \tif ( !array._ractive ) {\n  \t\t// define a non-enumerable _ractive property to store the wrappers\n  \t\tdefineProperty( array, '_ractive', {\n  \t\t\tvalue: {\n  \t\t\t\twrappers: [],\n  \t\t\t\tinstances: [],\n  \t\t\t\tsetting: false\n  \t\t\t},\n  \t\t\tconfigurable: true\n  \t\t});\n\n  \t\tpatch( array );\n  \t}\n\n  \t// store the ractive instance, so we can handle transitions later\n  \tif ( !array._ractive.instances[ ractive._guid ] ) {\n  \t\tarray._ractive.instances[ ractive._guid ] = 0;\n  \t\tarray._ractive.instances.push( ractive );\n  \t}\n\n  \tarray._ractive.instances[ ractive._guid ] += 1;\n  \tarray._ractive.wrappers.push( this );\n  };\n\n  ArrayWrapper.prototype.get = function get () {\n  \treturn this.value;\n  };\n\n  ArrayWrapper.prototype.reset = function reset ( value ) {\n  \treturn this.value === value;\n  };\n\n  ArrayWrapper.prototype.teardown = function teardown () {\n  \tvar array, storage, wrappers, instances, index;\n\n  \tarray = this.value;\n  \tstorage = array._ractive;\n  \twrappers = storage.wrappers;\n  \tinstances = storage.instances;\n\n  \t// if teardown() was invoked because we're clearing the cache as a result of\n  \t// a change that the array itself triggered, we can save ourselves the teardown\n  \t// and immediate setup\n  \tif ( storage.setting ) {\n  \t\treturn false; // so that we don't remove it from cached wrappers\n  \t}\n\n  \tindex = wrappers.indexOf( this );\n  \tif ( index === -1 ) {\n  \t\tthrow new Error( errorMessage$1 );\n  \t}\n\n  \twrappers.splice( index, 1 );\n\n  \t// if nothing else depends on this array, we can revert it to its\n  \t// natural state\n  \tif ( !wrappers.length ) {\n  \t\tdelete array._ractive;\n  \t\tpatch.unpatch( this.value );\n  \t}\n\n  \telse {\n  \t\t// remove ractive instance if possible\n  \t\tinstances[ this.root._guid ] -= 1;\n  \t\tif ( !instances[ this.root._guid ] ) {\n  \t\t\tindex = instances.indexOf( this.root );\n\n  \t\t\tif ( index === -1 ) {\n  \t\t\t\tthrow new Error( errorMessage$1 );\n  \t\t\t}\n\n  \t\t\tinstances.splice( index, 1 );\n  \t\t}\n  \t}\n  };\n\n  var magicAdaptor;\n\n  try {\n  \tObject.defineProperty({}, 'test', { get: function() {}, set: function() {} });\n\n  \tmagicAdaptor = {\n  \t\tfilter: function ( value ) {\n  \t\t\treturn value && typeof value === 'object';\n  \t\t},\n  \t\twrap: function ( ractive, value, keypath ) {\n  \t\t\treturn new MagicWrapper( ractive, value, keypath );\n  \t\t}\n  \t};\n  } catch ( err ) {\n  \tmagicAdaptor = false;\n  }\n\n  var magicAdaptor$1 = magicAdaptor;\n\n  function createOrWrapDescriptor ( originalDescriptor, ractive, keypath, wrapper ) {\n  \tif ( originalDescriptor.set && originalDescriptor.set.__magic ) {\n  \t\toriginalDescriptor.set.__magic.dependants.push({ ractive: ractive, keypath: keypath });\n  \t\treturn originalDescriptor;\n  \t}\n\n  \tvar setting;\n\n  \tvar dependants = [{ ractive: ractive, keypath: keypath }];\n\n  \tvar descriptor = {\n  \t\tget: function () {\n  \t\t\treturn 'value' in originalDescriptor ? originalDescriptor.value : originalDescriptor.get.call( this );\n  \t\t},\n  \t\tset: function (value) {\n  \t\t\tif ( setting ) return;\n\n  \t\t\tif ( 'value' in originalDescriptor ) {\n  \t\t\t\toriginalDescriptor.value = value;\n  \t\t\t} else {\n  \t\t\t\toriginalDescriptor.set.call( this, value );\n  \t\t\t}\n\n  \t\t\tif ( wrapper.locked ) return;\n  \t\t\tsetting = true;\n  \t\t\tdependants.forEach( function (ref) {\n  \t\t\t\tvar ractive = ref.ractive;\n  \t\t\t\tvar keypath = ref.keypath;\n\n  \t\t\t\tractive.set( keypath, value );\n  \t\t\t});\n  \t\t\tsetting = false;\n  \t\t},\n  \t\tenumerable: true\n  \t};\n\n  \tdescriptor.set.__magic = { dependants: dependants, originalDescriptor: originalDescriptor };\n\n  \treturn descriptor;\n  }\n\n  function revert ( descriptor, ractive, keypath ) {\n  \tif ( !descriptor.set || !descriptor.set.__magic ) return true;\n\n  \tvar dependants = descriptor.set.__magic;\n  \tvar i = dependants.length;\n  \twhile ( i-- ) {\n  \t\tvar dependant = dependants[i];\n  \t\tif ( dependant.ractive === ractive && dependant.keypath === keypath ) {\n  \t\t\tdependants.splice( i, 1 );\n  \t\t\treturn false;\n  \t\t}\n  \t}\n  }\n\n  var MagicWrapper = function MagicWrapper ( ractive, value, keypath ) {\n  \tvar this$1 = this;\n\n  \t\tthis.ractive = ractive;\n  \tthis.value = value;\n  \tthis.keypath = keypath;\n\n  \tthis.originalDescriptors = {};\n\n  \t// wrap all properties with getters\n  \tObject.keys( value ).forEach( function ( key ) {\n  \t\tvar originalDescriptor = Object.getOwnPropertyDescriptor( this$1.value, key );\n  \t\tthis$1.originalDescriptors[ key ] = originalDescriptor;\n\n  \t\tvar childKeypath = keypath ? (\"\" + keypath + \".\" + (escapeKey( key ))) : escapeKey( key );\n\n  \t\tvar descriptor = createOrWrapDescriptor( originalDescriptor, ractive, childKeypath, this$1 );\n\n\n\n  \t\tObject.defineProperty( this$1.value, key, descriptor );\n  \t});\n  };\n\n  MagicWrapper.prototype.get = function get () {\n  \treturn this.value;\n  };\n\n  MagicWrapper.prototype.reset = function reset ( value ) {\n  \treturn this.value === value;\n  };\n\n  MagicWrapper.prototype.set = function set ( key, value ) {\n  \tthis.value[ key ] = value;\n  };\n\n  MagicWrapper.prototype.teardown = function teardown () {\n  \tvar this$1 = this;\n\n  \t\tObject.keys( this.value ).forEach( function ( key ) {\n  \t\tvar descriptor = Object.getOwnPropertyDescriptor( this$1.value, key );\n  \t\tif ( !descriptor.set || !descriptor.set.__magic ) return;\n\n  \t\trevert( descriptor );\n\n  \t\tif ( descriptor.set.__magic.dependants.length === 1 ) {\n  \t\t\tObject.defineProperty( this$1.value, key, descriptor.set.__magic.originalDescriptor );\n  \t\t}\n  \t});\n  };\n\n  var MagicArrayWrapper = function MagicArrayWrapper ( ractive, array, keypath ) {\n  \tthis.value = array;\n\n  \tthis.magic = true;\n\n  \tthis.magicWrapper = magicAdaptor$1.wrap( ractive, array, keypath );\n  \tthis.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );\n  \tthis.arrayWrapper.magic = this.magicWrapper;\n\n  \t// ugh, this really is a terrible hack\n  \tObject.defineProperty( this, '__model', {\n  \t\tget: function () {\n  \t\t\treturn this.arrayWrapper.__model;\n  \t\t},\n  \t\tset: function ( model ) {\n  \t\t\tthis.arrayWrapper.__model = model;\n  \t\t}\n  \t});\n  };\n\n  MagicArrayWrapper.prototype.get = function get () {\n  \treturn this.value;\n  };\n\n  MagicArrayWrapper.prototype.teardown = function teardown () {\n  \tthis.arrayWrapper.teardown();\n  \tthis.magicWrapper.teardown();\n  };\n\n  MagicArrayWrapper.prototype.reset = function reset ( value ) {\n  \treturn this.arrayWrapper.reset( value ) && this.magicWrapper.reset( value );\n  };\n\n  var magicArrayAdaptor = {\n  \tfilter: function ( object, keypath, ractive ) {\n  \t\treturn magicAdaptor$1.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );\n  \t},\n\n  \twrap: function ( ractive, array, keypath ) {\n  \t\treturn new MagicArrayWrapper( ractive, array, keypath );\n  \t}\n  };\n\n  // TODO this is probably a bit anal, maybe we should leave it out\n  function prettify ( fnBody ) {\n  \tvar lines = fnBody\n  \t\t.replace( /^\\t+/gm, function ( tabs ) { return tabs.split( '\\t' ).join( '  ' ); } )\n  \t\t.split( '\\n' );\n\n  \tvar minIndent = lines.length < 2 ? 0 :\n  \t\tlines.slice( 1 ).reduce( function ( prev, line ) {\n  \t\t\treturn Math.min( prev, /^\\s*/.exec( line )[0].length );\n  \t\t}, Infinity );\n\n  \treturn lines.map( function ( line, i ) {\n  \t\treturn '    ' + ( i ? line.substring( minIndent ) : line );\n  \t}).join( '\\n' );\n  }\n\n  // Ditto. This function truncates the stack to only include app code\n  function truncateStack ( stack ) {\n  \tif ( !stack ) return '';\n\n  \tvar lines = stack.split( '\\n' );\n  \tvar name = Computation.name + '.getValue';\n\n  \tvar truncated = [];\n\n  \tvar len = lines.length;\n  \tfor ( var i = 1; i < len; i += 1 ) {\n  \t\tvar line = lines[i];\n\n  \t\tif ( ~line.indexOf( name ) ) {\n  \t\t\treturn truncated.join( '\\n' );\n  \t\t} else {\n  \t\t\ttruncated.push( line );\n  \t\t}\n  \t}\n  }\n\n  var Computation = (function (Model) {\n  \tfunction Computation ( viewmodel, signature, key ) {\n  \t\tModel.call( this, null, null );\n\n  \t\tthis.root = this.parent = viewmodel;\n  \t\tthis.signature = signature;\n\n  \t\tthis.key = key; // not actually used, but helps with debugging\n  \t\tthis.isExpression = key && key[0] === '@';\n\n  \t\tthis.isReadonly = !this.signature.setter;\n\n  \t\tthis.context = viewmodel.computationContext;\n\n  \t\tthis.dependencies = [];\n\n  \t\tthis.children = [];\n  \t\tthis.childByKey = {};\n\n  \t\tthis.deps = [];\n\n  \t\tthis.dirty = true;\n\n  \t\t// TODO: is there a less hackish way to do this?\n  \t\tthis.shuffle = undefined;\n  \t}\n\n  \tComputation.prototype = Object.create( Model && Model.prototype );\n  \tComputation.prototype.constructor = Computation;\n\n  \tComputation.prototype.get = function get ( shouldCapture ) {\n  \t\tif ( shouldCapture ) capture( this );\n\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n  \t\t\tthis.value = this.getValue();\n  \t\t\tif ( this.wrapper ) this.newWrapperValue = this.value;\n  \t\t\tthis.adapt();\n  \t\t}\n\n  \t\t// if capturing, this value needs to be unwrapped because it's for external use\n  \t\treturn shouldCapture && this.wrapper ? this.wrapperValue : this.value;\n  \t};\n\n  \tComputation.prototype.getValue = function getValue () {\n  \t\tstartCapturing();\n  \t\tvar result;\n\n  \t\ttry {\n  \t\t\tresult = this.signature.getter.call( this.context );\n  \t\t} catch ( err ) {\n  \t\t\twarnIfDebug( (\"Failed to compute \" + (this.getKeypath()) + \": \" + (err.message || err)) );\n\n  \t\t\t// TODO this is all well and good in Chrome, but...\n  \t\t\t// ...also, should encapsulate this stuff better, and only\n  \t\t\t// show it if Ractive.DEBUG\n  \t\t\tif ( hasConsole ) {\n  \t\t\t\tif ( console.groupCollapsed ) console.groupCollapsed( '%cshow details', 'color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;' );\n  \t\t\t\tvar functionBody = prettify( this.signature.getterString );\n  \t\t\t\tvar stack = this.signature.getterUseStack ? '\\n\\n' + truncateStack( err.stack ) : '';\n  \t\t\t\tconsole.error( (\"\" + (err.name) + \": \" + (err.message) + \"\\n\\n\" + functionBody + \"\" + stack) );\n  \t\t\t\tif ( console.groupCollapsed ) console.groupEnd();\n  \t\t\t}\n  \t\t}\n\n  \t\tvar dependencies = stopCapturing();\n  \t\tthis.setDependencies( dependencies );\n\n  \t\t// if not the first computation and the value is not the same,\n  \t\t// register the change for change events\n  \t\tif ( 'value' in this && result !== this.value ) {\n  \t\t\tthis.registerChange( this.getKeypath(), result );\n  \t\t}\n\n  \t\treturn result;\n  \t};\n\n  \tComputation.prototype.handleChange = function handleChange$1 () {\n  \t\tthis.dirty = true;\n\n  \t\tthis.links.forEach( marked );\n  \t\tthis.deps.forEach( handleChange );\n  \t\tthis.children.forEach( handleChange );\n  \t\tthis.clearUnresolveds(); // TODO same question as on Model - necessary for primitives?\n  \t};\n\n  \tComputation.prototype.joinKey = function joinKey ( key ) {\n  \t\tif ( key === undefined || key === '' ) return this;\n\n  \t\tif ( !this.childByKey.hasOwnProperty( key ) ) {\n  \t\t\tvar child = new ComputationChild( this, key );\n  \t\t\tthis.children.push( child );\n  \t\t\tthis.childByKey[ key ] = child;\n  \t\t}\n\n  \t\treturn this.childByKey[ key ];\n  \t};\n\n  \tComputation.prototype.mark = function mark () {\n  \t\tthis.handleChange();\n  \t};\n\n  \tComputation.prototype.rebinding = function rebinding ( next, previous ) {\n  \t\t// computations will grab all of their deps again automagically\n  \t\tif ( next !== previous ) this.handleChange();\n  \t};\n\n  \tComputation.prototype.set = function set ( value ) {\n  \t\tif ( !this.signature.setter ) {\n  \t\t\tthrow new Error( (\"Cannot set read-only computed value '\" + (this.key) + \"'\") );\n  \t\t}\n\n  \t\tthis.signature.setter( value );\n  \t\tthis.mark();\n  \t};\n\n  \tComputation.prototype.setDependencies = function setDependencies ( dependencies ) {\n  \t\t// unregister any soft dependencies we no longer have\n  \t\tvar this$1 = this;\n\n  \t\tvar i = this.dependencies.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar model = this$1.dependencies[i];\n  \t\t\tif ( !~dependencies.indexOf( model ) ) model.unregister( this$1 );\n  \t\t}\n\n  \t\t// and add any new ones\n  \t\ti = dependencies.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar model$1 = dependencies[i];\n  \t\t\tif ( !~this$1.dependencies.indexOf( model$1 ) ) model$1.register( this$1 );\n  \t\t}\n\n  \t\tthis.dependencies = dependencies;\n  \t};\n\n  \tComputation.prototype.teardown = function teardown () {\n  \t\tvar this$1 = this;\n\n  \t\tvar i = this.dependencies.length;\n  \t\twhile ( i-- ) {\n  \t\t\tif ( this$1.dependencies[i] ) this$1.dependencies[i].unregister( this$1 );\n  \t\t}\n  \t\tif ( this.root.computations[this.key] === this ) delete this.root.computations[this.key];\n  \t\tModel.prototype.teardown.call(this);\n  \t};\n\n  \tComputation.prototype.unregister = function unregister ( dependent ) {\n  \t\tModel.prototype.unregister.call( this, dependent );\n  \t\t// tear down expressions with no deps, because they will be replaced when needed\n  \t\tif ( this.isExpression && this.deps.length === 0 ) this.teardown();\n  \t};\n\n  \treturn Computation;\n  }(Model));\n\n  var RactiveModel = (function (Model) {\n  \tfunction RactiveModel ( ractive ) {\n  \t\tModel.call( this, null, '' );\n  \t\tthis.value = ractive;\n  \t\tthis.isRoot = true;\n  \t\tthis.root = this;\n  \t\tthis.adaptors = [];\n  \t\tthis.ractive = ractive;\n  \t\tthis.changes = {};\n  \t}\n\n  \tRactiveModel.prototype = Object.create( Model && Model.prototype );\n  \tRactiveModel.prototype.constructor = RactiveModel;\n\n  \tRactiveModel.prototype.getKeypath = function getKeypath() {\n  \t\treturn '@this';\n  \t};\n\n  \treturn RactiveModel;\n  }(Model));\n\n  var hasProp$1 = Object.prototype.hasOwnProperty;\n\n  var RootModel = (function (Model) {\n  \tfunction RootModel ( options ) {\n  \t\tModel.call( this, null, null );\n\n  \t\t// TODO deprecate this\n  \t\tthis.changes = {};\n\n  \t\tthis.isRoot = true;\n  \t\tthis.root = this;\n  \t\tthis.ractive = options.ractive; // TODO sever this link\n\n  \t\tthis.value = options.data;\n  \t\tthis.adaptors = options.adapt;\n  \t\tthis.adapt();\n\n  \t\tthis.computationContext = options.ractive;\n  \t\tthis.computations = {};\n\n  \t\t// TODO this is only for deprecation of using expression keypaths\n  \t\tthis.expressions = {};\n  \t}\n\n  \tRootModel.prototype = Object.create( Model && Model.prototype );\n  \tRootModel.prototype.constructor = RootModel;\n\n  \tRootModel.prototype.applyChanges = function applyChanges () {\n  \t\tthis._changeHash = {};\n  \t\tthis.flush();\n\n  \t\treturn this._changeHash;\n  \t};\n\n  \tRootModel.prototype.compute = function compute ( key, signature ) {\n  \t\tvar computation = new Computation( this, signature, key );\n  \t\tthis.computations[ key ] = computation;\n\n  \t\treturn computation;\n  \t};\n\n  \tRootModel.prototype.createLink = function createLink ( keypath, target, targetPath ) {\n  \t\tvar this$1 = this;\n\n  \t\tvar keys = splitKeypathI( keypath );\n\n  \t\tvar model = this;\n  \t\twhile ( keys.length ) {\n  \t\t\tvar key = keys.shift();\n  \t\t\tmodel = this$1.childByKey[ key ] || this$1.joinKey( key );\n  \t\t}\n\n  \t\treturn model.link( target, targetPath );\n  \t};\n\n  \tRootModel.prototype.get = function get ( shouldCapture, options ) {\n  \t\tvar this$1 = this;\n\n  \t\tif ( shouldCapture ) capture( this );\n\n  \t\tif ( !options || options.virtual !== false ) {\n  \t\t\tvar result = this.getVirtual();\n  \t\t\tvar keys = Object.keys( this.computations );\n  \t\t\tvar i = keys.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tvar computation = this$1.computations[ keys[i] ];\n  \t\t\t\t// exclude template expressions\n  \t\t\t\tif ( !computation.isExpression ) {\n  \t\t\t\t\tresult[ keys[i] ] = computation.get();\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn result;\n  \t\t} else {\n  \t\t\treturn this.value;\n  \t\t}\n  \t};\n\n  \tRootModel.prototype.getKeypath = function getKeypath () {\n  \t\treturn '';\n  \t};\n\n  \tRootModel.prototype.getRactiveModel = function getRactiveModel() {\n  \t\treturn this.ractiveModel || ( this.ractiveModel = new RactiveModel( this.ractive ) );\n  \t};\n\n  \tRootModel.prototype.getValueChildren = function getValueChildren () {\n  \t\tvar children = Model.prototype.getValueChildren.call( this, this.value );\n\n  \t\tthis.children.forEach( function ( child ) {\n  \t\t\tif ( child._link ) {\n  \t\t\t\tvar idx = children.indexOf( child );\n  \t\t\t\tif ( ~idx ) children.splice( idx, 1, child._link );\n  \t\t\t\telse children.push( child._link );\n  \t\t\t}\n  \t\t});\n\n  \t\tfor ( var k in this.computations ) {\n  \t\t\tchildren.push( this.computations[k] );\n  \t\t}\n\n  \t\treturn children;\n  \t};\n\n  \tRootModel.prototype.handleChange = function handleChange$1 () {\n  \t\tthis.deps.forEach( handleChange );\n  \t};\n\n  \tRootModel.prototype.has = function has ( key ) {\n  \t\tvar value = this.value;\n\n  \t\tkey = unescapeKey( key );\n  \t\tif ( hasProp$1.call( value, key ) ) return true;\n\n  \t\t// mappings/links and computations\n  \t\tif ( key in this.computations || this.childByKey[key] && this.childByKey[key]._link ) return true;\n  \t\t// TODO remove this after deprecation is done\n  \t\tif ( key in this.expressions ) return true;\n\n  \t\t// We climb up the constructor chain to find if one of them contains the key\n  \t\tvar constructor = value.constructor;\n  \t\twhile ( constructor !== Function && constructor !== Array && constructor !== Object ) {\n  \t\t\tif ( hasProp$1.call( constructor.prototype, key ) ) return true;\n  \t\t\tconstructor = constructor.constructor;\n  \t\t}\n\n  \t\treturn false;\n  \t};\n\n  \tRootModel.prototype.joinKey = function joinKey ( key, opts ) {\n  \t\tif ( key === '@global' ) return GlobalModel$1;\n  \t\tif ( key === '@this' ) return this.getRactiveModel();\n\n  \t\tif ( this.expressions.hasOwnProperty( key ) ) {\n  \t\t\twarnIfDebug( (\"Accessing expression keypaths (\" + (key.substr(1)) + \") from the instance is deprecated. You can used a getNodeInfo or event object to access keypaths with expression context.\") );\n  \t\t\treturn this.expressions[ key ];\n  \t\t}\n\n  \t\treturn this.computations.hasOwnProperty( key ) ? this.computations[ key ] :\n  \t\t       Model.prototype.joinKey.call( this, key, opts );\n  \t};\n\n  \tRootModel.prototype.map = function map ( localKey, origin ) {\n  \t\tvar local = this.joinKey( localKey );\n  \t\tlocal.link( origin );\n  \t};\n\n  \tRootModel.prototype.rebinding = function rebinding () {\n  \t};\n\n  \tRootModel.prototype.set = function set ( value ) {\n  \t\t// TODO wrapping root node is a baaaad idea. We should prevent this\n  \t\tvar wrapper = this.wrapper;\n  \t\tif ( wrapper ) {\n  \t\t\tvar shouldTeardown = !wrapper.reset || wrapper.reset( value ) === false;\n\n  \t\t\tif ( shouldTeardown ) {\n  \t\t\t\twrapper.teardown();\n  \t\t\t\tthis.wrapper = null;\n  \t\t\t\tthis.value = value;\n  \t\t\t\tthis.adapt();\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis.value = value;\n  \t\t\tthis.adapt();\n  \t\t}\n\n  \t\tthis.deps.forEach( handleChange );\n  \t\tthis.children.forEach( mark );\n  \t\tthis.clearUnresolveds(); // TODO do we need to do this with primitive values? if not, what about e.g. unresolved `length` property of null -> string?\n  \t};\n\n  \tRootModel.prototype.retrieve = function retrieve () {\n  \t\treturn this.wrapper ? this.wrapper.get() : this.value;\n  \t};\n\n  \tRootModel.prototype.update = function update () {\n  \t\t// noop\n  \t};\n\n  \treturn RootModel;\n  }(Model));\n\n  function getComputationSignature ( ractive, key, signature ) {\n  \tvar getter;\n  \tvar setter;\n\n  \t// useful for debugging\n  \tvar getterString;\n  \tvar getterUseStack;\n  \tvar setterString;\n\n  \tif ( typeof signature === 'function' ) {\n  \t\tgetter = bind( signature, ractive );\n  \t\tgetterString = signature.toString();\n  \t\tgetterUseStack = true;\n  \t}\n\n  \tif ( typeof signature === 'string' ) {\n  \t\tgetter = createFunctionFromString( signature, ractive );\n  \t\tgetterString = signature;\n  \t}\n\n  \tif ( typeof signature === 'object' ) {\n  \t\tif ( typeof signature.get === 'string' ) {\n  \t\t\tgetter = createFunctionFromString( signature.get, ractive );\n  \t\t\tgetterString = signature.get;\n  \t\t} else if ( typeof signature.get === 'function' ) {\n  \t\t\tgetter = bind( signature.get, ractive );\n  \t\t\tgetterString = signature.get.toString();\n  \t\t\tgetterUseStack = true;\n  \t\t} else {\n  \t\t\tfatal( '`%s` computation must have a `get()` method', key );\n  \t\t}\n\n  \t\tif ( typeof signature.set === 'function' ) {\n  \t\t\tsetter = bind( signature.set, ractive );\n  \t\t\tsetterString = signature.set.toString();\n  \t\t}\n  \t}\n\n  \treturn {\n  \t\tgetter: getter,\n  \t\tsetter: setter,\n  \t\tgetterString: getterString,\n  \t\tsetterString: setterString,\n  \t\tgetterUseStack: getterUseStack\n  \t};\n  }\n\n  var constructHook = new Hook( 'construct' );\n\n  var registryNames$1 = [\n  \t'adaptors',\n  \t'components',\n  \t'decorators',\n  \t'easing',\n  \t'events',\n  \t'interpolators',\n  \t'partials',\n  \t'transitions'\n  ];\n\n  var uid = 0;\n\n  function construct ( ractive, options ) {\n  \tif ( Ractive.DEBUG ) welcome();\n\n  \tinitialiseProperties( ractive );\n\n  \t// TODO remove this, eventually\n  \tdefineProperty( ractive, 'data', { get: deprecateRactiveData });\n\n  \t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n  \tconstructHook.fire( ractive, options );\n\n  \t// Add registries\n  \tregistryNames$1.forEach( function ( name ) {\n  \t\tractive[ name ] = extendObj( create( ractive.constructor[ name ] || null ), options[ name ] );\n  \t});\n\n  \t// Create a viewmodel\n  \tvar viewmodel = new RootModel({\n  \t\tadapt: getAdaptors( ractive, ractive.adapt, options ),\n  \t\tdata: dataConfigurator.init( ractive.constructor, ractive, options ),\n  \t\tractive: ractive\n  \t});\n\n  \tractive.viewmodel = viewmodel;\n\n  \t// Add computed properties\n  \tvar computed = extendObj( create( ractive.constructor.prototype.computed ), options.computed );\n\n  \tfor ( var key in computed ) {\n  \t\tvar signature = getComputationSignature( ractive, key, computed[ key ] );\n  \t\tviewmodel.compute( key, signature );\n  \t}\n  }\n\n  function combine$2 ( arrays ) {\n  \tvar res = [];\n  \tvar args = res.concat.apply( res, arrays );\n\n  \tvar i = args.length;\n  \twhile ( i-- ) {\n  \t\tif ( !~res.indexOf( args[i] ) ) {\n  \t\t\tres.unshift( args[i] );\n  \t\t}\n  \t}\n\n  \treturn res;\n  }\n\n  function getAdaptors ( ractive, protoAdapt, options ) {\n  \tprotoAdapt = protoAdapt.map( lookup );\n  \tvar adapt = ensureArray( options.adapt ).map( lookup );\n\n  \tvar builtins = [];\n  \tvar srcs = [ protoAdapt, adapt ];\n  \tif ( ractive.parent && !ractive.isolated ) {\n  \t\tsrcs.push( ractive.parent.viewmodel.adaptors );\n  \t}\n  \tsrcs.push( builtins );\n\n  \tvar magic = 'magic' in options ? options.magic : ractive.magic;\n  \tvar modifyArrays = 'modifyArrays' in options ? options.modifyArrays : ractive.modifyArrays;\n\n  \tif ( magic ) {\n  \t\tif ( !magicSupported ) {\n  \t\t\tthrow new Error( 'Getters and setters (magic mode) are not supported in this browser' );\n  \t\t}\n\n  \t\tif ( modifyArrays ) {\n  \t\t\tbuiltins.push( magicArrayAdaptor );\n  \t\t}\n\n  \t\tbuiltins.push( magicAdaptor$1 );\n  \t}\n\n  \tif ( modifyArrays ) {\n  \t\tbuiltins.push( arrayAdaptor );\n  \t}\n\n  \treturn combine$2( srcs );\n\n\n  \tfunction lookup ( adaptor ) {\n  \t\tif ( typeof adaptor === 'string' ) {\n  \t\t\tadaptor = findInViewHierarchy( 'adaptors', ractive, adaptor );\n\n  \t\t\tif ( !adaptor ) {\n  \t\t\t\tfatal( missingPlugin( adaptor, 'adaptor' ) );\n  \t\t\t}\n  \t\t}\n\n  \t\treturn adaptor;\n  \t}\n  }\n\n  function initialiseProperties ( ractive ) {\n  \t// Generate a unique identifier, for places where you'd use a weak map if it\n  \t// existed\n  \tractive._guid = 'r-' + uid++;\n\n  \t// events\n  \tractive._subs = create( null );\n\n  \t// storage for item configuration from instantiation to reset,\n  \t// like dynamic functions or original values\n  \tractive._config = {};\n\n  \t// nodes registry\n  \tractive.nodes = {};\n\n  \t// events\n  \tractive.event = null;\n  \tractive._eventQueue = [];\n\n  \t// live queries\n  \tractive._liveQueries = [];\n  \tractive._liveComponentQueries = [];\n\n  \t// observers\n  \tractive._observers = [];\n\n  \tif(!ractive.component){\n  \t\tractive.root = ractive;\n  \t\tractive.parent = ractive.container = null; // TODO container still applicable?\n  \t}\n\n  }\n\n  function deprecateRactiveData () {\n  \tthrow new Error( 'Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead' );\n  }\n\n  function getChildQueue ( queue, ractive ) {\n  \treturn queue[ ractive._guid ] || ( queue[ ractive._guid ] = [] );\n  }\n\n  function fire ( hookQueue, ractive ) {\n  \tvar childQueue = getChildQueue( hookQueue.queue, ractive );\n\n  \thookQueue.hook.fire( ractive );\n\n  \t// queue is \"live\" because components can end up being\n  \t// added while hooks fire on parents that modify data values.\n  \twhile ( childQueue.length ) {\n  \t\tfire( hookQueue, childQueue.shift() );\n  \t}\n\n  \tdelete hookQueue.queue[ ractive._guid ];\n  }\n\n  var HookQueue = function HookQueue ( event ) {\n  \tthis.hook = new Hook( event );\n  \tthis.inProcess = {};\n  \tthis.queue = {};\n  };\n\n  HookQueue.prototype.begin = function begin ( ractive ) {\n  \tthis.inProcess[ ractive._guid ] = true;\n  };\n\n  HookQueue.prototype.end = function end ( ractive ) {\n  \tvar parent = ractive.parent;\n\n  \t// If this is *isn't* a child of a component that's in process,\n  \t// it should call methods or fire at this point\n  \tif ( !parent || !this.inProcess[ parent._guid ] ) {\n  \t\tfire( this, ractive );\n  \t}\n  \t// elsewise, handoff to parent to fire when ready\n  \telse {\n  \t\tgetChildQueue( this.queue, parent ).push( ractive );\n  \t}\n\n  \tdelete this.inProcess[ ractive._guid ];\n  };\n\n  var configHook = new Hook( 'config' );\n  var initHook = new HookQueue( 'init' );\n\n  function initialise ( ractive, userOptions, options ) {\n  \tObject.keys( ractive.viewmodel.computations ).forEach( function ( key ) {\n  \t\tvar computation = ractive.viewmodel.computations[ key ];\n\n  \t\tif ( ractive.viewmodel.value.hasOwnProperty( key ) ) {\n  \t\t\tcomputation.set( ractive.viewmodel.value[ key ] );\n  \t\t}\n  \t});\n\n  \t// init config from Parent and options\n  \tconfig.init( ractive.constructor, ractive, userOptions );\n\n  \tconfigHook.fire( ractive );\n  \tinitHook.begin( ractive );\n\n  \tvar fragment;\n\n  \t// Render virtual DOM\n  \tif ( ractive.template ) {\n  \t\tvar cssIds;\n\n  \t\tif ( options.cssIds || ractive.cssId ) {\n  \t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n  \t\t\tif ( ractive.cssId ) {\n  \t\t\t\tcssIds.push( ractive.cssId );\n  \t\t\t}\n  \t\t}\n\n  \t\tractive.fragment = fragment = new Fragment({\n  \t\t\towner: ractive,\n  \t\t\ttemplate: ractive.template,\n  \t\t\tcssIds: cssIds\n  \t\t}).bind( ractive.viewmodel );\n  \t}\n\n  \tinitHook.end( ractive );\n\n  \tif ( fragment ) {\n  \t\t// render automatically ( if `el` is specified )\n  \t\tvar el = getElement( ractive.el );\n  \t\tif ( el ) {\n  \t\t\tvar promise = ractive.render( el, ractive.append );\n\n  \t\t\tif ( Ractive.DEBUG_PROMISES ) {\n  \t\t\t\tpromise['catch']( function ( err ) {\n  \t\t\t\t\twarnOnceIfDebug( 'Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;' );\n  \t\t\t\t\twarnIfDebug( 'An error happened during rendering', { ractive: ractive });\n  \t\t\t\t\tlogIfDebug( err );\n\n  \t\t\t\t\tthrow err;\n  \t\t\t\t});\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var DOMEvent = function DOMEvent ( name, owner ) {\n  \tif ( name.indexOf( '*' ) !== -1 ) {\n  \t\tfatal( (\"Only component proxy-events may contain \\\"*\\\" wildcards, <\" + (owner.name) + \" on-\" + name + \"=\\\"...\\\"/> is not valid\") );\n  \t}\n\n  \tthis.name = name;\n  \tthis.owner = owner;\n  \tthis.node = null;\n  \tthis.handler = null;\n  };\n\n  DOMEvent.prototype.listen = function listen ( directive ) {\n  \tvar node = this.node = this.owner.node;\n  \tvar name = this.name;\n\n  \tif ( !( (\"on\" + name) in node ) ) {\n  \t\twarnOnce( missingPlugin( name, 'events' ) );\n  \t\t}\n\n  \t\tnode.addEventListener( name, this.handler = function( event ) {\n  \t\tdirective.fire({\n  \t\t\t\tnode: node,\n  \t\t\toriginal: event\n  \t\t\t});\n  \t\t}, false );\n  };\n\n  DOMEvent.prototype.unlisten = function unlisten () {\n  \tthis.node.removeEventListener( this.name, this.handler, false );\n  };\n\n  var CustomEvent = function CustomEvent ( eventPlugin, owner ) {\n  \tthis.eventPlugin = eventPlugin;\n  \tthis.owner = owner;\n  \tthis.handler = null;\n  };\n\n  CustomEvent.prototype.listen = function listen ( directive ) {\n  \tvar node = this.owner.node;\n\n  \tthis.handler = this.eventPlugin( node, function ( event ) {\n  \t\tif ( event === void 0 ) event = {};\n\n  \t\t\tevent.node = event.node || node;\n  \t\tdirective.fire( event );\n  \t});\n  };\n\n  CustomEvent.prototype.unlisten = function unlisten () {\n  \tthis.handler.teardown();\n  };\n\n  var RactiveEvent = function RactiveEvent ( ractive, name ) {\n  \tthis.ractive = ractive;\n  \tthis.name = name;\n  \tthis.handler = null;\n  };\n\n  RactiveEvent.prototype.listen = function listen ( directive ) {\n  \tvar ractive = this.ractive;\n\n  \tthis.handler = ractive.on( this.name, function () {\n  \t\tvar event;\n\n  \t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n  \t\tif ( arguments.length && arguments[0] && arguments[0].node ) {\n  \t\t\tevent = Array.prototype.shift.call( arguments );\n  \t\t\tevent.component = ractive;\n  \t\t}\n\n  \t\tvar args = Array.prototype.slice.call( arguments );\n  \t\tdirective.fire( event, args );\n\n  \t\t// cancel bubbling\n  \t\treturn false;\n  \t});\n  };\n\n  RactiveEvent.prototype.unlisten = function unlisten () {\n  \tthis.handler.cancel();\n  };\n\n  var specialPattern = /^(event|arguments)(\\..+)?$/;\n  var dollarArgsPattern = /^\\$(\\d+)(\\..+)?$/;\n\n  var EventDirective = function EventDirective ( options ) {\n  \tvar this$1 = this;\n\n  \t\tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n  \tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n  \tthis.template = options.template;\n  \tthis.parentFragment = options.parentFragment;\n  \tthis.ractive = options.parentFragment.ractive;\n\n  \tthis.events = [];\n\n  \tif ( this.element.type === COMPONENT ) {\n  \t\tthis.template.n.split( '-' ).forEach( function ( n ) {\n  \t\t\tthis$1.events.push( new RactiveEvent( this$1.element.instance, n ) );\n  \t\t});\n  \t} else {\n  \t\tthis.template.n.split( '-' ).forEach( function ( n ) {\n  \t\t\tvar fn = findInViewHierarchy( 'events', this$1.ractive, n );\n  \t\t\t// we need to pass in \"this\" in order to get\n  \t\t\t// access to node when it is created.\n  \t\t\tthis$1.events.push(fn ? new CustomEvent( fn, this$1.element ) : new DOMEvent( n, this$1.element ));\n  \t\t});\n  \t}\n\n  \tthis.context = null;\n\n  \t// method calls\n  \tthis.resolvers = null;\n  \tthis.models = null;\n\n  \t// handler directive\n  \tthis.action = null;\n  \tthis.args = null;\n  };\n\n  EventDirective.prototype.bind = function bind () {\n  \tvar this$1 = this;\n\n  \t\tthis.context = this.parentFragment.findContext();\n\n  \tvar template = this.template.f;\n\n  \tif ( template.x ) {\n  \t\tthis.fn = getFunction( template.x.s, template.x.r.length );\n  \t\tthis.resolvers = [];\n  \t\tthis.models = template.x.r.map( function ( ref, i ) {\n  \t\t\tvar specialMatch = specialPattern.exec( ref );\n  \t\t\tif ( specialMatch ) {\n  \t\t\t\t// on-click=\"foo(event.node)\"\n  \t\t\t\treturn {\n  \t\t\t\t\tspecial: specialMatch[1],\n  \t\t\t\t\tkeys: specialMatch[2] ? splitKeypathI( specialMatch[2].substr(1) ) : []\n  \t\t\t\t};\n  \t\t\t}\n\n  \t\t\tvar dollarMatch = dollarArgsPattern.exec( ref );\n  \t\t\tif ( dollarMatch ) {\n  \t\t\t\t// on-click=\"foo($1)\"\n  \t\t\t\treturn {\n  \t\t\t\t\tspecial: 'arguments',\n  \t\t\t\t\tkeys: [ dollarMatch[1] - 1 ].concat( dollarMatch[2] ? splitKeypathI( dollarMatch[2].substr( 1 ) ) : [] )\n  \t\t\t\t};\n  \t\t\t}\n\n  \t\t\tvar resolver;\n\n  \t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n  \t\t\tif ( !model ) {\n  \t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n  \t\t\t\t\tthis$1.models[i] = model;\n  \t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n  \t\t\t\t\tmodel.register( this$1 );\n  \t\t\t\t});\n\n  \t\t\t\tthis$1.resolvers.push( resolver );\n  \t\t\t} else model.register( this$1 );\n\n  \t\t\treturn model;\n  \t\t});\n  \t}\n\n  \telse {\n  \t\t// TODO deprecate this style of directive\n  \t\tthis.action = typeof template === 'string' ? // on-click='foo'\n  \t\t\ttemplate :\n  \t\t\ttypeof template.n === 'string' ? // on-click='{{dynamic}}'\n  \t\t\t\ttemplate.n :\n  \t\t\t\tnew Fragment({\n  \t\t\t\t\towner: this,\n  \t\t\t\t\ttemplate: template.n\n  \t\t\t\t});\n\n  \t\tthis.args = template.a ? // static arguments\n  \t\t\t( typeof template.a === 'string' ? [ template.a ] : template.a ) :\n  \t\t\ttemplate.d ? // dynamic arguments\n  \t\t\t\tnew Fragment({\n  \t\t\t\t\towner: this,\n  \t\t\t\t\ttemplate: template.d\n  \t\t\t\t}) :\n  \t\t\t\t[]; // no arguments\n  \t}\n\n  \tif ( this.action && typeof this.action !== 'string' ) this.action.bind();\n  \tif ( this.args && template.d ) this.args.bind();\n  };\n\n  EventDirective.prototype.bubble = function bubble () {\n  \tif ( !this.dirty ) {\n  \t\tthis.dirty = true;\n  \t\tthis.owner.bubble();\n  \t}\n  };\n\n  EventDirective.prototype.destroyed = function destroyed () {\n  \tthis.events.forEach( function ( e ) { return e.unlisten(); } );\n  };\n\n  EventDirective.prototype.fire = function fire ( event, passedArgs ) {\n\n  \t// augment event object\n  \tif ( passedArgs === void 0 ) passedArgs = [];\n\n  \t\tif ( event && !event.hasOwnProperty( '_element' ) ) {\n  \t\t   addHelpers( event, this.owner );\n  \t}\n\n  \tif ( this.fn ) {\n  \t\tvar values = [];\n\n  \t\tif ( event ) passedArgs.unshift( event );\n\n  \t\tif ( this.models ) {\n  \t\t\tthis.models.forEach( function ( model ) {\n  \t\t\t\tif ( !model ) return values.push( undefined );\n\n  \t\t\t\tif ( model.special ) {\n  \t\t\t\t\tvar obj = model.special === 'event' ? event : passedArgs;\n  \t\t\t\t\tvar keys = model.keys.slice();\n\n  \t\t\t\t\twhile ( keys.length ) obj = obj[ keys.shift() ];\n  \t\t\t\t\treturn values.push( obj );\n  \t\t\t\t}\n\n  \t\t\t\tif ( model.wrapper ) {\n  \t\t\t\t\treturn values.push( model.wrapperValue );\n  \t\t\t\t}\n\n  \t\t\t\tvalues.push( model.get() );\n  \t\t\t});\n  \t\t}\n\n  \t\t// make event available as `this.event`\n  \t\tvar ractive = this.ractive;\n  \t\tvar oldEvent = ractive.event;\n\n  \t\tractive.event = event;\n  \t\tvar result = this.fn.apply( ractive, values ).pop();\n\n  \t\t// Auto prevent and stop if return is explicitly false\n  \t\tif ( result === false ) {\n  \t\t\tvar original = event ? event.original : undefined;\n  \t\t\tif ( original ) {\n  \t\t\t\toriginal.preventDefault && original.preventDefault();\n  \t\t\t\toriginal.stopPropagation && original.stopPropagation();\n  \t\t\t} else {\n  \t\t\t\twarnOnceIfDebug( (\"handler '\" + (this.template.n) + \"' returned false, but there is no event available to cancel\") );\n  \t\t\t}\n  \t\t}\n\n  \t\tractive.event = oldEvent;\n  \t}\n\n  \telse {\n  \t\tvar action = this.action.toString();\n  \t\tvar args = this.template.f.d ? this.args.getArgsList() : this.args;\n\n  \t\tif ( passedArgs.length ) args = args.concat( passedArgs );\n\n  \t\tif ( event ) event.name = action;\n\n  \t\tfireEvent( this.ractive, action, {\n  \t\t\tevent: event,\n  \t\t\targs: args\n  \t\t});\n  \t}\n  };\n\n  EventDirective.prototype.handleChange = function handleChange () {};\n\n  EventDirective.prototype.rebinding = function rebinding ( next, previous ) {\n  \tvar this$1 = this;\n\n  \t\tif ( !this.models ) return;\n  \tvar idx = this.models.indexOf( previous );\n\n  \tif ( ~idx ) {\n  \t\tthis.models.splice( idx, 1, next );\n  \t\tprevious.unregister( this );\n  \t\tif ( next ) next.addShuffleTask( function () { return next.register( this$1 ); } );\n  \t}\n  };\n\n  EventDirective.prototype.render = function render () {\n  \t// render events after everything else, so they fire after bindings\n  \tvar this$1 = this;\n\n  \t\trunloop.scheduleTask( function () { return this$1.events.forEach( function ( e ) { return e.listen( this$1 ); }, true ); } );\n  };\n\n  EventDirective.prototype.toString = function toString() { return ''; };\n\n  EventDirective.prototype.unbind = function unbind$1 () {\n  \tvar this$1 = this;\n\n  \t\tvar template = this.template.f;\n\n  \tif ( template.m ) {\n  \t\tif ( this.resolvers ) this.resolvers.forEach( unbind );\n  \t\tthis.resolvers = [];\n\n  \t\tif ( this.models ) this.models.forEach( function ( m ) {\n  \t\t\tif ( m.unregister ) m.unregister( this$1 );\n  \t\t});\n  \t\tthis.models = null;\n  \t}\n\n  \telse {\n  \t\t// TODO this is brittle and non-explicit, fix it\n  \t\tif ( this.action && this.action.unbind ) this.action.unbind();\n  \t\tif ( this.args && this.args.unbind ) this.args.unbind();\n  \t}\n  };\n\n  EventDirective.prototype.unrender = function unrender () {\n  \tthis.events.forEach( function ( e ) { return e.unlisten(); } );\n  };\n\n  EventDirective.prototype.update = function update () {\n  \tif ( this.method || !this.dirty ) return; // nothing to do\n\n  \tthis.dirty = false;\n\n  \t// ugh legacy\n  \tif ( this.action && this.action.update ) this.action.update();\n  \tif ( this.args && this.args.update ) this.args.update();\n  };\n\n  // TODO it's unfortunate that this has to run every time a\n  // component is rendered... is there a better way?\n  function updateLiveQueries ( component ) {\n  \t// Does this need to be added to any live queries?\n  \tvar instance = component.ractive;\n\n  \tdo {\n  \t\tvar liveQueries = instance._liveComponentQueries;\n\n  \t\tvar i = liveQueries.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar name = liveQueries[i];\n  \t\t\tvar query = liveQueries[ (\"_\" + name) ];\n\n  \t\t\tif ( query.test( component ) ) {\n  \t\t\t\tquery.add( component.instance );\n  \t\t\t\t// keep register of applicable selectors, for when we teardown\n  \t\t\t\tcomponent.liveQueries.push( query );\n  \t\t\t}\n  \t\t}\n  \t} while ( instance = instance.parent );\n  }\n\n  function removeFromLiveComponentQueries ( component ) {\n  \tvar instance = component.ractive;\n\n  \twhile ( instance ) {\n  \t\tvar query = instance._liveComponentQueries[ (\"_\" + (component.name)) ];\n  \t\tif ( query ) query.remove( component );\n\n  \t\tinstance = instance.parent;\n  \t}\n  }\n\n  function makeDirty ( query ) {\n  \tquery.makeDirty();\n  }\n\n  var teardownHook = new Hook( 'teardown' );\n\n  var Component = (function (Item) {\n  \tfunction Component ( options, ComponentConstructor ) {\n  \t\tvar this$1 = this;\n\n  \t\tItem.call( this, options );\n  \t\tthis.type = COMPONENT; // override ELEMENT from super\n\n  \t\tvar instance = create( ComponentConstructor.prototype );\n\n  \t\tthis.instance = instance;\n  \t\tthis.name = options.template.e;\n  \t\tthis.parentFragment = options.parentFragment;\n\n  \t\tthis.liveQueries = [];\n\n  \t\tif ( instance.el ) {\n  \t\t\twarnIfDebug( (\"The <\" + (this.name) + \"> component has a default 'el' property; it has been disregarded\") );\n  \t\t}\n\n  \t\tvar partials = options.template.p || {};\n  \t\tif ( !( 'content' in partials ) ) partials.content = options.template.f || [];\n  \t\tthis._partials = partials; // TEMP\n\n  \t\tthis.yielders = {};\n\n  \t\t// find container\n  \t\tvar fragment = options.parentFragment;\n  \t\tvar container;\n  \t\twhile ( fragment ) {\n  \t\t\tif ( fragment.owner.type === YIELDER ) {\n  \t\t\t\tcontainer = fragment.owner.container;\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tfragment = fragment.parent;\n  \t\t}\n\n  \t\t// add component-instance-specific properties\n  \t\tinstance.parent = this.parentFragment.ractive;\n  \t\tinstance.container = container || null;\n  \t\tinstance.root = instance.parent.root;\n  \t\tinstance.component = this;\n\n  \t\tconstruct( this.instance, { partials: partials });\n\n  \t\t// for hackability, this could be an open option\n  \t\t// for any ractive instance, but for now, just\n  \t\t// for components and just for ractive...\n  \t\tinstance._inlinePartials = partials;\n\n  \t\tthis.attributeByName = {};\n\n  \t\tthis.attributes = [];\n  \t\tvar leftovers = [];\n  \t\t( this.template.m || [] ).forEach( function ( template ) {\n  \t\t\tswitch ( template.t ) {\n  \t\t\t\tcase ATTRIBUTE:\n  \t\t\t\tcase EVENT:\n  \t\t\t\tcase TRANSITION:\n  \t\t\t\t\tthis$1.attributes.push( createItem({\n  \t\t\t\t\t\towner: this$1,\n  \t\t\t\t\t\tparentFragment: this$1.parentFragment,\n  \t\t\t\t\t\ttemplate: template\n  \t\t\t\t\t}) );\n  \t\t\t\t\tbreak;\n\n  \t\t\t\tcase BINDING_FLAG:\n  \t\t\t\tcase DECORATOR:\n  \t\t\t\t\tbreak;\n\n  \t\t\t\tdefault:\n  \t\t\t\t\tleftovers.push( template );\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t});\n\n  \t\tthis.attributes.push( new ConditionalAttribute({\n  \t\t\towner: this,\n  \t\t\tparentFragment: this.parentFragment,\n  \t\t\ttemplate: leftovers\n  \t\t}) );\n\n  \t\tthis.eventHandlers = [];\n  \t\tif ( this.template.v ) this.setupEvents();\n  \t}\n\n  \tComponent.prototype = Object.create( Item && Item.prototype );\n  \tComponent.prototype.constructor = Component;\n\n  \tComponent.prototype.bind = function bind$1$$ () {\n  \t\tthis.attributes.forEach( bind$1 );\n\n  \t\tinitialise( this.instance, {\n  \t\t\tpartials: this._partials\n  \t\t}, {\n  \t\t\tcssIds: this.parentFragment.cssIds\n  \t\t});\n\n  \t\tthis.eventHandlers.forEach( bind$1 );\n\n  \t\tthis.bound = true;\n  \t};\n\n  \tComponent.prototype.bubble = function bubble () {\n  \t\tif ( !this.dirty ) {\n  \t\t\tthis.dirty = true;\n  \t\t\tthis.parentFragment.bubble();\n  \t\t}\n  \t};\n\n  \tComponent.prototype.checkYielders = function checkYielders () {\n  \t\tvar this$1 = this;\n\n  \t\tObject.keys( this.yielders ).forEach( function ( name ) {\n  \t\t\tif ( this$1.yielders[ name ].length > 1 ) {\n  \t\t\t\trunloop.end();\n  \t\t\t\tthrow new Error( (\"A component template can only have one {{yield\" + (name ? ' ' + name : '') + \"}} declaration at a time\") );\n  \t\t\t}\n  \t\t});\n  \t};\n\n  \tComponent.prototype.destroyed = function destroyed () {\n  \t\tif ( this.instance.fragment ) this.instance.fragment.destroyed();\n  \t};\n\n  \tComponent.prototype.detach = function detach () {\n  \t\treturn this.instance.fragment.detach();\n  \t};\n\n  \tComponent.prototype.find = function find ( selector ) {\n  \t\treturn this.instance.fragment.find( selector );\n  \t};\n\n  \tComponent.prototype.findAll = function findAll ( selector, query ) {\n  \t\tthis.instance.fragment.findAll( selector, query );\n  \t};\n\n  \tComponent.prototype.findComponent = function findComponent ( name ) {\n  \t\tif ( !name || this.name === name ) return this.instance;\n\n  \t\tif ( this.instance.fragment ) {\n  \t\t\treturn this.instance.fragment.findComponent( name );\n  \t\t}\n  \t};\n\n  \tComponent.prototype.findAllComponents = function findAllComponents ( name, query ) {\n  \t\tif ( query.test( this ) ) {\n  \t\t\tquery.add( this.instance );\n\n  \t\t\tif ( query.live ) {\n  \t\t\t\tthis.liveQueries.push( query );\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.instance.fragment.findAllComponents( name, query );\n  \t};\n\n  \tComponent.prototype.firstNode = function firstNode ( skipParent ) {\n  \t\treturn this.instance.fragment.firstNode( skipParent );\n  \t};\n\n  \tComponent.prototype.render = function render$1$$ ( target, occupants ) {\n  \t\trender$1( this.instance, target, null, occupants );\n\n  \t\tthis.checkYielders();\n  \t\tthis.attributes.forEach( render );\n  \t\tthis.eventHandlers.forEach( render );\n  \t\tupdateLiveQueries( this );\n\n  \t\tthis.rendered = true;\n  \t};\n\n  \tComponent.prototype.setupEvents = function setupEvents () {\n  \t\tvar this$1 = this;\n\n  \t\tvar handlers = this.eventHandlers;\n\n  \t\tObject.keys( this.template.v ).forEach( function ( key ) {\n  \t\t\tvar eventNames = key.split( '-' );\n  \t\t\tvar template = this$1.template.v[ key ];\n\n  \t\t\teventNames.forEach( function ( eventName ) {\n  \t\t\t\tvar event = new RactiveEvent( this$1.instance, eventName );\n  \t\t\t\thandlers.push( new EventDirective( this$1, event, template ) );\n  \t\t\t});\n  \t\t});\n  \t};\n\n  \tComponent.prototype.shuffled = function shuffled () {\n  \t\tthis.liveQueries.forEach( makeDirty );\n  \t\tItem.prototype.shuffled.call(this);\n  \t};\n\n  \tComponent.prototype.toString = function toString () {\n  \t\treturn this.instance.toHTML();\n  \t};\n\n  \tComponent.prototype.unbind = function unbind$1 () {\n  \t\tthis.bound = false;\n\n  \t\tthis.attributes.forEach( unbind );\n\n  \t\tvar instance = this.instance;\n  \t\tinstance.viewmodel.teardown();\n  \t\tinstance.fragment.unbind();\n  \t\tinstance._observers.forEach( cancel );\n\n  \t\tremoveFromLiveComponentQueries( this );\n\n  \t\tif ( instance.fragment.rendered && instance.el.__ractive_instances__ ) {\n  \t\t\tremoveFromArray( instance.el.__ractive_instances__, instance );\n  \t\t}\n\n  \t\tteardownHook.fire( instance );\n  \t};\n\n  \tComponent.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n  \t\tvar this$1 = this;\n\n  \t\tthis.rendered = false;\n\n  \t\tthis.shouldDestroy = shouldDestroy;\n  \t\tthis.instance.unrender();\n  \t\tthis.attributes.forEach( unrender );\n  \t\tthis.eventHandlers.forEach( unrender );\n  \t\tthis.liveQueries.forEach( function ( query ) { return query.remove( this$1.instance ); } );\n  \t};\n\n  \tComponent.prototype.update = function update$1 () {\n  \t\tthis.dirty = false;\n  \t\tthis.instance.fragment.update();\n  \t\tthis.checkYielders();\n  \t\tthis.attributes.forEach( update );\n  \t\tthis.eventHandlers.forEach( update );\n  \t};\n\n  \treturn Component;\n  }(Item));\n\n  var missingDecorator = {\n  \tupdate: noop,\n  \tteardown: noop\n  };\n\n  var Decorator = function Decorator ( options ) {\n  \tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n  \tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n  \tthis.parentFragment = this.owner.parentFragment;\n  \tthis.ractive = this.owner.ractive;\n  \tvar template = this.template = options.template;\n\n  \tthis.dynamicName = typeof template.f.n === 'object';\n  \tthis.dynamicArgs = !!template.f.d;\n\n  \tif ( this.dynamicName ) {\n  \t\tthis.nameFragment = new Fragment({\n  \t\t\towner: this,\n  \t\t\ttemplate: template.f.n\n  \t\t});\n  \t} else {\n  \t\tthis.name = template.f.n || template.f;\n  \t}\n\n  \tif ( this.dynamicArgs ) {\n  \t\tthis.argsFragment = new Fragment({\n  \t\t\towner: this,\n  \t\t\ttemplate: template.f.d\n  \t\t});\n  \t} else {\n  \t\tif ( template.f.a && template.f.a.s ) {\n  \t\t\tthis.args = [];\n  \t\t} else {\n  \t\t\tthis.args = template.f.a || [];\n  \t\t}\n  \t}\n\n  \tthis.node = null;\n  \tthis.intermediary = null;\n\n  \tthis.element.decorators.push( this );\n  };\n\n  Decorator.prototype.bind = function bind () {\n  \tvar this$1 = this;\n\n  \t\tif ( this.dynamicName ) {\n  \t\tthis.nameFragment.bind();\n  \t\tthis.name = this.nameFragment.toString();\n  \t}\n\n  \tif ( this.dynamicArgs ) this.argsFragment.bind();\n\n  \t// TODO: dry this up once deprecation is done\n  \tif ( this.template.f.a && this.template.f.a.s ) {\n  \t\tthis.resolvers = [];\n  \t\tthis.models = this.template.f.a.r.map( function ( ref, i ) {\n  \t\t\tvar resolver;\n  \t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n  \t\t\tif ( !model ) {\n  \t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n  \t\t\t\t\tthis$1.models[i] = model;\n  \t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n  \t\t\t\t\tmodel.register( this$1 );\n  \t\t\t\t});\n\n  \t\t\t\tthis$1.resolvers.push( resolver );\n  \t\t\t} else model.register( this$1 );\n\n  \t\t\treturn model;\n  \t\t});\n  \t\tthis.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );\n  \t}\n  };\n\n  Decorator.prototype.bubble = function bubble () {\n  \tif ( !this.dirty ) {\n  \t\tthis.dirty = true;\n  \t\tthis.owner.bubble();\n  \t}\n  };\n\n  Decorator.prototype.destroyed = function destroyed () {\n  \tif ( this.intermediary ) this.intermediary.teardown();\n  };\n\n  Decorator.prototype.handleChange = function handleChange () { this.bubble(); };\n\n  Decorator.prototype.rebinding = function rebinding ( next, previous, safe ) {\n  \tvar idx = this.models.indexOf( previous );\n  \tif ( !~idx ) return;\n\n  \tnext = rebindMatch( this.template.f.a.r[ idx ], next, previous );\n  \tif ( next === previous ) return;\n\n  \tprevious.unregister( this );\n  \tthis.models.splice( idx, 1, next );\n  \tif ( next ) next.addShuffleRegister( this, 'mark' );\n\n  \tif ( !safe ) this.bubble();\n  };\n\n  Decorator.prototype.render = function render () {\n  \tvar this$1 = this;\n\n  \t\trunloop.scheduleTask( function () {\n  \t\tvar fn = findInViewHierarchy( 'decorators', this$1.ractive, this$1.name );\n\n  \t\tif ( !fn ) {\n  \t\t\twarnOnce( missingPlugin( this$1.name, 'decorator' ) );\n  \t\t\tthis$1.intermediary = missingDecorator;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis$1.node = this$1.element.node;\n\n  \t\tvar args;\n  \t\tif ( this$1.argsFn ) {\n  \t\t\targs = this$1.models.map( function ( model ) {\n  \t\t\t\tif ( !model ) return undefined;\n\n  \t\t\t\treturn model.get();\n  \t\t\t});\n  \t\t\targs = this$1.argsFn.apply( this$1.ractive, args );\n  \t\t} else {\n  \t\t\targs = this$1.dynamicArgs ? this$1.argsFragment.getArgsList() : this$1.args;\n  \t\t}\n\n  \t\tthis$1.intermediary = fn.apply( this$1.ractive, [ this$1.node ].concat( args ) );\n\n  \t\tif ( !this$1.intermediary || !this$1.intermediary.teardown ) {\n  \t\t\tthrow new Error( (\"The '\" + (this$1.name) + \"' decorator must return an object with a teardown method\") );\n  \t\t}\n  \t}, true );\n  \tthis.rendered = true;\n  };\n\n  Decorator.prototype.toString = function toString () { return ''; };\n\n  Decorator.prototype.unbind = function unbind$1 () {\n  \tvar this$1 = this;\n\n  \t\tif ( this.dynamicName ) this.nameFragment.unbind();\n  \tif ( this.dynamicArgs ) this.argsFragment.unbind();\n  \tif ( this.resolvers ) this.resolvers.forEach( unbind );\n  \tif ( this.models ) this.models.forEach( function ( m ) {\n  \t\tif ( m ) m.unregister( this$1 );\n  \t});\n  };\n\n  Decorator.prototype.unrender = function unrender ( shouldDestroy ) {\n  \tif ( ( !shouldDestroy || this.element.rendered ) && this.intermediary ) this.intermediary.teardown();\n  \tthis.rendered = false;\n  };\n\n  Decorator.prototype.update = function update () {\n  \tif ( !this.dirty ) return;\n\n  \tthis.dirty = false;\n\n  \tvar nameChanged = false;\n\n  \tif ( this.dynamicName && this.nameFragment.dirty ) {\n  \t\tvar name = this.nameFragment.toString();\n  \t\tnameChanged = name !== this.name;\n  \t\tthis.name = name;\n  \t}\n\n  \tif ( this.intermediary ) {\n  \t\tif ( nameChanged || !this.intermediary.update ) {\n  \t\t\tthis.unrender();\n  \t\t\tthis.render();\n  \t\t}\n  \t\telse {\n  \t\t\tif ( this.dynamicArgs ) {\n  \t\t\t\tif ( this.argsFragment.dirty ) {\n  \t\t\t\t\tvar args = this.argsFragment.getArgsList();\n  \t\t\t\t\tthis.intermediary.update.apply( this.ractive, args );\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse if ( this.argsFn ) {\n  \t\t\t\tvar args$1 = this.models.map( function ( model ) {\n  \t\t\t\t\tif ( !model ) return undefined;\n\n  \t\t\t\t\treturn model.get();\n  \t\t\t\t});\n  \t\t\t\tthis.intermediary.update.apply( this.ractive, this.argsFn.apply( this.ractive, args$1 ) );\n  \t\t\t}\n  \t\t\telse {\n  \t\t\t\tthis.intermediary.update.apply( this.ractive, this.args );\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// need to run these for unrender/render cases\n  \t// so can't just be in conditional if above\n\n  \tif ( this.dynamicName && this.nameFragment.dirty ) {\n  \t\tthis.nameFragment.update();\n  \t}\n\n  \tif ( this.dynamicArgs && this.argsFragment.dirty ) {\n  \t\tthis.argsFragment.update();\n  \t}\n  };\n\n  var Doctype = (function (Item) {\n  \tfunction Doctype () {\n  \t\tItem.apply(this, arguments);\n  \t}\n\n  \tDoctype.prototype = Object.create( Item && Item.prototype );\n  \tDoctype.prototype.constructor = Doctype;\n\n  \tDoctype.prototype.bind = function bind () {\n  \t\t// noop\n  \t};\n\n  \tDoctype.prototype.render = function render () {\n  \t\t// noop\n  \t};\n\n  \tDoctype.prototype.teardown = function teardown () {\n  \t\t// noop\n  \t};\n\n  \tDoctype.prototype.toString = function toString () {\n  \t\treturn '<!DOCTYPE' + this.template.a + '>';\n  \t};\n\n  \tDoctype.prototype.unbind = function unbind () {\n  \t\t// noop\n  \t};\n\n  \tDoctype.prototype.unrender = function unrender () {\n  \t\t// noop\n  \t};\n\n  \tDoctype.prototype.update = function update () {\n  \t\t// noop\n  \t};\n\n  \treturn Doctype;\n  }(Item));\n\n  function updateLiveQueries$1 ( element ) {\n  \t// Does this need to be added to any live queries?\n  \tvar node = element.node;\n  \tvar instance = element.ractive;\n\n  \tdo {\n  \t\tvar liveQueries = instance._liveQueries;\n\n  \t\tvar i = liveQueries.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar selector = liveQueries[i];\n  \t\t\tvar query = liveQueries[ (\"_\" + selector) ];\n\n  \t\t\tif ( query.test( node ) ) {\n  \t\t\t\tquery.add( node );\n  \t\t\t\t// keep register of applicable selectors, for when we teardown\n  \t\t\t\telement.liveQueries.push( query );\n  \t\t\t}\n  \t\t}\n  \t} while ( instance = instance.parent );\n  }\n\n  function warnAboutAmbiguity ( description, ractive ) {\n  \twarnOnceIfDebug( (\"The \" + description + \" being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\"), { ractive: ractive });\n  }\n\n  var Binding = function Binding ( element, name ) {\n  \tif ( name === void 0 ) name = 'value';\n\n  \t\tthis.element = element;\n  \tthis.ractive = element.ractive;\n  \tthis.attribute = element.attributeByName[ name ];\n\n  \tvar interpolator = this.attribute.interpolator;\n  \tinterpolator.twowayBinding = this;\n\n  \tvar model = interpolator.model;\n\n  \t// not bound?\n  \tif ( !model ) {\n  \t\t// try to force resolution\n  \t\tinterpolator.resolver.forceResolution();\n  \t\tmodel = interpolator.model;\n\n  \t\twarnAboutAmbiguity( (\"'\" + (interpolator.template.r) + \"' reference\"), this.ractive );\n  \t\t}\n\n  \t\telse if ( model.isUnresolved ) {\n  \t\t\t// reference expressions (e.g. foo[bar])\n  \t\t\tmodel.forceResolution();\n  \t\t\twarnAboutAmbiguity( 'expression', this.ractive );\n  \t}\n\n  \t// TODO include index/key/keypath refs as read-only\n  \telse if ( model.isReadonly ) {\n  \t\tvar keypath = model.getKeypath().replace( /^@/, '' );\n  \t\twarnOnceIfDebug( (\"Cannot use two-way binding on <\" + (element.name) + \"> element: \" + keypath + \" is read-only. To suppress this warning use <\" + (element.name) + \" twoway='false'...>\"), { ractive: this.ractive });\n  \t\treturn false;\n  \t}\n\n  \tthis.attribute.isTwoway = true;\n  \tthis.model = model;\n\n  \t// initialise value, if it's undefined\n  \tvar value = model.get();\n  \tthis.wasUndefined = value === undefined;\n\n  \tif ( value === undefined && this.getInitialValue ) {\n  \t\tvalue = this.getInitialValue();\n  \t\tmodel.set( value );\n  \t}\n  \tthis.lastVal( true, value );\n\n  \tvar parentForm = findElement( this.element, false, 'form' );\n  \tif ( parentForm ) {\n  \t\tthis.resetValue = value;\n  \t\tparentForm.formBindings.push( this );\n  \t}\n  };\n\n  Binding.prototype.bind = function bind () {\n  \tthis.model.registerTwowayBinding( this );\n  };\n\n  Binding.prototype.handleChange = function handleChange () {\n  \tvar this$1 = this;\n\n  \t\tvar value = this.getValue();\n  \tif ( this.lastVal() === value ) return;\n\n  \trunloop.start( this.root );\n  \tthis.attribute.locked = true;\n  \tthis.model.set( value );\n  \tthis.lastVal( true, value );\n\n  \t// if the value changes before observers fire, unlock to be updatable cause something weird and potentially freezy is up\n  \tif ( this.model.get() !== value ) this.attribute.locked = false;\n  \telse runloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n\n  \trunloop.end();\n  };\n\n  Binding.prototype.lastVal = function lastVal ( setting, value ) {\n  \tif ( setting ) this.lastValue = value;\n  \telse return this.lastValue;\n  };\n\n  Binding.prototype.rebinding = function rebinding ( next, previous ) {\n  \tvar this$1 = this;\n\n  \t\tif ( this.model && this.model === previous ) previous.unregisterTwowayBinding( this );\n  \tif ( next ) {\n  \t\tthis.model = next;\n  \t\trunloop.scheduleTask( function () { return next.registerTwowayBinding( this$1 ); } );\n  \t}\n  };\n\n  Binding.prototype.render = function render () {\n  \tthis.node = this.element.node;\n  \tthis.node._ractive.binding = this;\n  \tthis.rendered = true; // TODO is this used anywhere?\n  };\n\n  \tBinding.prototype.setFromNode = function setFromNode ( node ) {\n  \t\tthis.model.set( node.value );\n  };\n\n  Binding.prototype.unbind = function unbind () {\n  \tthis.model.unregisterTwowayBinding( this );\n  };\n\n  Binding.prototype.unrender = function unrender () {\n  \t\t// noop?\n  \t};\n\n  // This is the handler for DOM events that would lead to a change in the model\n  // (i.e. change, sometimes, input, and occasionally click and keyup)\n  function handleDomEvent () {\n  \tthis._ractive.binding.handleChange();\n  }\n\n  var CheckboxBinding = (function (Binding) {\n  \tfunction CheckboxBinding ( element ) {\n  \t\tBinding.call( this, element, 'checked' );\n  \t}\n\n  \tCheckboxBinding.prototype = Object.create( Binding && Binding.prototype );\n  \tCheckboxBinding.prototype.constructor = CheckboxBinding;\n\n  \tCheckboxBinding.prototype.render = function render () {\n  \t\tBinding.prototype.render.call(this);\n\n  \t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\n  \t\tif ( this.node.attachEvent ) {\n  \t\t\tthis.node.addEventListener( 'click', handleDomEvent, false );\n  \t\t}\n  \t};\n\n  \tCheckboxBinding.prototype.unrender = function unrender () {\n  \t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n  \t\tthis.node.removeEventListener( 'click', handleDomEvent, false );\n  \t};\n\n  \tCheckboxBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\treturn !!this.element.getAttribute( 'checked' );\n  \t};\n\n  \tCheckboxBinding.prototype.getValue = function getValue () {\n  \t\treturn this.node.checked;\n  \t};\n\n  \tCheckboxBinding.prototype.setFromNode = function setFromNode ( node ) {\n  \t\tthis.model.set( node.checked );\n  \t};\n\n  \treturn CheckboxBinding;\n  }(Binding));\n\n  function getBindingGroup ( group, model, getValue ) {\n  \tvar hash = \"\" + group + \"-bindingGroup\";\n  \treturn model[hash] || ( model[ hash ] = new BindingGroup( hash, model, getValue ) );\n  }\n\n  var BindingGroup = function BindingGroup ( hash, model, getValue ) {\n  \tvar this$1 = this;\n\n  \t\tthis.model = model;\n  \tthis.hash = hash;\n  \tthis.getValue = function () {\n  \t\tthis$1.value = getValue.call(this$1);\n  \t\treturn this$1.value;\n  \t};\n\n  \tthis.bindings = [];\n  };\n\n  BindingGroup.prototype.add = function add ( binding ) {\n  \tthis.bindings.push( binding );\n  };\n\n  BindingGroup.prototype.bind = function bind () {\n  \tthis.value = this.model.get();\n  \tthis.model.registerTwowayBinding( this );\n  \tthis.bound = true;\n  };\n\n  BindingGroup.prototype.remove = function remove ( binding ) {\n  \tremoveFromArray( this.bindings, binding );\n  \tif ( !this.bindings.length ) {\n  \t\tthis.unbind();\n  \t}\n  };\n\n  BindingGroup.prototype.unbind = function unbind () {\n  \tthis.model.unregisterTwowayBinding( this );\n  \tthis.bound = false;\n  \tdelete this.model[this.hash];\n  };\n\n  var push$2 = [].push;\n\n  function getValue() {\n  \tvar all = this.bindings.filter(function ( b ) { return b.node && b.node.checked; }).map(function ( b ) { return b.element.getAttribute( 'value' ); });\n  \tvar res = [];\n  \tall.forEach(function ( v ) { if ( !arrayContains( res, v ) ) res.push( v ); });\n  \treturn res;\n  }\n\n  var CheckboxNameBinding = (function (Binding) {\n  \tfunction CheckboxNameBinding ( element ) {\n  \t\tBinding.call( this, element, 'name' );\n\n  \t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n  \t\t// Each input has a reference to an array containing it and its\n  \t\t// group, as two-way binding depends on being able to ascertain\n  \t\t// the status of all inputs within the group\n  \t\tthis.group = getBindingGroup( 'checkboxes', this.model, getValue );\n  \t\tthis.group.add( this );\n\n  \t\tif ( this.noInitialValue ) {\n  \t\t\tthis.group.noInitialValue = true;\n  \t\t}\n\n  \t\t// If no initial value was set, and this input is checked, we\n  \t\t// update the model\n  \t\tif ( this.group.noInitialValue && this.element.getAttribute( 'checked' ) ) {\n  \t\t\tvar existingValue = this.model.get();\n  \t\t\tvar bindingValue = this.element.getAttribute( 'value' );\n\n  \t\t\tif ( !arrayContains( existingValue, bindingValue ) ) {\n  \t\t\t\tpush$2.call( existingValue, bindingValue ); // to avoid triggering runloop with array adaptor\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tCheckboxNameBinding.prototype = Object.create( Binding && Binding.prototype );\n  \tCheckboxNameBinding.prototype.constructor = CheckboxNameBinding;\n\n  \tCheckboxNameBinding.prototype.bind = function bind () {\n  \t\tif ( !this.group.bound ) {\n  \t\t\tthis.group.bind();\n  \t\t}\n  \t};\n\n  \tCheckboxNameBinding.prototype.changed = function changed () {\n  \t\tvar wasChecked = !!this.isChecked;\n  \t\tthis.isChecked = this.node.checked;\n  \t\treturn this.isChecked === wasChecked;\n  \t};\n\n  \tCheckboxNameBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\t// This only gets called once per group (of inputs that\n  \t\t// share a name), because it only gets called if there\n  \t\t// isn't an initial value. By the same token, we can make\n  \t\t// a note of that fact that there was no initial value,\n  \t\t// and populate it using any `checked` attributes that\n  \t\t// exist (which users should avoid, but which we should\n  \t\t// support anyway to avoid breaking expectations)\n  \t\tthis.noInitialValue = true; // TODO are noInitialValue and wasUndefined the same thing?\n  \t\treturn [];\n  \t};\n\n  \tCheckboxNameBinding.prototype.getValue = function getValue$1 () {\n  \t\treturn this.group.value;\n  \t};\n\n  \tCheckboxNameBinding.prototype.handleChange = function handleChange () {\n  \t\tthis.isChecked = this.element.node.checked;\n  \t\tthis.group.value = this.model.get();\n  \t\tvar value = this.element.getAttribute( 'value' );\n  \t\tif ( this.isChecked && !arrayContains( this.group.value, value ) ) {\n  \t\t\tthis.group.value.push( value );\n  \t\t} else if ( !this.isChecked && arrayContains( this.group.value, value ) ) {\n  \t\t\tremoveFromArray( this.group.value, value );\n  \t\t}\n  \t\t// make sure super knows there's a change\n  \t\tthis.lastValue = null;\n  \t\tBinding.prototype.handleChange.call(this);\n  \t};\n\n  \tCheckboxNameBinding.prototype.render = function render () {\n  \t\tBinding.prototype.render.call(this);\n\n  \t\tvar node = this.node;\n\n  \t\tvar existingValue = this.model.get();\n  \t\tvar bindingValue = this.element.getAttribute( 'value' );\n\n  \t\tif ( isArray( existingValue ) ) {\n  \t\t\tthis.isChecked = arrayContains( existingValue, bindingValue );\n  \t\t} else {\n  \t\t\tthis.isChecked = existingValue == bindingValue;\n  \t\t}\n\n  \t\tnode.name = '{{' + this.model.getKeypath() + '}}';\n  \t\tnode.checked = this.isChecked;\n\n  \t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n  \t\t// in case of IE emergency, bind to click event as well\n  \t\tif ( node.attachEvent ) {\n  \t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n  \t\t}\n  \t};\n\n  \tCheckboxNameBinding.prototype.setFromNode = function setFromNode ( node ) {\n  \t\tthis.group.bindings.forEach( function ( binding ) { return binding.wasUndefined = true; } );\n\n  \t\tif ( node.checked ) {\n  \t\t\tvar valueSoFar = this.group.getValue();\n  \t\t\tvalueSoFar.push( this.element.getAttribute( 'value' ) );\n\n  \t\t\tthis.group.model.set( valueSoFar );\n  \t\t}\n  \t};\n\n  \tCheckboxNameBinding.prototype.unbind = function unbind () {\n  \t\tthis.group.remove( this );\n  \t};\n\n  \tCheckboxNameBinding.prototype.unrender = function unrender () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener( 'change', handleDomEvent, false );\n  \t\tnode.removeEventListener( 'click', handleDomEvent, false );\n  \t};\n\n  \treturn CheckboxNameBinding;\n  }(Binding));\n\n  var ContentEditableBinding = (function (Binding) {\n  \tfunction ContentEditableBinding () {\n  \t\tBinding.apply(this, arguments);\n  \t}\n\n  \tContentEditableBinding.prototype = Object.create( Binding && Binding.prototype );\n  \tContentEditableBinding.prototype.constructor = ContentEditableBinding;\n\n  \tContentEditableBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\treturn this.element.fragment ? this.element.fragment.toString() : '';\n  \t};\n\n  \tContentEditableBinding.prototype.getValue = function getValue () {\n  \t\treturn this.element.node.innerHTML;\n  \t};\n\n  \tContentEditableBinding.prototype.render = function render () {\n  \t\tBinding.prototype.render.call(this);\n\n  \t\tvar node = this.node;\n\n  \t\tnode.addEventListener( 'change', handleDomEvent, false );\n  \t\tnode.addEventListener( 'blur', handleDomEvent, false );\n\n  \t\tif ( !this.ractive.lazy ) {\n  \t\t\tnode.addEventListener( 'input', handleDomEvent, false );\n\n  \t\t\tif ( node.attachEvent ) {\n  \t\t\t\tnode.addEventListener( 'keyup', handleDomEvent, false );\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \tContentEditableBinding.prototype.setFromNode = function setFromNode ( node ) {\n  \t\tthis.model.set( node.innerHTML );\n  \t};\n\n  \tContentEditableBinding.prototype.unrender = function unrender () {\n  \t\tvar node = this.node;\n\n  \t\tnode.removeEventListener( 'blur', handleDomEvent, false );\n  \t\tnode.removeEventListener( 'change', handleDomEvent, false );\n  \t\tnode.removeEventListener( 'input', handleDomEvent, false );\n  \t\tnode.removeEventListener( 'keyup', handleDomEvent, false );\n  \t};\n\n  \treturn ContentEditableBinding;\n  }(Binding));\n\n  function handleBlur () {\n  \thandleDomEvent.call( this );\n\n  \tvar value = this._ractive.binding.model.get();\n  \tthis.value = value == undefined ? '' : value;\n  }\n\n  function handleDelay ( delay ) {\n  \tvar timeout;\n\n  \treturn function () {\n  \t\tvar this$1 = this;\n\n  \t\tif ( timeout ) clearTimeout( timeout );\n\n  \t\ttimeout = setTimeout( function () {\n  \t\t\tvar binding = this$1._ractive.binding;\n  \t\t\tif ( binding.rendered ) handleDomEvent.call( this$1 );\n  \t\t\ttimeout = null;\n  \t\t}, delay );\n  \t};\n  }\n\n  var GenericBinding = (function (Binding) {\n  \tfunction GenericBinding () {\n  \t\tBinding.apply(this, arguments);\n  \t}\n\n  \tGenericBinding.prototype = Object.create( Binding && Binding.prototype );\n  \tGenericBinding.prototype.constructor = GenericBinding;\n\n  \tGenericBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\treturn '';\n  \t};\n\n  \tGenericBinding.prototype.getValue = function getValue () {\n  \t\treturn this.node.value;\n  \t};\n\n  \tGenericBinding.prototype.render = function render () {\n  \t\tBinding.prototype.render.call(this);\n\n  \t\t// any lazy setting for this element overrides the root\n  \t\t// if the value is a number, it's a timeout\n  \t\tvar lazy = this.ractive.lazy;\n  \t\tvar timeout = false;\n\n  \t\tif ( 'lazy' in this.element ) {\n  \t\t\tlazy = this.element.lazy;\n  \t\t}\n\n  \t\tif ( isNumeric( lazy ) ) {\n  \t\t\ttimeout = +lazy;\n  \t\t\tlazy = false;\n  \t\t}\n\n  \t\tthis.handler = timeout ? handleDelay( timeout ) : handleDomEvent;\n\n  \t\tvar node = this.node;\n\n  \t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n  \t\tif ( !lazy ) {\n  \t\t\tnode.addEventListener( 'input', this.handler, false );\n\n  \t\t\tif ( node.attachEvent ) {\n  \t\t\t\tnode.addEventListener( 'keyup', this.handler, false );\n  \t\t\t}\n  \t\t}\n\n  \t\tnode.addEventListener( 'blur', handleBlur, false );\n  \t};\n\n  \tGenericBinding.prototype.unrender = function unrender () {\n  \t\tvar node = this.element.node;\n  \t\tthis.rendered = false;\n\n  \t\tnode.removeEventListener( 'change', handleDomEvent, false );\n  \t\tnode.removeEventListener( 'input', this.handler, false );\n  \t\tnode.removeEventListener( 'keyup', this.handler, false );\n  \t\tnode.removeEventListener( 'blur', handleBlur, false );\n  \t};\n\n  \treturn GenericBinding;\n  }(Binding));\n\n  var FileBinding = (function (GenericBinding) {\n  \tfunction FileBinding () {\n  \t\tGenericBinding.apply(this, arguments);\n  \t}\n\n  \tFileBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n  \tFileBinding.prototype.constructor = FileBinding;\n\n  \tFileBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\treturn undefined;\n  \t};\n\n  \tFileBinding.prototype.getValue = function getValue () {\n  \t\treturn this.node.files;\n  \t};\n\n  \tFileBinding.prototype.render = function render () {\n  \t\tthis.element.lazy = false;\n  \t\tGenericBinding.prototype.render.call(this);\n  \t};\n\n  \tFileBinding.prototype.setFromNode = function setFromNode( node ) {\n  \t\tthis.model.set( node.files );\n  \t};\n\n  \treturn FileBinding;\n  }(GenericBinding));\n\n  function getSelectedOptions ( select ) {\n      return select.selectedOptions\n  \t\t? toArray( select.selectedOptions )\n  \t\t: select.options\n  \t\t\t? toArray( select.options ).filter( function ( option ) { return option.selected; } )\n  \t\t\t: [];\n  }\n\n  var MultipleSelectBinding = (function (Binding) {\n  \tfunction MultipleSelectBinding () {\n  \t\tBinding.apply(this, arguments);\n  \t}\n\n  \tMultipleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n  \tMultipleSelectBinding.prototype.constructor = MultipleSelectBinding;\n\n  \tMultipleSelectBinding.prototype.forceUpdate = function forceUpdate () {\n  \t\tvar this$1 = this;\n\n  \t\tvar value = this.getValue();\n\n  \t\tif ( value !== undefined ) {\n  \t\t\tthis.attribute.locked = true;\n  \t\t\trunloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n  \t\t\tthis.model.set( value );\n  \t\t}\n  \t};\n\n  \tMultipleSelectBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\treturn this.element.options\n  \t\t\t.filter( function ( option ) { return option.getAttribute( 'selected' ); } )\n  \t\t\t.map( function ( option ) { return option.getAttribute( 'value' ); } );\n  \t};\n\n  \tMultipleSelectBinding.prototype.getValue = function getValue () {\n  \t\tvar options = this.element.node.options;\n  \t\tvar len = options.length;\n\n  \t\tvar selectedValues = [];\n\n  \t\tfor ( var i = 0; i < len; i += 1 ) {\n  \t\t\tvar option = options[i];\n\n  \t\t\tif ( option.selected ) {\n  \t\t\t\tvar optionValue = option._ractive ? option._ractive.value : option.value;\n  \t\t\t\tselectedValues.push( optionValue );\n  \t\t\t}\n  \t\t}\n\n  \t\treturn selectedValues;\n  \t};\n\n  \tMultipleSelectBinding.prototype.handleChange = function handleChange () {\n  \t\tvar attribute = this.attribute;\n  \t\tvar previousValue = attribute.getValue();\n\n  \t\tvar value = this.getValue();\n\n  \t\tif ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {\n  \t\t\tBinding.prototype.handleChange.call(this);\n  \t\t}\n\n  \t\treturn this;\n  \t};\n\n  \tMultipleSelectBinding.prototype.render = function render () {\n  \t\tBinding.prototype.render.call(this);\n\n  \t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\n  \t\tif ( this.model.get() === undefined ) {\n  \t\t\t// get value from DOM, if possible\n  \t\t\tthis.handleChange();\n  \t\t}\n  \t};\n\n  \tMultipleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {\n  \t\tvar selectedOptions = getSelectedOptions( node );\n  \t\tvar i = selectedOptions.length;\n  \t\tvar result = new Array( i );\n\n  \t\twhile ( i-- ) {\n  \t\t\tvar option = selectedOptions[i];\n  \t\t\tresult[i] = option._ractive ? option._ractive.value : option.value;\n  \t\t}\n\n  \t\tthis.model.set( result );\n  \t};\n\n  \tMultipleSelectBinding.prototype.setValue = function setValue () {\n  \t\tthrow new Error( 'TODO not implemented yet' );\n  \t};\n\n  \tMultipleSelectBinding.prototype.unrender = function unrender () {\n  \t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n  \t};\n\n  \tMultipleSelectBinding.prototype.updateModel = function updateModel () {\n  \t\tif ( this.attribute.value === undefined || !this.attribute.value.length ) {\n  \t\t\tthis.keypath.set( this.initialValue );\n  \t\t}\n  \t};\n\n  \treturn MultipleSelectBinding;\n  }(Binding));\n\n  var NumericBinding = (function (GenericBinding) {\n  \tfunction NumericBinding () {\n  \t\tGenericBinding.apply(this, arguments);\n  \t}\n\n  \tNumericBinding.prototype = Object.create( GenericBinding && GenericBinding.prototype );\n  \tNumericBinding.prototype.constructor = NumericBinding;\n\n  \tNumericBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\treturn undefined;\n  \t};\n\n  \tNumericBinding.prototype.getValue = function getValue () {\n  \t\tvar value = parseFloat( this.node.value );\n  \t\treturn isNaN( value ) ? undefined : value;\n  \t};\n\n  \tNumericBinding.prototype.setFromNode = function setFromNode( node ) {\n  \t\tvar value = parseFloat( node.value );\n  \t\tif ( !isNaN( value ) ) this.model.set( value );\n  \t};\n\n  \treturn NumericBinding;\n  }(GenericBinding));\n\n  var siblings = {};\n\n  function getSiblings ( hash ) {\n  \treturn siblings[ hash ] || ( siblings[ hash ] = [] );\n  }\n\n  var RadioBinding = (function (Binding) {\n  \tfunction RadioBinding ( element ) {\n  \t\tBinding.call( this, element, 'checked' );\n\n  \t\tthis.siblings = getSiblings( this.ractive._guid + this.element.getAttribute( 'name' ) );\n  \t\tthis.siblings.push( this );\n  \t}\n\n  \tRadioBinding.prototype = Object.create( Binding && Binding.prototype );\n  \tRadioBinding.prototype.constructor = RadioBinding;\n\n  \tRadioBinding.prototype.getValue = function getValue () {\n  \t\treturn this.node.checked;\n  \t};\n\n  \tRadioBinding.prototype.handleChange = function handleChange () {\n  \t\trunloop.start( this.root );\n\n  \t\tthis.siblings.forEach( function ( binding ) {\n  \t\t\tbinding.model.set( binding.getValue() );\n  \t\t});\n\n  \t\trunloop.end();\n  \t};\n\n  \tRadioBinding.prototype.render = function render () {\n  \t\tBinding.prototype.render.call(this);\n\n  \t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n\n  \t\tif ( this.node.attachEvent ) {\n  \t\t\tthis.node.addEventListener( 'click', handleDomEvent, false );\n  \t\t}\n  \t};\n\n  \tRadioBinding.prototype.setFromNode = function setFromNode ( node ) {\n  \t\tthis.model.set( node.checked );\n  \t};\n\n  \tRadioBinding.prototype.unbind = function unbind () {\n  \t\tremoveFromArray( this.siblings, this );\n  \t};\n\n  \tRadioBinding.prototype.unrender = function unrender () {\n  \t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n  \t\tthis.node.removeEventListener( 'click', handleDomEvent, false );\n  \t};\n\n  \treturn RadioBinding;\n  }(Binding));\n\n  function getValue$1() {\n  \tvar checked = this.bindings.filter( function ( b ) { return b.node.checked; } );\n  \tif ( checked.length > 0 ) {\n  \t\treturn checked[0].element.getAttribute( 'value' );\n  \t}\n  }\n\n  var RadioNameBinding = (function (Binding) {\n  \tfunction RadioNameBinding ( element ) {\n  \t\tBinding.call( this, element, 'name' );\n\n  \t\tthis.group = getBindingGroup( 'radioname', this.model, getValue$1 );\n  \t\tthis.group.add( this );\n\n  \t\tif ( element.checked ) {\n  \t\t\tthis.group.value = this.getValue();\n  \t\t}\n  \t}\n\n  \tRadioNameBinding.prototype = Object.create( Binding && Binding.prototype );\n  \tRadioNameBinding.prototype.constructor = RadioNameBinding;\n\n  \tRadioNameBinding.prototype.bind = function bind () {\n  \t\tvar this$1 = this;\n\n  \t\tif ( !this.group.bound ) {\n  \t\t\tthis.group.bind();\n  \t\t}\n\n  \t\t// update name keypath when necessary\n  \t\tthis.nameAttributeBinding = {\n  \t\t\thandleChange: function () { return this$1.node.name = \"{{\" + (this$1.model.getKeypath()) + \"}}\"; }\n  \t\t};\n\n  \t\tthis.model.getKeypathModel().register( this.nameAttributeBinding );\n  \t};\n\n  \tRadioNameBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\tif ( this.element.getAttribute( 'checked' ) ) {\n  \t\t\treturn this.element.getAttribute( 'value' );\n  \t\t}\n  \t};\n\n  \tRadioNameBinding.prototype.getValue = function getValue$1 () {\n  \t\treturn this.element.getAttribute( 'value' );\n  \t};\n\n  \tRadioNameBinding.prototype.handleChange = function handleChange () {\n  \t\t// If this <input> is the one that's checked, then the value of its\n  \t\t// `name` model gets set to its value\n  \t\tif ( this.node.checked ) {\n  \t\t\tthis.group.value = this.getValue();\n  \t\t\tBinding.prototype.handleChange.call(this);\n  \t\t}\n  \t};\n\n  \tRadioNameBinding.prototype.lastVal = function lastVal ( setting, value ) {\n  \t\tif ( !this.group ) return;\n  \t\tif ( setting ) this.group.lastValue = value;\n  \t\telse return this.group.lastValue;\n  \t};\n\n  \tRadioNameBinding.prototype.render = function render () {\n  \t\tBinding.prototype.render.call(this);\n\n  \t\tvar node = this.node;\n\n  \t\tnode.name = \"{{\" + (this.model.getKeypath()) + \"}}\";\n  \t\tnode.checked = this.model.get() == this.element.getAttribute( 'value' );\n\n  \t\tnode.addEventListener( 'change', handleDomEvent, false );\n\n  \t\tif ( node.attachEvent ) {\n  \t\t\tnode.addEventListener( 'click', handleDomEvent, false );\n  \t\t}\n  \t};\n\n  \tRadioNameBinding.prototype.setFromNode = function setFromNode ( node ) {\n  \t\tif ( node.checked ) {\n  \t\t\tthis.group.model.set( this.element.getAttribute( 'value' ) );\n  \t\t}\n  \t};\n\n  \tRadioNameBinding.prototype.unbind = function unbind () {\n  \t\tthis.group.remove( this );\n\n  \t\tthis.model.getKeypathModel().unregister( this.nameAttributeBinding );\n  \t};\n\n  \tRadioNameBinding.prototype.unrender = function unrender () {\n  \t\tvar node = this.node;\n\n  \t\tnode.removeEventListener( 'change', handleDomEvent, false );\n  \t\tnode.removeEventListener( 'click', handleDomEvent, false );\n  \t};\n\n  \treturn RadioNameBinding;\n  }(Binding));\n\n  var SingleSelectBinding = (function (Binding) {\n  \tfunction SingleSelectBinding () {\n  \t\tBinding.apply(this, arguments);\n  \t}\n\n  \tSingleSelectBinding.prototype = Object.create( Binding && Binding.prototype );\n  \tSingleSelectBinding.prototype.constructor = SingleSelectBinding;\n\n  \tSingleSelectBinding.prototype.forceUpdate = function forceUpdate () {\n  \t\tvar this$1 = this;\n\n  \t\tvar value = this.getValue();\n\n  \t\tif ( value !== undefined ) {\n  \t\t\tthis.attribute.locked = true;\n  \t\t\trunloop.scheduleTask( function () { return this$1.attribute.locked = false; } );\n  \t\t\tthis.model.set( value );\n  \t\t}\n  \t};\n\n  \tSingleSelectBinding.prototype.getInitialValue = function getInitialValue () {\n  \t\tif ( this.element.getAttribute( 'value' ) !== undefined ) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar options = this.element.options;\n  \t\tvar len = options.length;\n\n  \t\tif ( !len ) return;\n\n  \t\tvar value;\n  \t\tvar optionWasSelected;\n  \t\tvar i = len;\n\n  \t\t// take the final selected option...\n  \t\twhile ( i-- ) {\n  \t\t\tvar option = options[i];\n\n  \t\t\tif ( option.getAttribute( 'selected' ) ) {\n  \t\t\t\tif ( !option.getAttribute( 'disabled' ) ) {\n  \t\t\t\t\tvalue = option.getAttribute( 'value' );\n  \t\t\t\t}\n\n  \t\t\t\toptionWasSelected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n\n  \t\t// or the first non-disabled option, if none are selected\n  \t\tif ( !optionWasSelected ) {\n  \t\t\twhile ( ++i < len ) {\n  \t\t\t\tif ( !options[i].getAttribute( 'disabled' ) ) {\n  \t\t\t\t\tvalue = options[i].getAttribute( 'value' );\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// This is an optimisation (aka hack) that allows us to forgo some\n  \t\t// other more expensive work\n  \t\t// TODO does it still work? seems at odds with new architecture\n  \t\tif ( value !== undefined ) {\n  \t\t\tthis.element.attributeByName.value.value = value;\n  \t\t}\n\n  \t\treturn value;\n  \t};\n\n  \tSingleSelectBinding.prototype.getValue = function getValue () {\n  \t\tvar options = this.node.options;\n  \t\tvar len = options.length;\n\n  \t\tvar i;\n  \t\tfor ( i = 0; i < len; i += 1 ) {\n  \t\t\tvar option = options[i];\n\n  \t\t\tif ( options[i].selected && !options[i].disabled ) {\n  \t\t\t\treturn option._ractive ? option._ractive.value : option.value;\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \tSingleSelectBinding.prototype.render = function render () {\n  \t\tBinding.prototype.render.call(this);\n  \t\tthis.node.addEventListener( 'change', handleDomEvent, false );\n  \t};\n\n  \tSingleSelectBinding.prototype.setFromNode = function setFromNode ( node ) {\n  \t\tvar option = getSelectedOptions( node )[0];\n  \t\tthis.model.set( option._ractive ? option._ractive.value : option.value );\n  \t};\n\n  \t// TODO this method is an anomaly... is it necessary?\n  \tSingleSelectBinding.prototype.setValue = function setValue ( value ) {\n  \t\tthis.model.set( value );\n  \t};\n\n  \tSingleSelectBinding.prototype.unrender = function unrender () {\n  \t\tthis.node.removeEventListener( 'change', handleDomEvent, false );\n  \t};\n\n  \treturn SingleSelectBinding;\n  }(Binding));\n\n  function isBindable ( attribute ) {\n  \treturn attribute &&\n  \t\t   attribute.template.f &&\n  \t       attribute.template.f.length === 1 &&\n  \t       attribute.template.f[0].t === INTERPOLATOR &&\n  \t       !attribute.template.f[0].s;\n  }\n\n  function selectBinding ( element ) {\n  \tvar attributes = element.attributeByName;\n\n  \t// contenteditable - bind if the contenteditable attribute is true\n  \t// or is bindable and may thus become true...\n  \tif ( element.getAttribute( 'contenteditable' ) || isBindable( attributes.contenteditable ) ) {\n  \t\t// ...and this element also has a value attribute to bind\n  \t\treturn isBindable( attributes.value ) ? ContentEditableBinding : null;\n  \t}\n\n  \t// <input>\n  \tif ( element.name === 'input' ) {\n  \t\tvar type = element.getAttribute( 'type' );\n\n  \t\tif ( type === 'radio' || type === 'checkbox' ) {\n  \t\t\tvar bindName = isBindable( attributes.name );\n  \t\t\tvar bindChecked = isBindable( attributes.checked );\n\n  \t\t\t// for radios we can either bind the name attribute, or the checked attribute - not both\n  \t\t\tif ( bindName && bindChecked ) {\n  \t\t\t\tif ( type === 'radio' ) {\n  \t\t\t\t\twarnIfDebug( 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both', { ractive: element.root });\n  \t\t\t\t} else {\n  \t\t\t\t\t// A checkbox with bindings for both name and checked - see https://github.com/ractivejs/ractive/issues/1749\n  \t\t\t\t\treturn CheckboxBinding;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tif ( bindName ) {\n  \t\t\t\treturn type === 'radio' ? RadioNameBinding : CheckboxNameBinding;\n  \t\t\t}\n\n  \t\t\tif ( bindChecked ) {\n  \t\t\t\treturn type === 'radio' ? RadioBinding : CheckboxBinding;\n  \t\t\t}\n  \t\t}\n\n  \t\tif ( type === 'file' && isBindable( attributes.value ) ) {\n  \t\t\treturn FileBinding;\n  \t\t}\n\n  \t\tif ( isBindable( attributes.value ) ) {\n  \t\t\treturn ( type === 'number' || type === 'range' ) ? NumericBinding : GenericBinding;\n  \t\t}\n\n  \t\treturn null;\n  \t}\n\n  \t// <select>\n  \tif ( element.name === 'select' && isBindable( attributes.value ) ) {\n  \t\treturn element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SingleSelectBinding;\n  \t}\n\n  \t// <textarea>\n  \tif ( element.name === 'textarea' && isBindable( attributes.value ) ) {\n  \t\treturn GenericBinding;\n  \t}\n  }\n\n  function makeDirty$1 ( query ) {\n  \tquery.makeDirty();\n  }\n\n  var endsWithSemi = /;\\s*$/;\n\n  var Element = (function (Item) {\n  \tfunction Element ( options ) {\n  \t\tvar this$1 = this;\n\n  \t\tItem.call( this, options );\n\n  \t\tthis.liveQueries = []; // TODO rare case. can we handle differently?\n\n  \t\tthis.name = options.template.e.toLowerCase();\n  \t\tthis.isVoid = voidElementNames.test( this.name );\n\n  \t\t// find parent element\n  \t\tthis.parent = findElement( this.parentFragment, false );\n\n  \t\tif ( this.parent && this.parent.name === 'option' ) {\n  \t\t\tthrow new Error( (\"An <option> element cannot contain other elements (encountered <\" + (this.name) + \">)\") );\n  \t\t}\n\n  \t\tthis.decorators = [];\n\n  \t\t// create attributes\n  \t\tthis.attributeByName = {};\n\n  \t\tthis.attributes = [];\n  \t\tvar leftovers = [];\n  \t\t( this.template.m || [] ).forEach( function ( template ) {\n  \t\t\tswitch ( template.t ) {\n  \t\t\t\tcase ATTRIBUTE:\n  \t\t\t\tcase BINDING_FLAG:\n  \t\t\t\tcase DECORATOR:\n  \t\t\t\tcase EVENT:\n  \t\t\t\tcase TRANSITION:\n  \t\t\t\t\tthis$1.attributes.push( createItem({\n  \t\t\t\t\t\towner: this$1,\n  \t\t\t\t\t\tparentFragment: this$1.parentFragment,\n  \t\t\t\t\t\ttemplate: template\n  \t\t\t\t\t}) );\n  \t\t\t\t\tbreak;\n\n  \t\t\t\tdefault:\n  \t\t\t\t\tleftovers.push( template );\n  \t\t\t\t\tbreak;\n  \t\t\t}\n  \t\t});\n\n  \t\tif ( leftovers.length ) {\n  \t\t\tthis.attributes.push( new ConditionalAttribute({\n  \t\t\t\towner: this,\n  \t\t\t\tparentFragment: this.parentFragment,\n  \t\t\t\ttemplate: leftovers\n  \t\t\t}) );\n  \t\t}\n\n  \t\tvar i = this.attributes.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar attr = this$1.attributes[ i ];\n  \t\t\tif ( attr.name === 'type' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n  \t\t\telse if ( attr.name === 'max' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n  \t\t\telse if ( attr.name === 'min' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n  \t\t\telse if ( attr.name === 'class' ) this$1.attributes.unshift( this$1.attributes.splice( i, 1 )[ 0 ] );\n  \t\t\telse if ( attr.name === 'value' ) {\n  \t\t\t\tthis$1.attributes.push( this$1.attributes.splice( i, 1 )[ 0 ] );\n  \t\t\t}\n  \t\t}\n\n  \t\t// create children\n  \t\tif ( options.template.f && !options.deferContent ) {\n  \t\t\tthis.fragment = new Fragment({\n  \t\t\t\ttemplate: options.template.f,\n  \t\t\t\towner: this,\n  \t\t\t\tcssIds: null\n  \t\t\t});\n  \t\t}\n\n  \t\tthis.binding = null; // filled in later\n  \t}\n\n  \tElement.prototype = Object.create( Item && Item.prototype );\n  \tElement.prototype.constructor = Element;\n\n  \tElement.prototype.bind = function bind$1$$ () {\n  \t\tthis.attributes.binding = true;\n  \t\tthis.attributes.forEach( bind$1 );\n  \t\tthis.attributes.binding = false;\n\n  \t\tif ( this.fragment ) this.fragment.bind();\n\n  \t\t// create two-way binding if necessary\n  \t\tif ( !this.binding ) this.recreateTwowayBinding();\n  \t};\n\n  \tElement.prototype.createTwowayBinding = function createTwowayBinding () {\n  \t\tvar shouldBind = 'twoway' in this ? this.twoway : this.ractive.twoway;\n\n  \t\tif ( !shouldBind ) return null;\n\n  \t\tvar Binding = selectBinding( this );\n\n  \t\tif ( !Binding ) return null;\n\n  \t\tvar binding = new Binding( this );\n\n  \t\treturn binding && binding.model ?\n  \t\t\tbinding :\n  \t\t\tnull;\n  \t};\n\n  \tElement.prototype.destroyed = function destroyed () {\n  \t\tthis.attributes.forEach( function ( a ) { return a.destroyed(); } );\n  \t\tif ( this.fragment ) this.fragment.destroyed();\n  \t};\n\n  \tElement.prototype.detach = function detach () {\n  \t\t// if this element is no longer rendered, the transitions are complete and the attributes can be torn down\n  \t\tif ( !this.rendered ) this.destroyed();\n\n  \t\treturn detachNode( this.node );\n  \t};\n\n  \tElement.prototype.find = function find ( selector ) {\n  \t\tif ( matches( this.node, selector ) ) return this.node;\n  \t\tif ( this.fragment ) {\n  \t\t\treturn this.fragment.find( selector );\n  \t\t}\n  \t};\n\n  \tElement.prototype.findAll = function findAll ( selector, query ) {\n  \t\t// Add this node to the query, if applicable, and register the\n  \t\t// query on this element\n  \t\tvar matches = query.test( this.node );\n  \t\tif ( matches ) {\n  \t\t\tquery.add( this.node );\n  \t\t\tif ( query.live ) this.liveQueries.push( query );\n  \t\t}\n\n  \t\tif ( this.fragment ) {\n  \t\t\tthis.fragment.findAll( selector, query );\n  \t\t}\n  \t};\n\n  \tElement.prototype.findComponent = function findComponent ( name ) {\n  \t\tif ( this.fragment ) {\n  \t\t\treturn this.fragment.findComponent( name );\n  \t\t}\n  \t};\n\n  \tElement.prototype.findAllComponents = function findAllComponents ( name, query ) {\n  \t\tif ( this.fragment ) {\n  \t\t\tthis.fragment.findAllComponents( name, query );\n  \t\t}\n  \t};\n\n  \tElement.prototype.findNextNode = function findNextNode () {\n  \t\treturn null;\n  \t};\n\n  \tElement.prototype.firstNode = function firstNode () {\n  \t\treturn this.node;\n  \t};\n\n  \tElement.prototype.getAttribute = function getAttribute ( name ) {\n  \t\tvar attribute = this.attributeByName[ name ];\n  \t\treturn attribute ? attribute.getValue() : undefined;\n  \t};\n\n  \tElement.prototype.recreateTwowayBinding = function recreateTwowayBinding () {\n  \t\tif ( this.binding ) {\n  \t\t\tthis.binding.unbind();\n  \t\t\tthis.binding.unrender();\n  \t\t}\n\n  \t\tif ( this.binding = this.createTwowayBinding() ) {\n  \t\t\tthis.binding.bind();\n  \t\t\tif ( this.rendered ) this.binding.render();\n  \t\t}\n  \t};\n\n  \tElement.prototype.render = function render$1 ( target, occupants ) {\n  \t\t// TODO determine correct namespace\n  \t\tvar this$1 = this;\n\n  \t\tthis.namespace = getNamespace( this );\n\n  \t\tvar node;\n  \t\tvar existing = false;\n\n  \t\tif ( occupants ) {\n  \t\t\tvar n;\n  \t\t\twhile ( ( n = occupants.shift() ) ) {\n  \t\t\t\tif ( n.nodeName.toUpperCase() === this$1.template.e.toUpperCase() && n.namespaceURI === this$1.namespace ) {\n  \t\t\t\t\tthis$1.node = node = n;\n  \t\t\t\t\texisting = true;\n  \t\t\t\t\tbreak;\n  \t\t\t\t} else {\n  \t\t\t\t\tdetachNode( n );\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tif ( !node ) {\n  \t\t\tnode = createElement( this.template.e, this.namespace, this.getAttribute( 'is' ) );\n  \t\t\tthis.node = node;\n  \t\t}\n\n  \t\tdefineProperty( node, '_ractive', {\n  \t\t\tvalue: {\n  \t\t\t\tproxy: this\n  \t\t\t}\n  \t\t});\n\n  \t\t// Is this a top-level node of a component? If so, we may need to add\n  \t\t// a data-ractive-css attribute, for CSS encapsulation\n  \t\tif ( this.parentFragment.cssIds ) {\n  \t\t\tnode.setAttribute( 'data-ractive-css', this.parentFragment.cssIds.map( function ( x ) { return (\"{\" + x + \"}\"); } ).join( ' ' ) );\n  \t\t}\n\n  \t\tif ( existing && this.foundNode ) this.foundNode( node );\n\n  \t\tif ( this.fragment ) {\n  \t\t\tvar children = existing ? toArray( node.childNodes ) : undefined;\n\n  \t\t\tthis.fragment.render( node, children );\n\n  \t\t\t// clean up leftover children\n  \t\t\tif ( children ) {\n  \t\t\t\tchildren.forEach( detachNode );\n  \t\t\t}\n  \t\t}\n\n  \t\tif ( existing ) {\n  \t\t\t// store initial values for two-way binding\n  \t\t\tif ( this.binding && this.binding.wasUndefined ) this.binding.setFromNode( node );\n  \t\t\t// remove unused attributes\n  \t\t\tvar i = node.attributes.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tvar name = node.attributes[i].name;\n  \t\t\t\tif ( !( name in this$1.attributeByName ) ) node.removeAttribute( name );\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.attributes.forEach( render );\n\n  \t\tif ( this.binding ) this.binding.render();\n\n  \t\tupdateLiveQueries$1( this );\n\n  \t\tif ( this._introTransition && this.ractive.transitionsEnabled ) {\n  \t\t\tthis._introTransition.isIntro = true;\n  \t\t\trunloop.registerTransition( this._introTransition );\n  \t\t}\n\n  \t\tif ( !existing ) {\n  \t\t\ttarget.appendChild( node );\n  \t\t}\n\n  \t\tthis.rendered = true;\n  \t};\n\n  \tElement.prototype.shuffled = function shuffled () {\n  \t\tthis.liveQueries.forEach( makeDirty$1 );\n  \t\tItem.prototype.shuffled.call(this);\n  \t};\n\n  \tElement.prototype.toString = function toString () {\n  \t\tvar tagName = this.template.e;\n\n  \t\tvar attrs = this.attributes.map( stringifyAttribute ).join( '' );\n\n  \t\t// Special case - selected options\n  \t\tif ( this.name === 'option' && this.isSelected() ) {\n  \t\t\tattrs += ' selected';\n  \t\t}\n\n  \t\t// Special case - two-way radio name bindings\n  \t\tif ( this.name === 'input' && inputIsCheckedRadio( this ) ) {\n  \t\t\tattrs += ' checked';\n  \t\t}\n\n  \t\t// Special case style and class attributes and directives\n  \t\tvar style, cls;\n  \t\tthis.attributes.forEach( function ( attr ) {\n  \t\t\tif ( attr.name === 'class' ) {\n  \t\t\t\tcls = ( cls || '' ) + ( cls ? ' ' : '' ) + safeAttributeString( attr.getString() );\n  \t\t\t} else if ( attr.name === 'style' ) {\n  \t\t\t\tstyle = ( style || '' ) + ( style ? ' ' : '' ) + safeAttributeString( attr.getString() );\n  \t\t\t\tif ( style && !endsWithSemi.test( style ) ) style += ';';\n  \t\t\t} else if ( attr.styleName ) {\n  \t\t\t\tstyle = ( style || '' ) + ( style ? ' ' : '' ) +  \"\" + (decamelize( attr.styleName )) + \": \" + (safeAttributeString( attr.getString() )) + \";\";\n  \t\t\t} else if ( attr.inlineClass && attr.getValue() ) {\n  \t\t\t\tcls = ( cls || '' ) + ( cls ? ' ' : '' ) + attr.inlineClass;\n  \t\t\t}\n  \t\t});\n  \t\t// put classes first, then inline style\n  \t\tif ( style !== undefined ) attrs = ' style' + ( style ? (\"=\\\"\" + style + \"\\\"\") : '' ) + attrs;\n  \t\tif ( cls !== undefined ) attrs = ' class' + (cls ? (\"=\\\"\" + cls + \"\\\"\") : '') + attrs;\n\n  \t\tvar str = \"<\" + tagName + \"\" + attrs + \">\";\n\n  \t\tif ( this.isVoid ) return str;\n\n  \t\t// Special case - textarea\n  \t\tif ( this.name === 'textarea' && this.getAttribute( 'value' ) !== undefined ) {\n  \t\t\tstr += escapeHtml( this.getAttribute( 'value' ) );\n  \t\t}\n\n  \t\t// Special case - contenteditable\n  \t\telse if ( this.getAttribute( 'contenteditable' ) !== undefined ) {\n  \t\t\tstr += ( this.getAttribute( 'value' ) || '' );\n  \t\t}\n\n  \t\tif ( this.fragment ) {\n  \t\t\tstr += this.fragment.toString( !/^(?:script|style)$/i.test( this.template.e ) ); // escape text unless script/style\n  \t\t}\n\n  \t\tstr += \"</\" + tagName + \">\";\n  \t\treturn str;\n  \t};\n\n  \tElement.prototype.unbind = function unbind$1 () {\n  \t\tthis.attributes.forEach( unbind );\n\n  \t\tif ( this.binding ) this.binding.unbind();\n  \t\tif ( this.fragment ) this.fragment.unbind();\n  \t};\n\n  \tElement.prototype.unrender = function unrender ( shouldDestroy ) {\n  \t\tif ( !this.rendered ) return;\n  \t\tthis.rendered = false;\n\n  \t\t// unrendering before intro completed? complete it now\n  \t\t// TODO should be an API for aborting transitions\n  \t\tvar transition = this._introTransition;\n  \t\tif ( transition && transition.complete ) transition.complete();\n\n  \t\t// Detach as soon as we can\n  \t\tif ( this.name === 'option' ) {\n  \t\t\t// <option> elements detach immediately, so that\n  \t\t\t// their parent <select> element syncs correctly, and\n  \t\t\t// since option elements can't have transitions anyway\n  \t\t\tthis.detach();\n  \t\t} else if ( shouldDestroy ) {\n  \t\t\trunloop.detachWhenReady( this );\n  \t\t}\n\n  \t\tif ( this.fragment ) this.fragment.unrender();\n\n  \t\tif ( this.binding ) this.binding.unrender();\n\n  \t\t// outro transition\n  \t\tif ( this._outroTransition && this.ractive.transitionsEnabled ) {\n  \t\t\tthis._outroTransition.isIntro = false;\n  \t\t\trunloop.registerTransition( this._outroTransition );\n  \t\t}\n\n  \t\tremoveFromLiveQueries( this );\n  \t\t// TODO forms are a special case\n  \t};\n\n  \tElement.prototype.update = function update$1 () {\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n\n  \t\t\tthis.attributes.forEach( update );\n\n  \t\t\tif ( this.fragment ) this.fragment.update();\n  \t\t}\n  \t};\n\n  \treturn Element;\n  }(Item));\n\n  function inputIsCheckedRadio ( element ) {\n  \tvar attributes = element.attributeByName;\n\n  \tvar typeAttribute  = attributes.type;\n  \tvar valueAttribute = attributes.value;\n  \tvar nameAttribute  = attributes.name;\n\n  \tif ( !typeAttribute || ( typeAttribute.value !== 'radio' ) || !valueAttribute || !nameAttribute.interpolator ) {\n  \t\treturn;\n  \t}\n\n  \tif ( valueAttribute.getValue() === nameAttribute.interpolator.model.get() ) {\n  \t\treturn true;\n  \t}\n  }\n\n  function stringifyAttribute ( attribute ) {\n  \tvar str = attribute.toString();\n  \treturn str ? ' ' + str : '';\n  }\n\n  function removeFromLiveQueries ( element ) {\n  \tvar i = element.liveQueries.length;\n  \twhile ( i-- ) {\n  \t\tvar query = element.liveQueries[i];\n  \t\tquery.remove( element.node );\n  \t}\n  }\n\n  function getNamespace ( element ) {\n  \t// Use specified namespace...\n  \tvar xmlns = element.getAttribute( 'xmlns' );\n  \tif ( xmlns ) return xmlns;\n\n  \t// ...or SVG namespace, if this is an <svg> element\n  \tif ( element.name === 'svg' ) return svg$1;\n\n  \tvar parent = element.parent;\n\n  \tif ( parent ) {\n  \t\t// ...or HTML, if the parent is a <foreignObject>\n  \t\tif ( parent.name === 'foreignobject' ) return html;\n\n  \t\t// ...or inherit from the parent node\n  \t\treturn parent.node.namespaceURI;\n  \t}\n\n  \treturn element.ractive.el.namespaceURI;\n  }\n\n  var Form = (function (Element) {\n  \tfunction Form ( options ) {\n  \t\tElement.call( this, options );\n  \t\tthis.formBindings = [];\n  \t}\n\n  \tForm.prototype = Object.create( Element && Element.prototype );\n  \tForm.prototype.constructor = Form;\n\n  \tForm.prototype.render = function render ( target, occupants ) {\n  \t\tElement.prototype.render.call( this, target, occupants );\n  \t\tthis.node.addEventListener( 'reset', handleReset, false );\n  \t};\n\n  \tForm.prototype.unrender = function unrender ( shouldDestroy ) {\n  \t\tthis.node.removeEventListener( 'reset', handleReset, false );\n  \t\tElement.prototype.unrender.call( this, shouldDestroy );\n  \t};\n\n  \treturn Form;\n  }(Element));\n\n  function handleReset () {\n  \tvar element = this._ractive.proxy;\n\n  \trunloop.start();\n  \telement.formBindings.forEach( updateModel$1 );\n  \trunloop.end();\n  }\n\n  function updateModel$1 ( binding ) {\n  \tbinding.model.set( binding.resetValue );\n  }\n\n  var Mustache = (function (Item) {\n  \tfunction Mustache ( options ) {\n  \t\tItem.call( this, options );\n\n  \t\tthis.parentFragment = options.parentFragment;\n  \t\tthis.template = options.template;\n  \t\tthis.index = options.index;\n  \t\tif ( options.owner ) this.parent = options.owner;\n\n  \t\tthis.isStatic = !!options.template.s;\n\n  \t\tthis.model = null;\n  \t\tthis.dirty = false;\n  \t}\n\n  \tMustache.prototype = Object.create( Item && Item.prototype );\n  \tMustache.prototype.constructor = Mustache;\n\n  \tMustache.prototype.bind = function bind () {\n  \t\t// try to find a model for this view\n  \t\tvar this$1 = this;\n\n  \t\tvar model = resolve$2( this.parentFragment, this.template );\n  \t\tvar value = model ? model.get() : undefined;\n\n  \t\tif ( this.isStatic ) {\n  \t\t\tthis.model = { get: function () { return value; } };\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif ( model ) {\n  \t\t\tmodel.register( this );\n  \t\t\tthis.model = model;\n  \t\t} else {\n  \t\t\tthis.resolver = this.parentFragment.resolve( this.template.r, function ( model ) {\n  \t\t\t\tthis$1.model = model;\n  \t\t\t\tmodel.register( this$1 );\n\n  \t\t\t\tthis$1.handleChange();\n  \t\t\t\tthis$1.resolver = null;\n  \t\t\t});\n  \t\t}\n  \t};\n\n  \tMustache.prototype.handleChange = function handleChange () {\n  \t\tthis.bubble();\n  \t};\n\n  \tMustache.prototype.rebinding = function rebinding ( next, previous, safe ) {\n  \t\tnext = rebindMatch( this.template, next, previous );\n  \t\tif ( this['static'] ) return false;\n  \t\tif ( next === this.model ) return false;\n\n  \t\tif ( this.model ) {\n  \t\t\tthis.model.unregister( this );\n  \t\t}\n  \t\tif ( next ) next.addShuffleRegister( this, 'mark' );\n  \t\tthis.model = next;\n  \t\tif ( !safe ) this.handleChange();\n  \t\treturn true;\n  \t};\n\n  \tMustache.prototype.unbind = function unbind () {\n  \t\tif ( !this.isStatic ) {\n  \t\t\tthis.model && this.model.unregister( this );\n  \t\t\tthis.model = undefined;\n  \t\t\tthis.resolver && this.resolver.unbind();\n  \t\t}\n  \t};\n\n  \treturn Mustache;\n  }(Item));\n\n  var Interpolator = (function (Mustache) {\n  \tfunction Interpolator () {\n  \t\tMustache.apply(this, arguments);\n  \t}\n\n  \tInterpolator.prototype = Object.create( Mustache && Mustache.prototype );\n  \tInterpolator.prototype.constructor = Interpolator;\n\n  \tInterpolator.prototype.bubble = function bubble () {\n  \t\tif ( this.owner ) this.owner.bubble();\n  \t\tMustache.prototype.bubble.call(this);\n  \t};\n\n  \tInterpolator.prototype.detach = function detach () {\n  \t\treturn detachNode( this.node );\n  \t};\n\n  \tInterpolator.prototype.firstNode = function firstNode () {\n  \t\treturn this.node;\n  \t};\n\n  \tInterpolator.prototype.getString = function getString () {\n  \t\treturn this.model ? safeToStringValue( this.model.get() ) : '';\n  \t};\n\n  \tInterpolator.prototype.render = function render ( target, occupants ) {\n  \t\tif ( inAttributes() ) return;\n  \t\tvar value = this.getString();\n\n  \t\tthis.rendered = true;\n\n  \t\tif ( occupants ) {\n  \t\t\tvar n = occupants[0];\n  \t\t\tif ( n && n.nodeType === 3 ) {\n  \t\t\t\toccupants.shift();\n  \t\t\t\tif ( n.nodeValue !== value ) {\n  \t\t\t\t\tn.nodeValue = value;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tn = this.node = doc.createTextNode( value );\n  \t\t\t\tif ( occupants[0] ) {\n  \t\t\t\t\ttarget.insertBefore( n, occupants[0] );\n  \t\t\t\t} else {\n  \t\t\t\t\ttarget.appendChild( n );\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis.node = n;\n  \t\t} else {\n  \t\t\tthis.node = doc.createTextNode( value );\n  \t\t\ttarget.appendChild( this.node );\n  \t\t}\n  \t};\n\n  \tInterpolator.prototype.toString = function toString ( escape ) {\n  \t\tvar string = this.getString();\n  \t\treturn escape ? escapeHtml( string ) : string;\n  \t};\n\n  \tInterpolator.prototype.unrender = function unrender ( shouldDestroy ) {\n  \t\tif ( shouldDestroy ) this.detach();\n  \t\tthis.rendered = false;\n  \t};\n\n  \tInterpolator.prototype.update = function update () {\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n  \t\t\tif ( this.rendered ) {\n  \t\t\t\tthis.node.data = this.getString();\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \tInterpolator.prototype.valueOf = function valueOf () {\n  \t\treturn this.model ? this.model.get() : undefined;\n  \t};\n\n  \treturn Interpolator;\n  }(Mustache));\n\n  var Input = (function (Element) {\n  \tfunction Input () {\n  \t\tElement.apply(this, arguments);\n  \t}\n\n  \tInput.prototype = Object.create( Element && Element.prototype );\n  \tInput.prototype.constructor = Input;\n\n  \tInput.prototype.render = function render ( target, occupants ) {\n  \t\tElement.prototype.render.call( this, target, occupants );\n  \t\tthis.node.defaultValue = this.node.value;\n  \t};\n\n  \treturn Input;\n  }(Element));\n\n  var Mapping = (function (Item) {\n  \tfunction Mapping ( options ) {\n  \t\tItem.call( this, options );\n\n  \t\tthis.name = options.template.n;\n\n  \t\tthis.owner = options.owner || options.parentFragment.owner || options.element || findElement( options.parentFragment );\n  \t\tthis.element = options.element || (this.owner.attributeByName ? this.owner : findElement( options.parentFragment ) );\n  \t\tthis.parentFragment = this.element.parentFragment; // shared\n  \t\tthis.ractive = this.parentFragment.ractive;\n\n  \t\tthis.fragment = null;\n\n  \t\tthis.element.attributeByName[ this.name ] = this;\n\n  \t\tthis.value = options.template.f;\n  \t}\n\n  \tMapping.prototype = Object.create( Item && Item.prototype );\n  \tMapping.prototype.constructor = Mapping;\n\n  \tMapping.prototype.bind = function bind () {\n  \t\tif ( this.fragment ) {\n  \t\t\tthis.fragment.bind();\n  \t\t}\n\n  \t\tvar template = this.template.f;\n  \t\tvar viewmodel = this.element.instance.viewmodel;\n\n  \t\tif ( template === 0 ) {\n  \t\t\t// empty attributes are `true`\n  \t\t\tviewmodel.joinKey( this.name ).set( true );\n  \t\t}\n\n  \t\telse if ( typeof template === 'string' ) {\n  \t\t\tvar parsed = parseJSON( template );\n  \t\t\tviewmodel.joinKey( this.name ).set( parsed ? parsed.value : template );\n  \t\t}\n\n  \t\telse if ( isArray( template ) ) {\n  \t\t\tcreateMapping( this, true );\n  \t\t}\n  \t};\n\n  \tMapping.prototype.render = function render () {};\n\n  \tMapping.prototype.unbind = function unbind () {\n  \t\tif ( this.fragment ) this.fragment.unbind();\n  \t\tif ( this.boundFragment ) this.boundFragment.unbind();\n\n  \t\tif ( this.element.bound ) {\n  \t\t\tif ( this.link.target === this.model ) this.link.owner.unlink();\n  \t\t}\n  \t};\n\n  \tMapping.prototype.unrender = function unrender () {};\n\n  \tMapping.prototype.update = function update () {\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n  \t\t\tif ( this.fragment ) this.fragment.update();\n  \t\t\tif ( this.boundFragment ) this.boundFragment.update();\n  \t\t\tif ( this.rendered ) this.updateDelegate();\n  \t\t}\n  \t};\n\n  \treturn Mapping;\n  }(Item));\n\n  function createMapping ( item ) {\n  \tvar template = item.template.f;\n  \tvar viewmodel = item.element.instance.viewmodel;\n  \tvar childData = viewmodel.value;\n\n  \tif ( template.length === 1 && template[0].t === INTERPOLATOR ) {\n  \t\titem.model = resolve$2( item.parentFragment, template[0] );\n\n  \t\tif ( !item.model ) {\n  \t\t\twarnOnceIfDebug( (\"The \" + (item.name) + \"='{{\" + (template[0].r) + \"}}' mapping is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\"), { ractive: item.element.instance }); // TODO add docs page explaining item\n  \t\t\titem.parentFragment.ractive.get( item.name ); // side-effect: create mappings as necessary\n  \t\t\titem.model = item.parentFragment.findContext().joinKey( item.name );\n  \t\t}\n\n  \t\titem.link = viewmodel.createLink( item.name, item.model, template[0].r );\n\n  \t\tif ( item.model.get() === undefined && item.name in childData ) {\n  \t\t\titem.model.set( childData[ item.name ] );\n  \t\t}\n  \t}\n\n  \telse {\n  \t\titem.boundFragment = new Fragment({\n  \t\t\towner: item,\n  \t\t\ttemplate: template\n  \t\t}).bind();\n\n  \t\titem.model = viewmodel.joinKey( item.name );\n  \t\titem.model.set( item.boundFragment.valueOf() );\n\n  \t\t// item is a *bit* of a hack\n  \t\titem.boundFragment.bubble = function () {\n  \t\t\tFragment.prototype.bubble.call( item.boundFragment );\n  \t\t\t// defer this to avoid mucking around model deps if there happens to be an expression involved\n  \t\t\trunloop.scheduleTask(function () {\n  \t\t\t\titem.boundFragment.update();\n  \t\t\t\titem.model.set( item.boundFragment.valueOf() );\n  \t\t\t});\n  \t\t};\n  \t}\n  }\n\n  var Option = (function (Element) {\n  \tfunction Option ( options ) {\n  \t\tvar template = options.template;\n  \t\tif ( !template.a ) template.a = {};\n\n  \t\t// If the value attribute is missing, use the element's content,\n  \t\t// as long as it isn't disabled\n  \t\tif ( template.a.value === undefined && !( 'disabled' in template.a ) ) {\n  \t\t\ttemplate.a.value = template.f || '';\n  \t\t}\n\n  \t\tElement.call( this, options );\n\n  \t\tthis.select = findElement( this.parent || this.parentFragment, false, 'select' );\n  \t}\n\n  \tOption.prototype = Object.create( Element && Element.prototype );\n  \tOption.prototype.constructor = Option;\n\n  \tOption.prototype.bind = function bind () {\n  \t\tif ( !this.select ) {\n  \t\t\tElement.prototype.bind.call(this);\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// If the select has a value, it overrides the `selected` attribute on\n  \t\t// this option - so we delete the attribute\n  \t\tvar selectedAttribute = this.attributeByName.selected;\n  \t\tif ( selectedAttribute && this.select.getAttribute( 'value' ) !== undefined ) {\n  \t\t\tvar index = this.attributes.indexOf( selectedAttribute );\n  \t\t\tthis.attributes.splice( index, 1 );\n  \t\t\tdelete this.attributeByName.selected;\n  \t\t}\n\n  \t\tElement.prototype.bind.call(this);\n  \t\tthis.select.options.push( this );\n  \t};\n\n  \tOption.prototype.bubble = function bubble () {\n  \t\t// if we're using content as value, may need to update here\n  \t\tvar value = this.getAttribute( 'value' );\n  \t\tif ( this.node && this.node.value !== value ) {\n  \t\t\tthis.node._ractive.value = value;\n  \t\t}\n  \t\tElement.prototype.bubble.call(this);\n  \t};\n\n  \tOption.prototype.getAttribute = function getAttribute ( name ) {\n  \t\tvar attribute = this.attributeByName[ name ];\n  \t\treturn attribute ? attribute.getValue() : name === 'value' && this.fragment ? this.fragment.valueOf() : undefined;\n  \t};\n\n  \tOption.prototype.isSelected = function isSelected () {\n  \t\tvar optionValue = this.getAttribute( 'value' );\n\n  \t\tif ( optionValue === undefined || !this.select ) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tvar selectValue = this.select.getAttribute( 'value' );\n\n  \t\tif ( selectValue == optionValue ) {\n  \t\t\treturn true;\n  \t\t}\n\n  \t\tif ( this.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {\n  \t\t\tvar i = selectValue.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tif ( selectValue[i] == optionValue ) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \tOption.prototype.render = function render ( target, occupants ) {\n  \t\tElement.prototype.render.call( this, target, occupants );\n\n  \t\tif ( !this.attributeByName.value ) {\n  \t\t\tthis.node._ractive.value = this.getAttribute( 'value' );\n  \t\t}\n  \t};\n\n  \tOption.prototype.unbind = function unbind () {\n  \t\tElement.prototype.unbind.call(this);\n\n  \t\tif ( this.select ) {\n  \t\t\tremoveFromArray( this.select.options, this );\n  \t\t}\n  \t};\n\n  \treturn Option;\n  }(Element));\n\n  function getPartialTemplate ( ractive, name, parentFragment ) {\n  \t// If the partial in instance or view heirarchy instances, great\n  \tvar partial = getPartialFromRegistry( ractive, name, parentFragment || {} );\n  \tif ( partial ) return partial;\n\n  \t// Does it exist on the page as a script tag?\n  \tpartial = parser.fromId( name, { noThrow: true } );\n  \tif ( partial ) {\n  \t\t// parse and register to this ractive instance\n  \t\tvar parsed = parser.parseFor( partial, ractive );\n\n  \t\t// register extra partials on the ractive instance if they don't already exist\n  \t\tif ( parsed.p ) fillGaps( ractive.partials, parsed.p );\n\n  \t\t// register (and return main partial if there are others in the template)\n  \t\treturn ractive.partials[ name ] = parsed.t;\n  \t}\n  }\n\n  function getPartialFromRegistry ( ractive, name, parentFragment ) {\n  \t// if there was an instance up-hierarchy, cool\n  \tvar partial = findParentPartial( name, parentFragment.owner );\n  \tif ( partial ) return partial;\n\n  \t// find first instance in the ractive or view hierarchy that has this partial\n  \tvar instance = findInstance( 'partials', ractive, name );\n\n  \tif ( !instance ) { return; }\n\n  \tpartial = instance.partials[ name ];\n\n  \t// partial is a function?\n  \tvar fn;\n  \tif ( typeof partial === 'function' ) {\n  \t\tfn = partial.bind( instance );\n  \t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n  \t\tpartial = fn.call( ractive, parser );\n  \t}\n\n  \tif ( !partial && partial !== '' ) {\n  \t\twarnIfDebug( noRegistryFunctionReturn, name, 'partial', 'partial', { ractive: ractive });\n  \t\treturn;\n  \t}\n\n  \t// If this was added manually to the registry,\n  \t// but hasn't been parsed, parse it now\n  \tif ( !parser.isParsed( partial ) ) {\n  \t\t// use the parseOptions of the ractive instance on which it was found\n  \t\tvar parsed = parser.parseFor( partial, instance );\n\n  \t\t// Partials cannot contain nested partials!\n  \t\t// TODO add a test for this\n  \t\tif ( parsed.p ) {\n  \t\t\twarnIfDebug( 'Partials ({{>%s}}) cannot contain nested inline partials', name, { ractive: ractive });\n  \t\t}\n\n  \t\t// if fn, use instance to store result, otherwise needs to go\n  \t\t// in the correct point in prototype chain on instance or constructor\n  \t\tvar target = fn ? instance : findOwner( instance, name );\n\n  \t\t// may be a template with partials, which need to be registered and main template extracted\n  \t\ttarget.partials[ name ] = partial = parsed.t;\n  \t}\n\n  \t// store for reset\n  \tif ( fn ) partial._fn = fn;\n\n  \treturn partial.v ? partial.t : partial;\n  }\n\n  function findOwner ( ractive, key ) {\n  \treturn ractive.partials.hasOwnProperty( key )\n  \t\t? ractive\n  \t\t: findConstructor( ractive.constructor, key);\n  }\n\n  function findConstructor ( constructor, key ) {\n  \tif ( !constructor ) { return; }\n  \treturn constructor.partials.hasOwnProperty( key )\n  \t\t? constructor\n  \t\t: findConstructor( constructor._Parent, key );\n  }\n\n  function findParentPartial( name, parent ) {\n  \tif ( parent ) {\n  \t\tif ( parent.template && parent.template.p && parent.template.p[name] ) {\n  \t\t\treturn parent.template.p[name];\n  \t\t} else if ( parent.parentFragment && parent.parentFragment.owner ) {\n  \t\t\treturn findParentPartial( name, parent.parentFragment.owner );\n  \t\t}\n  \t}\n  }\n\n  var Partial = (function (Mustache) {\n  \tfunction Partial () {\n  \t\tMustache.apply(this, arguments);\n  \t}\n\n  \tPartial.prototype = Object.create( Mustache && Mustache.prototype );\n  \tPartial.prototype.constructor = Partial;\n\n  \tPartial.prototype.bind = function bind () {\n  \t\t// keep track of the reference name for future resets\n  \t\tthis.refName = this.template.r;\n\n  \t\t// name matches take priority over expressions\n  \t\tvar template = this.refName ? getPartialTemplate( this.ractive, this.refName, this.parentFragment ) || null : null;\n  \t\tvar templateObj;\n\n  \t\tif ( template ) {\n  \t\t\tthis.named = true;\n  \t\t\tthis.setTemplate( this.template.r, template );\n  \t\t}\n\n  \t\tif ( !template ) {\n  \t\t\tMustache.prototype.bind.call(this);\n  \t\t\tif ( this.model && ( templateObj = this.model.get() ) && typeof templateObj === 'object' && ( typeof templateObj.template === 'string' || isArray( templateObj.t ) ) ) {\n  \t\t\t\tif ( templateObj.template ) {\n  \t\t\t\t\tthis.source = templateObj.template;\n  \t\t\t\t\ttemplateObj = parsePartial( this.template.r, templateObj.template, this.ractive );\n  \t\t\t\t} else {\n  \t\t\t\t\tthis.source = templateObj.t;\n  \t\t\t\t}\n  \t\t\t\tthis.setTemplate( this.template.r, templateObj.t );\n  \t\t\t} else if ( ( !this.model || typeof this.model.get() !== 'string' ) && this.refName ) {\n  \t\t\t\tthis.setTemplate( this.refName, template );\n  \t\t\t} else {\n  \t\t\t\tthis.setTemplate( this.model.get() );\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.fragment = new Fragment({\n  \t\t\towner: this,\n  \t\t\ttemplate: this.partialTemplate\n  \t\t}).bind();\n  \t};\n\n  \tPartial.prototype.detach = function detach () {\n  \t\treturn this.fragment.detach();\n  \t};\n\n  \tPartial.prototype.find = function find ( selector ) {\n  \t\treturn this.fragment.find( selector );\n  \t};\n\n  \tPartial.prototype.findAll = function findAll ( selector, query ) {\n  \t\tthis.fragment.findAll( selector, query );\n  \t};\n\n  \tPartial.prototype.findComponent = function findComponent ( name ) {\n  \t\treturn this.fragment.findComponent( name );\n  \t};\n\n  \tPartial.prototype.findAllComponents = function findAllComponents ( name, query ) {\n  \t\tthis.fragment.findAllComponents( name, query );\n  \t};\n\n  \tPartial.prototype.firstNode = function firstNode ( skipParent ) {\n  \t\treturn this.fragment.firstNode( skipParent );\n  \t};\n\n  \tPartial.prototype.forceResetTemplate = function forceResetTemplate () {\n  \t\tvar this$1 = this;\n\n  \t\tthis.partialTemplate = undefined;\n\n  \t\t// on reset, check for the reference name first\n  \t\tif ( this.refName ) {\n  \t\t\tthis.partialTemplate = getPartialTemplate( this.ractive, this.refName, this.parentFragment );\n  \t\t}\n\n  \t\t// then look for the resolved name\n  \t\tif ( !this.partialTemplate ) {\n  \t\t\tthis.partialTemplate = getPartialTemplate( this.ractive, this.name, this.parentFragment );\n  \t\t}\n\n  \t\tif ( !this.partialTemplate ) {\n  \t\t\twarnOnceIfDebug( (\"Could not find template for partial '\" + (this.name) + \"'\") );\n  \t\t\tthis.partialTemplate = [];\n  \t\t}\n\n  \t\tif ( this.inAttribute ) {\n  \t\t\tdoInAttributes( function () { return this$1.fragment.resetTemplate( this$1.partialTemplate ); } );\n  \t\t} else {\n  \t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n  \t\t}\n\n  \t\tthis.bubble();\n  \t};\n\n  \tPartial.prototype.render = function render ( target, occupants ) {\n  \t\tthis.fragment.render( target, occupants );\n  \t};\n\n  \tPartial.prototype.setTemplate = function setTemplate ( name, template ) {\n  \t\tthis.name = name;\n\n  \t\tif ( !template && template !== null ) template = getPartialTemplate( this.ractive, name, this.parentFragment );\n\n  \t\tif ( !template ) {\n  \t\t\twarnOnceIfDebug( (\"Could not find template for partial '\" + name + \"'\") );\n  \t\t}\n\n  \t\tthis.partialTemplate = template || [];\n  \t};\n\n  \tPartial.prototype.toString = function toString ( escape ) {\n  \t\treturn this.fragment.toString( escape );\n  \t};\n\n  \tPartial.prototype.unbind = function unbind () {\n  \t\tMustache.prototype.unbind.call(this);\n  \t\tthis.fragment.unbind();\n  \t};\n\n  \tPartial.prototype.unrender = function unrender ( shouldDestroy ) {\n  \t\tthis.fragment.unrender( shouldDestroy );\n  \t};\n\n  \tPartial.prototype.update = function update () {\n  \t\tvar template;\n\n  \t\tif ( this.dirty ) {\n  \t\t\tthis.dirty = false;\n\n  \t\t\tif ( !this.named ) {\n  \t\t\t\tif ( this.model ) {\n  \t\t\t\t\ttemplate = this.model.get();\n  \t\t\t\t}\n\n  \t\t\t\tif ( template && typeof template === 'string' && template !== this.name ) {\n  \t\t\t\t\tthis.setTemplate( template );\n  \t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n  \t\t\t\t} else if ( template && typeof template === 'object' && ( typeof template.template === 'string' || isArray( template.t ) ) ) {\n  \t\t\t\t\tif ( template.t !== this.source && template.template !== this.source ) {\n  \t\t\t\t\t\tif ( template.template ) {\n  \t\t\t\t\t\t\tthis.source = template.template;\n  \t\t\t\t\t\t\ttemplate = parsePartial( this.name, template.template, this.ractive );\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tthis.source = template.t;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\tthis.setTemplate( this.name, template.t );\n  \t\t\t\t\t\tthis.fragment.resetTemplate( this.partialTemplate );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis.fragment.update();\n  \t\t}\n  \t};\n\n  \treturn Partial;\n  }(Mustache));\n\n  function parsePartial( name, partial, ractive ) {\n  \tvar parsed;\n\n  \ttry {\n  \t\tparsed = parser.parse( partial, parser.getParseOptions( ractive ) );\n  \t} catch (e) {\n  \t\twarnIfDebug( (\"Could not parse partial from expression '\" + name + \"'\\n\" + (e.message)) );\n  \t}\n\n  \treturn parsed || { t: [] };\n  }\n\n  var RepeatedFragment = function RepeatedFragment ( options ) {\n  \tthis.parent = options.owner.parentFragment;\n\n  \t// bit of a hack, so reference resolution works without another\n  \t// layer of indirection\n  \tthis.parentFragment = this;\n  \tthis.owner = options.owner;\n  \tthis.ractive = this.parent.ractive;\n\n  \t// encapsulated styles should be inherited until they get applied by an element\n  \tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\n  \tthis.context = null;\n  \tthis.rendered = false;\n  \tthis.iterations = [];\n\n  \tthis.template = options.template;\n\n  \tthis.indexRef = options.indexRef;\n  \tthis.keyRef = options.keyRef;\n\n  \tthis.pendingNewIndices = null;\n  \tthis.previousIterations = null;\n\n  \t// track array versus object so updates of type rest\n  \tthis.isArray = false;\n  };\n\n  RepeatedFragment.prototype.bind = function bind ( context ) {\n  \tvar this$1 = this;\n\n  \t\tthis.context = context;\n  \tvar value = context.get();\n\n  \t// {{#each array}}...\n  \tif ( this.isArray = isArray( value ) ) {\n  \t\t// we can't use map, because of sparse arrays\n  \t\tthis.iterations = [];\n  \t\tvar max = value.length;\n  \t\tfor ( var i = 0; i < max; i += 1 ) {\n  \t\t\tthis$1.iterations[i] = this$1.createIteration( i, i );\n  \t\t}\n  \t}\n\n  \t// {{#each object}}...\n  \telse if ( isObject( value ) ) {\n  \t\tthis.isArray = false;\n\n  \t\t// TODO this is a dreadful hack. There must be a neater way\n  \t\tif ( this.indexRef ) {\n  \t\t\tvar refs = this.indexRef.split( ',' );\n  \t\t\tthis.keyRef = refs[0];\n  \t\t\tthis.indexRef = refs[1];\n  \t\t}\n\n  \t\tthis.iterations = Object.keys( value ).map( function ( key, index ) {\n  \t\t\treturn this$1.createIteration( key, index );\n  \t\t});\n  \t}\n\n  \treturn this;\n  };\n\n  RepeatedFragment.prototype.bubble = function bubble () {\n  \tthis.owner.bubble();\n  };\n\n  RepeatedFragment.prototype.createIteration = function createIteration ( key, index ) {\n  \tvar fragment = new Fragment({\n  \t\towner: this,\n  \t\ttemplate: this.template\n  \t});\n\n  \t// TODO this is a bit hacky\n  \tfragment.key = key;\n  \tfragment.index = index;\n  \tfragment.isIteration = true;\n\n  \tvar model = this.context.joinKey( key );\n\n  \t// set up an iteration alias if there is one\n  \tif ( this.owner.template.z ) {\n  \t\tfragment.aliases = {};\n  \t\tfragment.aliases[ this.owner.template.z[0].n ] = model;\n  \t}\n\n  \treturn fragment.bind( model );\n  };\n\n  RepeatedFragment.prototype.destroyed = function destroyed () {\n  \tthis.iterations.forEach( function ( i ) { return i.destroyed(); } );\n  };\n\n  RepeatedFragment.prototype.detach = function detach () {\n  \tvar docFrag = createDocumentFragment();\n  \tthis.iterations.forEach( function ( fragment ) { return docFrag.appendChild( fragment.detach() ); } );\n  \treturn docFrag;\n  };\n\n  RepeatedFragment.prototype.find = function find ( selector ) {\n  \tvar this$1 = this;\n\n  \t\tvar len = this.iterations.length;\n  \tvar i;\n\n  \tfor ( i = 0; i < len; i += 1 ) {\n  \t\tvar found = this$1.iterations[i].find( selector );\n  \t\tif ( found ) return found;\n  \t}\n  };\n\n  RepeatedFragment.prototype.findAll = function findAll ( selector, query ) {\n  \tvar this$1 = this;\n\n  \t\tvar len = this.iterations.length;\n  \tvar i;\n\n  \tfor ( i = 0; i < len; i += 1 ) {\n  \t\tthis$1.iterations[i].findAll( selector, query );\n  \t}\n  };\n\n  RepeatedFragment.prototype.findComponent = function findComponent ( name ) {\n  \tvar this$1 = this;\n\n  \t\tvar len = this.iterations.length;\n  \tvar i;\n\n  \tfor ( i = 0; i < len; i += 1 ) {\n  \t\tvar found = this$1.iterations[i].findComponent( name );\n  \t\tif ( found ) return found;\n  \t}\n  };\n\n  RepeatedFragment.prototype.findAllComponents = function findAllComponents ( name, query ) {\n  \tvar this$1 = this;\n\n  \t\tvar len = this.iterations.length;\n  \tvar i;\n\n  \tfor ( i = 0; i < len; i += 1 ) {\n  \t\tthis$1.iterations[i].findAllComponents( name, query );\n  \t}\n  };\n\n  RepeatedFragment.prototype.findNextNode = function findNextNode ( iteration ) {\n  \tvar this$1 = this;\n\n  \t\tif ( iteration.index < this.iterations.length - 1 ) {\n  \t\tfor ( var i = iteration.index + 1; i < this$1.iterations.length; i++ ) {\n  \t\t\tvar node = this$1.iterations[ i ].firstNode( true );\n  \t\t\tif ( node ) return node;\n  \t\t}\n  \t}\n\n  \treturn this.owner.findNextNode();\n  };\n\n  RepeatedFragment.prototype.firstNode = function firstNode ( skipParent ) {\n  \treturn this.iterations[0] ? this.iterations[0].firstNode( skipParent ) : null;\n  };\n\n  RepeatedFragment.prototype.rebinding = function rebinding ( next ) {\n  \tvar this$1 = this;\n\n  \t\tthis.context = next;\n  \tthis.iterations.forEach( function ( fragment ) {\n  \t\tvar model = next ? next.joinKey( fragment.key || fragment.index ) : undefined;\n  \t\tfragment.context = model;\n  \t\tif ( this$1.owner.template.z ) {\n  \t\t\tfragment.aliases = {};\n  \t\t\tfragment.aliases[ this$1.owner.template.z[0].n ] = model;\n  \t\t}\n  \t});\n  };\n\n  RepeatedFragment.prototype.render = function render ( target, occupants ) {\n  \t// TODO use docFrag.cloneNode...\n\n  \tif ( this.iterations ) {\n  \t\tthis.iterations.forEach( function ( fragment ) { return fragment.render( target, occupants ); } );\n  \t}\n\n  \tthis.rendered = true;\n  };\n\n  RepeatedFragment.prototype.shuffle = function shuffle ( newIndices ) {\n  \tvar this$1 = this;\n\n  \t\tif ( !this.pendingNewIndices ) this.previousIterations = this.iterations.slice();\n\n  \tif ( !this.pendingNewIndices ) this.pendingNewIndices = [];\n\n  \tthis.pendingNewIndices.push( newIndices );\n\n  \tvar iterations = [];\n\n  \tnewIndices.forEach( function ( newIndex, oldIndex ) {\n  \t\tif ( newIndex === -1 ) return;\n\n  \t\tvar fragment = this$1.iterations[ oldIndex ];\n  \t\titerations[ newIndex ] = fragment;\n\n  \t\tif ( newIndex !== oldIndex && fragment ) fragment.dirty = true;\n  \t});\n\n  \tthis.iterations = iterations;\n\n  \tthis.bubble();\n  };\n\n  RepeatedFragment.prototype.shuffled = function shuffled () {\n  \tthis.iterations.forEach( function ( i ) { return i.shuffled(); } );\n  };\n\n  RepeatedFragment.prototype.toString = function toString$1$$ ( escape ) {\n  \treturn this.iterations ?\n  \t\tthis.iterations.map( escape ? toEscapedString : toString$1 ).join( '' ) :\n  \t\t'';\n  };\n\n  RepeatedFragment.prototype.unbind = function unbind$1 () {\n  \tthis.iterations.forEach( unbind );\n  \treturn this;\n  };\n\n  RepeatedFragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n  \tthis.iterations.forEach( shouldDestroy ? unrenderAndDestroy : unrender );\n  \tif ( this.pendingNewIndices && this.previousIterations ) {\n  \t\tthis.previousIterations.forEach( function ( fragment ) {\n  \t\t\tif ( fragment.rendered ) shouldDestroy ? unrenderAndDestroy( fragment ) : unrender( fragment );\n  \t\t});\n  \t}\n  \tthis.rendered = false;\n  };\n\n  // TODO smart update\n  RepeatedFragment.prototype.update = function update$1 () {\n  \t// skip dirty check, since this is basically just a facade\n\n  \tvar this$1 = this;\n\n  \t\tif ( this.pendingNewIndices ) {\n  \t\tthis.updatePostShuffle();\n  \t\treturn;\n  \t}\n\n  \tif ( this.updating ) return;\n  \tthis.updating = true;\n\n  \tvar value = this.context.get(),\n  \t\t\t  wasArray = this.isArray;\n\n  \tvar toRemove;\n  \tvar oldKeys;\n  \tvar reset = true;\n  \tvar i;\n\n  \tif ( this.isArray = isArray( value ) ) {\n  \t\tif ( wasArray ) {\n  \t\t\treset = false;\n  \t\t\tif ( this.iterations.length > value.length ) {\n  \t\t\t\ttoRemove = this.iterations.splice( value.length );\n  \t\t\t}\n  \t\t}\n  \t} else if ( isObject( value ) && !wasArray ) {\n  \t\treset = false;\n  \t\ttoRemove = [];\n  \t\toldKeys = {};\n  \t\ti = this.iterations.length;\n\n  \t\twhile ( i-- ) {\n  \t\t\tvar fragment$1 = this$1.iterations[i];\n  \t\t\tif ( fragment$1.key in value ) {\n  \t\t\t\toldKeys[ fragment$1.key ] = true;\n  \t\t\t} else {\n  \t\t\t\tthis$1.iterations.splice( i, 1 );\n  \t\t\t\ttoRemove.push( fragment$1 );\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif ( reset ) {\n  \t\ttoRemove = this.iterations;\n  \t\tthis.iterations = [];\n  \t}\n\n  \tif ( toRemove ) {\n  \t\ttoRemove.forEach( function ( fragment ) {\n  \t\t\tfragment.unbind();\n  \t\t\tfragment.unrender( true );\n  \t\t});\n  \t}\n\n  \t// update the remaining ones\n  \tthis.iterations.forEach( update );\n\n  \t// add new iterations\n  \tvar newLength = isArray( value ) ?\n  \t\tvalue.length :\n  \t\tisObject( value ) ?\n  \t\t\tObject.keys( value ).length :\n  \t\t\t0;\n\n  \tvar docFrag;\n  \tvar fragment;\n\n  \tif ( newLength > this.iterations.length ) {\n  \t\tdocFrag = this.rendered ? createDocumentFragment() : null;\n  \t\ti = this.iterations.length;\n\n  \t\tif ( isArray( value ) ) {\n  \t\t\twhile ( i < value.length ) {\n  \t\t\t\tfragment = this$1.createIteration( i, i );\n\n  \t\t\t\tthis$1.iterations.push( fragment );\n  \t\t\t\tif ( this$1.rendered ) fragment.render( docFrag );\n\n  \t\t\t\ti += 1;\n  \t\t\t}\n  \t\t}\n\n  \t\telse if ( isObject( value ) ) {\n  \t\t\t// TODO this is a dreadful hack. There must be a neater way\n  \t\t\tif ( this.indexRef && !this.keyRef ) {\n  \t\t\t\tvar refs = this.indexRef.split( ',' );\n  \t\t\t\tthis.keyRef = refs[0];\n  \t\t\t\tthis.indexRef = refs[1];\n  \t\t\t}\n\n  \t\t\tObject.keys( value ).forEach( function ( key ) {\n  \t\t\t\tif ( !oldKeys || !( key in oldKeys ) ) {\n  \t\t\t\t\tfragment = this$1.createIteration( key, i );\n\n  \t\t\t\t\tthis$1.iterations.push( fragment );\n  \t\t\t\t\tif ( this$1.rendered ) fragment.render( docFrag );\n\n  \t\t\t\t\ti += 1;\n  \t\t\t\t}\n  \t\t\t});\n  \t\t}\n\n  \t\tif ( this.rendered ) {\n  \t\t\tvar parentNode = this.parent.findParentNode();\n  \t\t\tvar anchor = this.parent.findNextNode( this.owner );\n\n  \t\t\tparentNode.insertBefore( docFrag, anchor );\n  \t\t}\n  \t}\n\n  \tthis.updating = false;\n  };\n\n  RepeatedFragment.prototype.updatePostShuffle = function updatePostShuffle () {\n  \tvar this$1 = this;\n\n  \t\tvar newIndices = this.pendingNewIndices[ 0 ];\n\n  \t// map first shuffle through\n  \tthis.pendingNewIndices.slice( 1 ).forEach( function ( indices ) {\n  \t\tnewIndices.forEach( function ( newIndex, oldIndex ) {\n  \t\t\tnewIndices[ oldIndex ] = indices[ newIndex ];\n  \t\t});\n  \t});\n\n  \t// This algorithm (for detaching incorrectly-ordered fragments from the DOM and\n  \t// storing them in a document fragment for later reinsertion) seems a bit hokey,\n  \t// but it seems to work for now\n  \tvar len = this.context.get().length, oldLen = this.previousIterations.length;\n  \tvar i;\n  \tvar removed = {};\n\n  \tnewIndices.forEach( function ( newIndex, oldIndex ) {\n  \t\tvar fragment = this$1.previousIterations[ oldIndex ];\n  \t\tthis$1.previousIterations[ oldIndex ] = null;\n\n  \t\tif ( newIndex === -1 ) {\n  \t\t\tremoved[ oldIndex ] = fragment;\n  \t\t} else if ( fragment.index !== newIndex ) {\n  \t\t\tvar model = this$1.context.joinKey( newIndex );\n  \t\t\tfragment.index = newIndex;\n  \t\t\tfragment.context = model;\n  \t\t\tif ( this$1.owner.template.z ) {\n  \t\t\t\tfragment.aliases = {};\n  \t\t\t\tfragment.aliases[ this$1.owner.template.z[0].n ] = model;\n  \t\t\t}\n  \t\t}\n  \t});\n\n  \t// if the array was spliced outside of ractive, sometimes there are leftover fragments not in the newIndices\n  \tthis.previousIterations.forEach( function ( frag, i ) {\n  \t\tif ( frag ) removed[ i ] = frag;\n  \t});\n\n  \t// create new/move existing iterations\n  \tvar docFrag = this.rendered ? createDocumentFragment() : null;\n  \tvar parentNode = this.rendered ? this.parent.findParentNode() : null;\n\n  \tvar contiguous = 'startIndex' in newIndices;\n  \ti = contiguous ? newIndices.startIndex : 0;\n\n  \tfor ( i; i < len; i++ ) {\n  \t\tvar frag = this$1.iterations[i];\n\n  \t\tif ( frag && contiguous ) {\n  \t\t\t// attach any built-up iterations\n  \t\t\tif ( this$1.rendered ) {\n  \t\t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n  \t\t\t\tif ( docFrag.childNodes.length  ) parentNode.insertBefore( docFrag, frag.firstNode() );\n  \t\t\t}\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif ( !frag ) this$1.iterations[i] = this$1.createIteration( i, i );\n\n  \t\tif ( this$1.rendered ) {\n  \t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n\n  \t\t\tif ( frag ) docFrag.appendChild( frag.detach() );\n  \t\t\telse {\n  \t\t\t\tthis$1.iterations[i].render( docFrag );\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// append any leftovers\n  \tif ( this.rendered ) {\n  \t\tfor ( i = len; i < oldLen; i++ ) {\n  \t\t\tif ( removed[i] ) docFrag.appendChild( removed[i].detach() );\n  \t\t}\n\n  \t\tif ( docFrag.childNodes.length ) {\n  \t\t\tparentNode.insertBefore( docFrag, this.owner.findNextNode() );\n  \t\t}\n  \t}\n\n  \t// trigger removal on old nodes\n  \tObject.keys( removed ).forEach( function ( k ) { return removed[k].unbind().unrender( true ); } );\n\n  \tthis.iterations.forEach( update );\n\n  \tthis.pendingNewIndices = null;\n\n  \tthis.shuffled();\n  };\n\n  function isEmpty ( value ) {\n  \treturn !value ||\n  \t       ( isArray( value ) && value.length === 0 ) ||\n  \t\t   ( isObject( value ) && Object.keys( value ).length === 0 );\n  }\n\n  function getType ( value, hasIndexRef ) {\n  \tif ( hasIndexRef || isArray( value ) ) return SECTION_EACH;\n  \tif ( isObject( value ) || typeof value === 'function' ) return SECTION_IF_WITH;\n  \tif ( value === undefined ) return null;\n  \treturn SECTION_IF;\n  }\n\n  var Section = (function (Mustache) {\n  \tfunction Section ( options ) {\n  \t\tMustache.call( this, options );\n\n  \t\tthis.sectionType = options.template.n || null;\n  \t\tthis.templateSectionType = this.sectionType;\n  \t\tthis.subordinate = options.template.l === 1;\n  \t\tthis.fragment = null;\n  \t}\n\n  \tSection.prototype = Object.create( Mustache && Mustache.prototype );\n  \tSection.prototype.constructor = Section;\n\n  \tSection.prototype.bind = function bind () {\n  \t\tMustache.prototype.bind.call(this);\n\n  \t\tif ( this.subordinate ) {\n  \t\t\tthis.sibling = this.parentFragment.items[ this.parentFragment.items.indexOf( this ) - 1 ];\n  \t\t\tthis.sibling.nextSibling = this;\n  \t\t}\n\n  \t\t// if we managed to bind, we need to create children\n  \t\tif ( this.model ) {\n  \t\t\tthis.dirty = true;\n  \t\t\tthis.update();\n  \t\t} else if ( this.sectionType && this.sectionType === SECTION_UNLESS && ( !this.sibling || !this.sibling.isTruthy() ) ) {\n  \t\t\tthis.fragment = new Fragment({\n  \t\t\t\towner: this,\n  \t\t\t\ttemplate: this.template.f\n  \t\t\t}).bind();\n  \t\t}\n  \t};\n\n  \tSection.prototype.detach = function detach () {\n  \t\treturn this.fragment ? this.fragment.detach() : createDocumentFragment();\n  \t};\n\n  \tSection.prototype.find = function find ( selector ) {\n  \t\tif ( this.fragment ) {\n  \t\t\treturn this.fragment.find( selector );\n  \t\t}\n  \t};\n\n  \tSection.prototype.findAll = function findAll ( selector, query ) {\n  \t\tif ( this.fragment ) {\n  \t\t\tthis.fragment.findAll( selector, query );\n  \t\t}\n  \t};\n\n  \tSection.prototype.findComponent = function findComponent ( name ) {\n  \t\tif ( this.fragment ) {\n  \t\t\treturn this.fragment.findComponent( name );\n  \t\t}\n  \t};\n\n  \tSection.prototype.findAllComponents = function findAllComponents ( name, query ) {\n  \t\tif ( this.fragment ) {\n  \t\t\tthis.fragment.findAllComponents( name, query );\n  \t\t}\n  \t};\n\n  \tSection.prototype.firstNode = function firstNode ( skipParent ) {\n  \t\treturn this.fragment && this.fragment.firstNode( skipParent );\n  \t};\n\n  \tSection.prototype.isTruthy = function isTruthy () {\n  \t\tif ( this.subordinate && this.sibling.isTruthy() ) return true;\n  \t\tvar value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n  \t\treturn !!value && ( this.templateSectionType === SECTION_IF_WITH || !isEmpty( value ) );\n  \t};\n\n  \tSection.prototype.rebinding = function rebinding ( next, previous, safe ) {\n  \t\tif ( Mustache.prototype.rebinding.call( this, next, previous, safe ) ) {\n  \t\t\tif ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {\n  \t\t\t\tthis.fragment.rebinding( next, previous );\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \tSection.prototype.render = function render ( target, occupants ) {\n  \t\tthis.rendered = true;\n  \t\tif ( this.fragment ) this.fragment.render( target, occupants );\n  \t};\n\n  \tSection.prototype.shuffle = function shuffle ( newIndices ) {\n  \t\tif ( this.fragment && this.sectionType === SECTION_EACH ) {\n  \t\t\tthis.fragment.shuffle( newIndices );\n  \t\t}\n  \t};\n\n  \tSection.prototype.toString = function toString ( escape ) {\n  \t\treturn this.fragment ? this.fragment.toString( escape ) : '';\n  \t};\n\n  \tSection.prototype.unbind = function unbind () {\n  \t\tMustache.prototype.unbind.call(this);\n  \t\tif ( this.fragment ) this.fragment.unbind();\n  \t};\n\n  \tSection.prototype.unrender = function unrender ( shouldDestroy ) {\n  \t\tif ( this.rendered && this.fragment ) this.fragment.unrender( shouldDestroy );\n  \t\tthis.rendered = false;\n  \t};\n\n  \tSection.prototype.update = function update () {\n  \t\tif ( !this.dirty ) return;\n\n  \t\tif ( this.fragment && this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ) {\n  \t\t\tthis.fragment.context = this.model;\n  \t\t}\n\n  \t\tif ( !this.model && this.sectionType !== SECTION_UNLESS ) return;\n\n  \t\tthis.dirty = false;\n\n  \t\tvar value = !this.model ? undefined : this.model.isRoot ? this.model.value : this.model.get();\n  \t\tvar siblingFalsey = !this.subordinate || !this.sibling.isTruthy();\n  \t\tvar lastType = this.sectionType;\n\n  \t\t// watch for switching section types\n  \t\tif ( this.sectionType === null || this.templateSectionType === null ) this.sectionType = getType( value, this.template.i );\n  \t\tif ( lastType && lastType !== this.sectionType && this.fragment ) {\n  \t\t\tif ( this.rendered ) {\n  \t\t\t\tthis.fragment.unbind().unrender( true );\n  \t\t\t}\n\n  \t\t\tthis.fragment = null;\n  \t\t}\n\n  \t\tvar newFragment;\n\n  \t\tvar fragmentShouldExist = this.sectionType === SECTION_EACH || // each always gets a fragment, which may have no iterations\n  \t\t                            this.sectionType === SECTION_WITH || // with (partial context) always gets a fragment\n  \t\t                            ( siblingFalsey && ( this.sectionType === SECTION_UNLESS ? !this.isTruthy() : this.isTruthy() ) ); // if, unless, and if-with depend on siblings and the condition\n\n  \t\tif ( fragmentShouldExist ) {\n  \t\t\tif ( this.fragment ) {\n  \t\t\t\tthis.fragment.update();\n  \t\t\t} else {\n  \t\t\t\tif ( this.sectionType === SECTION_EACH ) {\n  \t\t\t\t\tnewFragment = new RepeatedFragment({\n  \t\t\t\t\t\towner: this,\n  \t\t\t\t\t\ttemplate: this.template.f,\n  \t\t\t\t\t\tindexRef: this.template.i\n  \t\t\t\t\t}).bind( this.model );\n  \t\t\t\t} else {\n  \t \t\t\t\t// only with and if-with provide context - if and unless do not\n  \t\t\t\t\tvar context = this.sectionType !== SECTION_IF && this.sectionType !== SECTION_UNLESS ? this.model : null;\n  \t\t\t\t\tnewFragment = new Fragment({\n  \t\t\t\t\t\towner: this,\n  \t\t\t\t\t\ttemplate: this.template.f\n  \t\t\t\t\t}).bind( context );\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tif ( this.fragment && this.rendered ) {\n  \t\t\t\tthis.fragment.unbind().unrender( true );\n  \t\t\t}\n\n  \t\t\tthis.fragment = null;\n  \t\t}\n\n  \t\tif ( newFragment ) {\n  \t\t\tif ( this.rendered ) {\n  \t\t\t\tvar parentNode = this.parentFragment.findParentNode();\n  \t\t\t\tvar anchor = this.parentFragment.findNextNode( this );\n\n  \t\t\t\tif ( anchor ) {\n  \t\t\t\t\tvar docFrag = createDocumentFragment();\n  \t\t\t\t\tnewFragment.render( docFrag );\n\n  \t\t\t\t\t// we use anchor.parentNode, not parentNode, because the sibling\n  \t\t\t\t\t// may be temporarily detached as a result of a shuffle\n  \t\t\t\t\tanchor.parentNode.insertBefore( docFrag, anchor );\n  \t\t\t\t} else {\n  \t\t\t\t\tnewFragment.render( parentNode );\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis.fragment = newFragment;\n  \t\t}\n\n  \t\tif ( this.nextSibling ) {\n  \t\t\tthis.nextSibling.dirty = true;\n  \t\t\tthis.nextSibling.update();\n  \t\t}\n  \t};\n\n  \treturn Section;\n  }(Mustache));\n\n  function valueContains ( selectValue, optionValue ) {\n  \tvar i = selectValue.length;\n  \twhile ( i-- ) {\n  \t\tif ( selectValue[i] == optionValue ) return true;\n  \t}\n  }\n\n  var Select = (function (Element) {\n  \tfunction Select ( options ) {\n  \t\tElement.call( this, options );\n  \t\tthis.options = [];\n  \t}\n\n  \tSelect.prototype = Object.create( Element && Element.prototype );\n  \tSelect.prototype.constructor = Select;\n\n  \tSelect.prototype.foundNode = function foundNode ( node ) {\n  \t\tif ( this.binding ) {\n  \t\t\tvar selectedOptions = getSelectedOptions( node );\n\n  \t\t\tif ( selectedOptions.length > 0 ) {\n  \t\t\t\tthis.selectedOptions = selectedOptions;\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \tSelect.prototype.render = function render ( target, occupants ) {\n  \t\tElement.prototype.render.call( this, target, occupants );\n  \t\tthis.sync();\n\n  \t\tvar node = this.node;\n\n  \t\tvar i = node.options.length;\n  \t\twhile ( i-- ) {\n  \t\t\tnode.options[i].defaultSelected = node.options[i].selected;\n  \t\t}\n\n  \t\tthis.rendered = true;\n  \t};\n\n  \tSelect.prototype.sync = function sync () {\n  \t\tvar this$1 = this;\n\n  \t\tvar selectNode = this.node;\n\n  \t\tif ( !selectNode ) return;\n\n  \t\tvar options = toArray( selectNode.options );\n\n  \t\tif ( this.selectedOptions ) {\n  \t\t\toptions.forEach( function ( o ) {\n  \t\t\t\tif ( this$1.selectedOptions.indexOf( o ) >= 0 ) o.selected = true;\n  \t\t\t\telse o.selected = false;\n  \t\t\t});\n  \t\t\tthis.binding.setFromNode( selectNode );\n  \t\t\tdelete this.selectedOptions;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar selectValue = this.getAttribute( 'value' );\n  \t\tvar isMultiple = this.getAttribute( 'multiple' );\n\n  \t\t// If the <select> has a specified value, that should override\n  \t\t// these options\n  \t\tif ( selectValue !== undefined ) {\n  \t\t\tvar optionWasSelected;\n\n  \t\t\toptions.forEach( function ( o ) {\n  \t\t\t\tvar optionValue = o._ractive ? o._ractive.value : o.value;\n  \t\t\t\tvar shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;\n\n  \t\t\t\tif ( shouldSelect ) {\n  \t\t\t\t\toptionWasSelected = true;\n  \t\t\t\t}\n\n  \t\t\t\to.selected = shouldSelect;\n  \t\t\t});\n\n  \t\t\tif ( !optionWasSelected && !isMultiple ) {\n  \t\t\t\tif ( this.binding ) {\n  \t\t\t\t\tthis.binding.forceUpdate();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// Otherwise the value should be initialised according to which\n  \t\t// <option> element is selected, if twoway binding is in effect\n  \t\telse if ( this.binding ) {\n  \t\t\tthis.binding.forceUpdate();\n  \t\t}\n  \t};\n\n  \tSelect.prototype.update = function update () {\n  \t\tElement.prototype.update.call(this);\n  \t\tthis.sync();\n  \t};\n\n  \treturn Select;\n  }(Element));\n\n  var Textarea = (function (Input) {\n  \tfunction Textarea( options ) {\n  \t\tvar template = options.template;\n\n  \t\toptions.deferContent = true;\n\n  \t\tInput.call( this, options );\n\n  \t\t// check for single interpolator binding\n  \t\tif ( !this.attributeByName.value ) {\n  \t\t\tif ( template.f && isBindable( { template: template } ) ) {\n  \t\t\t\tthis.attributes.push( createItem( {\n  \t\t\t\t\towner: this,\n  \t\t\t\t\ttemplate: { t: ATTRIBUTE, f: template.f, n: 'value' },\n  \t\t\t\t\tparentFragment: this.parentFragment\n  \t\t\t\t} ) );\n  \t\t\t} else {\n  \t\t\t\tthis.fragment = new Fragment({ owner: this, cssIds: null, template: template.f });\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tTextarea.prototype = Object.create( Input && Input.prototype );\n  \tTextarea.prototype.constructor = Textarea;\n\n  \tTextarea.prototype.bubble = function bubble () {\n  \t\tvar this$1 = this;\n\n  \t\tif ( !this.dirty ) {\n  \t\t\tthis.dirty = true;\n\n  \t\t\tif ( this.rendered && !this.binding && this.fragment ) {\n  \t\t\t\trunloop.scheduleTask( function () {\n  \t\t\t\t\tthis$1.dirty = false;\n  \t\t\t\t\tthis$1.node.value = this$1.fragment.toString();\n  \t\t\t\t});\n  \t\t\t}\n\n  \t\t\tthis.parentFragment.bubble(); // default behaviour\n  \t\t}\n  \t};\n\n  \treturn Textarea;\n  }(Input));\n\n  var Text = (function (Item) {\n  \tfunction Text ( options ) {\n  \t\tItem.call( this, options );\n  \t\tthis.type = TEXT;\n  \t}\n\n  \tText.prototype = Object.create( Item && Item.prototype );\n  \tText.prototype.constructor = Text;\n\n  \tText.prototype.bind = function bind () {\n  \t\t// noop\n  \t};\n\n  \tText.prototype.detach = function detach () {\n  \t\treturn detachNode( this.node );\n  \t};\n\n  \tText.prototype.firstNode = function firstNode () {\n  \t\treturn this.node;\n  \t};\n\n  \tText.prototype.render = function render ( target, occupants ) {\n  \t\tif ( inAttributes() ) return;\n  \t\tthis.rendered = true;\n\n  \t\tif ( occupants ) {\n  \t\t\tvar n = occupants[0];\n  \t\t\tif ( n && n.nodeType === 3 ) {\n  \t\t\t\toccupants.shift();\n  \t\t\t\tif ( n.nodeValue !== this.template ) {\n  \t\t\t\t\tn.nodeValue = this.template;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tn = this.node = doc.createTextNode( this.template );\n  \t\t\t\tif ( occupants[0] ) {\n  \t\t\t\t\ttarget.insertBefore( n, occupants[0] );\n  \t\t\t\t} else {\n  \t\t\t\t\ttarget.appendChild( n );\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis.node = n;\n  \t\t} else {\n  \t\t\tthis.node = doc.createTextNode( this.template );\n  \t\t\ttarget.appendChild( this.node );\n  \t\t}\n  \t};\n\n  \tText.prototype.toString = function toString ( escape ) {\n  \t\treturn escape ? escapeHtml( this.template ) : this.template;\n  \t};\n\n  \tText.prototype.unbind = function unbind () {\n  \t\t// noop\n  \t};\n\n  \tText.prototype.unrender = function unrender ( shouldDestroy ) {\n  \t\tif ( this.rendered && shouldDestroy ) this.detach();\n  \t\tthis.rendered = false;\n  \t};\n\n  \tText.prototype.update = function update () {\n  \t\t// noop\n  \t};\n\n  \tText.prototype.valueOf = function valueOf () {\n  \t\treturn this.template;\n  \t};\n\n  \treturn Text;\n  }(Item));\n\n  var prefix;\n\n  if ( !isClient ) {\n  \tprefix = null;\n  } else {\n  \tvar prefixCache = {};\n  \tvar testStyle = createElement( 'div' ).style;\n\n  \tprefix = function ( prop ) {\n  \t\tprop = camelCase( prop );\n\n  \t\tif ( !prefixCache[ prop ] ) {\n  \t\t\tif ( testStyle[ prop ] !== undefined ) {\n  \t\t\t\tprefixCache[ prop ] = prop;\n  \t\t\t}\n\n  \t\t\telse {\n  \t\t\t\t// test vendors...\n  \t\t\t\tvar capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );\n\n  \t\t\t\tvar i = vendors.length;\n  \t\t\t\twhile ( i-- ) {\n  \t\t\t\t\tvar vendor = vendors[i];\n  \t\t\t\t\tif ( testStyle[ vendor + capped ] !== undefined ) {\n  \t\t\t\t\t\tprefixCache[ prop ] = vendor + capped;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\treturn prefixCache[ prop ];\n  \t};\n  }\n\n  var prefix$1 = prefix;\n\n  var visible;\n  var hidden = 'hidden';\n\n  if ( doc ) {\n  \tvar prefix$2;\n\n  \tif ( hidden in doc ) {\n  \t\tprefix$2 = '';\n  \t} else {\n  \t\tvar i$1 = vendors.length;\n  \t\twhile ( i$1-- ) {\n  \t\t\tvar vendor = vendors[i$1];\n  \t\t\thidden = vendor + 'Hidden';\n\n  \t\t\tif ( hidden in doc ) {\n  \t\t\t\tprefix$2 = vendor;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif ( prefix$2 !== undefined ) {\n  \t\tdoc.addEventListener( prefix$2 + 'visibilitychange', onChange );\n  \t\tonChange();\n  \t} else {\n  \t\t// gah, we're in an old browser\n  \t\tif ( 'onfocusout' in doc ) {\n  \t\t\tdoc.addEventListener( 'focusout', onHide );\n  \t\t\tdoc.addEventListener( 'focusin', onShow );\n  \t\t}\n\n  \t\telse {\n  \t\t\twin.addEventListener( 'pagehide', onHide );\n  \t\t\twin.addEventListener( 'blur', onHide );\n\n  \t\t\twin.addEventListener( 'pageshow', onShow );\n  \t\t\twin.addEventListener( 'focus', onShow );\n  \t\t}\n\n  \t\tvisible = true; // until proven otherwise. Not ideal but hey\n  \t}\n  }\n\n  function onChange () {\n  \tvisible = !doc[ hidden ];\n  }\n\n  function onHide () {\n  \tvisible = false;\n  }\n\n  function onShow () {\n  \tvisible = true;\n  }\n\n  var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );\n\n  function unprefix ( prop ) {\n  \treturn prop.replace( unprefixPattern, '' );\n  }\n\n  var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );\n\n  function hyphenate ( str ) {\n  \tif ( !str ) return ''; // edge case\n\n  \tif ( vendorPattern.test( str ) ) str = '-' + str;\n\n  \treturn str.replace( /[A-Z]/g, function ( match ) { return '-' + match.toLowerCase(); } );\n  }\n\n  var createTransitions;\n\n  if ( !isClient ) {\n  \tcreateTransitions = null;\n  } else {\n  \tvar testStyle$1 = createElement( 'div' ).style;\n  \tvar linear$1 = function ( x ) { return x; };\n\n  \tvar canUseCssTransitions = {};\n  \tvar cannotUseCssTransitions = {};\n\n  \t// determine some facts about our environment\n  \tvar TRANSITION$1;\n  \tvar TRANSITIONEND;\n  \tvar CSS_TRANSITIONS_ENABLED;\n  \tvar TRANSITION_DURATION;\n  \tvar TRANSITION_PROPERTY;\n  \tvar TRANSITION_TIMING_FUNCTION;\n\n  \tif ( testStyle$1.transition !== undefined ) {\n  \t\tTRANSITION$1 = 'transition';\n  \t\tTRANSITIONEND = 'transitionend';\n  \t\tCSS_TRANSITIONS_ENABLED = true;\n  \t} else if ( testStyle$1.webkitTransition !== undefined ) {\n  \t\tTRANSITION$1 = 'webkitTransition';\n  \t\tTRANSITIONEND = 'webkitTransitionEnd';\n  \t\tCSS_TRANSITIONS_ENABLED = true;\n  \t} else {\n  \t\tCSS_TRANSITIONS_ENABLED = false;\n  \t}\n\n  \tif ( TRANSITION$1 ) {\n  \t\tTRANSITION_DURATION = TRANSITION$1 + 'Duration';\n  \t\tTRANSITION_PROPERTY = TRANSITION$1 + 'Property';\n  \t\tTRANSITION_TIMING_FUNCTION = TRANSITION$1 + 'TimingFunction';\n  \t}\n\n  \tcreateTransitions = function ( t, to, options, changedProperties, resolve ) {\n\n  \t\t// Wait a beat (otherwise the target styles will be applied immediately)\n  \t\t// TODO use a fastdom-style mechanism?\n  \t\tsetTimeout( function () {\n  \t\t\tvar jsTransitionsComplete;\n  \t\t\tvar cssTransitionsComplete;\n  \t\t\tvar cssTimeout;\n\n  \t\t\tfunction transitionDone () { clearTimeout( cssTimeout ); }\n\n  \t\t\tfunction checkComplete () {\n  \t\t\t\tif ( jsTransitionsComplete && cssTransitionsComplete ) {\n  \t\t\t\t\tt.unregisterCompleteHandler( transitionDone );\n  \t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n  \t\t\t\t\tt.ractive.fire( t.name + ':end', t.node, t.isIntro );\n  \t\t\t\t\tresolve();\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// this is used to keep track of which elements can use CSS to animate\n  \t\t\t// which properties\n  \t\t\tvar hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;\n\n  \t\t\t// need to reset transition properties\n  \t\t\tvar style = t.node.style;\n  \t\t\tvar previous = {\n  \t\t\t\tproperty: style[ TRANSITION_PROPERTY ],\n  \t\t\t\ttiming: style[ TRANSITION_TIMING_FUNCTION ],\n  \t\t\t\tduration: style[ TRANSITION_DURATION ]\n  \t\t\t};\n\n  \t\t\tstyle[ TRANSITION_PROPERTY ] = changedProperties.map( prefix$1 ).map( hyphenate ).join( ',' );\n  \t\t\tstyle[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );\n  \t\t\tstyle[ TRANSITION_DURATION ] = ( options.duration / 1000 ) + 's';\n\n  \t\t\tfunction transitionEndHandler ( event ) {\n  \t\t\t\tvar index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );\n\n  \t\t\t\tif ( index !== -1 ) {\n  \t\t\t\t\tchangedProperties.splice( index, 1 );\n  \t\t\t\t}\n\n  \t\t\t\tif ( changedProperties.length ) {\n  \t\t\t\t\t// still transitioning...\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tclearTimeout( cssTimeout );\n  \t\t\t\tcssTransitionsDone();\n  \t\t\t}\n\n  \t\t\tfunction cssTransitionsDone () {\n  \t\t\t\tstyle[ TRANSITION_PROPERTY ] = previous.property;\n  \t\t\t\tstyle[ TRANSITION_TIMING_FUNCTION ] = previous.duration;\n  \t\t\t\tstyle[ TRANSITION_DURATION ] = previous.timing;\n\n  \t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n  \t\t\t\tcssTransitionsComplete = true;\n  \t\t\t\tcheckComplete();\n  \t\t\t}\n\n  \t\t\tt.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );\n\n  \t\t\t// safety net in case transitionend never fires\n  \t\t\tcssTimeout = setTimeout( function () {\n  \t\t\t\tchangedProperties = [];\n  \t\t\t\tcssTransitionsDone();\n  \t\t\t}, options.duration + ( options.delay || 0 ) + 50 );\n  \t\t\tt.registerCompleteHandler( transitionDone );\n\n  \t\t\tsetTimeout( function () {\n  \t\t\t\tvar i = changedProperties.length;\n  \t\t\t\tvar hash;\n  \t\t\t\tvar originalValue;\n  \t\t\t\tvar index;\n  \t\t\t\tvar propertiesToTransitionInJs = [];\n  \t\t\t\tvar prop;\n  \t\t\t\tvar suffix;\n  \t\t\t\tvar interpolator;\n\n  \t\t\t\twhile ( i-- ) {\n  \t\t\t\t\tprop = changedProperties[i];\n  \t\t\t\t\thash = hashPrefix + prop;\n\n  \t\t\t\t\tif ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {\n  \t\t\t\t\t\tstyle[ prefix$1( prop ) ] = to[ prop ];\n\n  \t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n  \t\t\t\t\t\t// this tag/property combo, find out now\n  \t\t\t\t\t\tif ( !canUseCssTransitions[ hash ] ) {\n  \t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n\n  \t\t\t\t\t\t\t// if this property is transitionable in this browser,\n  \t\t\t\t\t\t\t// the current style will be different from the target style\n  \t\t\t\t\t\t\tcanUseCssTransitions[ hash ] = ( t.getStyle( prop ) != to[ prop ] );\n  \t\t\t\t\t\t\tcannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];\n\n  \t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n  \t\t\t\t\t\t\tif ( cannotUseCssTransitions[ hash ] ) {\n  \t\t\t\t\t\t\t\tstyle[ prefix$1( prop ) ] = originalValue;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n\n  \t\t\t\t\tif ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {\n  \t\t\t\t\t\t// we need to fall back to timer-based stuff\n  \t\t\t\t\t\tif ( originalValue === undefined ) {\n  \t\t\t\t\t\t\toriginalValue = t.getStyle( prop );\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n  \t\t\t\t\t\t// will get confused\n  \t\t\t\t\t\tindex = changedProperties.indexOf( prop );\n  \t\t\t\t\t\tif ( index === -1 ) {\n  \t\t\t\t\t\t\twarnIfDebug( 'Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!', { node: t.node });\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tchangedProperties.splice( index, 1 );\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n  \t\t\t\t\t\tsuffix = /[^\\d]*$/.exec( to[ prop ] )[0];\n  \t\t\t\t\t\tinterpolator = interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ) || ( function () { return to[ prop ]; } );\n\n  \t\t\t\t\t\t// ...then kick off a timer-based transition\n  \t\t\t\t\t\tpropertiesToTransitionInJs.push({\n  \t\t\t\t\t\t\tname: prefix$1( prop ),\n  \t\t\t\t\t\t\tinterpolator: interpolator,\n  \t\t\t\t\t\t\tsuffix: suffix\n  \t\t\t\t\t\t});\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// javascript transitions\n  \t\t\t\tif ( propertiesToTransitionInJs.length ) {\n  \t\t\t\t\tvar easing;\n\n  \t\t\t\t\tif ( typeof options.easing === 'string' ) {\n  \t\t\t\t\t\teasing = t.ractive.easing[ options.easing ];\n\n  \t\t\t\t\t\tif ( !easing ) {\n  \t\t\t\t\t\t\twarnOnceIfDebug( missingPlugin( options.easing, 'easing' ) );\n  \t\t\t\t\t\t\teasing = linear$1;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t} else if ( typeof options.easing === 'function' ) {\n  \t\t\t\t\t\teasing = options.easing;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\teasing = linear$1;\n  \t\t\t\t\t}\n\n  \t\t\t\t\tnew Ticker({\n  \t\t\t\t\t\tduration: options.duration,\n  \t\t\t\t\t\teasing: easing,\n  \t\t\t\t\t\tstep: function ( pos ) {\n  \t\t\t\t\t\t\tvar i = propertiesToTransitionInJs.length;\n  \t\t\t\t\t\t\twhile ( i-- ) {\n  \t\t\t\t\t\t\t\tvar prop = propertiesToTransitionInJs[i];\n  \t\t\t\t\t\t\t\tt.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t},\n  \t\t\t\t\t\tcomplete: function () {\n  \t\t\t\t\t\t\tjsTransitionsComplete = true;\n  \t\t\t\t\t\t\tcheckComplete();\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t} else {\n  \t\t\t\t\tjsTransitionsComplete = true;\n  \t\t\t\t}\n\n  \t\t\t\tif ( !changedProperties.length ) {\n  \t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n  \t\t\t\t\t// the fact that it will never fire\n  \t\t\t\t\tt.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );\n  \t\t\t\t\tcssTransitionsComplete = true;\n  \t\t\t\t\tcheckComplete();\n  \t\t\t\t}\n  \t\t\t}, 0 );\n  \t\t}, options.delay || 0 );\n  \t};\n  }\n\n  var createTransitions$1 = createTransitions;\n\n  function resetStyle ( node, style ) {\n  \tif ( style ) {\n  \t\tnode.setAttribute( 'style', style );\n  \t} else {\n  \t\t// Next line is necessary, to remove empty style attribute!\n  \t\t// See http://stackoverflow.com/a/7167553\n  \t\tnode.getAttribute( 'style' );\n  \t\tnode.removeAttribute( 'style' );\n  \t}\n  }\n\n  var getComputedStyle = win && ( win.getComputedStyle || legacy.getComputedStyle );\n  var resolved = Promise$1.resolve();\n\n  var names = {\n  \tt0: 'intro-outro',\n  \tt1: 'intro',\n  \tt2: 'outro'\n  };\n\n  var Transition = function Transition ( options ) {\n  \tthis.owner = options.owner || options.parentFragment.owner || findElement( options.parentFragment );\n  \tthis.element = this.owner.attributeByName ? this.owner : findElement( options.parentFragment );\n  \tthis.ractive = this.owner.ractive;\n  \tthis.template = options.template;\n  \tthis.parentFragment = options.parentFragment;\n  \tthis.options = options;\n  \tthis.onComplete = [];\n  };\n\n  Transition.prototype.animateStyle = function animateStyle ( style, value, options ) {\n  \tvar this$1 = this;\n\n  \t\tif ( arguments.length === 4 ) {\n  \t\tthrow new Error( 't.animateStyle() returns a promise - use .then() instead of passing a callback' );\n  \t}\n\n  \t// Special case - page isn't visible. Don't animate anything, because\n  \t// that way you'll never get CSS transitionend events\n  \tif ( !visible ) {\n  \t\tthis.setStyle( style, value );\n  \t\treturn resolved;\n  \t}\n\n  \tvar to;\n\n  \tif ( typeof style === 'string' ) {\n  \t\tto = {};\n  \t\tto[ style ] = value;\n  \t} else {\n  \t\tto = style;\n\n  \t\t// shuffle arguments\n  \t\toptions = value;\n  \t}\n\n  \t// As of 0.3.9, transition authors should supply an `option` object with\n  \t// `duration` and `easing` properties (and optional `delay`), plus a\n  \t// callback function that gets called after the animation completes\n\n  \t// TODO remove this check in a future version\n  \tif ( !options ) {\n  \t\twarnOnceIfDebug( 'The \"%s\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340', this.name );\n  \t\toptions = this;\n  \t}\n\n  \treturn new Promise$1( function ( fulfil ) {\n  \t\t// Edge case - if duration is zero, set style synchronously and complete\n  \t\tif ( !options.duration ) {\n  \t\t\tthis$1.setStyle( to );\n  \t\t\tfulfil();\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// Get a list of the properties we're animating\n  \t\tvar propertyNames = Object.keys( to );\n  \t\tvar changedProperties = [];\n\n  \t\t// Store the current styles\n  \t\tvar computedStyle = getComputedStyle( this$1.owner.node );\n\n  \t\tvar i = propertyNames.length;\n  \t\twhile ( i-- ) {\n  \t\t\tvar prop = propertyNames[i];\n  \t\t\tvar current = computedStyle[ prefix$1( prop ) ];\n\n  \t\t\tif ( current === '0px' ) current = 0;\n\n  \t\t\t// we need to know if we're actually changing anything\n  \t\t\tif ( current != to[ prop ] ) { // use != instead of !==, so we can compare strings with numbers\n  \t\t\t\tchangedProperties.push( prop );\n\n  \t\t\t\t// make the computed style explicit, so we can animate where\n  \t\t\t\t// e.g. height='auto'\n  \t\t\t\tthis$1.owner.node.style[ prefix$1( prop ) ] = current;\n  \t\t\t}\n  \t\t}\n\n  \t\t// If we're not actually changing anything, the transitionend event\n  \t\t// will never fire! So we complete early\n  \t\tif ( !changedProperties.length ) {\n  \t\t\tfulfil();\n  \t\t\treturn;\n  \t\t}\n\n  \t\tcreateTransitions$1( this$1, to, options, changedProperties, fulfil );\n  \t});\n  };\n\n  Transition.prototype.bind = function bind () {\n  \tvar this$1 = this;\n\n  \t\tvar options = this.options;\n  \tif ( options.template ) {\n  \t\tif ( options.template.v === 't0' || options.template.v == 't1' ) this.element._introTransition = this;\n  \t\tif ( options.template.v === 't0' || options.template.v == 't2' ) this.element._outroTransition = this;\n  \t\tthis.eventName = names[ options.template.v ];\n  \t}\n\n  \tvar ractive = this.owner.ractive;\n\n  \tif ( options.name ) {\n  \t\tthis.name = options.name;\n  \t} else {\n  \t\tvar name = options.template.f;\n  \t\tif ( typeof name.n === 'string' ) name = name.n;\n\n  \t\tif ( typeof name !== 'string' ) {\n  \t\t\tvar fragment = new Fragment({\n  \t\t\t\towner: this.owner,\n  \t\t\t\ttemplate: name.n\n  \t\t\t}).bind(); // TODO need a way to capture values without bind()\n\n  \t\t\tname = fragment.toString();\n  \t\t\tfragment.unbind();\n\n  \t\t\tif ( name === '' ) {\n  \t\t\t\t// empty string okay, just no transition\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.name = name;\n  \t}\n\n  \tif ( options.params ) {\n  \t\tthis.params = options.params;\n  \t} else {\n  \t\tif ( options.template.f.a && !options.template.f.a.s ) {\n  \t\t\tthis.params = options.template.f.a;\n  \t\t}\n\n  \t\telse if ( options.template.f.d ) {\n  \t\t\t// TODO is there a way to interpret dynamic arguments without all the\n  \t\t\t// 'dependency thrashing'?\n  \t\t\tvar fragment$1 = new Fragment({\n  \t\t\t\towner: this.owner,\n  \t\t\t\ttemplate: options.template.f.d\n  \t\t\t}).bind();\n\n  \t\t\tthis.params = fragment$1.getArgsList();\n  \t\t\tfragment$1.unbind();\n  \t\t}\n  \t}\n\n  \tif ( typeof this.name === 'function' ) {\n  \t\tthis._fn = this.name;\n  \t\tthis.name = this._fn.name;\n  \t} else {\n  \t\tthis._fn = findInViewHierarchy( 'transitions', ractive, this.name );\n  \t}\n\n  \tif ( !this._fn ) {\n  \t\twarnOnceIfDebug( missingPlugin( this.name, 'transition' ), { ractive: ractive });\n  \t}\n\n  \t// TODO: dry up after deprecation is done\n  \tif ( options.template && this.template.f.a && this.template.f.a.s ) {\n  \t\tthis.resolvers = [];\n  \t\tthis.models = this.template.f.a.r.map( function ( ref, i ) {\n  \t\t\tvar resolver;\n  \t\t\tvar model = resolveReference( this$1.parentFragment, ref );\n  \t\t\tif ( !model ) {\n  \t\t\t\tresolver = this$1.parentFragment.resolve( ref, function ( model ) {\n  \t\t\t\t\tthis$1.models[i] = model;\n  \t\t\t\t\tremoveFromArray( this$1.resolvers, resolver );\n  \t\t\t\t\tmodel.register( this$1 );\n  \t\t\t\t});\n\n  \t\t\t\tthis$1.resolvers.push( resolver );\n  \t\t\t} else model.register( this$1 );\n\n  \t\t\treturn model;\n  \t\t});\n  \t\tthis.argsFn = getFunction( this.template.f.a.s, this.template.f.a.r.length );\n  \t}\n  };\n\n  Transition.prototype.destroyed = function destroyed () {};\n\n  Transition.prototype.getStyle = function getStyle ( props ) {\n  \tvar computedStyle = getComputedStyle( this.owner.node );\n\n  \tif ( typeof props === 'string' ) {\n  \t\tvar value = computedStyle[ prefix$1( props ) ];\n  \t\treturn value === '0px' ? 0 : value;\n  \t}\n\n  \tif ( !isArray( props ) ) {\n  \t\tthrow new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );\n  \t}\n\n  \tvar styles = {};\n\n  \tvar i = props.length;\n  \twhile ( i-- ) {\n  \t\tvar prop = props[i];\n  \t\tvar value$1 = computedStyle[ prefix$1( prop ) ];\n\n  \t\tif ( value$1 === '0px' ) value$1 = 0;\n  \t\tstyles[ prop ] = value$1;\n  \t}\n\n  \treturn styles;\n  };\n\n  Transition.prototype.processParams = function processParams ( params, defaults ) {\n  \tif ( typeof params === 'number' ) {\n  \t\tparams = { duration: params };\n  \t}\n\n  \telse if ( typeof params === 'string' ) {\n  \t\tif ( params === 'slow' ) {\n  \t\t\tparams = { duration: 600 };\n  \t\t} else if ( params === 'fast' ) {\n  \t\t\tparams = { duration: 200 };\n  \t\t} else {\n  \t\t\tparams = { duration: 400 };\n  \t\t}\n  \t} else if ( !params ) {\n  \t\tparams = {};\n  \t}\n\n  \treturn extendObj( {}, defaults, params );\n  };\n\n  Transition.prototype.rebinding = function rebinding ( next, previous ) {\n  \tvar idx = this.models.indexOf( previous );\n  \tif ( !~idx ) return;\n\n  \tnext = rebindMatch( this.template.f.a.r[ idx ], next, previous );\n  \tif ( next === previous ) return;\n\n  \tprevious.unregister( this );\n  \tthis.models.splice( idx, 1, next );\n  \tif ( next ) next.addShuffleRegister( this, 'mark' );\n  };\n\n  Transition.prototype.registerCompleteHandler = function registerCompleteHandler ( fn ) {\n  \taddToArray( this.onComplete, fn );\n  };\n\n  Transition.prototype.render = function render () {};\n\n  Transition.prototype.setStyle = function setStyle ( style, value ) {\n  \tif ( typeof style === 'string' ) {\n  \t\tthis.owner.node.style[ prefix$1( style ) ] = value;\n  \t}\n\n  \telse {\n  \t\tvar prop;\n  \t\tfor ( prop in style ) {\n  \t\t\tif ( style.hasOwnProperty( prop ) ) {\n  \t\t\t\tthis.owner.node.style[ prefix$1( prop ) ] = style[ prop ];\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn this;\n  };\n\n  Transition.prototype.start = function start () {\n  \tvar this$1 = this;\n\n  \t\tvar node = this.node = this.element.node;\n  \tvar originalStyle = node.getAttribute( 'style' );\n\n  \tvar completed;\n  \tvar args = this.params;\n\n  \t// create t.complete() - we don't want this on the prototype,\n  \t// because we don't want `this` silliness when passing it as\n  \t// an argument\n  \tthis.complete = function ( noReset ) {\n  \t\tif ( completed ) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis$1.onComplete.forEach( function ( fn ) { return fn(); } );\n  \t\tif ( !noReset && this$1.isIntro ) {\n  \t\t\tresetStyle( node, originalStyle);\n  \t\t}\n\n  \t\tthis$1._manager.remove( this$1 );\n\n  \t\tcompleted = true;\n  \t};\n\n  \t// If the transition function doesn't exist, abort\n  \tif ( !this._fn ) {\n  \t\tthis.complete();\n  \t\treturn;\n  \t}\n\n  \t// get expression args if supplied\n  \tif ( this.argsFn ) {\n  \t\tvar values = this.models.map( function ( model ) {\n  \t\t\tif ( !model ) return undefined;\n\n  \t\t\treturn model.get();\n  \t\t});\n  \t\targs = this.argsFn.apply( this.ractive, values );\n  \t}\n\n  \tvar promise = this._fn.apply( this.ractive, [ this ].concat( args ) );\n  \tif ( promise ) promise.then( this.complete );\n  };\n\n  Transition.prototype.toString = function toString () { return ''; };\n\n  Transition.prototype.unbind = function unbind$1 () {\n  \tif ( this.resolvers ) this.resolvers.forEach( unbind );\n  };\n\n  Transition.prototype.unregisterCompleteHandler = function unregisterCompleteHandler ( fn ) {\n  \tremoveFromArray( this.onComplete, fn );\n  };\n\n  Transition.prototype.unrender = function unrender () {};\n\n  Transition.prototype.update = function update () {};\n\n  var elementCache = {};\n\n  var ieBug;\n  var ieBlacklist;\n\n  try {\n  \tcreateElement( 'table' ).innerHTML = 'foo';\n  } catch ( err ) {\n  \tieBug = true;\n\n  \tieBlacklist = {\n  \t\tTABLE:  [ '<table class=\"x\">', '</table>' ],\n  \t\tTHEAD:  [ '<table><thead class=\"x\">', '</thead></table>' ],\n  \t\tTBODY:  [ '<table><tbody class=\"x\">', '</tbody></table>' ],\n  \t\tTR:     [ '<table><tr class=\"x\">', '</tr></table>' ],\n  \t\tSELECT: [ '<select class=\"x\">', '</select>' ]\n  \t};\n  }\n\n  function insertHtml ( html, node, docFrag ) {\n  \tvar nodes = [];\n\n  \t// render 0 and false\n  \tif ( html == null || html === '' ) return nodes;\n\n  \tvar container;\n  \tvar wrapper;\n  \tvar selectedOption;\n\n  \tif ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {\n  \t\tcontainer = element( 'DIV' );\n  \t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n  \t\tcontainer = container.querySelector( '.x' );\n\n  \t\tif ( container.tagName === 'SELECT' ) {\n  \t\t\tselectedOption = container.options[ container.selectedIndex ];\n  \t\t}\n  \t}\n\n  \telse if ( node.namespaceURI === svg$1 ) {\n  \t\tcontainer = element( 'DIV' );\n  \t\tcontainer.innerHTML = '<svg class=\"x\">' + html + '</svg>';\n  \t\tcontainer = container.querySelector( '.x' );\n  \t}\n\n  \telse if ( node.tagName === 'TEXTAREA' ) {\n  \t\tcontainer = createElement( 'div' );\n\n  \t\tif ( typeof container.textContent !== 'undefined' ) {\n  \t\t\tcontainer.textContent = html;\n  \t\t} else {\n  \t\t\tcontainer.innerHTML = html;\n  \t\t}\n  \t}\n\n  \telse {\n  \t\tcontainer = element( node.tagName );\n  \t\tcontainer.innerHTML = html;\n\n  \t\tif ( container.tagName === 'SELECT' ) {\n  \t\t\tselectedOption = container.options[ container.selectedIndex ];\n  \t\t}\n  \t}\n\n  \tvar child;\n  \twhile ( child = container.firstChild ) {\n  \t\tnodes.push( child );\n  \t\tdocFrag.appendChild( child );\n  \t}\n\n  \t// This is really annoying. Extracting <option> nodes from the\n  \t// temporary container <select> causes the remaining ones to\n  \t// become selected. So now we have to deselect them. IE8, you\n  \t// amaze me. You really do\n  \t// ...and now Chrome too\n  \tvar i;\n  \tif ( node.tagName === 'SELECT' ) {\n  \t\ti = nodes.length;\n  \t\twhile ( i-- ) {\n  \t\t\tif ( nodes[i] !== selectedOption ) {\n  \t\t\t\tnodes[i].selected = false;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn nodes;\n  }\n\n  function element ( tagName ) {\n  \treturn elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );\n  }\n\n  var Triple = (function (Mustache) {\n  \tfunction Triple ( options ) {\n  \t\tMustache.call( this, options );\n  \t}\n\n  \tTriple.prototype = Object.create( Mustache && Mustache.prototype );\n  \tTriple.prototype.constructor = Triple;\n\n  \tTriple.prototype.detach = function detach () {\n  \t\tvar docFrag = createDocumentFragment();\n  \t\tthis.nodes.forEach( function ( node ) { return docFrag.appendChild( node ); } );\n  \t\treturn docFrag;\n  \t};\n\n  \tTriple.prototype.find = function find ( selector ) {\n  \t\tvar this$1 = this;\n\n  \t\tvar len = this.nodes.length;\n  \t\tvar i;\n\n  \t\tfor ( i = 0; i < len; i += 1 ) {\n  \t\t\tvar node = this$1.nodes[i];\n\n  \t\t\tif ( node.nodeType !== 1 ) continue;\n\n  \t\t\tif ( matches( node, selector ) ) return node;\n\n  \t\t\tvar queryResult = node.querySelector( selector );\n  \t\t\tif ( queryResult ) return queryResult;\n  \t\t}\n\n  \t\treturn null;\n  \t};\n\n  \tTriple.prototype.findAll = function findAll ( selector, query ) {\n  \t\tvar this$1 = this;\n\n  \t\tvar len = this.nodes.length;\n  \t\tvar i;\n\n  \t\tfor ( i = 0; i < len; i += 1 ) {\n  \t\t\tvar node = this$1.nodes[i];\n\n  \t\t\tif ( node.nodeType !== 1 ) continue;\n\n  \t\t\tif ( query.test( node ) ) query.add( node );\n\n  \t\t\tvar queryAllResult = node.querySelectorAll( selector );\n  \t\t\tif ( queryAllResult ) {\n  \t\t\t\tvar numNodes = queryAllResult.length;\n  \t\t\t\tvar j;\n\n  \t\t\t\tfor ( j = 0; j < numNodes; j += 1 ) {\n  \t\t\t\t\tquery.add( queryAllResult[j] );\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t};\n\n  \tTriple.prototype.findComponent = function findComponent () {\n  \t\treturn null;\n  \t};\n\n  \tTriple.prototype.firstNode = function firstNode () {\n  \t\treturn this.nodes[0];\n  \t};\n\n  \tTriple.prototype.render = function render ( target ) {\n  \t\tvar html = this.model ? this.model.get() : '';\n  \t\tthis.nodes = insertHtml( html, this.parentFragment.findParentNode(), target );\n  \t\tthis.rendered = true;\n  \t};\n\n  \tTriple.prototype.toString = function toString () {\n  \t\treturn this.model && this.model.get() != null ? decodeCharacterReferences( '' + this.model.get() ) : '';\n  \t};\n\n  \tTriple.prototype.unrender = function unrender () {\n  \t\tif ( this.nodes ) this.nodes.forEach( function ( node ) { return detachNode( node ); } );\n  \t\tthis.rendered = false;\n  \t};\n\n  \tTriple.prototype.update = function update () {\n  \t\tif ( this.rendered && this.dirty ) {\n  \t\t\tthis.dirty = false;\n\n  \t\t\tthis.unrender();\n  \t\t\tvar docFrag = createDocumentFragment();\n  \t\t\tthis.render( docFrag );\n\n  \t\t\tvar parentNode = this.parentFragment.findParentNode();\n  \t\t\tvar anchor = this.parentFragment.findNextNode( this );\n\n  \t\t\tparentNode.insertBefore( docFrag, anchor );\n  \t\t} else {\n  \t\t\t// make sure to reset the dirty flag even if not rendered\n  \t\t\tthis.dirty = false;\n  \t\t}\n  \t};\n\n  \treturn Triple;\n  }(Mustache));\n\n  var Yielder = (function (Item) {\n  \tfunction Yielder ( options ) {\n  \t\tItem.call( this, options );\n\n  \t\tthis.container = options.parentFragment.ractive;\n  \t\tthis.component = this.container.component;\n\n  \t\tthis.containerFragment = options.parentFragment;\n  \t\tthis.parentFragment = this.component.parentFragment;\n\n  \t\t// {{yield}} is equivalent to {{yield content}}\n  \t\tthis.name = options.template.n || '';\n  \t}\n\n  \tYielder.prototype = Object.create( Item && Item.prototype );\n  \tYielder.prototype.constructor = Yielder;\n\n  \tYielder.prototype.bind = function bind () {\n  \t\tvar name = this.name;\n\n  \t\t( this.component.yielders[ name ] || ( this.component.yielders[ name ] = [] ) ).push( this );\n\n  \t\t// TODO don't parse here\n  \t\tvar template = this.container._inlinePartials[ name || 'content' ];\n\n  \t\tif ( typeof template === 'string' ) {\n  \t\t\ttemplate = parse( template ).t;\n  \t\t}\n\n  \t\tif ( !template ) {\n  \t\t\twarnIfDebug( (\"Could not find template for partial \\\"\" + name + \"\\\"\"), { ractive: this.ractive });\n  \t\t\ttemplate = [];\n  \t\t}\n\n  \t\tthis.fragment = new Fragment({\n  \t\t\towner: this,\n  \t\t\tractive: this.container.parent,\n  \t\t\ttemplate: template\n  \t\t}).bind();\n  \t};\n\n  \tYielder.prototype.bubble = function bubble () {\n  \t\tif ( !this.dirty ) {\n  \t\t\tthis.containerFragment.bubble();\n  \t\t\tthis.dirty = true;\n  \t\t}\n  \t};\n\n  \tYielder.prototype.detach = function detach () {\n  \t\treturn this.fragment.detach();\n  \t};\n\n  \tYielder.prototype.find = function find ( selector ) {\n  \t\treturn this.fragment.find( selector );\n  \t};\n\n  \tYielder.prototype.findAll = function findAll ( selector, queryResult ) {\n  \t\tthis.fragment.findAll( selector, queryResult );\n  \t};\n\n  \tYielder.prototype.findComponent = function findComponent ( name ) {\n  \t\treturn this.fragment.findComponent( name );\n  \t};\n\n  \tYielder.prototype.findAllComponents = function findAllComponents ( name, queryResult ) {\n  \t\tthis.fragment.findAllComponents( name, queryResult );\n  \t};\n\n  \tYielder.prototype.findNextNode = function findNextNode() {\n  \t\treturn this.containerFragment.findNextNode( this );\n  \t};\n\n  \tYielder.prototype.firstNode = function firstNode ( skipParent ) {\n  \t\treturn this.fragment.firstNode( skipParent );\n  \t};\n\n  \tYielder.prototype.render = function render ( target, occupants ) {\n  \t\treturn this.fragment.render( target, occupants );\n  \t};\n\n  \tYielder.prototype.setTemplate = function setTemplate ( name ) {\n  \t\tvar template = this.parentFragment.ractive.partials[ name ];\n\n  \t\tif ( typeof template === 'string' ) {\n  \t\t\ttemplate = parse( template ).t;\n  \t\t}\n\n  \t\tthis.partialTemplate = template || []; // TODO warn on missing partial\n  \t};\n\n  \tYielder.prototype.toString = function toString ( escape ) {\n  \t\treturn this.fragment.toString( escape );\n  \t};\n\n  \tYielder.prototype.unbind = function unbind () {\n  \t\tthis.fragment.unbind();\n  \t\tremoveFromArray( this.component.yielders[ this.name ], this );\n  \t};\n\n  \tYielder.prototype.unrender = function unrender ( shouldDestroy ) {\n  \t\tthis.fragment.unrender( shouldDestroy );\n  \t};\n\n  \tYielder.prototype.update = function update () {\n  \t\tthis.dirty = false;\n  \t\tthis.fragment.update();\n  \t};\n\n  \treturn Yielder;\n  }(Item));\n\n  // finds the component constructor in the registry or view hierarchy registries\n  function getComponentConstructor ( ractive, name ) {\n  \tvar instance = findInstance( 'components', ractive, name );\n  \tvar Component;\n\n  \tif ( instance ) {\n  \t\tComponent = instance.components[ name ];\n\n  \t\t// best test we have for not Ractive.extend\n  \t\tif ( !Component._Parent ) {\n  \t\t\t// function option, execute and store for reset\n  \t\t\tvar fn = Component.bind( instance );\n  \t\t\tfn.isOwner = instance.components.hasOwnProperty( name );\n  \t\t\tComponent = fn();\n\n  \t\t\tif ( !Component ) {\n  \t\t\t\twarnIfDebug( noRegistryFunctionReturn, name, 'component', 'component', { ractive: ractive });\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif ( typeof Component === 'string' ) {\n  \t\t\t\t// allow string lookup\n  \t\t\t\tComponent = getComponentConstructor( ractive, Component );\n  \t\t\t}\n\n  \t\t\tComponent._fn = fn;\n  \t\t\tinstance.components[ name ] = Component;\n  \t\t}\n  \t}\n\n  \treturn Component;\n  }\n\n  var constructors = {};\n  constructors[ ALIAS ] = Alias;\n  constructors[ DOCTYPE ] = Doctype;\n  constructors[ INTERPOLATOR ] = Interpolator;\n  constructors[ PARTIAL ] = Partial;\n  constructors[ SECTION ] = Section;\n  constructors[ TRIPLE ] = Triple;\n  constructors[ YIELDER ] = Yielder;\n\n  constructors[ ATTRIBUTE ] = Attribute;\n  constructors[ BINDING_FLAG ] = BindingFlag;\n  constructors[ DECORATOR ] = Decorator;\n  constructors[ EVENT ] = EventDirective;\n  constructors[ TRANSITION ] = Transition;\n\n  var specialElements = {\n  \tdoctype: Doctype,\n  \tform: Form,\n  \tinput: Input,\n  \toption: Option,\n  \tselect: Select,\n  \ttextarea: Textarea\n  };\n\n  function createItem ( options ) {\n  \tif ( typeof options.template === 'string' ) {\n  \t\treturn new Text( options );\n  \t}\n\n  \tif ( options.template.t === ELEMENT ) {\n  \t\t// could be component or element\n  \t\tvar ComponentConstructor = getComponentConstructor( options.parentFragment.ractive, options.template.e );\n  \t\tif ( ComponentConstructor ) {\n  \t\t\treturn new Component( options, ComponentConstructor );\n  \t\t}\n\n  \t\tvar tagName = options.template.e.toLowerCase();\n\n  \t\tvar ElementConstructor = specialElements[ tagName ] || Element;\n  \t\treturn new ElementConstructor( options );\n  \t}\n\n  \tvar Item;\n\n  \t// component mappings are a special case of attribute\n  \tif ( options.template.t === ATTRIBUTE ) {\n  \t\tvar el = options.owner;\n  \t\tif ( !el || ( el.type !== COMPONENT && el.type !== ELEMENT ) ) {\n  \t\t\tel = findElement( options.parentFragment );\n  \t\t}\n  \t\toptions.element = el;\n\n  \t\tItem = el.type === COMPONENT ? Mapping : Attribute;\n  \t} else {\n  \t\tItem = constructors[ options.template.t ];\n  \t}\n\n  \tif ( !Item ) throw new Error( (\"Unrecognised item type \" + (options.template.t)) );\n\n  \treturn new Item( options );\n  }\n\n  // TODO all this code needs to die\n  function processItems ( items, values, guid, counter ) {\n  \tif ( counter === void 0 ) counter = 0;\n\n  \treturn items.map( function ( item ) {\n  \t\tif ( item.type === TEXT ) {\n  \t\t\treturn item.template;\n  \t\t}\n\n  \t\tif ( item.fragment ) {\n  \t\t\tif ( item.fragment.iterations ) {\n  \t\t\t\treturn item.fragment.iterations.map( function ( fragment ) {\n  \t\t\t\t\treturn processItems( fragment.items, values, guid, counter );\n  \t\t\t\t}).join( '' );\n  \t\t\t} else {\n  \t\t\t\treturn processItems( item.fragment.items, values, guid, counter );\n  \t\t\t}\n  \t\t}\n\n  \t\tvar placeholderId = \"\" + guid + \"-\" + (counter++);\n  \t\tvar model = item.model || item.newModel;\n\n  \t\tvalues[ placeholderId ] = model ?\n  \t\t\tmodel.wrapper ?\n  \t\t\t\tmodel.wrapperValue :\n  \t\t\t\tmodel.get() :\n  \t\t\tundefined;\n\n  \t\treturn '${' + placeholderId + '}';\n  \t}).join( '' );\n  }\n\n  function unrenderAndDestroy$1 ( item ) {\n  \titem.unrender( true );\n  }\n\n  var Fragment = function Fragment ( options ) {\n  \tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n\n  \tthis.isRoot = !options.owner.parentFragment;\n  \tthis.parent = this.isRoot ? null : this.owner.parentFragment;\n  \tthis.ractive = options.ractive || ( this.isRoot ? options.owner : this.parent.ractive );\n\n  \tthis.componentParent = ( this.isRoot && this.ractive.component ) ? this.ractive.component.parentFragment : null;\n\n  \tthis.context = null;\n  \tthis.rendered = false;\n\n  \t// encapsulated styles should be inherited until they get applied by an element\n  \tthis.cssIds = 'cssIds' in options ? options.cssIds : ( this.parent ? this.parent.cssIds : null );\n\n  \tthis.resolvers = [];\n\n  \tthis.dirty = false;\n  \tthis.dirtyArgs = this.dirtyValue = true; // TODO getArgsList is nonsense - should deprecate legacy directives style\n\n  \tthis.template = options.template || [];\n  \tthis.createItems();\n  };\n\n  Fragment.prototype.bind = function bind$1$$ ( context ) {\n  \tthis.context = context;\n  \tthis.items.forEach( bind$1 );\n  \tthis.bound = true;\n\n  \t// in rare cases, a forced resolution (or similar) will cause the\n  \t// fragment to be dirty before it's even finished binding. In those\n  \t// cases we update immediately\n  \tif ( this.dirty ) this.update();\n\n  \treturn this;\n  };\n\n  Fragment.prototype.bubble = function bubble () {\n  \tthis.dirtyArgs = this.dirtyValue = true;\n\n  \tif ( !this.dirty ) {\n  \t\tthis.dirty = true;\n\n  \t\tif ( this.isRoot ) { // TODO encapsulate 'is component root, but not overall root' check?\n  \t\t\tif ( this.ractive.component ) {\n  \t\t\t\tthis.ractive.component.bubble();\n  \t\t\t} else if ( this.bound ) {\n  \t\t\t\trunloop.addFragment( this );\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis.owner.bubble();\n  \t\t}\n  \t}\n  };\n\n  Fragment.prototype.createItems = function createItems () {\n  \t// this is a hot code path\n  \tvar this$1 = this;\n\n  \t\tvar max = this.template.length;\n  \tthis.items = [];\n  \tfor ( var i = 0; i < max; i++ ) {\n  \t\tthis$1.items[i] = createItem({ parentFragment: this$1, template: this$1.template[i], index: i });\n  \t}\n  };\n\n  Fragment.prototype.destroyed = function destroyed () {\n  \tthis.items.forEach( function ( i ) { return i.destroyed(); } );\n  };\n\n  Fragment.prototype.detach = function detach () {\n  \tvar docFrag = createDocumentFragment();\n  \tthis.items.forEach( function ( item ) { return docFrag.appendChild( item.detach() ); } );\n  \treturn docFrag;\n  };\n\n  Fragment.prototype.find = function find ( selector ) {\n  \tvar this$1 = this;\n\n  \t\tvar len = this.items.length;\n  \tvar i;\n\n  \tfor ( i = 0; i < len; i += 1 ) {\n  \t\tvar found = this$1.items[i].find( selector );\n  \t\tif ( found ) return found;\n  \t}\n  };\n\n  Fragment.prototype.findAll = function findAll ( selector, query ) {\n  \tvar this$1 = this;\n\n  \t\tif ( this.items ) {\n  \t\tvar len = this.items.length;\n  \t\tvar i;\n\n  \t\tfor ( i = 0; i < len; i += 1 ) {\n  \t\t\tvar item = this$1.items[i];\n\n  \t\t\tif ( item.findAll ) {\n  \t\t\t\titem.findAll( selector, query );\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn query;\n  };\n\n  Fragment.prototype.findComponent = function findComponent ( name ) {\n  \tvar this$1 = this;\n\n  \t\tvar len = this.items.length;\n  \tvar i;\n\n  \tfor ( i = 0; i < len; i += 1 ) {\n  \t\tvar found = this$1.items[i].findComponent( name );\n  \t\tif ( found ) return found;\n  \t}\n  };\n\n  Fragment.prototype.findAllComponents = function findAllComponents ( name, query ) {\n  \tvar this$1 = this;\n\n  \t\tif ( this.items ) {\n  \t\tvar len = this.items.length;\n  \t\tvar i;\n\n  \t\tfor ( i = 0; i < len; i += 1 ) {\n  \t\t\tvar item = this$1.items[i];\n\n  \t\t\tif ( item.findAllComponents ) {\n  \t\t\t\titem.findAllComponents( name, query );\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn query;\n  };\n\n  Fragment.prototype.findContext = function findContext () {\n  \tvar fragment = this;\n  \twhile ( fragment && !fragment.context ) fragment = fragment.parent;\n  \tif ( !fragment ) return this.ractive.viewmodel;\n  \telse return fragment.context;\n  };\n\n  Fragment.prototype.findNextNode = function findNextNode ( item ) {\n  \t// search for the next node going forward\n  \tvar this$1 = this;\n\n  \t\tif ( item ) {\n  \t\tfor ( var i = item.index + 1; i < this$1.items.length; i++ ) {\n  \t\t\tif ( !this$1.items[ i ] ) continue;\n\n  \t\t\tvar node = this$1.items[ i ].firstNode( true );\n  \t\t\tif ( node ) return node;\n  \t\t}\n  \t}\n\n  \t// if this is the root fragment, and there are no more items,\n  \t// it means we're at the end...\n  \tif ( this.isRoot ) {\n  \t\tif ( this.ractive.component ) {\n  \t\t\treturn this.ractive.component.parentFragment.findNextNode( this.ractive.component );\n  \t\t}\n\n  \t\t// TODO possible edge case with other content\n  \t\t// appended to this.ractive.el?\n  \t\treturn null;\n  \t}\n\n  \tif ( this.parent ) return this.owner.findNextNode( this ); // the argument is in case the parent is a RepeatedFragment\n  };\n\n  Fragment.prototype.findParentNode = function findParentNode () {\n  \tvar fragment = this;\n\n  \tdo {\n  \t\tif ( fragment.owner.type === ELEMENT ) {\n  \t\t\treturn fragment.owner.node;\n  \t\t}\n\n  \t\tif ( fragment.isRoot && !fragment.ractive.component ) { // TODO encapsulate check\n  \t\t\treturn fragment.ractive.el;\n  \t\t}\n\n  \t\tif ( fragment.owner.type === YIELDER ) {\n  \t\t\tfragment = fragment.owner.containerFragment;\n  \t\t} else {\n  \t\t\tfragment = fragment.componentParent || fragment.parent; // TODO ugh\n  \t\t}\n  \t} while ( fragment );\n\n  \tthrow new Error( 'Could not find parent node' ); // TODO link to issue tracker\n  };\n\n  Fragment.prototype.findRepeatingFragment = function findRepeatingFragment () {\n  \tvar fragment = this;\n  \t// TODO better check than fragment.parent.iterations\n  \twhile ( ( fragment.parent || fragment.componentParent ) && !fragment.isIteration ) {\n  \t\tfragment = fragment.parent || fragment.componentParent;\n  \t}\n\n  \treturn fragment;\n  };\n\n  Fragment.prototype.firstNode = function firstNode ( skipParent ) {\n  \tvar this$1 = this;\n\n  \t\tvar node;\n  \tfor ( var i = 0; i < this$1.items.length; i++ ) {\n  \t\tnode = this$1.items[i].firstNode( true );\n\n  \t\tif ( node ) {\n  \t\t\treturn node;\n  \t\t}\n  \t}\n\n  \tif ( skipParent ) return null;\n\n  \treturn this.parent.findNextNode( this.owner );\n  };\n\n  // TODO ideally, this would be deprecated in favour of an\n  // expression-like approach\n  Fragment.prototype.getArgsList = function getArgsList () {\n  \tif ( this.dirtyArgs ) {\n  \t\tvar values = {};\n  \t\tvar source = processItems( this.items, values, this.ractive._guid );\n  \t\tvar parsed = parseJSON( '[' + source + ']', values );\n\n  \t\tthis.argsList = parsed ?\n  \t\t\tparsed.value :\n  \t\t\t[ this.toString() ];\n\n  \t\tthis.dirtyArgs = false;\n  \t}\n\n  \treturn this.argsList;\n  };\n\n  Fragment.prototype.rebinding = function rebinding ( next ) {\n  \tthis.context = next;\n  };\n\n  Fragment.prototype.render = function render ( target, occupants ) {\n  \tif ( this.rendered ) throw new Error( 'Fragment is already rendered!' );\n  \tthis.rendered = true;\n\n  \tthis.items.forEach( function ( item ) { return item.render( target, occupants ); } );\n  };\n\n  Fragment.prototype.resetTemplate = function resetTemplate ( template ) {\n  \tvar wasBound = this.bound;\n  \tvar wasRendered = this.rendered;\n\n  \t// TODO ensure transitions are disabled globally during reset\n\n  \tif ( wasBound ) {\n  \t\tif ( wasRendered ) this.unrender( true );\n  \t\tthis.unbind();\n  \t}\n\n  \tthis.template = template;\n  \tthis.createItems();\n\n  \tif ( wasBound ) {\n  \t\tthis.bind( this.context );\n\n  \t\tif ( wasRendered ) {\n  \t\t\tvar parentNode = this.findParentNode();\n  \t\t\tvar anchor = this.findNextNode();\n\n  \t\t\tif ( anchor ) {\n  \t\t\t\tvar docFrag = createDocumentFragment();\n  \t\t\t\tthis.render( docFrag );\n  \t\t\t\tparentNode.insertBefore( docFrag, anchor );\n  \t\t\t} else {\n  \t\t\t\tthis.render( parentNode );\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  Fragment.prototype.resolve = function resolve ( template, callback ) {\n  \tif ( !this.context && this.parent.resolve ) {\n  \t\treturn this.parent.resolve( template, callback );\n  \t}\n\n  \tvar resolver = new ReferenceResolver( this, template, callback );\n  \tthis.resolvers.push( resolver );\n\n  \treturn resolver; // so we can e.g. force resolution\n  };\n\n  Fragment.prototype.shuffled = function shuffled () {\n  \tthis.items.forEach( function ( i ) { return i.shuffled(); } );\n  };\n\n  Fragment.prototype.toHtml = function toHtml () {\n  \treturn this.toString();\n  };\n\n  Fragment.prototype.toString = function toString$1$$ ( escape ) {\n  \treturn this.items.map( escape ? toEscapedString : toString$1 ).join( '' );\n  };\n\n  Fragment.prototype.unbind = function unbind$1 () {\n  \tthis.items.forEach( unbind );\n  \tthis.bound = false;\n\n  \treturn this;\n  };\n\n  Fragment.prototype.unrender = function unrender$1 ( shouldDestroy ) {\n  \tthis.items.forEach( shouldDestroy ? unrenderAndDestroy$1 : unrender );\n  \tthis.rendered = false;\n  };\n\n  Fragment.prototype.update = function update$1 () {\n  \tif ( this.dirty ) {\n  \t\tif ( !this.updating ) {\n  \t\t\tthis.dirty = false;\n  \t\t\tthis.updating = true;\n  \t\t\tthis.items.forEach( update );\n  \t\t\tthis.updating = false;\n  \t\t} else if ( this.isRoot ) {\n  \t\t\trunloop.addFragmentToRoot( this );\n  \t\t}\n  \t}\n  };\n\n  Fragment.prototype.valueOf = function valueOf () {\n  \tif ( this.items.length === 1 ) {\n  \t\treturn this.items[0].valueOf();\n  \t}\n\n  \tif ( this.dirtyValue ) {\n  \t\tvar values = {};\n  \t\tvar source = processItems( this.items, values, this.ractive._guid );\n  \t\tvar parsed = parseJSON( source, values );\n\n  \t\tthis.value = parsed ?\n  \t\t\tparsed.value :\n  \t\t\tthis.toString();\n\n  \t\tthis.dirtyValue = false;\n  \t}\n\n  \treturn this.value;\n  };\n\n  // TODO should resetTemplate be asynchronous? i.e. should it be a case\n  // of outro, update template, intro? I reckon probably not, since that\n  // could be achieved with unrender-resetTemplate-render. Also, it should\n  // conceptually be similar to resetPartial, which couldn't be async\n\n  function Ractive$resetTemplate ( template ) {\n  \ttemplateConfigurator.init( null, this, { template: template });\n\n  \tvar transitionsEnabled = this.transitionsEnabled;\n  \tthis.transitionsEnabled = false;\n\n  \t// Is this is a component, we need to set the `shouldDestroy`\n  \t// flag, otherwise it will assume by default that a parent node\n  \t// will be detached, and therefore it doesn't need to bother\n  \t// detaching its own nodes\n  \tvar component = this.component;\n  \tif ( component ) component.shouldDestroy = true;\n  \tthis.unrender();\n  \tif ( component ) component.shouldDestroy = false;\n\n  \t// remove existing fragment and create new one\n  \tthis.fragment.unbind().unrender( true );\n\n  \tthis.fragment = new Fragment({\n  \t\ttemplate: this.template,\n  \t\troot: this,\n  \t\towner: this\n  \t});\n\n  \tvar docFrag = createDocumentFragment();\n  \tthis.fragment.bind( this.viewmodel ).render( docFrag );\n\n  \t// if this is a component, its el may not be valid, so find a\n  \t// target based on the component container\n  \tif ( component ) {\n  \t\tthis.fragment.findParentNode().insertBefore( docFrag, component.findNextNode() );\n  \t} else {\n  \t\tthis.el.insertBefore( docFrag, this.anchor );\n  \t}\n\n  \tthis.transitionsEnabled = transitionsEnabled;\n  }\n\n  var reverse$1 = makeArrayMethod( 'reverse' ).path;\n\n  function Ractive$set ( keypath, value ) {\n  \tvar ractive = this;\n\n  \treturn set( ractive, build( ractive, keypath, value ) );\n  }\n\n  var shift$1 = makeArrayMethod( 'shift' ).path;\n\n  var sort$1 = makeArrayMethod( 'sort' ).path;\n\n  var splice$1 = makeArrayMethod( 'splice' ).path;\n\n  function Ractive$subtract ( keypath, d ) {\n  \treturn add( this, keypath, ( d === undefined ? -1 : -d ) );\n  }\n\n  var teardownHook$1 = new Hook( 'teardown' );\n\n  // Teardown. This goes through the root fragment and all its children, removing observers\n  // and generally cleaning up after itself\n\n  function Ractive$teardown () {\n  \tif ( this.torndown ) {\n  \t\twarnIfDebug( 'ractive.teardown() was called on a Ractive instance that was already torn down' );\n  \t\treturn Promise$1.resolve();\n  \t}\n\n  \tthis.torndown = true;\n  \tthis.fragment.unbind();\n  \tthis.viewmodel.teardown();\n\n  \tthis._observers.forEach( cancel );\n\n  \tif ( this.fragment.rendered && this.el.__ractive_instances__ ) {\n  \t\tremoveFromArray( this.el.__ractive_instances__, this );\n  \t}\n\n  \tthis.shouldDestroy = true;\n  \tvar promise = ( this.fragment.rendered ? this.unrender() : Promise$1.resolve() );\n\n  \tteardownHook$1.fire( this );\n\n  \treturn promise;\n  }\n\n  function Ractive$toggle ( keypath ) {\n  \tif ( typeof keypath !== 'string' ) {\n  \t\tthrow new TypeError( badArguments );\n  \t}\n\n  \treturn set( this, gather( this, keypath ).map( function ( m ) { return [ m, !m.get() ]; } ) );\n  }\n\n  function Ractive$toCSS() {\n  \tvar cssIds = [ this.cssId ].concat( this.findAllComponents().map( function ( c ) { return c.cssId; } ) );\n  \tvar uniqueCssIds = Object.keys(cssIds.reduce( function ( ids, id ) { return (ids[id] = true, ids); }, {}));\n  \treturn getCSS( uniqueCssIds );\n  }\n\n  function Ractive$toHTML () {\n  \treturn this.fragment.toString( true );\n  }\n\n  function toText () {\n  \treturn this.fragment.toString( false );\n  }\n\n  function Ractive$transition ( name, node, params ) {\n\n  \tif ( node instanceof HTMLElement ) {\n  \t\t// good to go\n  \t}\n  \telse if ( isObject( node ) ) {\n  \t\t// omitted, use event node\n  \t\tparams = node;\n  \t}\n\n  \t// if we allow query selector, then it won't work\n  \t// simple params like \"fast\"\n\n  \t// else if ( typeof node === 'string' ) {\n  \t// \t// query selector\n  \t// \tnode = this.find( node )\n  \t// }\n\n  \tnode = node || this.event.node;\n\n  \tif ( !node || !node._ractive ) {\n  \t\tfatal( (\"No node was supplied for transition \" + name) );\n  \t}\n\n  \tparams = params || {};\n  \tvar owner = node._ractive.proxy;\n  \tvar transition = new Transition({ owner: owner, parentFragment: owner.parentFragment, name: name, params: params });\n  \ttransition.bind();\n\n  \tvar promise = runloop.start( this, true );\n  \trunloop.registerTransition( transition );\n  \trunloop.end();\n\n  \tpromise.then( function () { return transition.unbind(); } );\n  \treturn promise;\n  }\n\n  function unlink$1( here ) {\n  \tvar promise = runloop.start();\n  \tthis.viewmodel.joinAll( splitKeypathI( here ), { lastLink: false } ).unlink();\n  \trunloop.end();\n  \treturn promise;\n  }\n\n  var unrenderHook$1 = new Hook( 'unrender' );\n\n  function Ractive$unrender () {\n  \tif ( !this.fragment.rendered ) {\n  \t\twarnIfDebug( 'ractive.unrender() was called on a Ractive instance that was not rendered' );\n  \t\treturn Promise$1.resolve();\n  \t}\n\n  \tvar promise = runloop.start( this, true );\n\n  \t// If this is a component, and the component isn't marked for destruction,\n  \t// don't detach nodes from the DOM unnecessarily\n  \tvar shouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n  \tthis.fragment.unrender( shouldDestroy );\n\n  \tremoveFromArray( this.el.__ractive_instances__, this );\n\n  \tunrenderHook$1.fire( this );\n\n  \trunloop.end();\n  \treturn promise;\n  }\n\n  var unshift$1 = makeArrayMethod( 'unshift' ).path;\n\n  function Ractive$updateModel ( keypath, cascade ) {\n  \tvar promise = runloop.start( this, true );\n\n  \tif ( !keypath ) {\n  \t\tthis.viewmodel.updateFromBindings( true );\n  \t} else {\n  \t\tthis.viewmodel.joinAll( splitKeypathI( keypath ) ).updateFromBindings( cascade !== false );\n  \t}\n\n  \trunloop.end();\n\n  \treturn promise;\n  }\n\n  var proto = {\n  \tadd: Ractive$add,\n  \tanimate: Ractive$animate,\n  \tdetach: Ractive$detach,\n  \tfind: Ractive$find,\n  \tfindAll: Ractive$findAll,\n  \tfindAllComponents: Ractive$findAllComponents,\n  \tfindComponent: Ractive$findComponent,\n  \tfindContainer: Ractive$findContainer,\n  \tfindParent: Ractive$findParent,\n  \tfire: Ractive$fire,\n  \tget: Ractive$get,\n  \tgetNodeInfo: getNodeInfo,\n  \tinsert: Ractive$insert,\n  \tlink: link$1,\n  \tmerge: thisRactive$merge,\n  \tobserve: observe,\n  \tobserveList: observeList,\n  \tobserveOnce: observeOnce,\n  \t// TODO reinstate these\n  \t// observeListOnce,\n  \toff: Ractive$off,\n  \ton: Ractive$on,\n  \tonce: Ractive$once,\n  \tpop: pop$1,\n  \tpush: push$1,\n  \trender: Ractive$render,\n  \treset: Ractive$reset,\n  \tresetPartial: resetPartial,\n  \tresetTemplate: Ractive$resetTemplate,\n  \treverse: reverse$1,\n  \tset: Ractive$set,\n  \tshift: shift$1,\n  \tsort: sort$1,\n  \tsplice: splice$1,\n  \tsubtract: Ractive$subtract,\n  \tteardown: Ractive$teardown,\n  \ttoggle: Ractive$toggle,\n  \ttoCSS: Ractive$toCSS,\n  \ttoCss: Ractive$toCSS,\n  \ttoHTML: Ractive$toHTML,\n  \ttoHtml: Ractive$toHTML,\n  \ttoText: toText,\n  \ttransition: Ractive$transition,\n  \tunlink: unlink$1,\n  \tunrender: Ractive$unrender,\n  \tunshift: unshift$1,\n  \tupdate: Ractive$update,\n  \tupdateModel: Ractive$updateModel\n  };\n\n  function wrap$1 ( method, superMethod, force ) {\n\n  \tif ( force || needsSuper( method, superMethod ) )  {\n\n  \t\treturn function () {\n\n  \t\t\tvar hasSuper = ( '_super' in this ), _super = this._super, result;\n\n  \t\t\tthis._super = superMethod;\n\n  \t\t\tresult = method.apply( this, arguments );\n\n  \t\t\tif ( hasSuper ) {\n  \t\t\t\tthis._super = _super;\n  \t\t\t}\n\n  \t\t\treturn result;\n  \t\t};\n  \t}\n\n  \telse {\n  \t\treturn method;\n  \t}\n  }\n\n  function needsSuper ( method, superMethod ) {\n  \treturn typeof superMethod === 'function' && /_super/.test( method );\n  }\n\n  function unwrap ( Child ) {\n  \tvar options = {};\n\n  \twhile ( Child ) {\n  \t\taddRegistries( Child, options );\n  \t\taddOtherOptions( Child, options );\n\n  \t\tif ( Child._Parent !== Ractive ) {\n  \t\t\tChild = Child._Parent;\n  \t\t} else {\n  \t\t\tChild = false;\n  \t\t}\n  \t}\n\n  \treturn options;\n  }\n\n  function addRegistries ( Child, options ) {\n  \tregistries.forEach( function ( r ) {\n  \t\taddRegistry(\n  \t\t\tr.useDefaults ? Child.prototype : Child,\n  \t\t\toptions, r.name );\n  \t});\n  }\n\n  function addRegistry ( target, options, name ) {\n  \tvar registry, keys = Object.keys( target[ name ] );\n\n  \tif ( !keys.length ) { return; }\n\n  \tif ( !( registry = options[ name ] ) ) {\n  \t\tregistry = options[ name ] = {};\n  \t}\n\n  \tkeys\n  \t\t.filter( function ( key ) { return !( key in registry ); } )\n  \t\t.forEach( function ( key ) { return registry[ key ] = target[ name ][ key ]; } );\n  }\n\n  function addOtherOptions ( Child, options ) {\n  \tObject.keys( Child.prototype ).forEach( function ( key ) {\n  \t\tif ( key === 'computed' ) { return; }\n\n  \t\tvar value = Child.prototype[ key ];\n\n  \t\tif ( !( key in options ) ) {\n  \t\t\toptions[ key ] = value._method ? value._method : value;\n  \t\t}\n\n  \t\t// is it a wrapped function?\n  \t\telse if ( typeof options[ key ] === 'function'\n  \t\t\t\t&& typeof value === 'function'\n  \t\t\t\t&& options[ key ]._method ) {\n\n  \t\t\tvar result, needsSuper = value._method;\n\n  \t\t\tif ( needsSuper ) { value = value._method; }\n\n  \t\t\t// rewrap bound directly to parent fn\n  \t\t\tresult = wrap$1( options[ key ]._method, value );\n\n  \t\t\tif ( needsSuper ) { result._method = result; }\n\n  \t\t\toptions[ key ] = result;\n  \t\t}\n  \t});\n  }\n\n  function extend () {\n  \tvar options = [], len = arguments.length;\n  \twhile ( len-- ) options[ len ] = arguments[ len ];\n\n  \tif( !options.length ) {\n  \t\treturn extendOne( this );\n  \t} else {\n  \t\treturn options.reduce( extendOne, this );\n  \t}\n  }\n\n  function extendOne ( Parent, options ) {\n  \tif ( options === void 0 ) options = {};\n\n  \tvar Child, proto;\n\n  \t// if we're extending with another Ractive instance...\n  \t//\n  \t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n  \t//   var Spiderman = Human.extend( Spider );\n  \t//\n  \t// ...inherit prototype methods and default options as well\n  \tif ( options.prototype instanceof Ractive ) {\n  \t\toptions = unwrap( options );\n  \t}\n\n  \tChild = function ( options ) {\n  \t\tif ( !( this instanceof Child ) ) return new Child( options );\n\n  \t\tconstruct( this, options || {} );\n  \t\tinitialise( this, options || {}, {} );\n  \t};\n\n  \tproto = create( Parent.prototype );\n  \tproto.constructor = Child;\n\n  \t// Static properties\n  \tdefineProperties( Child, {\n  \t\t// alias prototype as defaults\n  \t\tdefaults: { value: proto },\n\n  \t\t// extendable\n  \t\textend: { value: extend, writable: true, configurable: true },\n\n  \t\t// Parent - for IE8, can't use Object.getPrototypeOf\n  \t\t_Parent: { value: Parent }\n  \t});\n\n  \t// extend configuration\n  \tconfig.extend( Parent, proto, options );\n\n  \tdataConfigurator.extend( Parent, proto, options );\n\n  \tif ( options.computed ) {\n  \t\tproto.computed = extendObj( create( Parent.prototype.computed ), options.computed );\n  \t}\n\n  \tChild.prototype = proto;\n\n  \treturn Child;\n  }\n\n  function joinKeys () {\n  \tvar keys = [], len = arguments.length;\n  \twhile ( len-- ) keys[ len ] = arguments[ len ];\n\n  \treturn keys.map( escapeKey ).join( '.' );\n  }\n\n  function splitKeypath ( keypath ) {\n  \treturn splitKeypathI( keypath ).map( unescapeKey );\n  }\n\n  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n  // older browsers, these are made available via a shim - here, we do a quick\n  // pre-flight check to make sure that either a) we're not in a shit browser,\n  // or b) we're using a Ractive-legacy.js build\n  var FUNCTION = 'function';\n\n  if (\n  \ttypeof Date.now !== FUNCTION                 ||\n  \ttypeof String.prototype.trim !== FUNCTION    ||\n  \ttypeof Object.keys !== FUNCTION              ||\n  \ttypeof Array.prototype.indexOf !== FUNCTION  ||\n  \ttypeof Array.prototype.forEach !== FUNCTION  ||\n  \ttypeof Array.prototype.map !== FUNCTION      ||\n  \ttypeof Array.prototype.filter !== FUNCTION   ||\n  \t( win && typeof win.addEventListener !== FUNCTION )\n  ) {\n  \tthrow new Error( 'It looks like you\\'re attempting to use Ractive.js in an older browser. You\\'ll need to use one of the \\'legacy builds\\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );\n  }\n\n  function Ractive ( options ) {\n  \tif ( !( this instanceof Ractive ) ) return new Ractive( options );\n\n  \tconstruct( this, options || {} );\n  \tinitialise( this, options || {}, {} );\n  }\n\n  extendObj( Ractive.prototype, proto, defaults );\n  Ractive.prototype.constructor = Ractive;\n\n  // alias prototype as `defaults`\n  Ractive.defaults = Ractive.prototype;\n\n  // static properties\n  defineProperties( Ractive, {\n\n  \t// debug flag\n  \tDEBUG:          { writable: true, value: true },\n  \tDEBUG_PROMISES: { writable: true, value: true },\n\n  \t// static methods:\n  \textend:         { value: extend },\n  \tescapeKey:      { value: escapeKey },\n  \tgetNodeInfo:    { value: staticInfo },\n  \tjoinKeys:       { value: joinKeys },\n  \tparse:          { value: parse },\n  \tsplitKeypath:   { value: splitKeypath },\n  \tunescapeKey:    { value: unescapeKey },\n  \tgetCSS:         { value: getCSS },\n\n  \t// namespaced constructors\n  \tPromise:        { value: Promise$1 },\n\n  \t// support\n  \tenhance:        { writable: true, value: false },\n  \tsvg:            { value: svg },\n  \tmagic:          { value: magicSupported },\n\n  \t// version\n  \tVERSION:        { value: '0.8.5' },\n\n  \t// plugins\n  \tadaptors:       { writable: true, value: {} },\n  \tcomponents:     { writable: true, value: {} },\n  \tdecorators:     { writable: true, value: {} },\n  \teasing:         { writable: true, value: easing },\n  \tevents:         { writable: true, value: {} },\n  \tinterpolators:  { writable: true, value: interpolators },\n  \tpartials:       { writable: true, value: {} },\n  \ttransitions:    { writable: true, value: {} }\n  });\n\n  return Ractive;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ractive/ractive.js\n// module id = 2\n// module chunks = 0","module.exports={\"v\":4,\"t\":[{\"t\":7,\"e\":\"Header\"},\" \",{\"t\":7,\"e\":\"main\",\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"intro-wrap\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"h1\",\"f\":[\"Select your username\"]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"label\",\"f\":[\"Username: \",{\"t\":7,\"e\":\"input\",\"m\":[{\"n\":\"change\",\"f\":\"handleInput\",\"t\":70},{\"n\":\"name\",\"f\":\"user\",\"t\":13},{\"n\":\"type\",\"f\":\"input\",\"t\":13},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"user\"}],\"t\":13}]}]},\" \",{\"t\":7,\"e\":\"br\"},\" \",{\"t\":7,\"e\":\"button\",\"m\":[{\"n\":\"tap\",\"f\":\"hideUserForm\",\"t\":70}],\"f\":[\"Select\"]}]}]}],\"n\":51,\"r\":\"selectUser\"},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"page-wrap\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input status-wrap\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"col-1\",\"t\":13}],\"f\":[{\"t\":4,\"f\":[{\"t\":7,\"e\":\"div\",\"f\":[\"Your username is \",{\"t\":7,\"e\":\"strong\",\"f\":[{\"t\":2,\"r\":\"user\"}]}]}],\"n\":50,\"r\":\"user\"},\" \",{\"t\":7,\"e\":\"div\",\"f\":[\"Connection status: \",{\"t\":7,\"e\":\"strong\",\"f\":[{\"t\":4,\"f\":[\"open\"],\"n\":50,\"r\":\"conn\"},{\"t\":4,\"n\":51,\"f\":[\"closed\"],\"l\":1}]}]},\" \",{\"t\":4,\"f\":[{\"t\":7,\"e\":\"button\",\"m\":[{\"n\":\"tap\",\"f\":\"connect\",\"t\":70}],\"f\":[\"connect\"]}],\"n\":50,\"x\":{\"r\":[\"conn\"],\"s\":\"!_0\"}}]},{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"col-2\",\"t\":13}],\"f\":[\" \",{\"t\":4,\"f\":[{\"t\":7,\"e\":\"div\",\"f\":[\"Incoming from \",{\"t\":7,\"e\":\"strong\",\"f\":[{\"t\":2,\"r\":\"vibrate.sender\"}]}]}],\"n\":50,\"x\":{\"r\":[\"vibrate.sender\",\"sending\"],\"s\":\"_0&&!_1\"}},\" \",{\"t\":4,\"f\":[{\"t\":7,\"e\":\"div\",\"f\":[\"Sending...\"]}],\"n\":50,\"r\":\"sending\"}]}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"label\",\"f\":[\"Username: \",{\"t\":7,\"e\":\"input\",\"m\":[{\"n\":\"change\",\"f\":\"changeUser\",\"t\":70},{\"n\":\"type\",\"f\":\"input\",\"t\":13},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"vibrate.recipient\"}],\"t\":13}]}]}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"button vibrate\",\"t\":13},{\"n\":\"press\",\"f\":\"startVibrate\",\"t\":70},{\"n\":\"pressup\",\"f\":\"endVibrate\",\"t\":70}],\"f\":[{\"t\":4,\"f\":[\"SENDING\"],\"n\":50,\"r\":\"sending\"},{\"t\":4,\"n\":51,\"f\":[\"PUSH\"],\"l\":1}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"select\",\"m\":[{\"n\":\"change\",\"f\":\"selectSpeed\",\"t\":70},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"vibrate.speed\"}],\"t\":13}],\"f\":[{\"t\":7,\"e\":\"option\",\"m\":[{\"n\":\"value\",\"f\":\"200\",\"t\":13}],\"f\":[\"Fast\"]},\" \",{\"t\":7,\"e\":\"option\",\"m\":[{\"n\":\"value\",\"f\":\"500\",\"t\":13}],\"f\":[\"Medium\"]},\" \",{\"t\":7,\"e\":\"option\",\"m\":[{\"n\":\"value\",\"f\":\"1000\",\"t\":13}],\"f\":[\"Slow\"]}]}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"input\",\"m\":[{\"n\":\"change\",\"f\":\"selectSpeed\",\"t\":70},{\"n\":\"type\",\"f\":\"range\",\"t\":13},{\"n\":\"min\",\"f\":\"100\",\"t\":13},{\"n\":\"max\",\"f\":\"1000\",\"t\":13},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"vibrate.speed\"}],\"t\":13}]}]},\" \",{\"t\":7,\"e\":\"div\",\"m\":[{\"n\":\"class\",\"f\":\"form-input\",\"t\":13}],\"f\":[{\"t\":7,\"e\":\"input\",\"m\":[{\"n\":\"change\",\"f\":\"selectSpeed\",\"t\":70},{\"n\":\"type\",\"f\":\"input\",\"t\":13},{\"n\":\"value\",\"f\":[{\"t\":2,\"r\":\"vibrate.speed\"}],\"t\":13}]}]}]}]}],\"e\":{}};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ractive-loader!./app/views/root.html\n// module id = 3\n// module chunks = 0","module.exports = (function() {\n    'use strict';\n\n    var Ractive = require('ractive');\n    var template = require(\"html!./../views/components/header.html\");\n\n    function HeaderComponent(root) {\n        var component = Ractive.extend({\n            template: template,\n            oninit: function() {\n                this.on('toggleMenu',function(event) {\n                    this.toggle(\"menuOpen\");\n\n                    if (this.get(\"signupOpen\")) {\n                        this.set({signupOpen:false});\n                    }\n                });\n                this.on('toggleSignup',function(event) {\n                    console.log(\"signup\")\n                    this.toggle(\"signupOpen\");\n                    this.set(\"menuOpen\", false);\n                });\n            }\n        });\n        return component;\n    }\n\n    return HeaderComponent;\n})();\n\n\n// WEBPACK FOOTER //\n// ./app/components/header.js","module.exports = \"<header> <h1>Veebrate</h1> </header>\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/html-loader!./app/views/components/header.html\n// module id = 5\n// module chunks = 0","/*\n *   Copyright (c) 2011-2015 The original author or authors\n *   ------------------------------------------------------\n *   All rights reserved. This program and the accompanying materials\n *   are made available under the terms of the Eclipse Public License v1.0\n *   and Apache License v2.0 which accompanies this distribution.\n *\n *       The Eclipse Public License is available at\n *       http://www.eclipse.org/legal/epl-v10.html\n *\n *       The Apache License v2.0 is available at\n *       http://www.opensource.org/licenses/apache2.0.php\n *\n *   You may elect to redistribute this code under either of these licenses.\n */\n!function (factory) {\n  if (typeof require === 'function' && typeof module !== 'undefined') {\n    // CommonJS loader\n    var SockJS = require('sockjs-client');\n    if(!SockJS) {\n      throw new Error('vertx-eventbus.js requires sockjs-client, see http://sockjs.org');\n    }\n    factory(SockJS);\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD loader\n    define('vertx-eventbus', ['sockjs'], factory);\n  } else {\n    // plain old include\n    if (typeof this.SockJS === 'undefined') {\n      throw new Error('vertx-eventbus.js requires sockjs-client, see http://sockjs.org');\n    }\n\n    EventBus = factory(this.SockJS);\n  }\n}(function (SockJS) {\n\n  function makeUUID() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (a, b) {\n      return b = Math.random() * 16, (a == 'y' ? b & 3 | 8 : b | 0).toString(16);\n    });\n  }\n\n  function mergeHeaders(defaultHeaders, headers) {\n    if (defaultHeaders) {\n      if(!headers) {\n        return defaultHeaders;\n      }\n\n      for (var headerName in defaultHeaders) {\n        if (defaultHeaders.hasOwnProperty(headerName)) {\n          // user can overwrite the default headers\n          if (typeof headers[headerName] === 'undefined') {\n            headers[headerName] = defaultHeaders[headerName];\n          }\n        }\n      }\n    }\n\n    // headers are required to be a object\n    return headers || {};\n  }\n\n  /**\n   * EventBus\n   *\n   * @param url\n   * @param options\n   * @constructor\n   */\n  var EventBus = function (url, options) {\n    var self = this;\n\n    options = options || {};\n\n    var pingInterval = options.vertxbus_ping_interval || 5000;\n    var pingTimerID;\n\n    // attributes\n    this.sockJSConn = new SockJS(url, null, options);\n    this.state = EventBus.CONNECTING;\n    this.handlers = {};\n    this.replyHandlers = {};\n    this.defaultHeaders = null;\n\n    // default event handlers\n    this.onerror = function (err) {\n      try {\n        console.error(err);\n      } catch (e) {\n        // dev tools are disabled so we cannot use console on IE\n      }\n    };\n\n    var sendPing = function () {\n      self.sockJSConn.send(JSON.stringify({type: 'ping'}));\n    };\n\n    this.sockJSConn.onopen = function () {\n      // Send the first ping then send a ping every pingInterval milliseconds\n      sendPing();\n      pingTimerID = setInterval(sendPing, pingInterval);\n      self.state = EventBus.OPEN;\n      self.onopen && self.onopen();\n    };\n\n    this.sockJSConn.onclose = function (e) {\n      self.state = EventBus.CLOSED;\n      if (pingTimerID) clearInterval(pingTimerID);\n      self.onclose && self.onclose(e);\n    };\n\n    this.sockJSConn.onmessage = function (e) {\n      var json = JSON.parse(e.data);\n\n      // define a reply function on the message itself\n      if (json.replyAddress) {\n        Object.defineProperty(json, 'reply', {\n          value: function (message, headers, callback) {\n            self.send(json.replyAddress, message, headers, callback);\n          }\n        });\n      }\n\n      if (self.handlers[json.address]) {\n        // iterate all registered handlers\n        var handlers = self.handlers[json.address];\n        for (var i = 0; i < handlers.length; i++) {\n          if (json.type === 'err') {\n            handlers[i]({failureCode: json.failureCode, failureType: json.failureType, message: json.message});\n          } else {\n            handlers[i](null, json);\n          }\n        }\n      } else if (self.replyHandlers[json.address]) {\n        // Might be a reply message\n        var handler = self.replyHandlers[json.address];\n        delete self.replyHandlers[json.address];\n        if (json.type === 'err') {\n          handler({failureCode: json.failureCode, failureType: json.failureType, message: json.message});\n        } else {\n          handler(null, json);\n        }\n      } else {\n        if (json.type === 'err') {\n          self.onerror(json);\n        } else {\n          try {\n            console.warn('No handler found for message: ', json);\n          } catch (e) {\n            // dev tools are disabled so we cannot use console on IE\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Send a message\n   *\n   * @param {String} address\n   * @param {Object} message\n   * @param {Object} [headers]\n   * @param {Function} [callback]\n   */\n  EventBus.prototype.send = function (address, message, headers, callback) {\n    // are we ready?\n    if (this.state != EventBus.OPEN) {\n      throw new Error('INVALID_STATE_ERR');\n    }\n\n    if (typeof headers === 'function') {\n      callback = headers;\n      headers = {};\n    }\n\n    var envelope = {\n      type: 'send',\n      address: address,\n      headers: mergeHeaders(this.defaultHeaders, headers),\n      body: message\n    };\n\n    if (callback) {\n      var replyAddress = makeUUID();\n      envelope.replyAddress = replyAddress;\n      this.replyHandlers[replyAddress] = callback;\n    }\n\n    this.sockJSConn.send(JSON.stringify(envelope));\n  };\n\n  /**\n   * Publish a message\n   *\n   * @param {String} address\n   * @param {Object} message\n   * @param {Object} [headers]\n   */\n  EventBus.prototype.publish = function (address, message, headers) {\n    // are we ready?\n    if (this.state != EventBus.OPEN) {\n      throw new Error('INVALID_STATE_ERR');\n    }\n\n    this.sockJSConn.send(JSON.stringify({\n      type: 'publish',\n      address: address,\n      headers: mergeHeaders(this.defaultHeaders, headers),\n      body: message\n    }));\n  };\n\n  /**\n   * Register a new handler\n   *\n   * @param {String} address\n   * @param {Object} [headers]\n   * @param {Function} callback\n   */\n  EventBus.prototype.registerHandler = function (address, headers, callback) {\n    // are we ready?\n    if (this.state != EventBus.OPEN) {\n      throw new Error('INVALID_STATE_ERR');\n    }\n\n    if (typeof headers === 'function') {\n      callback = headers;\n      headers = {};\n    }\n\n    // ensure it is an array\n    if (!this.handlers[address]) {\n      this.handlers[address] = [];\n      // First handler for this address so we should register the connection\n      this.sockJSConn.send(JSON.stringify({\n        type: 'register',\n        address: address,\n        headers: mergeHeaders(this.defaultHeaders, headers)\n      }));\n    }\n\n    this.handlers[address].push(callback);\n  };\n\n  /**\n   * Unregister a handler\n   *\n   * @param {String} address\n   * @param {Object} [headers]\n   * @param {Function} callback\n   */\n  EventBus.prototype.unregisterHandler = function (address, headers, callback) {\n    // are we ready?\n    if (this.state != EventBus.OPEN) {\n      throw new Error('INVALID_STATE_ERR');\n    }\n\n    var handlers = this.handlers[address];\n\n    if (handlers) {\n\n      if (typeof headers === 'function') {\n        callback = headers;\n        headers = {};\n      }\n\n      var idx = handlers.indexOf(callback);\n      if (idx != -1) {\n        handlers.splice(idx, 1);\n        if (handlers.length === 0) {\n          // No more local handlers so we should unregister the connection\n          this.sockJSConn.send(JSON.stringify({\n            type: 'unregister',\n            address: address,\n            headers: mergeHeaders(this.defaultHeaders, headers)\n          }));\n\n          delete this.handlers[address];\n        }\n      }\n    }\n  };\n\n  /**\n   * Closes the connection to the EvenBus Bridge.\n   */\n  EventBus.prototype.close = function () {\n    this.state = EventBus.CLOSING;\n    this.sockJSConn.close();\n  };\n\n  EventBus.CONNECTING = 0;\n  EventBus.OPEN = 1;\n  EventBus.CLOSING = 2;\n  EventBus.CLOSED = 3;\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = EventBus;\n    } else {\n      exports.EventBus = EventBus;\n    }\n  } else {\n    return EventBus;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vertx3-eventbus-client/vertx-eventbus.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nvar transportList = require('./transport-list');\n\nmodule.exports = require('./main')(transportList);\n\n// TODO can't get rid of this until all servers do\nif ('_sockjs_onload' in global) {\n  setTimeout(global._sockjs_onload, 1);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/entry.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nmodule.exports = [\n  // streaming transports\n  require('./transport/websocket')\n, require('./transport/xhr-streaming')\n, require('./transport/xdr-streaming')\n, require('./transport/eventsource')\n, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))\n\n  // polling transports\n, require('./transport/htmlfile')\n, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))\n, require('./transport/xhr-polling')\n, require('./transport/xdr-polling')\n, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))\n, require('./transport/jsonp-polling')\n];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport-list.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nvar utils = require('../utils/event')\n  , urlUtils = require('../utils/url')\n  , inherits = require('inherits')\n  , EventEmitter = require('events').EventEmitter\n  , WebsocketDriver = require('./driver/websocket')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:websocket');\n}\n\nfunction WebSocketTransport(transUrl) {\n  if (!WebSocketTransport.enabled()) {\n    throw new Error('Transport created when disabled');\n  }\n\n  EventEmitter.call(this);\n  debug('constructor', transUrl);\n\n  var self = this;\n  var url = urlUtils.addPath(transUrl, '/websocket');\n  if (url.slice(0, 5) === 'https') {\n    url = 'wss' + url.slice(5);\n  } else {\n    url = 'ws' + url.slice(4);\n  }\n  this.url = url;\n\n  this.ws = new WebsocketDriver(this.url);\n  this.ws.onmessage = function(e) {\n    debug('message event', e.data);\n    self.emit('message', e.data);\n  };\n  // Firefox has an interesting bug. If a websocket connection is\n  // created after onunload, it stays alive even when user\n  // navigates away from the page. In such situation let's lie -\n  // let's not open the ws connection at all. See:\n  // https://github.com/sockjs/sockjs-client/issues/28\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n  this.unloadRef = utils.unloadAdd(function() {\n    debug('unload');\n    self.ws.close();\n  });\n  this.ws.onclose = function(e) {\n    debug('close event', e.code, e.reason);\n    self.emit('close', e.code, e.reason);\n    self._cleanup();\n  };\n  this.ws.onerror = function(e) {\n    debug('error event', e);\n    self.emit('close', 1006, 'WebSocket connection broken');\n    self._cleanup();\n  };\n}\n\ninherits(WebSocketTransport, EventEmitter);\n\nWebSocketTransport.prototype.send = function(data) {\n  var msg = '[' + data + ']';\n  debug('send', msg);\n  this.ws.send(msg);\n};\n\nWebSocketTransport.prototype.close = function() {\n  debug('close');\n  if (this.ws) {\n    this.ws.close();\n  }\n  this._cleanup();\n};\n\nWebSocketTransport.prototype._cleanup = function() {\n  debug('_cleanup');\n  var ws = this.ws;\n  if (ws) {\n    ws.onmessage = ws.onclose = ws.onerror = null;\n  }\n  utils.unloadDel(this.unloadRef);\n  this.unloadRef = this.ws = null;\n  this.removeAllListeners();\n};\n\nWebSocketTransport.enabled = function() {\n  debug('enabled');\n  return !!WebsocketDriver;\n};\nWebSocketTransport.transportName = 'websocket';\n\n// In theory, ws should require 1 round trip. But in chrome, this is\n// not very stable over SSL. Most likely a ws connection requires a\n// separate SSL connection, in which case 2 round trips are an\n// absolute minumum.\nWebSocketTransport.roundTrips = 2;\n\nmodule.exports = WebSocketTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/websocket.js\n// module id = 9\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 10\n// module chunks = 0","'use strict';\n\nvar random = require('./random');\n\nvar onUnload = {}\n  , afterUnload = false\n    // detect google chrome packaged apps because they don't allow the 'unload' event\n  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime\n  ;\n\nmodule.exports = {\n  attachEvent: function(event, listener) {\n    if (typeof global.addEventListener !== 'undefined') {\n      global.addEventListener(event, listener, false);\n    } else if (global.document && global.attachEvent) {\n      // IE quirks.\n      // According to: http://stevesouders.com/misc/test-postmessage.php\n      // the message gets delivered only to 'document', not 'window'.\n      global.document.attachEvent('on' + event, listener);\n      // I get 'window' for ie8.\n      global.attachEvent('on' + event, listener);\n    }\n  }\n\n, detachEvent: function(event, listener) {\n    if (typeof global.addEventListener !== 'undefined') {\n      global.removeEventListener(event, listener, false);\n    } else if (global.document && global.detachEvent) {\n      global.document.detachEvent('on' + event, listener);\n      global.detachEvent('on' + event, listener);\n    }\n  }\n\n, unloadAdd: function(listener) {\n    if (isChromePackagedApp) {\n      return null;\n    }\n\n    var ref = random.string(8);\n    onUnload[ref] = listener;\n    if (afterUnload) {\n      setTimeout(this.triggerUnloadCallbacks, 0);\n    }\n    return ref;\n  }\n\n, unloadDel: function(ref) {\n    if (ref in onUnload) {\n      delete onUnload[ref];\n    }\n  }\n\n, triggerUnloadCallbacks: function() {\n    for (var ref in onUnload) {\n      onUnload[ref]();\n      delete onUnload[ref];\n    }\n  }\n};\n\nvar unloadTriggered = function() {\n  if (afterUnload) {\n    return;\n  }\n  afterUnload = true;\n  module.exports.triggerUnloadCallbacks();\n};\n\n// 'unload' alone is not reliable in opera within an iframe, but we\n// can't use `beforeunload` as IE fires it on javascript: links.\nif (!isChromePackagedApp) {\n  module.exports.attachEvent('unload', unloadTriggered);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/event.js\n// module id = 11\n// module chunks = 0","'use strict';\n\n/* global crypto:true */\nvar crypto = require('crypto');\n\n// This string has length 32, a power of 2, so the modulus doesn't introduce a\n// bias.\nvar _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';\nmodule.exports = {\n  string: function(length) {\n    var max = _randomStringChars.length;\n    var bytes = crypto.randomBytes(length);\n    var ret = [];\n    for (var i = 0; i < length; i++) {\n      ret.push(_randomStringChars.substr(bytes[i] % max, 1));\n    }\n    return ret.join('');\n  }\n\n, number: function(max) {\n    return Math.floor(Math.random() * max);\n  }\n\n, numberString: function(max) {\n    var t = ('' + (max - 1)).length;\n    var p = new Array(t + 1).join('0');\n    return (p + this.number(max)).slice(-t);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/random.js\n// module id = 12\n// module chunks = 0","'use strict';\n\nif (global.crypto && global.crypto.getRandomValues) {\n  module.exports.randomBytes = function(length) {\n    var bytes = new Uint8Array(length);\n    global.crypto.getRandomValues(bytes);\n    return bytes;\n  };\n} else {\n  module.exports.randomBytes = function(length) {\n    var bytes = new Array(length);\n    for (var i = 0; i < length; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n    return bytes;\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/browser-crypto.js\n// module id = 13\n// module chunks = 0","'use strict';\n\nvar URL = require('url-parse');\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:utils:url');\n}\n\nmodule.exports = {\n  getOrigin: function(url) {\n    if (!url) {\n      return null;\n    }\n\n    var p = new URL(url);\n    if (p.protocol === 'file:') {\n      return null;\n    }\n\n    var port = p.port;\n    if (!port) {\n      port = (p.protocol === 'https:') ? '443' : '80';\n    }\n\n    return p.protocol + '//' + p.hostname + ':' + port;\n  }\n\n, isOriginEqual: function(a, b) {\n    var res = this.getOrigin(a) === this.getOrigin(b);\n    debug('same', a, b, res);\n    return res;\n  }\n\n, isSchemeEqual: function(a, b) {\n    return (a.split(':')[0] === b.split(':')[0]);\n  }\n\n, addPath: function (url, path) {\n    var qs = url.split('?');\n    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');\n  }\n\n, addQuery: function (url, q) {\n    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/url.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nvar required = require('requires-port')\n  , lolcation = require('./lolcation')\n  , qs = require('querystringify')\n  , relativere = /^\\/(?!\\/)/\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i;\n\n/**\n * These are the parse instructions for the URL parsers, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar instructions = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port'],                  // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n /**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase\n * @property {Boolean} slashes Indicates whether the protocol is followed by double slash (\"//\")\n * @property {String} rest     Rest of the URL that is not part of the protocol\n */\n\n /**\n  * Extract protocol information from a URL with/without double slash (\"//\")\n  *\n  * @param  {String} address   URL we want to extract from.\n  * @return {ProtocolExtract}  Extracted information\n  * @api private\n  */\nfunction extractProtocol(address) {\n  var match = protocolre.exec(address);\n\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3] ? match[3] : ''\n  };\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} location Location defaults for relative paths.\n * @param {Boolean|Function} parser Parser for the query string.\n * @api public\n */\nfunction URL(address, location, parser) {\n  if (!(this instanceof URL)) {\n    return new URL(address, location, parser);\n  }\n\n  var relative = relativere.test(address)\n    , parse, instruction, index, key\n    , type = typeof location\n    , url = this\n    , extracted\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) {\n    parser = qs.parse;\n  }\n\n  location = lolcation(location);\n\n  //\n  // extract protocol information before running the instructions\n  //\n  extracted = extractProtocol(address);\n  url.protocol = extracted.protocol || location.protocol || '';\n  url.slashes = extracted.slashes || location.slashes;\n  address = extracted.rest;\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if (index = parse.exec(address)) {\n      url[key] = index[1];\n      address = address.slice(0, address.length - index[0].length);\n    }\n\n    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) {\n      url[key] = url[key].toLowerCase();\n    }\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  //\n  // The href is just the compiled result.\n  //\n  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol +'//'+ url.host : 'null';\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function used to parse\n *                               the query.\n *                               When setting the protocol, double slash will be removed from\n *                               the final url if it is true.\n * @returns {URL}\n * @api public\n */\nURL.prototype.set = function set(part, value, fn) {\n  var url = this;\n\n  if ('query' === part) {\n    if ('string' === typeof value && value.length) {\n      value = (fn || qs.parse)(value);\n    }\n\n    url[part] = value;\n  } else if ('port' === part) {\n    url[part] = value;\n\n    if (!required(value, url.protocol)) {\n      url.host = url.hostname;\n      url[part] = '';\n    } else if (value) {\n      url.host = url.hostname +':'+ value;\n    }\n  } else if ('hostname' === part) {\n    url[part] = value;\n\n    if (url.port) value += ':'+ url.port;\n    url.host = value;\n  } else if ('host' === part) {\n    url[part] = value;\n\n    if (/:\\d+$/.test(value)) {\n      value = value.split(':');\n      url.port = value.pop();\n      url.hostname = value.join(':');\n    } else {\n      url.hostname = value;\n      url.port = '';\n    }\n  } else if ('protocol' === part) {\n    url.protocol = value.toLowerCase();\n    url.slashes = !fn;\n  } else {\n    url[part] = value;\n  }\n\n  for (var i = 0; i < instructions.length; i++) {\n    var ins = instructions[i];\n\n    if (ins[4]) {\n      url[ins[1]] = url[ins[1]].toLowerCase();\n    }\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol +'//'+ url.host : 'null';\n  url.href = url.toString();\n\n  return url;\n};\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String}\n * @api public\n */\nURL.prototype.toString = function toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n};\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nURL.extractProtocol = extractProtocol;\nURL.location = lolcation;\nURL.qs = qs;\n\nmodule.exports = URL;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/url-parse/index.js\n// module id = 15\n// module chunks = 0","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/requires-port/index.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nvar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 }\n  , URL;\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @api public\n */\nmodule.exports = function lolcation(loc) {\n  loc = loc || global.location || {};\n  URL = URL || require('./');\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new URL(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new URL(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/url-parse/lolcation.js\n// module id = 17\n// module chunks = 0","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  //\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n  // the lastIndex property so we can continue executing this loop until we've\n  // parsed all results.\n  //\n  for (;\n    part = parser.exec(query);\n    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n  );\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/querystringify/index.js\n// module id = 18\n// module chunks = 0","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debug/browser.js\n// module id = 19\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/debug/debug.js\n// module id = 20\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ms/index.js\n// module id = 21\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inherits/inherits_browser.js\n// module id = 22\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , EventTarget = require('./eventtarget')\n  ;\n\nfunction EventEmitter() {\n  EventTarget.call(this);\n}\n\ninherits(EventEmitter, EventTarget);\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (type) {\n    delete this._listeners[type];\n  } else {\n    this._listeners = {};\n  }\n};\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this\n    , fired = false;\n\n  function g() {\n    self.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  this.on(type, g);\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var listeners = this._listeners[type];\n  if (!listeners) {\n    return;\n  }\n  var args = Array.prototype.slice.call(arguments, 1);\n  for (var i = 0; i < listeners.length; i++) {\n    listeners[i].apply(this, args);\n  }\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;\nEventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;\n\nmodule.exports.EventEmitter = EventEmitter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/event/emitter.js\n// module id = 23\n// module chunks = 0","'use strict';\n\n/* Simplified implementation of DOM2 EventTarget.\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n */\n\nfunction EventTarget() {\n  this._listeners = {};\n}\n\nEventTarget.prototype.addEventListener = function(eventType, listener) {\n  if (!(eventType in this._listeners)) {\n    this._listeners[eventType] = [];\n  }\n  var arr = this._listeners[eventType];\n  // #4\n  if (arr.indexOf(listener) === -1) {\n    // Make a copy so as not to interfere with a current dispatchEvent.\n    arr = arr.concat([listener]);\n  }\n  this._listeners[eventType] = arr;\n};\n\nEventTarget.prototype.removeEventListener = function(eventType, listener) {\n  var arr = this._listeners[eventType];\n  if (!arr) {\n    return;\n  }\n  var idx = arr.indexOf(listener);\n  if (idx !== -1) {\n    if (arr.length > 1) {\n      // Make a copy so as not to interfere with a current dispatchEvent.\n      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));\n    } else {\n      delete this._listeners[eventType];\n    }\n    return;\n  }\n};\n\nEventTarget.prototype.dispatchEvent = function(event) {\n  var t = event.type;\n  var args = Array.prototype.slice.call(arguments, 0);\n  // TODO: This doesn't match the real behavior; per spec, onfoo get\n  // their place in line from the /first/ time they're set from\n  // non-null. Although WebKit bumps it to the end every time it's\n  // set.\n  if (this['on' + t]) {\n    this['on' + t].apply(this, args);\n  }\n  if (t in this._listeners) {\n    // Grab a reference to the listeners list. removeEventListener may alter the list.\n    var listeners = this._listeners[t];\n    for (var i = 0; i < listeners.length; i++) {\n      listeners[i].apply(this, args);\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/event/eventtarget.js\n// module id = 24\n// module chunks = 0","module.exports = global.WebSocket || global.MozWebSocket;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/browser/websocket.js\n// module id = 25\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , AjaxBasedTransport = require('./lib/ajax-based')\n  , XhrReceiver = require('./receiver/xhr')\n  , XHRCorsObject = require('./sender/xhr-cors')\n  , XHRLocalObject = require('./sender/xhr-local')\n  , browser = require('../utils/browser')\n  ;\n\nfunction XhrStreamingTransport(transUrl) {\n  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\n    throw new Error('Transport created when disabled');\n  }\n  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);\n}\n\ninherits(XhrStreamingTransport, AjaxBasedTransport);\n\nXhrStreamingTransport.enabled = function(info) {\n  if (info.nullOrigin) {\n    return false;\n  }\n  // Opera doesn't support xhr-streaming #60\n  // But it might be able to #92\n  if (browser.isOpera()) {\n    return false;\n  }\n\n  return XHRCorsObject.enabled;\n};\n\nXhrStreamingTransport.transportName = 'xhr-streaming';\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n// Safari gets confused when a streaming ajax request is started\n// before onload. This causes the load indicator to spin indefinetely.\n// Only require body when used in a browser\nXhrStreamingTransport.needBody = !!global.document;\n\nmodule.exports = XhrStreamingTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/xhr-streaming.js\n// module id = 26\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , urlUtils = require('../../utils/url')\n  , SenderReceiver = require('./sender-receiver')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:ajax-based');\n}\n\nfunction createAjaxSender(AjaxObject) {\n  return function(url, payload, callback) {\n    debug('create ajax sender', url, payload);\n    var opt = {};\n    if (typeof payload === 'string') {\n      opt.headers = {'Content-type':'text/plain'};\n    }\n    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');\n    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);\n    xo.once('finish', function(status) {\n      debug('finish', status);\n      xo = null;\n\n      if (status !== 200 && status !== 204) {\n        return callback(new Error('http status ' + status));\n      }\n      callback();\n    });\n    return function() {\n      debug('abort');\n      xo.close();\n      xo = null;\n\n      var err = new Error('Aborted');\n      err.code = 1000;\n      callback(err);\n    };\n  };\n}\n\nfunction AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {\n  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);\n}\n\ninherits(AjaxBasedTransport, SenderReceiver);\n\nmodule.exports = AjaxBasedTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/lib/ajax-based.js\n// module id = 27\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , urlUtils = require('../../utils/url')\n  , BufferedSender = require('./buffered-sender')\n  , Polling = require('./polling')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:sender-receiver');\n}\n\nfunction SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {\n  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);\n  debug(pollUrl);\n  var self = this;\n  BufferedSender.call(this, transUrl, senderFunc);\n\n  this.poll = new Polling(Receiver, pollUrl, AjaxObject);\n  this.poll.on('message', function(msg) {\n    debug('poll message', msg);\n    self.emit('message', msg);\n  });\n  this.poll.once('close', function(code, reason) {\n    debug('poll close', code, reason);\n    self.poll = null;\n    self.emit('close', code, reason);\n    self.close();\n  });\n}\n\ninherits(SenderReceiver, BufferedSender);\n\nSenderReceiver.prototype.close = function() {\n  debug('close');\n  this.removeAllListeners();\n  if (this.poll) {\n    this.poll.abort();\n    this.poll = null;\n  }\n  this.stop();\n};\n\nmodule.exports = SenderReceiver;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/lib/sender-receiver.js\n// module id = 28\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , EventEmitter = require('events').EventEmitter\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:buffered-sender');\n}\n\nfunction BufferedSender(url, sender) {\n  debug(url);\n  EventEmitter.call(this);\n  this.sendBuffer = [];\n  this.sender = sender;\n  this.url = url;\n}\n\ninherits(BufferedSender, EventEmitter);\n\nBufferedSender.prototype.send = function(message) {\n  debug('send', message);\n  this.sendBuffer.push(message);\n  if (!this.sendStop) {\n    this.sendSchedule();\n  }\n};\n\n// For polling transports in a situation when in the message callback,\n// new message is being send. If the sending connection was started\n// before receiving one, it is possible to saturate the network and\n// timeout due to the lack of receiving socket. To avoid that we delay\n// sending messages by some small time, in order to let receiving\n// connection be started beforehand. This is only a halfmeasure and\n// does not fix the big problem, but it does make the tests go more\n// stable on slow networks.\nBufferedSender.prototype.sendScheduleWait = function() {\n  debug('sendScheduleWait');\n  var self = this;\n  var tref;\n  this.sendStop = function() {\n    debug('sendStop');\n    self.sendStop = null;\n    clearTimeout(tref);\n  };\n  tref = setTimeout(function() {\n    debug('timeout');\n    self.sendStop = null;\n    self.sendSchedule();\n  }, 25);\n};\n\nBufferedSender.prototype.sendSchedule = function() {\n  debug('sendSchedule', this.sendBuffer.length);\n  var self = this;\n  if (this.sendBuffer.length > 0) {\n    var payload = '[' + this.sendBuffer.join(',') + ']';\n    this.sendStop = this.sender(this.url, payload, function(err) {\n      self.sendStop = null;\n      if (err) {\n        debug('error', err);\n        self.emit('close', err.code || 1006, 'Sending error: ' + err);\n        self._cleanup();\n      } else {\n        self.sendScheduleWait();\n      }\n    });\n    this.sendBuffer = [];\n  }\n};\n\nBufferedSender.prototype._cleanup = function() {\n  debug('_cleanup');\n  this.removeAllListeners();\n};\n\nBufferedSender.prototype.stop = function() {\n  debug('stop');\n  this._cleanup();\n  if (this.sendStop) {\n    this.sendStop();\n    this.sendStop = null;\n  }\n};\n\nmodule.exports = BufferedSender;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/lib/buffered-sender.js\n// module id = 29\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , EventEmitter = require('events').EventEmitter\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:polling');\n}\n\nfunction Polling(Receiver, receiveUrl, AjaxObject) {\n  debug(receiveUrl);\n  EventEmitter.call(this);\n  this.Receiver = Receiver;\n  this.receiveUrl = receiveUrl;\n  this.AjaxObject = AjaxObject;\n  this._scheduleReceiver();\n}\n\ninherits(Polling, EventEmitter);\n\nPolling.prototype._scheduleReceiver = function() {\n  debug('_scheduleReceiver');\n  var self = this;\n  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);\n\n  poll.on('message', function(msg) {\n    debug('message', msg);\n    self.emit('message', msg);\n  });\n\n  poll.once('close', function(code, reason) {\n    debug('close', code, reason, self.pollIsClosing);\n    self.poll = poll = null;\n\n    if (!self.pollIsClosing) {\n      if (reason === 'network') {\n        self._scheduleReceiver();\n      } else {\n        self.emit('close', code || 1006, reason);\n        self.removeAllListeners();\n      }\n    }\n  });\n};\n\nPolling.prototype.abort = function() {\n  debug('abort');\n  this.removeAllListeners();\n  this.pollIsClosing = true;\n  if (this.poll) {\n    this.poll.abort();\n  }\n};\n\nmodule.exports = Polling;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/lib/polling.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , EventEmitter = require('events').EventEmitter\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:receiver:xhr');\n}\n\nfunction XhrReceiver(url, AjaxObject) {\n  debug(url);\n  EventEmitter.call(this);\n  var self = this;\n\n  this.bufferPosition = 0;\n\n  this.xo = new AjaxObject('POST', url, null);\n  this.xo.on('chunk', this._chunkHandler.bind(this));\n  this.xo.once('finish', function(status, text) {\n    debug('finish', status, text);\n    self._chunkHandler(status, text);\n    self.xo = null;\n    var reason = status === 200 ? 'network' : 'permanent';\n    debug('close', reason);\n    self.emit('close', null, reason);\n    self._cleanup();\n  });\n}\n\ninherits(XhrReceiver, EventEmitter);\n\nXhrReceiver.prototype._chunkHandler = function(status, text) {\n  debug('_chunkHandler', status);\n  if (status !== 200 || !text) {\n    return;\n  }\n\n  for (var idx = -1; ; this.bufferPosition += idx + 1) {\n    var buf = text.slice(this.bufferPosition);\n    idx = buf.indexOf('\\n');\n    if (idx === -1) {\n      break;\n    }\n    var msg = buf.slice(0, idx);\n    if (msg) {\n      debug('message', msg);\n      this.emit('message', msg);\n    }\n  }\n};\n\nXhrReceiver.prototype._cleanup = function() {\n  debug('_cleanup');\n  this.removeAllListeners();\n};\n\nXhrReceiver.prototype.abort = function() {\n  debug('abort');\n  if (this.xo) {\n    this.xo.close();\n    debug('close');\n    this.emit('close', null, 'user');\n    this.xo = null;\n  }\n  this._cleanup();\n};\n\nmodule.exports = XhrReceiver;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/receiver/xhr.js\n// module id = 31\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , XhrDriver = require('../driver/xhr')\n  ;\n\nfunction XHRCorsObject(method, url, payload, opts) {\n  XhrDriver.call(this, method, url, payload, opts);\n}\n\ninherits(XHRCorsObject, XhrDriver);\n\nXHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;\n\nmodule.exports = XHRCorsObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/sender/xhr-cors.js\n// module id = 32\n// module chunks = 0","'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , inherits = require('inherits')\n  , utils = require('../../utils/event')\n  , urlUtils = require('../../utils/url')\n  , XHR = global.XMLHttpRequest\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:browser:xhr');\n}\n\nfunction AbstractXHRObject(method, url, payload, opts) {\n  debug(method, url);\n  var self = this;\n  EventEmitter.call(this);\n\n  setTimeout(function () {\n    self._start(method, url, payload, opts);\n  }, 0);\n}\n\ninherits(AbstractXHRObject, EventEmitter);\n\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\n  var self = this;\n\n  try {\n    this.xhr = new XHR();\n  } catch (x) {}\n\n  if (!this.xhr) {\n    debug('no xhr');\n    this.emit('finish', 0, 'no xhr support');\n    this._cleanup();\n    return;\n  }\n\n  // several browsers cache POSTs\n  url = urlUtils.addQuery(url, 't=' + (+new Date()));\n\n  // Explorer tends to keep connection open, even after the\n  // tab gets closed: http://bugs.jquery.com/ticket/5280\n  this.unloadRef = utils.unloadAdd(function() {\n    debug('unload cleanup');\n    self._cleanup(true);\n  });\n  try {\n    this.xhr.open(method, url, true);\n    if (this.timeout && 'timeout' in this.xhr) {\n      this.xhr.timeout = this.timeout;\n      this.xhr.ontimeout = function() {\n        debug('xhr timeout');\n        self.emit('finish', 0, '');\n        self._cleanup(false);\n      };\n    }\n  } catch (e) {\n    debug('exception', e);\n    // IE raises an exception on wrong port.\n    this.emit('finish', 0, '');\n    this._cleanup(false);\n    return;\n  }\n\n  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {\n    debug('withCredentials');\n    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n    // \"This never affects same-site requests.\"\n\n    this.xhr.withCredentials = 'true';\n  }\n  if (opts && opts.headers) {\n    for (var key in opts.headers) {\n      this.xhr.setRequestHeader(key, opts.headers[key]);\n    }\n  }\n\n  this.xhr.onreadystatechange = function() {\n    if (self.xhr) {\n      var x = self.xhr;\n      var text, status;\n      debug('readyState', x.readyState);\n      switch (x.readyState) {\n      case 3:\n        // IE doesn't like peeking into responseText or status\n        // on Microsoft.XMLHTTP and readystate=3\n        try {\n          status = x.status;\n          text = x.responseText;\n        } catch (e) {}\n        debug('status', status);\n        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n        if (status === 1223) {\n          status = 204;\n        }\n\n        // IE does return readystate == 3 for 404 answers.\n        if (status === 200 && text && text.length > 0) {\n          debug('chunk');\n          self.emit('chunk', status, text);\n        }\n        break;\n      case 4:\n        status = x.status;\n        debug('status', status);\n        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450\n        if (status === 1223) {\n          status = 204;\n        }\n        // IE returns this for a bad port\n        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx\n        if (status === 12005 || status === 12029) {\n          status = 0;\n        }\n\n        debug('finish', status, x.responseText);\n        self.emit('finish', status, x.responseText);\n        self._cleanup(false);\n        break;\n      }\n    }\n  };\n\n  try {\n    self.xhr.send(payload);\n  } catch (e) {\n    self.emit('finish', 0, '');\n    self._cleanup(false);\n  }\n};\n\nAbstractXHRObject.prototype._cleanup = function(abort) {\n  debug('cleanup');\n  if (!this.xhr) {\n    return;\n  }\n  this.removeAllListeners();\n  utils.unloadDel(this.unloadRef);\n\n  // IE needs this field to be a function\n  this.xhr.onreadystatechange = function() {};\n  if (this.xhr.ontimeout) {\n    this.xhr.ontimeout = null;\n  }\n\n  if (abort) {\n    try {\n      this.xhr.abort();\n    } catch (x) {}\n  }\n  this.unloadRef = this.xhr = null;\n};\n\nAbstractXHRObject.prototype.close = function() {\n  debug('close');\n  this._cleanup(true);\n};\n\nAbstractXHRObject.enabled = !!XHR;\n// override XMLHttpRequest for IE6/7\n// obfuscate to avoid firewalls\nvar axo = ['Active'].concat('Object').join('X');\nif (!AbstractXHRObject.enabled && (axo in global)) {\n  debug('overriding xmlhttprequest');\n  XHR = function() {\n    try {\n      return new global[axo]('Microsoft.XMLHTTP');\n    } catch (e) {\n      return null;\n    }\n  };\n  AbstractXHRObject.enabled = !!new XHR();\n}\n\nvar cors = false;\ntry {\n  cors = 'withCredentials' in new XHR();\n} catch (ignored) {}\n\nAbstractXHRObject.supportsCORS = cors;\n\nmodule.exports = AbstractXHRObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/browser/abstract-xhr.js\n// module id = 33\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , XhrDriver = require('../driver/xhr')\n  ;\n\nfunction XHRLocalObject(method, url, payload /*, opts */) {\n  XhrDriver.call(this, method, url, payload, {\n    noCredentials: true\n  });\n}\n\ninherits(XHRLocalObject, XhrDriver);\n\nXHRLocalObject.enabled = XhrDriver.enabled;\n\nmodule.exports = XHRLocalObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/sender/xhr-local.js\n// module id = 34\n// module chunks = 0","'use strict';\n\nmodule.exports = {\n  isOpera: function() {\n    return global.navigator &&\n      /opera/i.test(global.navigator.userAgent);\n  }\n\n, isKonqueror: function() {\n    return global.navigator &&\n      /konqueror/i.test(global.navigator.userAgent);\n  }\n\n  // #187 wrap document.domain in try/catch because of WP8 from file:///\n, hasDomain: function () {\n    // non-browser client always has a domain\n    if (!global.document) {\n      return true;\n    }\n\n    try {\n      return !!global.document.domain;\n    } catch (e) {\n      return false;\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/browser.js\n// module id = 35\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , AjaxBasedTransport = require('./lib/ajax-based')\n  , XhrReceiver = require('./receiver/xhr')\n  , XDRObject = require('./sender/xdr')\n  ;\n\n// According to:\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n\nfunction XdrStreamingTransport(transUrl) {\n  if (!XDRObject.enabled) {\n    throw new Error('Transport created when disabled');\n  }\n  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);\n}\n\ninherits(XdrStreamingTransport, AjaxBasedTransport);\n\nXdrStreamingTransport.enabled = function(info) {\n  if (info.cookie_needed || info.nullOrigin) {\n    return false;\n  }\n  return XDRObject.enabled && info.sameScheme;\n};\n\nXdrStreamingTransport.transportName = 'xdr-streaming';\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\n\nmodule.exports = XdrStreamingTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/xdr-streaming.js\n// module id = 36\n// module chunks = 0","'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , inherits = require('inherits')\n  , eventUtils = require('../../utils/event')\n  , browser = require('../../utils/browser')\n  , urlUtils = require('../../utils/url')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:sender:xdr');\n}\n\n// References:\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\n\nfunction XDRObject(method, url, payload) {\n  debug(method, url);\n  var self = this;\n  EventEmitter.call(this);\n\n  setTimeout(function() {\n    self._start(method, url, payload);\n  }, 0);\n}\n\ninherits(XDRObject, EventEmitter);\n\nXDRObject.prototype._start = function(method, url, payload) {\n  debug('_start');\n  var self = this;\n  var xdr = new global.XDomainRequest();\n  // IE caches even POSTs\n  url = urlUtils.addQuery(url, 't=' + (+new Date()));\n\n  xdr.onerror = function() {\n    debug('onerror');\n    self._error();\n  };\n  xdr.ontimeout = function() {\n    debug('ontimeout');\n    self._error();\n  };\n  xdr.onprogress = function() {\n    debug('progress', xdr.responseText);\n    self.emit('chunk', 200, xdr.responseText);\n  };\n  xdr.onload = function() {\n    debug('load');\n    self.emit('finish', 200, xdr.responseText);\n    self._cleanup(false);\n  };\n  this.xdr = xdr;\n  this.unloadRef = eventUtils.unloadAdd(function() {\n    self._cleanup(true);\n  });\n  try {\n    // Fails with AccessDenied if port number is bogus\n    this.xdr.open(method, url);\n    if (this.timeout) {\n      this.xdr.timeout = this.timeout;\n    }\n    this.xdr.send(payload);\n  } catch (x) {\n    this._error();\n  }\n};\n\nXDRObject.prototype._error = function() {\n  this.emit('finish', 0, '');\n  this._cleanup(false);\n};\n\nXDRObject.prototype._cleanup = function(abort) {\n  debug('cleanup', abort);\n  if (!this.xdr) {\n    return;\n  }\n  this.removeAllListeners();\n  eventUtils.unloadDel(this.unloadRef);\n\n  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;\n  if (abort) {\n    try {\n      this.xdr.abort();\n    } catch (x) {}\n  }\n  this.unloadRef = this.xdr = null;\n};\n\nXDRObject.prototype.close = function() {\n  debug('close');\n  this._cleanup(true);\n};\n\n// IE 8/9 if the request target uses the same scheme - #79\nXDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());\n\nmodule.exports = XDRObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/sender/xdr.js\n// module id = 37\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , AjaxBasedTransport = require('./lib/ajax-based')\n  , EventSourceReceiver = require('./receiver/eventsource')\n  , XHRCorsObject = require('./sender/xhr-cors')\n  , EventSourceDriver = require('eventsource')\n  ;\n\nfunction EventSourceTransport(transUrl) {\n  if (!EventSourceTransport.enabled()) {\n    throw new Error('Transport created when disabled');\n  }\n\n  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);\n}\n\ninherits(EventSourceTransport, AjaxBasedTransport);\n\nEventSourceTransport.enabled = function() {\n  return !!EventSourceDriver;\n};\n\nEventSourceTransport.transportName = 'eventsource';\nEventSourceTransport.roundTrips = 2;\n\nmodule.exports = EventSourceTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/eventsource.js\n// module id = 38\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , EventEmitter = require('events').EventEmitter\n  , EventSourceDriver = require('eventsource')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:receiver:eventsource');\n}\n\nfunction EventSourceReceiver(url) {\n  debug(url);\n  EventEmitter.call(this);\n\n  var self = this;\n  var es = this.es = new EventSourceDriver(url);\n  es.onmessage = function(e) {\n    debug('message', e.data);\n    self.emit('message', decodeURI(e.data));\n  };\n  es.onerror = function(e) {\n    debug('error', es.readyState, e);\n    // ES on reconnection has readyState = 0 or 1.\n    // on network error it's CLOSED = 2\n    var reason = (es.readyState !== 2 ? 'network' : 'permanent');\n    self._cleanup();\n    self._close(reason);\n  };\n}\n\ninherits(EventSourceReceiver, EventEmitter);\n\nEventSourceReceiver.prototype.abort = function() {\n  debug('abort');\n  this._cleanup();\n  this._close('user');\n};\n\nEventSourceReceiver.prototype._cleanup = function() {\n  debug('cleanup');\n  var es = this.es;\n  if (es) {\n    es.onmessage = es.onerror = null;\n    es.close();\n    this.es = null;\n  }\n};\n\nEventSourceReceiver.prototype._close = function(reason) {\n  debug('close', reason);\n  var self = this;\n  // Safari and chrome < 15 crash if we close window before\n  // waiting for ES cleanup. See:\n  // https://code.google.com/p/chromium/issues/detail?id=89155\n  setTimeout(function() {\n    self.emit('close', null, reason);\n    self.removeAllListeners();\n  }, 200);\n};\n\nmodule.exports = EventSourceReceiver;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/receiver/eventsource.js\n// module id = 39\n// module chunks = 0","module.exports = global.EventSource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/browser/eventsource.js\n// module id = 40\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , IframeTransport = require('../iframe')\n  , objectUtils = require('../../utils/object')\n  ;\n\nmodule.exports = function(transport) {\n\n  function IframeWrapTransport(transUrl, baseUrl) {\n    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);\n  }\n\n  inherits(IframeWrapTransport, IframeTransport);\n\n  IframeWrapTransport.enabled = function(url, info) {\n    if (!global.document) {\n      return false;\n    }\n\n    var iframeInfo = objectUtils.extend({}, info);\n    iframeInfo.sameOrigin = true;\n    return transport.enabled(iframeInfo) && IframeTransport.enabled();\n  };\n\n  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;\n  IframeWrapTransport.needBody = true;\n  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)\n\n  IframeWrapTransport.facadeTransport = transport;\n\n  return IframeWrapTransport;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/lib/iframe-wrap.js\n// module id = 41\n// module chunks = 0","'use strict';\n\n// Few cool transports do work only for same-origin. In order to make\n// them work cross-domain we shall use iframe, served from the\n// remote domain. New browsers have capabilities to communicate with\n// cross domain iframe using postMessage(). In IE it was implemented\n// from IE 8+, but of course, IE got some details wrong:\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n//    http://stevesouders.com/misc/test-postmessage.php\n\nvar inherits = require('inherits')\n  , JSON3 = require('json3')\n  , EventEmitter = require('events').EventEmitter\n  , version = require('../version')\n  , urlUtils = require('../utils/url')\n  , iframeUtils = require('../utils/iframe')\n  , eventUtils = require('../utils/event')\n  , random = require('../utils/random')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:transport:iframe');\n}\n\nfunction IframeTransport(transport, transUrl, baseUrl) {\n  if (!IframeTransport.enabled()) {\n    throw new Error('Transport created when disabled');\n  }\n  EventEmitter.call(this);\n\n  var self = this;\n  this.origin = urlUtils.getOrigin(baseUrl);\n  this.baseUrl = baseUrl;\n  this.transUrl = transUrl;\n  this.transport = transport;\n  this.windowId = random.string(8);\n\n  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;\n  debug(transport, transUrl, iframeUrl);\n\n  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {\n    debug('err callback');\n    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');\n    self.close();\n  });\n\n  this.onmessageCallback = this._message.bind(this);\n  eventUtils.attachEvent('message', this.onmessageCallback);\n}\n\ninherits(IframeTransport, EventEmitter);\n\nIframeTransport.prototype.close = function() {\n  debug('close');\n  this.removeAllListeners();\n  if (this.iframeObj) {\n    eventUtils.detachEvent('message', this.onmessageCallback);\n    try {\n      // When the iframe is not loaded, IE raises an exception\n      // on 'contentWindow'.\n      this.postMessage('c');\n    } catch (x) {}\n    this.iframeObj.cleanup();\n    this.iframeObj = null;\n    this.onmessageCallback = this.iframeObj = null;\n  }\n};\n\nIframeTransport.prototype._message = function(e) {\n  debug('message', e.data);\n  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {\n    debug('not same origin', e.origin, this.origin);\n    return;\n  }\n\n  var iframeMessage;\n  try {\n    iframeMessage = JSON3.parse(e.data);\n  } catch (ignored) {\n    debug('bad json', e.data);\n    return;\n  }\n\n  if (iframeMessage.windowId !== this.windowId) {\n    debug('mismatched window id', iframeMessage.windowId, this.windowId);\n    return;\n  }\n\n  switch (iframeMessage.type) {\n  case 's':\n    this.iframeObj.loaded();\n    // window global dependency\n    this.postMessage('s', JSON3.stringify([\n      version\n    , this.transport\n    , this.transUrl\n    , this.baseUrl\n    ]));\n    break;\n  case 't':\n    this.emit('message', iframeMessage.data);\n    break;\n  case 'c':\n    var cdata;\n    try {\n      cdata = JSON3.parse(iframeMessage.data);\n    } catch (ignored) {\n      debug('bad json', iframeMessage.data);\n      return;\n    }\n    this.emit('close', cdata[0], cdata[1]);\n    this.close();\n    break;\n  }\n};\n\nIframeTransport.prototype.postMessage = function(type, data) {\n  debug('postMessage', type, data);\n  this.iframeObj.post(JSON3.stringify({\n    windowId: this.windowId\n  , type: type\n  , data: data || ''\n  }), this.origin);\n};\n\nIframeTransport.prototype.send = function(message) {\n  debug('send', message);\n  this.postMessage('m', message);\n};\n\nIframeTransport.enabled = function() {\n  return iframeUtils.iframeEnabled;\n};\n\nIframeTransport.transportName = 'iframe';\nIframeTransport.roundTrips = 2;\n\nmodule.exports = IframeTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/iframe.js\n// module id = 42\n// module chunks = 0","/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = typeof define === \"function\" && define.amd;\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json3/lib/json3.js\n// module id = 43\n// module chunks = 0","module.exports = function(module) {\n\tif(!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tmodule.children = [];\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 44\n// module chunks = 0","module.exports = __webpack_amd_options__;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = 45\n// module chunks = 0","module.exports = '1.0.3';\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/version.js\n// module id = 46\n// module chunks = 0","'use strict';\n\nvar eventUtils = require('./event')\n  , JSON3 = require('json3')\n  , browser = require('./browser')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:utils:iframe');\n}\n\nmodule.exports = {\n  WPrefix: '_jp'\n, currentWindowId: null\n\n, polluteGlobalNamespace: function() {\n    if (!(module.exports.WPrefix in global)) {\n      global[module.exports.WPrefix] = {};\n    }\n  }\n\n, postMessage: function(type, data) {\n    if (global.parent !== global) {\n      global.parent.postMessage(JSON3.stringify({\n        windowId: module.exports.currentWindowId\n      , type: type\n      , data: data || ''\n      }), '*');\n    } else {\n      debug('Cannot postMessage, no parent window.', type, data);\n    }\n  }\n\n, createIframe: function(iframeUrl, errorCallback) {\n    var iframe = global.document.createElement('iframe');\n    var tref, unloadRef;\n    var unattach = function() {\n      debug('unattach');\n      clearTimeout(tref);\n      // Explorer had problems with that.\n      try {\n        iframe.onload = null;\n      } catch (x) {}\n      iframe.onerror = null;\n    };\n    var cleanup = function() {\n      debug('cleanup');\n      if (iframe) {\n        unattach();\n        // This timeout makes chrome fire onbeforeunload event\n        // within iframe. Without the timeout it goes straight to\n        // onunload.\n        setTimeout(function() {\n          if (iframe) {\n            iframe.parentNode.removeChild(iframe);\n          }\n          iframe = null;\n        }, 0);\n        eventUtils.unloadDel(unloadRef);\n      }\n    };\n    var onerror = function(err) {\n      debug('onerror', err);\n      if (iframe) {\n        cleanup();\n        errorCallback(err);\n      }\n    };\n    var post = function(msg, origin) {\n      debug('post', msg, origin);\n      try {\n        // When the iframe is not loaded, IE raises an exception\n        // on 'contentWindow'.\n        setTimeout(function() {\n          if (iframe && iframe.contentWindow) {\n            iframe.contentWindow.postMessage(msg, origin);\n          }\n        }, 0);\n      } catch (x) {}\n    };\n\n    iframe.src = iframeUrl;\n    iframe.style.display = 'none';\n    iframe.style.position = 'absolute';\n    iframe.onerror = function() {\n      onerror('onerror');\n    };\n    iframe.onload = function() {\n      debug('onload');\n      // `onload` is triggered before scripts on the iframe are\n      // executed. Give it few seconds to actually load stuff.\n      clearTimeout(tref);\n      tref = setTimeout(function() {\n        onerror('onload timeout');\n      }, 2000);\n    };\n    global.document.body.appendChild(iframe);\n    tref = setTimeout(function() {\n      onerror('timeout');\n    }, 15000);\n    unloadRef = eventUtils.unloadAdd(cleanup);\n    return {\n      post: post\n    , cleanup: cleanup\n    , loaded: unattach\n    };\n  }\n\n/* jshint undef: false, newcap: false */\n/* eslint no-undef: 0, new-cap: 0 */\n, createHtmlfile: function(iframeUrl, errorCallback) {\n    var axo = ['Active'].concat('Object').join('X');\n    var doc = new global[axo]('htmlfile');\n    var tref, unloadRef;\n    var iframe;\n    var unattach = function() {\n      clearTimeout(tref);\n      iframe.onerror = null;\n    };\n    var cleanup = function() {\n      if (doc) {\n        unattach();\n        eventUtils.unloadDel(unloadRef);\n        iframe.parentNode.removeChild(iframe);\n        iframe = doc = null;\n        CollectGarbage();\n      }\n    };\n    var onerror = function(r)  {\n      debug('onerror', r);\n      if (doc) {\n        cleanup();\n        errorCallback(r);\n      }\n    };\n    var post = function(msg, origin) {\n      try {\n        // When the iframe is not loaded, IE raises an exception\n        // on 'contentWindow'.\n        setTimeout(function() {\n          if (iframe && iframe.contentWindow) {\n              iframe.contentWindow.postMessage(msg, origin);\n          }\n        }, 0);\n      } catch (x) {}\n    };\n\n    doc.open();\n    doc.write('<html><s' + 'cript>' +\n              'document.domain=\"' + global.document.domain + '\";' +\n              '</s' + 'cript></html>');\n    doc.close();\n    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];\n    var c = doc.createElement('div');\n    doc.body.appendChild(c);\n    iframe = doc.createElement('iframe');\n    c.appendChild(iframe);\n    iframe.src = iframeUrl;\n    iframe.onerror = function() {\n      onerror('onerror');\n    };\n    tref = setTimeout(function() {\n      onerror('timeout');\n    }, 15000);\n    unloadRef = eventUtils.unloadAdd(cleanup);\n    return {\n      post: post\n    , cleanup: cleanup\n    , loaded: unattach\n    };\n  }\n};\n\nmodule.exports.iframeEnabled = false;\nif (global.document) {\n  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n  // huge delay, or not at all.\n  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||\n    typeof global.postMessage === 'object') && (!browser.isKonqueror());\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/iframe.js\n// module id = 47\n// module chunks = 0","'use strict';\n\nmodule.exports = {\n  isObject: function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  }\n\n, extend: function(obj) {\n    if (!this.isObject(obj)) {\n      return obj;\n    }\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      source = arguments[i];\n      for (prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          obj[prop] = source[prop];\n        }\n      }\n    }\n    return obj;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/object.js\n// module id = 48\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , HtmlfileReceiver = require('./receiver/htmlfile')\n  , XHRLocalObject = require('./sender/xhr-local')\n  , AjaxBasedTransport = require('./lib/ajax-based')\n  ;\n\nfunction HtmlFileTransport(transUrl) {\n  if (!HtmlfileReceiver.enabled) {\n    throw new Error('Transport created when disabled');\n  }\n  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);\n}\n\ninherits(HtmlFileTransport, AjaxBasedTransport);\n\nHtmlFileTransport.enabled = function(info) {\n  return HtmlfileReceiver.enabled && info.sameOrigin;\n};\n\nHtmlFileTransport.transportName = 'htmlfile';\nHtmlFileTransport.roundTrips = 2;\n\nmodule.exports = HtmlFileTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/htmlfile.js\n// module id = 49\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , iframeUtils = require('../../utils/iframe')\n  , urlUtils = require('../../utils/url')\n  , EventEmitter = require('events').EventEmitter\n  , random = require('../../utils/random')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:receiver:htmlfile');\n}\n\nfunction HtmlfileReceiver(url) {\n  debug(url);\n  EventEmitter.call(this);\n  var self = this;\n  iframeUtils.polluteGlobalNamespace();\n\n  this.id = 'a' + random.string(6);\n  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));\n\n  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);\n  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?\n      iframeUtils.createHtmlfile : iframeUtils.createIframe;\n\n  global[iframeUtils.WPrefix][this.id] = {\n    start: function() {\n      debug('start');\n      self.iframeObj.loaded();\n    }\n  , message: function(data) {\n      debug('message', data);\n      self.emit('message', data);\n    }\n  , stop: function() {\n      debug('stop');\n      self._cleanup();\n      self._close('network');\n    }\n  };\n  this.iframeObj = constructFunc(url, function() {\n    debug('callback');\n    self._cleanup();\n    self._close('permanent');\n  });\n}\n\ninherits(HtmlfileReceiver, EventEmitter);\n\nHtmlfileReceiver.prototype.abort = function() {\n  debug('abort');\n  this._cleanup();\n  this._close('user');\n};\n\nHtmlfileReceiver.prototype._cleanup = function() {\n  debug('_cleanup');\n  if (this.iframeObj) {\n    this.iframeObj.cleanup();\n    this.iframeObj = null;\n  }\n  delete global[iframeUtils.WPrefix][this.id];\n};\n\nHtmlfileReceiver.prototype._close = function(reason) {\n  debug('_close', reason);\n  this.emit('close', null, reason);\n  this.removeAllListeners();\n};\n\nHtmlfileReceiver.htmlfileEnabled = false;\n\n// obfuscate to avoid firewalls\nvar axo = ['Active'].concat('Object').join('X');\nif (axo in global) {\n  try {\n    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');\n  } catch (x) {}\n}\n\nHtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;\n\nmodule.exports = HtmlfileReceiver;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/receiver/htmlfile.js\n// module id = 50\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , AjaxBasedTransport = require('./lib/ajax-based')\n  , XhrReceiver = require('./receiver/xhr')\n  , XHRCorsObject = require('./sender/xhr-cors')\n  , XHRLocalObject = require('./sender/xhr-local')\n  ;\n\nfunction XhrPollingTransport(transUrl) {\n  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {\n    throw new Error('Transport created when disabled');\n  }\n  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);\n}\n\ninherits(XhrPollingTransport, AjaxBasedTransport);\n\nXhrPollingTransport.enabled = function(info) {\n  if (info.nullOrigin) {\n    return false;\n  }\n\n  if (XHRLocalObject.enabled && info.sameOrigin) {\n    return true;\n  }\n  return XHRCorsObject.enabled;\n};\n\nXhrPollingTransport.transportName = 'xhr-polling';\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\n\nmodule.exports = XhrPollingTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/xhr-polling.js\n// module id = 51\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , AjaxBasedTransport = require('./lib/ajax-based')\n  , XdrStreamingTransport = require('./xdr-streaming')\n  , XhrReceiver = require('./receiver/xhr')\n  , XDRObject = require('./sender/xdr')\n  ;\n\nfunction XdrPollingTransport(transUrl) {\n  if (!XDRObject.enabled) {\n    throw new Error('Transport created when disabled');\n  }\n  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);\n}\n\ninherits(XdrPollingTransport, AjaxBasedTransport);\n\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\nXdrPollingTransport.transportName = 'xdr-polling';\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\n\nmodule.exports = XdrPollingTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/xdr-polling.js\n// module id = 52\n// module chunks = 0","'use strict';\n\n// The simplest and most robust transport, using the well-know cross\n// domain hack - JSONP. This transport is quite inefficient - one\n// message could use up to one http request. But at least it works almost\n// everywhere.\n// Known limitations:\n//   o you will get a spinning cursor\n//   o for Konqueror a dumb timer is needed to detect errors\n\nvar inherits = require('inherits')\n  , SenderReceiver = require('./lib/sender-receiver')\n  , JsonpReceiver = require('./receiver/jsonp')\n  , jsonpSender = require('./sender/jsonp')\n  ;\n\nfunction JsonPTransport(transUrl) {\n  if (!JsonPTransport.enabled()) {\n    throw new Error('Transport created when disabled');\n  }\n  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);\n}\n\ninherits(JsonPTransport, SenderReceiver);\n\nJsonPTransport.enabled = function() {\n  return !!global.document;\n};\n\nJsonPTransport.transportName = 'jsonp-polling';\nJsonPTransport.roundTrips = 1;\nJsonPTransport.needBody = true;\n\nmodule.exports = JsonPTransport;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/jsonp-polling.js\n// module id = 53\n// module chunks = 0","'use strict';\n\nvar utils = require('../../utils/iframe')\n  , random = require('../../utils/random')\n  , browser = require('../../utils/browser')\n  , urlUtils = require('../../utils/url')\n  , inherits = require('inherits')\n  , EventEmitter = require('events').EventEmitter\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:receiver:jsonp');\n}\n\nfunction JsonpReceiver(url) {\n  debug(url);\n  var self = this;\n  EventEmitter.call(this);\n\n  utils.polluteGlobalNamespace();\n\n  this.id = 'a' + random.string(6);\n  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));\n\n  global[utils.WPrefix][this.id] = this._callback.bind(this);\n  this._createScript(urlWithId);\n\n  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n  this.timeoutId = setTimeout(function() {\n    debug('timeout');\n    self._abort(new Error('JSONP script loaded abnormally (timeout)'));\n  }, JsonpReceiver.timeout);\n}\n\ninherits(JsonpReceiver, EventEmitter);\n\nJsonpReceiver.prototype.abort = function() {\n  debug('abort');\n  if (global[utils.WPrefix][this.id]) {\n    var err = new Error('JSONP user aborted read');\n    err.code = 1000;\n    this._abort(err);\n  }\n};\n\nJsonpReceiver.timeout = 35000;\nJsonpReceiver.scriptErrorTimeout = 1000;\n\nJsonpReceiver.prototype._callback = function(data) {\n  debug('_callback', data);\n  this._cleanup();\n\n  if (this.aborting) {\n    return;\n  }\n\n  if (data) {\n    debug('message', data);\n    this.emit('message', data);\n  }\n  this.emit('close', null, 'network');\n  this.removeAllListeners();\n};\n\nJsonpReceiver.prototype._abort = function(err) {\n  debug('_abort', err);\n  this._cleanup();\n  this.aborting = true;\n  this.emit('close', err.code, err.message);\n  this.removeAllListeners();\n};\n\nJsonpReceiver.prototype._cleanup = function() {\n  debug('_cleanup');\n  clearTimeout(this.timeoutId);\n  if (this.script2) {\n    this.script2.parentNode.removeChild(this.script2);\n    this.script2 = null;\n  }\n  if (this.script) {\n    var script = this.script;\n    // Unfortunately, you can't really abort script loading of\n    // the script.\n    script.parentNode.removeChild(script);\n    script.onreadystatechange = script.onerror =\n        script.onload = script.onclick = null;\n    this.script = null;\n  }\n  delete global[utils.WPrefix][this.id];\n};\n\nJsonpReceiver.prototype._scriptError = function() {\n  debug('_scriptError');\n  var self = this;\n  if (this.errorTimer) {\n    return;\n  }\n\n  this.errorTimer = setTimeout(function() {\n    if (!self.loadedOkay) {\n      self._abort(new Error('JSONP script loaded abnormally (onerror)'));\n    }\n  }, JsonpReceiver.scriptErrorTimeout);\n};\n\nJsonpReceiver.prototype._createScript = function(url) {\n  debug('_createScript', url);\n  var self = this;\n  var script = this.script = global.document.createElement('script');\n  var script2;  // Opera synchronous load trick.\n\n  script.id = 'a' + random.string(8);\n  script.src = url;\n  script.type = 'text/javascript';\n  script.charset = 'UTF-8';\n  script.onerror = this._scriptError.bind(this);\n  script.onload = function() {\n    debug('onload');\n    self._abort(new Error('JSONP script loaded abnormally (onload)'));\n  };\n\n  // IE9 fires 'error' event after onreadystatechange or before, in random order.\n  // Use loadedOkay to determine if actually errored\n  script.onreadystatechange = function() {\n    debug('onreadystatechange', script.readyState);\n    if (/loaded|closed/.test(script.readyState)) {\n      if (script && script.htmlFor && script.onclick) {\n        self.loadedOkay = true;\n        try {\n          // In IE, actually execute the script.\n          script.onclick();\n        } catch (x) {}\n      }\n      if (script) {\n        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));\n      }\n    }\n  };\n  // IE: event/htmlFor/onclick trick.\n  // One can't rely on proper order for onreadystatechange. In order to\n  // make sure, set a 'htmlFor' and 'event' properties, so that\n  // script code will be installed as 'onclick' handler for the\n  // script object. Later, onreadystatechange, manually execute this\n  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n  // set. For reference see:\n  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n  // Also, read on that about script ordering:\n  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n  if (typeof script.async === 'undefined' && global.document.attachEvent) {\n    // According to mozilla docs, in recent browsers script.async defaults\n    // to 'true', so we may use it to detect a good browser:\n    // https://developer.mozilla.org/en/HTML/Element/script\n    if (!browser.isOpera()) {\n      // Naively assume we're in IE\n      try {\n        script.htmlFor = script.id;\n        script.event = 'onclick';\n      } catch (x) {}\n      script.async = true;\n    } else {\n      // Opera, second sync script hack\n      script2 = this.script2 = global.document.createElement('script');\n      script2.text = \"try{var a = document.getElementById('\" + script.id + \"'); if(a)a.onerror();}catch(x){};\";\n      script.async = script2.async = false;\n    }\n  }\n  if (typeof script.async !== 'undefined') {\n    script.async = true;\n  }\n\n  var head = global.document.getElementsByTagName('head')[0];\n  head.insertBefore(script, head.firstChild);\n  if (script2) {\n    head.insertBefore(script2, head.firstChild);\n  }\n};\n\nmodule.exports = JsonpReceiver;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/receiver/jsonp.js\n// module id = 54\n// module chunks = 0","'use strict';\n\nvar random = require('../../utils/random')\n  , urlUtils = require('../../utils/url')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:sender:jsonp');\n}\n\nvar form, area;\n\nfunction createIframe(id) {\n  debug('createIframe', id);\n  try {\n    // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n    return global.document.createElement('<iframe name=\"' + id + '\">');\n  } catch (x) {\n    var iframe = global.document.createElement('iframe');\n    iframe.name = id;\n    return iframe;\n  }\n}\n\nfunction createForm() {\n  debug('createForm');\n  form = global.document.createElement('form');\n  form.style.display = 'none';\n  form.style.position = 'absolute';\n  form.method = 'POST';\n  form.enctype = 'application/x-www-form-urlencoded';\n  form.acceptCharset = 'UTF-8';\n\n  area = global.document.createElement('textarea');\n  area.name = 'd';\n  form.appendChild(area);\n\n  global.document.body.appendChild(form);\n}\n\nmodule.exports = function(url, payload, callback) {\n  debug(url, payload);\n  if (!form) {\n    createForm();\n  }\n  var id = 'a' + random.string(8);\n  form.target = id;\n  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);\n\n  var iframe = createIframe(id);\n  iframe.id = id;\n  iframe.style.display = 'none';\n  form.appendChild(iframe);\n\n  try {\n    area.value = payload;\n  } catch (e) {\n    // seriously broken browsers get here\n  }\n  form.submit();\n\n  var completed = function(err) {\n    debug('completed', id, err);\n    if (!iframe.onerror) {\n      return;\n    }\n    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\n    // Opera mini doesn't like if we GC iframe\n    // immediately, thus this timeout.\n    setTimeout(function() {\n      debug('cleaning up', id);\n      iframe.parentNode.removeChild(iframe);\n      iframe = null;\n    }, 500);\n    area.value = '';\n    // It is not possible to detect if the iframe succeeded or\n    // failed to submit our form.\n    callback(err);\n  };\n  iframe.onerror = function() {\n    debug('onerror', id);\n    completed();\n  };\n  iframe.onload = function() {\n    debug('onload', id);\n    completed();\n  };\n  iframe.onreadystatechange = function(e) {\n    debug('onreadystatechange', id, iframe.readyState, e);\n    if (iframe.readyState === 'complete') {\n      completed();\n    }\n  };\n  return function() {\n    debug('aborted', id);\n    completed(new Error('Aborted'));\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/sender/jsonp.js\n// module id = 55\n// module chunks = 0","'use strict';\n\nrequire('./shims');\n\nvar URL = require('url-parse')\n  , inherits = require('inherits')\n  , JSON3 = require('json3')\n  , random = require('./utils/random')\n  , escape = require('./utils/escape')\n  , urlUtils = require('./utils/url')\n  , eventUtils = require('./utils/event')\n  , transport = require('./utils/transport')\n  , objectUtils = require('./utils/object')\n  , browser = require('./utils/browser')\n  , log = require('./utils/log')\n  , Event = require('./event/event')\n  , EventTarget = require('./event/eventtarget')\n  , loc = require('./location')\n  , CloseEvent = require('./event/close')\n  , TransportMessageEvent = require('./event/trans-message')\n  , InfoReceiver = require('./info-receiver')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  // Make debug module available globally so you can enable via the console easily\n  global.dbg = require('debug');\n  debug = global.dbg('sockjs-client:main');\n}\n\nvar transports;\n\n// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface\nfunction SockJS(url, protocols, options) {\n  if (!(this instanceof SockJS)) {\n    return new SockJS(url, protocols, options);\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'SockJS: 1 argument required, but only 0 present\");\n  }\n  EventTarget.call(this);\n\n  this.readyState = SockJS.CONNECTING;\n  this.extensions = '';\n  this.protocol = '';\n\n  // non-standard extension\n  options = options || {};\n  if (options.protocols_whitelist) {\n    log.warn(\"'protocols_whitelist' is DEPRECATED. Use 'transports' instead.\");\n  }\n  this._transportsWhitelist = options.transports;\n\n  var sessionId = options.sessionId || 8;\n  if (typeof sessionId === 'function') {\n    this._generateSessionId = sessionId;\n  } else if (typeof sessionId === 'number') {\n    this._generateSessionId = function() {\n      return random.string(sessionId);\n    };\n  } else {\n    throw new TypeError(\"If sessionId is used in the options, it needs to be a number or a function.\");\n  }\n\n  this._server = options.server || random.numberString(1000);\n\n  // Step 1 of WS spec - parse and validate the url. Issue #8\n  var parsedUrl = new URL(url);\n  if (!parsedUrl.host || !parsedUrl.protocol) {\n    throw new SyntaxError(\"The URL '\" + url + \"' is invalid\");\n  } else if (parsedUrl.hash) {\n    throw new SyntaxError('The URL must not contain a fragment');\n  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {\n    throw new SyntaxError(\"The URL's scheme must be either 'http:' or 'https:'. '\" + parsedUrl.protocol + \"' is not allowed.\");\n  }\n\n  var secure = parsedUrl.protocol === 'https:';\n  // Step 2 - don't allow secure origin with an insecure protocol\n  if (loc.protocol === 'https' && !secure) {\n    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');\n  }\n\n  // Step 3 - check port access - no need here\n  // Step 4 - parse protocols argument\n  if (!protocols) {\n    protocols = [];\n  } else if (!Array.isArray(protocols)) {\n    protocols = [protocols];\n  }\n\n  // Step 5 - check protocols argument\n  var sortedProtocols = protocols.sort();\n  sortedProtocols.forEach(function(proto, i) {\n    if (!proto) {\n      throw new SyntaxError(\"The protocols entry '\" + proto + \"' is invalid.\");\n    }\n    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {\n      throw new SyntaxError(\"The protocols entry '\" + proto + \"' is duplicated.\");\n    }\n  });\n\n  // Step 6 - convert origin\n  var o = urlUtils.getOrigin(loc.href);\n  this._origin = o ? o.toLowerCase() : null;\n\n  // remove the trailing slash\n  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\\/+$/, ''));\n\n  // store the sanitized url\n  this.url = parsedUrl.href;\n  debug('using url', this.url);\n\n  // Step 7 - start connection in background\n  // obtain server info\n  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26\n  this._urlInfo = {\n    nullOrigin: !browser.hasDomain()\n  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)\n  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)\n  };\n\n  this._ir = new InfoReceiver(this.url, this._urlInfo);\n  this._ir.once('finish', this._receiveInfo.bind(this));\n}\n\ninherits(SockJS, EventTarget);\n\nfunction userSetCode(code) {\n  return code === 1000 || (code >= 3000 && code <= 4999);\n}\n\nSockJS.prototype.close = function(code, reason) {\n  // Step 1\n  if (code && !userSetCode(code)) {\n    throw new Error('InvalidAccessError: Invalid code');\n  }\n  // Step 2.4 states the max is 123 bytes, but we are just checking length\n  if (reason && reason.length > 123) {\n    throw new SyntaxError('reason argument has an invalid length');\n  }\n\n  // Step 3.1\n  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {\n    return;\n  }\n\n  // TODO look at docs to determine how to set this\n  var wasClean = true;\n  this._close(code || 1000, reason || 'Normal closure', wasClean);\n};\n\nSockJS.prototype.send = function(data) {\n  // #13 - convert anything non-string to string\n  // TODO this currently turns objects into [object Object]\n  if (typeof data !== 'string') {\n    data = '' + data;\n  }\n  if (this.readyState === SockJS.CONNECTING) {\n    throw new Error('InvalidStateError: The connection has not been established yet');\n  }\n  if (this.readyState !== SockJS.OPEN) {\n    return;\n  }\n  this._transport.send(escape.quote(data));\n};\n\nSockJS.version = require('./version');\n\nSockJS.CONNECTING = 0;\nSockJS.OPEN = 1;\nSockJS.CLOSING = 2;\nSockJS.CLOSED = 3;\n\nSockJS.prototype._receiveInfo = function(info, rtt) {\n  debug('_receiveInfo', rtt);\n  this._ir = null;\n  if (!info) {\n    this._close(1002, 'Cannot connect to server');\n    return;\n  }\n\n  // establish a round-trip timeout (RTO) based on the\n  // round-trip time (RTT)\n  this._rto = this.countRTO(rtt);\n  // allow server to override url used for the actual transport\n  this._transUrl = info.base_url ? info.base_url : this.url;\n  info = objectUtils.extend(info, this._urlInfo);\n  debug('info', info);\n  // determine list of desired and supported transports\n  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);\n  this._transports = enabledTransports.main;\n  debug(this._transports.length + ' enabled transports');\n\n  this._connect();\n};\n\nSockJS.prototype._connect = function() {\n  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {\n    debug('attempt', Transport.transportName);\n    if (Transport.needBody) {\n      if (!global.document.body ||\n          (typeof global.document.readyState !== 'undefined' &&\n            global.document.readyState !== 'complete' &&\n            global.document.readyState !== 'interactive')) {\n        debug('waiting for body');\n        this._transports.unshift(Transport);\n        eventUtils.attachEvent('load', this._connect.bind(this));\n        return;\n      }\n    }\n\n    // calculate timeout based on RTO and round trips. Default to 5s\n    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;\n    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);\n    debug('using timeout', timeoutMs);\n\n    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());\n    debug('transport url', transportUrl);\n    var transportObj = new Transport(transportUrl, this._transUrl);\n    transportObj.on('message', this._transportMessage.bind(this));\n    transportObj.once('close', this._transportClose.bind(this));\n    transportObj.transportName = Transport.transportName;\n    this._transport = transportObj;\n\n    return;\n  }\n  this._close(2000, 'All transports failed', false);\n};\n\nSockJS.prototype._transportTimeout = function() {\n  debug('_transportTimeout');\n  if (this.readyState === SockJS.CONNECTING) {\n    this._transportClose(2007, 'Transport timed out');\n  }\n};\n\nSockJS.prototype._transportMessage = function(msg) {\n  debug('_transportMessage', msg);\n  var self = this\n    , type = msg.slice(0, 1)\n    , content = msg.slice(1)\n    , payload\n    ;\n\n  // first check for messages that don't need a payload\n  switch (type) {\n    case 'o':\n      this._open();\n      return;\n    case 'h':\n      this.dispatchEvent(new Event('heartbeat'));\n      debug('heartbeat', this.transport);\n      return;\n  }\n\n  if (content) {\n    try {\n      payload = JSON3.parse(content);\n    } catch (e) {\n      debug('bad json', content);\n    }\n  }\n\n  if (typeof payload === 'undefined') {\n    debug('empty payload', content);\n    return;\n  }\n\n  switch (type) {\n    case 'a':\n      if (Array.isArray(payload)) {\n        payload.forEach(function(p) {\n          debug('message', self.transport, p);\n          self.dispatchEvent(new TransportMessageEvent(p));\n        });\n      }\n      break;\n    case 'm':\n      debug('message', this.transport, payload);\n      this.dispatchEvent(new TransportMessageEvent(payload));\n      break;\n    case 'c':\n      if (Array.isArray(payload) && payload.length === 2) {\n        this._close(payload[0], payload[1], true);\n      }\n      break;\n  }\n};\n\nSockJS.prototype._transportClose = function(code, reason) {\n  debug('_transportClose', this.transport, code, reason);\n  if (this._transport) {\n    this._transport.removeAllListeners();\n    this._transport = null;\n    this.transport = null;\n  }\n\n  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {\n    this._connect();\n    return;\n  }\n\n  this._close(code, reason);\n};\n\nSockJS.prototype._open = function() {\n  debug('_open', this._transport.transportName, this.readyState);\n  if (this.readyState === SockJS.CONNECTING) {\n    if (this._transportTimeoutId) {\n      clearTimeout(this._transportTimeoutId);\n      this._transportTimeoutId = null;\n    }\n    this.readyState = SockJS.OPEN;\n    this.transport = this._transport.transportName;\n    this.dispatchEvent(new Event('open'));\n    debug('connected', this.transport);\n  } else {\n    // The server might have been restarted, and lost track of our\n    // connection.\n    this._close(1006, 'Server lost session');\n  }\n};\n\nSockJS.prototype._close = function(code, reason, wasClean) {\n  debug('_close', this.transport, code, reason, wasClean, this.readyState);\n  var forceFail = false;\n\n  if (this._ir) {\n    forceFail = true;\n    this._ir.close();\n    this._ir = null;\n  }\n  if (this._transport) {\n    this._transport.close();\n    this._transport = null;\n    this.transport = null;\n  }\n\n  if (this.readyState === SockJS.CLOSED) {\n    throw new Error('InvalidStateError: SockJS has already been closed');\n  }\n\n  this.readyState = SockJS.CLOSING;\n  setTimeout(function() {\n    this.readyState = SockJS.CLOSED;\n\n    if (forceFail) {\n      this.dispatchEvent(new Event('error'));\n    }\n\n    var e = new CloseEvent('close');\n    e.wasClean = wasClean || false;\n    e.code = code || 1000;\n    e.reason = reason;\n\n    this.dispatchEvent(e);\n    this.onmessage = this.onclose = this.onerror = null;\n    debug('disconnected');\n  }.bind(this), 0);\n};\n\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n// and RFC 2988.\nSockJS.prototype.countRTO = function(rtt) {\n  // In a local environment, when using IE8/9 and the `jsonp-polling`\n  // transport the time needed to establish a connection (the time that pass\n  // from the opening of the transport to the call of `_dispatchOpen`) is\n  // around 200msec (the lower bound used in the article above) and this\n  // causes spurious timeouts. For this reason we calculate a value slightly\n  // larger than that used in the article.\n  if (rtt > 100) {\n    return 4 * rtt; // rto > 400msec\n  }\n  return 300 + rtt; // 300msec < rto <= 400msec\n};\n\nmodule.exports = function(availableTransports) {\n  transports = transport(availableTransports);\n  require('./iframe-bootstrap')(SockJS, availableTransports);\n  return SockJS;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/main.js\n// module id = 56\n// module chunks = 0","/* eslint-disable */\n/* jscs: disable */\n'use strict';\n\n// pulled specific shims from https://github.com/es-shims/es5-shim\n\nvar ArrayPrototype = Array.prototype;\nvar ObjectPrototype = Object.prototype;\nvar FunctionPrototype = Function.prototype;\nvar StringPrototype = String.prototype;\nvar array_slice = ArrayPrototype.slice;\n\nvar _toString = ObjectPrototype.toString;\nvar isFunction = function (val) {\n    return ObjectPrototype.toString.call(val) === '[object Function]';\n};\nvar isArray = function isArray(obj) {\n    return _toString.call(obj) === '[object Array]';\n};\nvar isString = function isString(obj) {\n    return _toString.call(obj) === '[object String]';\n};\n\nvar supportsDescriptors = Object.defineProperty && (function () {\n    try {\n        Object.defineProperty({}, 'x', {});\n        return true;\n    } catch (e) { /* this is ES3 */\n        return false;\n    }\n}());\n\n// Define configurable, writable and non-enumerable props\n// if they don't exist.\nvar defineProperty;\nif (supportsDescriptors) {\n    defineProperty = function (object, name, method, forceAssign) {\n        if (!forceAssign && (name in object)) { return; }\n        Object.defineProperty(object, name, {\n            configurable: true,\n            enumerable: false,\n            writable: true,\n            value: method\n        });\n    };\n} else {\n    defineProperty = function (object, name, method, forceAssign) {\n        if (!forceAssign && (name in object)) { return; }\n        object[name] = method;\n    };\n}\nvar defineProperties = function (object, map, forceAssign) {\n    for (var name in map) {\n        if (ObjectPrototype.hasOwnProperty.call(map, name)) {\n          defineProperty(object, name, map[name], forceAssign);\n        }\n    }\n};\n\nvar toObject = function (o) {\n    if (o == null) { // this matches both null and undefined\n        throw new TypeError(\"can't convert \" + o + ' to object');\n    }\n    return Object(o);\n};\n\n//\n// Util\n// ======\n//\n\n// ES5 9.4\n// http://es5.github.com/#x9.4\n// http://jsperf.com/to-integer\n\nfunction toInteger(num) {\n    var n = +num;\n    if (n !== n) { // isNaN\n        n = 0;\n    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n    }\n    return n;\n}\n\nfunction ToUint32(x) {\n    return x >>> 0;\n}\n\n//\n// Function\n// ========\n//\n\n// ES-5 15.3.4.5\n// http://es5.github.com/#x15.3.4.5\n\nfunction Empty() {}\n\ndefineProperties(FunctionPrototype, {\n    bind: function bind(that) { // .length is 1\n        // 1. Let Target be the this value.\n        var target = this;\n        // 2. If IsCallable(Target) is false, throw a TypeError exception.\n        if (!isFunction(target)) {\n            throw new TypeError('Function.prototype.bind called on incompatible ' + target);\n        }\n        // 3. Let A be a new (possibly empty) internal list of all of the\n        //   argument values provided after thisArg (arg1, arg2 etc), in order.\n        // XXX slicedArgs will stand in for \"A\" if used\n        var args = array_slice.call(arguments, 1); // for normal call\n        // 4. Let F be a new native ECMAScript object.\n        // 11. Set the [[Prototype]] internal property of F to the standard\n        //   built-in Function prototype object as specified in 15.3.3.1.\n        // 12. Set the [[Call]] internal property of F as described in\n        //   15.3.4.5.1.\n        // 13. Set the [[Construct]] internal property of F as described in\n        //   15.3.4.5.2.\n        // 14. Set the [[HasInstance]] internal property of F as described in\n        //   15.3.4.5.3.\n        var binder = function () {\n\n            if (this instanceof bound) {\n                // 15.3.4.5.2 [[Construct]]\n                // When the [[Construct]] internal method of a function object,\n                // F that was created using the bind function is called with a\n                // list of arguments ExtraArgs, the following steps are taken:\n                // 1. Let target be the value of F's [[TargetFunction]]\n                //   internal property.\n                // 2. If target has no [[Construct]] internal method, a\n                //   TypeError exception is thrown.\n                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\n                //   property.\n                // 4. Let args be a new list containing the same values as the\n                //   list boundArgs in the same order followed by the same\n                //   values as the list ExtraArgs in the same order.\n                // 5. Return the result of calling the [[Construct]] internal\n                //   method of target providing args as the arguments.\n\n                var result = target.apply(\n                    this,\n                    args.concat(array_slice.call(arguments))\n                );\n                if (Object(result) === result) {\n                    return result;\n                }\n                return this;\n\n            } else {\n                // 15.3.4.5.1 [[Call]]\n                // When the [[Call]] internal method of a function object, F,\n                // which was created using the bind function is called with a\n                // this value and a list of arguments ExtraArgs, the following\n                // steps are taken:\n                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\n                //   property.\n                // 2. Let boundThis be the value of F's [[BoundThis]] internal\n                //   property.\n                // 3. Let target be the value of F's [[TargetFunction]] internal\n                //   property.\n                // 4. Let args be a new list containing the same values as the\n                //   list boundArgs in the same order followed by the same\n                //   values as the list ExtraArgs in the same order.\n                // 5. Return the result of calling the [[Call]] internal method\n                //   of target providing boundThis as the this value and\n                //   providing args as the arguments.\n\n                // equiv: target.call(this, ...boundArgs, ...args)\n                return target.apply(\n                    that,\n                    args.concat(array_slice.call(arguments))\n                );\n\n            }\n\n        };\n\n        // 15. If the [[Class]] internal property of Target is \"Function\", then\n        //     a. Let L be the length property of Target minus the length of A.\n        //     b. Set the length own property of F to either 0 or L, whichever is\n        //       larger.\n        // 16. Else set the length own property of F to 0.\n\n        var boundLength = Math.max(0, target.length - args.length);\n\n        // 17. Set the attributes of the length own property of F to the values\n        //   specified in 15.3.5.1.\n        var boundArgs = [];\n        for (var i = 0; i < boundLength; i++) {\n            boundArgs.push('$' + i);\n        }\n\n        // XXX Build a dynamic function with desired amount of arguments is the only\n        // way to set the length property of a function.\n        // In environments where Content Security Policies enabled (Chrome extensions,\n        // for ex.) all use of eval or Function costructor throws an exception.\n        // However in all of these environments Function.prototype.bind exists\n        // and so this code will never be executed.\n        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n\n        if (target.prototype) {\n            Empty.prototype = target.prototype;\n            bound.prototype = new Empty();\n            // Clean up dangling references.\n            Empty.prototype = null;\n        }\n\n        // TODO\n        // 18. Set the [[Extensible]] internal property of F to true.\n\n        // TODO\n        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\n        // 20. Call the [[DefineOwnProperty]] internal method of F with\n        //   arguments \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\n        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\n        //   false.\n        // 21. Call the [[DefineOwnProperty]] internal method of F with\n        //   arguments \"arguments\", PropertyDescriptor {[[Get]]: thrower,\n        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\n        //   and false.\n\n        // TODO\n        // NOTE Function objects created using Function.prototype.bind do not\n        // have a prototype property or the [[Code]], [[FormalParameters]], and\n        // [[Scope]] internal properties.\n        // XXX can't delete prototype in pure-js.\n\n        // 22. Return F.\n        return bound;\n    }\n});\n\n//\n// Array\n// =====\n//\n\n// ES5 15.4.3.2\n// http://es5.github.com/#x15.4.3.2\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\ndefineProperties(Array, { isArray: isArray });\n\n\nvar boxedString = Object('a');\nvar splitString = boxedString[0] !== 'a' || !(0 in boxedString);\n\nvar properlyBoxesContext = function properlyBoxed(method) {\n    // Check node 0.6.21 bug where third parameter is not boxed\n    var properlyBoxesNonStrict = true;\n    var properlyBoxesStrict = true;\n    if (method) {\n        method.call('foo', function (_, __, context) {\n            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }\n        });\n\n        method.call([1], function () {\n            'use strict';\n            properlyBoxesStrict = typeof this === 'string';\n        }, 'x');\n    }\n    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;\n};\n\ndefineProperties(ArrayPrototype, {\n    forEach: function forEach(fun /*, thisp*/) {\n        var object = toObject(this),\n            self = splitString && isString(this) ? this.split('') : object,\n            thisp = arguments[1],\n            i = -1,\n            length = self.length >>> 0;\n\n        // If no callback function or if callback is not a callable function\n        if (!isFunction(fun)) {\n            throw new TypeError(); // TODO message\n        }\n\n        while (++i < length) {\n            if (i in self) {\n                // Invoke the callback function with call, passing arguments:\n                // context, property value, property key, thisArg object\n                // context\n                fun.call(thisp, self[i], i, object);\n            }\n        }\n    }\n}, !properlyBoxesContext(ArrayPrototype.forEach));\n\n// ES5 15.4.4.14\n// http://es5.github.com/#x15.4.4.14\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\nvar hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;\ndefineProperties(ArrayPrototype, {\n    indexOf: function indexOf(sought /*, fromIndex */ ) {\n        var self = splitString && isString(this) ? this.split('') : toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n\n        var i = 0;\n        if (arguments.length > 1) {\n            i = toInteger(arguments[1]);\n        }\n\n        // handle negative indices\n        i = i >= 0 ? i : Math.max(0, length + i);\n        for (; i < length; i++) {\n            if (i in self && self[i] === sought) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}, hasFirefox2IndexOfBug);\n\n//\n// String\n// ======\n//\n\n// ES5 15.5.4.14\n// http://es5.github.com/#x15.5.4.14\n\n// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]\n// Many browsers do not split properly with regular expressions or they\n// do not perform the split correctly under obscure conditions.\n// See http://blog.stevenlevithan.com/archives/cross-browser-split\n// I've tested in many browsers and this seems to cover the deviant ones:\n//    'ab'.split(/(?:ab)*/) should be [\"\", \"\"], not [\"\"]\n//    '.'.split(/(.?)(.?)/) should be [\"\", \".\", \"\", \"\"], not [\"\", \"\"]\n//    'tesst'.split(/(s)*/) should be [\"t\", undefined, \"e\", \"s\", \"t\"], not\n//       [undefined, \"t\", undefined, \"e\", ...]\n//    ''.split(/.?/) should be [], not [\"\"]\n//    '.'.split(/()()/) should be [\".\"], not [\"\", \"\", \".\"]\n\nvar string_split = StringPrototype.split;\nif (\n    'ab'.split(/(?:ab)*/).length !== 2 ||\n    '.'.split(/(.?)(.?)/).length !== 4 ||\n    'tesst'.split(/(s)*/)[1] === 't' ||\n    'test'.split(/(?:)/, -1).length !== 4 ||\n    ''.split(/.?/).length ||\n    '.'.split(/()()/).length > 1\n) {\n    (function () {\n        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group\n\n        StringPrototype.split = function (separator, limit) {\n            var string = this;\n            if (separator === void 0 && limit === 0) {\n                return [];\n            }\n\n            // If `separator` is not a regex, use native split\n            if (_toString.call(separator) !== '[object RegExp]') {\n                return string_split.call(this, separator, limit);\n            }\n\n            var output = [],\n                flags = (separator.ignoreCase ? 'i' : '') +\n                        (separator.multiline  ? 'm' : '') +\n                        (separator.extended   ? 'x' : '') + // Proposed for ES6\n                        (separator.sticky     ? 'y' : ''), // Firefox 3+\n                lastLastIndex = 0,\n                // Make `global` and avoid `lastIndex` issues by working with a copy\n                separator2, match, lastIndex, lastLength;\n            separator = new RegExp(separator.source, flags + 'g');\n            string += ''; // Type-convert\n            if (!compliantExecNpcg) {\n                // Doesn't need flags gy, but they don't hurt\n                separator2 = new RegExp('^' + separator.source + '$(?!\\\\s)', flags);\n            }\n            /* Values for `limit`, per the spec:\n             * If undefined: 4294967295 // Math.pow(2, 32) - 1\n             * If 0, Infinity, or NaN: 0\n             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n             * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n             * If other: Type-convert, then use the above rules\n             */\n            limit = limit === void 0 ?\n                -1 >>> 0 : // Math.pow(2, 32) - 1\n                ToUint32(limit);\n            while (match = separator.exec(string)) {\n                // `separator.lastIndex` is not reliable cross-browser\n                lastIndex = match.index + match[0].length;\n                if (lastIndex > lastLastIndex) {\n                    output.push(string.slice(lastLastIndex, match.index));\n                    // Fix browsers whose `exec` methods don't consistently return `undefined` for\n                    // nonparticipating capturing groups\n                    if (!compliantExecNpcg && match.length > 1) {\n                        match[0].replace(separator2, function () {\n                            for (var i = 1; i < arguments.length - 2; i++) {\n                                if (arguments[i] === void 0) {\n                                    match[i] = void 0;\n                                }\n                            }\n                        });\n                    }\n                    if (match.length > 1 && match.index < string.length) {\n                        ArrayPrototype.push.apply(output, match.slice(1));\n                    }\n                    lastLength = match[0].length;\n                    lastLastIndex = lastIndex;\n                    if (output.length >= limit) {\n                        break;\n                    }\n                }\n                if (separator.lastIndex === match.index) {\n                    separator.lastIndex++; // Avoid an infinite loop\n                }\n            }\n            if (lastLastIndex === string.length) {\n                if (lastLength || !separator.test('')) {\n                    output.push('');\n                }\n            } else {\n                output.push(string.slice(lastLastIndex));\n            }\n            return output.length > limit ? output.slice(0, limit) : output;\n        };\n    }());\n\n// [bugfix, chrome]\n// If separator is undefined, then the result array contains just one String,\n// which is the this value (converted to a String). If limit is not undefined,\n// then the output array is truncated so that it contains no more than limit\n// elements.\n// \"0\".split(undefined, 0) -> []\n} else if ('0'.split(void 0, 0).length) {\n    StringPrototype.split = function split(separator, limit) {\n        if (separator === void 0 && limit === 0) { return []; }\n        return string_split.call(this, separator, limit);\n    };\n}\n\n// ES5 15.5.4.20\n// whitespace from: http://es5.github.io/#x15.5.4.20\nvar ws = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n    '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028' +\n    '\\u2029\\uFEFF';\nvar zeroWidth = '\\u200b';\nvar wsRegexChars = '[' + ws + ']';\nvar trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');\nvar trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');\nvar hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());\ndefineProperties(StringPrototype, {\n    // http://blog.stevenlevithan.com/archives/faster-trim-javascript\n    // http://perfectionkills.com/whitespace-deviations/\n    trim: function trim() {\n        if (this === void 0 || this === null) {\n            throw new TypeError(\"can't convert \" + this + ' to object');\n        }\n        return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');\n    }\n}, hasTrimWhitespaceBug);\n\n// ECMA-262, 3rd B.2.3\n// Not an ECMAScript standard, although ECMAScript 3rd Edition has a\n// non-normative section suggesting uniform semantics and it should be\n// normalized across all browsers\n// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE\nvar string_substr = StringPrototype.substr;\nvar hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';\ndefineProperties(StringPrototype, {\n    substr: function substr(start, length) {\n        return string_substr.call(\n            this,\n            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,\n            length\n        );\n    }\n}, hasNegativeSubstrBug);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/shims.js\n// module id = 57\n// module chunks = 0","'use strict';\n\nvar JSON3 = require('json3');\n\n// Some extra characters that Chrome gets wrong, and substitutes with\n// something else on the wire.\nvar extraEscapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g\n  , extraLookup;\n\n// This may be quite slow, so let's delay until user actually uses bad\n// characters.\nvar unrollLookup = function(escapable) {\n  var i;\n  var unrolled = {};\n  var c = [];\n  for (i = 0; i < 65536; i++) {\n    c.push( String.fromCharCode(i) );\n  }\n  escapable.lastIndex = 0;\n  c.join('').replace(escapable, function(a) {\n    unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    return '';\n  });\n  escapable.lastIndex = 0;\n  return unrolled;\n};\n\n// Quote string, also taking care of unicode characters that browsers\n// often break. Especially, take care of unicode surrogates:\n// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\nmodule.exports = {\n  quote: function(string) {\n    var quoted = JSON3.stringify(string);\n\n    // In most cases this should be very fast and good enough.\n    extraEscapable.lastIndex = 0;\n    if (!extraEscapable.test(quoted)) {\n      return quoted;\n    }\n\n    if (!extraLookup) {\n      extraLookup = unrollLookup(extraEscapable);\n    }\n\n    return quoted.replace(extraEscapable, function(a) {\n      return extraLookup[a];\n    });\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/escape.js\n// module id = 58\n// module chunks = 0","'use strict';\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:utils:transport');\n}\n\nmodule.exports = function(availableTransports) {\n  return {\n    filterToEnabled: function(transportsWhitelist, info) {\n      var transports = {\n        main: []\n      , facade: []\n      };\n      if (!transportsWhitelist) {\n        transportsWhitelist = [];\n      } else if (typeof transportsWhitelist === 'string') {\n        transportsWhitelist = [transportsWhitelist];\n      }\n\n      availableTransports.forEach(function(trans) {\n        if (!trans) {\n          return;\n        }\n\n        if (trans.transportName === 'websocket' && info.websocket === false) {\n          debug('disabled from server', 'websocket');\n          return;\n        }\n\n        if (transportsWhitelist.length &&\n            transportsWhitelist.indexOf(trans.transportName) === -1) {\n          debug('not in whitelist', trans.transportName);\n          return;\n        }\n\n        if (trans.enabled(info)) {\n          debug('enabled', trans.transportName);\n          transports.main.push(trans);\n          if (trans.facadeTransport) {\n            transports.facade.push(trans.facadeTransport);\n          }\n        } else {\n          debug('disabled', trans.transportName);\n        }\n      });\n      return transports;\n    }\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/transport.js\n// module id = 59\n// module chunks = 0","'use strict';\n\nvar logObject = {};\n['log', 'debug', 'warn'].forEach(function (level) {\n  var levelExists = global.console && global.console[level] && global.console[level].apply;\n  logObject[level] = levelExists ? function () {\n    return global.console[level].apply(global.console, arguments);\n  } : (level === 'log' ? function () {} : logObject.log);\n});\n\nmodule.exports = logObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/utils/log.js\n// module id = 60\n// module chunks = 0","'use strict';\n\nfunction Event(eventType) {\n  this.type = eventType;\n}\n\nEvent.prototype.initEvent = function(eventType, canBubble, cancelable) {\n  this.type = eventType;\n  this.bubbles = canBubble;\n  this.cancelable = cancelable;\n  this.timeStamp = +new Date();\n  return this;\n};\n\nEvent.prototype.stopPropagation = function() {};\nEvent.prototype.preventDefault  = function() {};\n\nEvent.CAPTURING_PHASE = 1;\nEvent.AT_TARGET       = 2;\nEvent.BUBBLING_PHASE  = 3;\n\nmodule.exports = Event;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/event/event.js\n// module id = 61\n// module chunks = 0","'use strict';\n\nmodule.exports = global.location || {\n  origin: 'http://localhost:80'\n, protocol: 'http'\n, host: 'localhost'\n, port: 80\n, href: 'http://localhost/'\n, hash: ''\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/location.js\n// module id = 62\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , Event = require('./event')\n  ;\n\nfunction CloseEvent() {\n  Event.call(this);\n  this.initEvent('close', false, false);\n  this.wasClean = false;\n  this.code = 0;\n  this.reason = '';\n}\n\ninherits(CloseEvent, Event);\n\nmodule.exports = CloseEvent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/event/close.js\n// module id = 63\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , Event = require('./event')\n  ;\n\nfunction TransportMessageEvent(data) {\n  Event.call(this);\n  this.initEvent('message', false, false);\n  this.data = data;\n}\n\ninherits(TransportMessageEvent, Event);\n\nmodule.exports = TransportMessageEvent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/event/trans-message.js\n// module id = 64\n// module chunks = 0","'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , inherits = require('inherits')\n  , urlUtils = require('./utils/url')\n  , XDR = require('./transport/sender/xdr')\n  , XHRCors = require('./transport/sender/xhr-cors')\n  , XHRLocal = require('./transport/sender/xhr-local')\n  , XHRFake = require('./transport/sender/xhr-fake')\n  , InfoIframe = require('./info-iframe')\n  , InfoAjax = require('./info-ajax')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:info-receiver');\n}\n\nfunction InfoReceiver(baseUrl, urlInfo) {\n  debug(baseUrl);\n  var self = this;\n  EventEmitter.call(this);\n\n  setTimeout(function() {\n    self.doXhr(baseUrl, urlInfo);\n  }, 0);\n}\n\ninherits(InfoReceiver, EventEmitter);\n\n// TODO this is currently ignoring the list of available transports and the whitelist\n\nInfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {\n  // determine method of CORS support (if needed)\n  if (urlInfo.sameOrigin) {\n    return new InfoAjax(url, XHRLocal);\n  }\n  if (XHRCors.enabled) {\n    return new InfoAjax(url, XHRCors);\n  }\n  if (XDR.enabled && urlInfo.sameScheme) {\n    return new InfoAjax(url, XDR);\n  }\n  if (InfoIframe.enabled()) {\n    return new InfoIframe(baseUrl, url);\n  }\n  return new InfoAjax(url, XHRFake);\n};\n\nInfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {\n  var self = this\n    , url = urlUtils.addPath(baseUrl, '/info')\n    ;\n  debug('doXhr', url);\n\n  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);\n\n  this.timeoutRef = setTimeout(function() {\n    debug('timeout');\n    self._cleanup(false);\n    self.emit('finish');\n  }, InfoReceiver.timeout);\n\n  this.xo.once('finish', function(info, rtt) {\n    debug('finish', info, rtt);\n    self._cleanup(true);\n    self.emit('finish', info, rtt);\n  });\n};\n\nInfoReceiver.prototype._cleanup = function(wasClean) {\n  debug('_cleanup');\n  clearTimeout(this.timeoutRef);\n  this.timeoutRef = null;\n  if (!wasClean && this.xo) {\n    this.xo.close();\n  }\n  this.xo = null;\n};\n\nInfoReceiver.prototype.close = function() {\n  debug('close');\n  this.removeAllListeners();\n  this._cleanup(false);\n};\n\nInfoReceiver.timeout = 8000;\n\nmodule.exports = InfoReceiver;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/info-receiver.js\n// module id = 65\n// module chunks = 0","'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , inherits = require('inherits')\n  ;\n\nfunction XHRFake(/* method, url, payload, opts */) {\n  var self = this;\n  EventEmitter.call(this);\n\n  this.to = setTimeout(function() {\n    self.emit('finish', 200, '{}');\n  }, XHRFake.timeout);\n}\n\ninherits(XHRFake, EventEmitter);\n\nXHRFake.prototype.close = function() {\n  clearTimeout(this.to);\n};\n\nXHRFake.timeout = 2000;\n\nmodule.exports = XHRFake;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/transport/sender/xhr-fake.js\n// module id = 66\n// module chunks = 0","'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , inherits = require('inherits')\n  , JSON3 = require('json3')\n  , utils = require('./utils/event')\n  , IframeTransport = require('./transport/iframe')\n  , InfoReceiverIframe = require('./info-iframe-receiver')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:info-iframe');\n}\n\nfunction InfoIframe(baseUrl, url) {\n  var self = this;\n  EventEmitter.call(this);\n\n  var go = function() {\n    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);\n\n    ifr.once('message', function(msg) {\n      if (msg) {\n        var d;\n        try {\n          d = JSON3.parse(msg);\n        } catch (e) {\n          debug('bad json', msg);\n          self.emit('finish');\n          self.close();\n          return;\n        }\n\n        var info = d[0], rtt = d[1];\n        self.emit('finish', info, rtt);\n      }\n      self.close();\n    });\n\n    ifr.once('close', function() {\n      self.emit('finish');\n      self.close();\n    });\n  };\n\n  // TODO this seems the same as the 'needBody' from transports\n  if (!global.document.body) {\n    utils.attachEvent('load', go);\n  } else {\n    go();\n  }\n}\n\ninherits(InfoIframe, EventEmitter);\n\nInfoIframe.enabled = function() {\n  return IframeTransport.enabled();\n};\n\nInfoIframe.prototype.close = function() {\n  if (this.ifr) {\n    this.ifr.close();\n  }\n  this.removeAllListeners();\n  this.ifr = null;\n};\n\nmodule.exports = InfoIframe;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/info-iframe.js\n// module id = 67\n// module chunks = 0","'use strict';\n\nvar inherits = require('inherits')\n  , EventEmitter = require('events').EventEmitter\n  , JSON3 = require('json3')\n  , XHRLocalObject = require('./transport/sender/xhr-local')\n  , InfoAjax = require('./info-ajax')\n  ;\n\nfunction InfoReceiverIframe(transUrl) {\n  var self = this;\n  EventEmitter.call(this);\n\n  this.ir = new InfoAjax(transUrl, XHRLocalObject);\n  this.ir.once('finish', function(info, rtt) {\n    self.ir = null;\n    self.emit('message', JSON3.stringify([info, rtt]));\n  });\n}\n\ninherits(InfoReceiverIframe, EventEmitter);\n\nInfoReceiverIframe.transportName = 'iframe-info-receiver';\n\nInfoReceiverIframe.prototype.close = function() {\n  if (this.ir) {\n    this.ir.close();\n    this.ir = null;\n  }\n  this.removeAllListeners();\n};\n\nmodule.exports = InfoReceiverIframe;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/info-iframe-receiver.js\n// module id = 68\n// module chunks = 0","'use strict';\n\nvar EventEmitter = require('events').EventEmitter\n  , inherits = require('inherits')\n  , JSON3 = require('json3')\n  , objectUtils = require('./utils/object')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:info-ajax');\n}\n\nfunction InfoAjax(url, AjaxObject) {\n  EventEmitter.call(this);\n\n  var self = this;\n  var t0 = +new Date();\n  this.xo = new AjaxObject('GET', url);\n\n  this.xo.once('finish', function(status, text) {\n    var info, rtt;\n    if (status === 200) {\n      rtt = (+new Date()) - t0;\n      if (text) {\n        try {\n          info = JSON3.parse(text);\n        } catch (e) {\n          debug('bad json', text);\n        }\n      }\n\n      if (!objectUtils.isObject(info)) {\n        info = {};\n      }\n    }\n    self.emit('finish', info, rtt);\n    self.removeAllListeners();\n  });\n}\n\ninherits(InfoAjax, EventEmitter);\n\nInfoAjax.prototype.close = function() {\n  this.removeAllListeners();\n  this.xo.close();\n};\n\nmodule.exports = InfoAjax;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/info-ajax.js\n// module id = 69\n// module chunks = 0","'use strict';\n\nvar urlUtils = require('./utils/url')\n  , eventUtils = require('./utils/event')\n  , JSON3 = require('json3')\n  , FacadeJS = require('./facade')\n  , InfoIframeReceiver = require('./info-iframe-receiver')\n  , iframeUtils = require('./utils/iframe')\n  , loc = require('./location')\n  ;\n\nvar debug = function() {};\nif (process.env.NODE_ENV !== 'production') {\n  debug = require('debug')('sockjs-client:iframe-bootstrap');\n}\n\nmodule.exports = function(SockJS, availableTransports) {\n  var transportMap = {};\n  availableTransports.forEach(function(at) {\n    if (at.facadeTransport) {\n      transportMap[at.facadeTransport.transportName] = at.facadeTransport;\n    }\n  });\n\n  // hard-coded for the info iframe\n  // TODO see if we can make this more dynamic\n  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;\n  var parentOrigin;\n\n  /* eslint-disable camelcase */\n  SockJS.bootstrap_iframe = function() {\n    /* eslint-enable camelcase */\n    var facade;\n    iframeUtils.currentWindowId = loc.hash.slice(1);\n    var onMessage = function(e) {\n      if (e.source !== parent) {\n        return;\n      }\n      if (typeof parentOrigin === 'undefined') {\n        parentOrigin = e.origin;\n      }\n      if (e.origin !== parentOrigin) {\n        return;\n      }\n\n      var iframeMessage;\n      try {\n        iframeMessage = JSON3.parse(e.data);\n      } catch (ignored) {\n        debug('bad json', e.data);\n        return;\n      }\n\n      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {\n        return;\n      }\n      switch (iframeMessage.type) {\n      case 's':\n        var p;\n        try {\n          p = JSON3.parse(iframeMessage.data);\n        } catch (ignored) {\n          debug('bad json', iframeMessage.data);\n          break;\n        }\n        var version = p[0];\n        var transport = p[1];\n        var transUrl = p[2];\n        var baseUrl = p[3];\n        debug(version, transport, transUrl, baseUrl);\n        // change this to semver logic\n        if (version !== SockJS.version) {\n          throw new Error('Incompatibile SockJS! Main site uses:' +\n                    ' \"' + version + '\", the iframe:' +\n                    ' \"' + SockJS.version + '\".');\n        }\n\n        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||\n            !urlUtils.isOriginEqual(baseUrl, loc.href)) {\n          throw new Error('Can\\'t connect to different domain from within an ' +\n                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');\n        }\n        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));\n        break;\n      case 'm':\n        facade._send(iframeMessage.data);\n        break;\n      case 'c':\n        if (facade) {\n          facade._close();\n        }\n        facade = null;\n        break;\n      }\n    };\n\n    eventUtils.attachEvent('message', onMessage);\n\n    // Start\n    iframeUtils.postMessage('s');\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/iframe-bootstrap.js\n// module id = 70\n// module chunks = 0","'use strict';\n\nvar JSON3 = require('json3')\n  , iframeUtils = require('./utils/iframe')\n  ;\n\nfunction FacadeJS(transport) {\n  this._transport = transport;\n  transport.on('message', this._transportMessage.bind(this));\n  transport.on('close', this._transportClose.bind(this));\n}\n\nFacadeJS.prototype._transportClose = function(code, reason) {\n  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));\n};\nFacadeJS.prototype._transportMessage = function(frame) {\n  iframeUtils.postMessage('t', frame);\n};\nFacadeJS.prototype._send = function(data) {\n  this._transport.send(data);\n};\nFacadeJS.prototype._close = function() {\n  this._transport.close();\n  this._transport.removeAllListeners();\n};\n\nmodule.exports = FacadeJS;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sockjs-client/lib/facade.js\n// module id = 71\n// module chunks = 0",";(function (root, factory) {\n\n  if (typeof define === 'function' && define.amd) {\n    define(['ractive', 'hammerjs'], factory);\n  }\n\n  else if (typeof module !== 'undefined') {\n    factory(require('ractive'), require('hammerjs'));\n  }\n\n  else {\n    factory(root.Ractive, root.Hammer);\n  }\n\n}(this, function (Ractive, Hammer) {\n\n  // Check the recognizers documentation.\n  // http://hammerjs.github.io/recognizer-tap\n\n  var defaults = {\n    tap: {\n      recognizerClass: Hammer.Tap,\n      options: {\n        time: 500\n      },\n      events: [\n        'tap' \n      ]\n    },\n    doubletap: {\n      recognizerClass: Hammer.Tap,\n      options: {\n        taps: 2,\n        event: 'doubletap'\n      },\n      recognizeWith: ['tap'],\n      events: [\n        'doubletap' \n      ]\n    },\n    swipe: {\n      recognizerClass: Hammer.Swipe,\n      options: {},\n      events: [\n        'swipe',\n        'swipeleft',\n        'swiperight',\n        'swipeup',\n        'swipedown' \n      ]\n    },\n    pan: {\n      recognizerClass: Hammer.Pan,\n      options: {\n        direction: Hammer.DIRECTION_HORIZONTAL\n      },\n      recognizeWith: ['swipe'],\n      events: [\n        'pan',\n        'panstart',\n        'panmove',\n        'panend',\n        'pancancel',\n        'panleft',\n        'panright',\n        'panup',\n        'pandown' \n      ]\n    },\n    press: {\n      recognizerClass: Hammer.Press,\n      options: {},\n      events: [\n        'press',\n        'pressup'\n      ]\n    },\n    rotate: {\n      recognizerClass: Hammer.Rotate,\n      options: {},\n      events: [\n        'rotate',\n        'rotatestart',\n        'rotatemove',\n        'rotateend',\n        'rotatecancel' \n      ]\n    },\n    pinch: {\n      recognizerClass: Hammer.Pinch,\n      options: {},\n      recognizeWith: ['rotate'],\n      events: [\n        'pinch',\n        'pinchstart',\n        'pinchmove',\n        'pinchend',\n        'pinchcancel',\n        'pinchin',\n        'pinchout' \n      ]\n    }\n  };\n\n  var aliases;\n\n  // bind all events using buildEvent\n  for (var recognizerName in defaults) {\n    if (!defaults.hasOwnProperty(recognizerName)) continue;\n    \n    var events = defaults[recognizerName].events;\n    for (var i = 0; i < events.length; i++) {\n      buildEvent(events[i], recognizerName, defaults[recognizerName]);\n    }\n  }\n\n  /**\n   * buildEvent : buildEvent(event, recognizerName, config)\n   * (private) registers an event handler for buildEvent.\n   *\n   *     buildEvent('panstart', 'pan', { ... });\n   */\n\n  function buildEvent(eventName, recognizerName, config) {\n    Ractive.events[eventName] = buildEventHandler(eventName, recognizerName, config);\n  }\n\n  /**\n   * buildEventHandler() : buildEventHandler(event, recognizerName, config)\n   * (private) Creates the event handler for a given `eventName` that will be\n   * registered to `Ractive.events`.\n   */\n\n  function buildEventHandler(eventName, recognizerName, config) {\n    return function (node, fire) {\n      var hammerManager = getHammerManager(node);\n\n      var recognizerExists = (hammerManager.get(recognizerName) !== null);\n\n      if (!recognizerExists) {\n        // init with default options\n        var recognizer = new config.recognizerClass(config.options);\n\n        // Hammer.Recognizer.set merges it on top of the defaults supplied above\n        var options = parseOptions(node, recognizerName);\n        if (options)\n          recognizer.set(options);\n\n        hammerManager.add(recognizer);\n        \n        updateRecognizeWith(hammerManager);\n      }\n\n      // register the handler\n      hammerManager.on(eventName, function (e) {\n        fire({\n          node: node,\n          original: e\n        });\n      });\n\n      // handle exits\n      function teardown() {\n        getHammerManager(node).destroy();\n        delete node._hammer;\n      }\n\n      return { teardown: teardown };\n    };\n  }\n\n  /**\n   * updateRecognizeWith : updateRecognizeWith(hammerManager)\n   * (private) Sets recognizeWith if defaults have it\n   *\n   * Since we add recognizers dynamically and without any strict order,\n   *  we need to guard against trying to set a requireWith for a recognizer\n   *  that haven't been created yet.\n   * \n   */\n  function updateRecognizeWith(hammerManager) {\n    for (var i = 0; i < hammerManager.recognizers.length; i++) {\n      var recognizer = hammerManager.recognizers[i];\n      var recognizerName = recognizer.options.event;\n\n      if (!defaults[recognizerName].hasOwnProperty('recognizeWith')) continue;\n      \n      var recognizeWiths = defaults[recognizerName].recognizeWith;\n      for (var k = 0; k < recognizeWiths.length; k++) {\n        // Verify that the recgonizer we're trying to depend on is really there\n        if (!hammerManager.get(recognizeWiths[k])) continue;\n\n        // It's safe to recognizeWith multiple times for the same recognizer\n        recognizer.recognizeWith(recognizeWiths[k]);\n      }\n    }\n  }\n\n  /**\n   * parseOptions : parseOptions(node, key)\n   * (private) Returns options for a given DOM node.\n   *\n   *     node = <div data-swipe-direction='left' data-swipe-threshold='2'>\n   *\n   *     parseOptions(node, 'swipe')\n   *     => { direction: 'left', threshold: 2 }\n   */\n\n  function parseOptions(node, key) {\n    var attrs = node.attributes,\n        output,\n        re = new RegExp(\"^(?:data-)?\"+key+\"-(.*)$\");\n\n    for (var i = attrs.length-1; i >= 0; i--) {\n      var attr = attrs[i],\n          m = attr.name.match(re);\n\n      if (!m) continue;\n      if (!output) output = {};\n      output[m[1]] = parseHammerValue(attr.value, m[1]);\n    }\n\n    return output;\n  }\n\n  /**\n   * parseHammerValue : parseHammerValue(str, key)\n   * (private) Value-izes a given string `str`, converting it to a number as\n   * needed. If `key` is given, it can also resolve aliases for that given\n   * key.\n   *\n   * Used by `getData()`. \n   *\n   *     parseHammerValue(\"100\")   => 100\n   *     parseHammerValue(\"right\") => \"right\"\n   *     parseHammerValue(\"right\", \"direction\") => Hammer.DIRECTION_RIGHT\n   */\n\n  function parseHammerValue(str, key) {\n    if (str.match && str.match(/^-?\\d+(?:\\.\\d+)?$/)) return +str;\n    return (aliases[key] && aliases[key][str]) ||\n      aliases.all[str] || str;\n  }\n\n  /*\n   * Aliases for `val()`.\n   */\n\n  aliases = {\n    all: {\n      'true': true,\n      'false': false,\n      'undefined': undefined,\n      'null': null\n    },\n    direction: {\n      'none': Hammer.DIRECTION_NONE,\n      'all': Hammer.DIRECTION_ALL,\n      'up': Hammer.DIRECTION_UP,\n      'down': Hammer.DIRECTION_DOWN,\n      'left': Hammer.DIRECTION_LEFT,\n      'right': Hammer.DIRECTION_RIGHT,\n      'horizontal': Hammer.DIRECTION_HORIZONTAL,\n      'vertical': Hammer.DIRECTION_VERTICAL\n    }\n  };\n\n  /**\n   * getHammerManager : getHammerManager(node)\n   * (private) Returns the `HammerManager` instance for the given node.\n   */\n\n  function getHammerManager(node) {\n    if (node._hammer) return node._hammer;\n\n    node._hammer = new Hammer.Manager(node, {recognizers: []});\n    return node._hammer;\n  }\n\n\n  return {defaults: defaults};\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ractive-touch/index.js\n// module id = 72\n// module chunks = 0","/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function(window, document, exportName, undefined) {\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function() {\n        var e = new Error('get-stack-trace');\n        var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n            .replace(/^\\s+at\\s+/gm, '')\n            .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n        var log = window.console && (window.console.warn || window.console.log);\n        if (log) {\n            log.call(window.console, deprecationMessage, stack);\n        }\n        return method.apply(this, arguments);\n    };\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n        if (target === undefined || target === null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n\n        var output = Object(target);\n        for (var index = 1; index < arguments.length; index++) {\n            var source = arguments[index];\n            if (source !== undefined && source !== null) {\n                for (var nextKey in source) {\n                    if (source.hasOwnProperty(nextKey)) {\n                        output[nextKey] = source[nextKey];\n                    }\n                }\n            }\n        }\n        return output;\n    };\n} else {\n    assign = Object.assign;\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nvar extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nvar merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        assign(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return (doc.defaultView || doc.parentWindow || window);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = input.deltaX - last.deltaX;\n        var deltaY = input.deltaY - last.deltaY;\n\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down\n        if (!this.pressed) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n\n    this.primaryTouch = null;\n    this.lastTouches = [];\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n            return;\n        }\n\n        // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n        if (isTouch) {\n            recordTouches.call(this, inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n            return;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nfunction recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n        this.primaryTouch = eventData.changedPointers[0].identifier;\n        setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        setLastTouch.call(this, eventData);\n    }\n}\n\nfunction setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n        var lastTouch = {x: touch.clientX, y: touch.clientY};\n        this.lastTouches.push(lastTouch);\n        var lts = this.lastTouches;\n        var removeLastTouch = function() {\n            var i = lts.indexOf(lastTouch);\n            if (i > -1) {\n                lts.splice(i, 1);\n            }\n        };\n        setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n}\n\nfunction isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;\n    for (var i = 0; i < this.lastTouches.length; i++) {\n        var t = this.lastTouches[i];\n        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);\n        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n        if (hasNone) {\n            //do not prevent defaults if this is a tap gesture\n\n            var isTapPointer = input.pointers.length === 1;\n            var isTapMovement = input.distance < 2;\n            var isTapTouchTime = input.deltaTime < 250;\n\n            if (isTapPointer && isTapMovement && isTapTouchTime) {\n                return;\n            }\n        }\n\n        if (hasPanX && hasPanY) {\n            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n            return;\n        }\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\nfunction getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n        return false;\n    }\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {\n\n        // If css.supports is not supported but there is native touch-action assume it supports\n        // all values. This is the case for IE 10 and 11.\n        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(event) {\n            self.manager.emit(event, input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n\n        emit(self.options.event); // simple 'eventName' events\n\n        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n            emit(input.additionalEvent);\n        }\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(self.options.event + stateStr(state));\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = assign({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n\n        if (direction) {\n            input.additionalEvent = this.options.event + direction;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            input.additionalEvent = this.options.event + inOut;\n        }\n        this._super.emit.call(this, input);\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 251, // minimal time of the pointer to be pressed\n        threshold: 9 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.3,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.overallVelocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.overallVelocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.overallVelocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.offsetDirection &&\n            input.distance > this.options.threshold &&\n            input.maxPointers == this.options.pointers &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.offsetDirection);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 9, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.7';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, {enable: false}],\n        [PinchRecognizer, {enable: false}, ['rotate']],\n        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],\n        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        assign(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        recognizer = this.get(recognizer);\n\n        // let's make sure this recognizer exists\n        if (recognizer) {\n            var recognizers = this.recognizers;\n            var index = inArray(recognizers, recognizer);\n\n            if (index !== -1) {\n                recognizers.splice(index, 1);\n                this.touchAction.update();\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n        if (handler === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        if (events === undefined) {\n            return;\n        }\n\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    if (!element.style) {\n        return;\n    }\n    var prop;\n    each(manager.options.cssProps, function(value, name) {\n        prop = prefixed(element.style, name);\n        if (add) {\n            manager.oldCssProps[prop] = element.style[prop];\n            element.style[prop] = value;\n        } else {\n            element.style[prop] = manager.oldCssProps[prop] || '';\n        }\n    });\n    if (!add) {\n        manager.oldCssProps = {};\n    }\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nassign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\nvar freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line\nfreeGlobal.Hammer = Hammer;\n\nif (typeof define === 'function' && define.amd) {\n    define(function() {\n        return Hammer;\n    });\n} else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n} else {\n    window[exportName] = Hammer;\n}\n\n})(window, document, 'Hammer');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/hammerjs/hammer.js\n// module id = 73\n// module chunks = 0","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\tglobal.Ractive.events.tap = factory()\n}(this, function () { 'use strict';\n\n\t// maximum milliseconds between down and up before cancel\n\n\tvar ractive_events_tap = tap;\n\n\tvar DISTANCE_THRESHOLD = 5; // maximum pixels pointer can move before cancel\n\tvar TIME_THRESHOLD = 400;\n\tfunction tap(node, callback) {\n\t\treturn new ractive_events_tap__TapHandler(node, callback);\n\t}\n\n\tvar ractive_events_tap__TapHandler = function ractive_events_tap__TapHandler(node, callback) {\n\t\tthis.node = node;\n\t\tthis.callback = callback;\n\n\t\tthis.preventMousedownEvents = false;\n\n\t\tthis.bind(node);\n\t};\n\n\tractive_events_tap__TapHandler.prototype = {\n\t\tbind: function bind(node) {\n\t\t\t// listen for mouse/pointer events...\n\t\t\tif (window.navigator.pointerEnabled) {\n\t\t\t\tnode.addEventListener(\"pointerdown\", handleMousedown, false);\n\t\t\t} else if (window.navigator.msPointerEnabled) {\n\t\t\t\tnode.addEventListener(\"MSPointerDown\", handleMousedown, false);\n\t\t\t} else {\n\t\t\t\tnode.addEventListener(\"mousedown\", handleMousedown, false);\n\t\t\t}\n\n\t\t\t// ...and touch events\n\t\t\tnode.addEventListener(\"touchstart\", handleTouchstart, false);\n\n\t\t\t// native buttons, and <input type='button'> elements, should fire a tap event\n\t\t\t// when the space key is pressed\n\t\t\tif (node.tagName === \"BUTTON\" || node.type === \"button\") {\n\t\t\t\tnode.addEventListener(\"focus\", handleFocus, false);\n\t\t\t}\n\n\t\t\tnode.__tap_handler__ = this;\n\t\t},\n\n\t\tfire: function fire(event, x, y) {\n\t\t\tthis.callback({\n\t\t\t\tnode: this.node,\n\t\t\t\toriginal: event,\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\t\t},\n\n\t\tmousedown: function mousedown(event) {\n\t\t\tvar _this = this;\n\n\t\t\tif (this.preventMousedownEvents) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (event.which !== undefined && event.which !== 1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar x = event.clientX;\n\t\t\tvar y = event.clientY;\n\n\t\t\t// This will be null for mouse events.\n\t\t\tvar pointerId = event.pointerId;\n\n\t\t\tvar handleMouseup = function (event) {\n\t\t\t\tif (event.pointerId != pointerId) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_this.fire(event, x, y);\n\t\t\t\tcancel();\n\t\t\t};\n\n\t\t\tvar handleMousemove = function (event) {\n\t\t\t\tif (event.pointerId != pointerId) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (Math.abs(event.clientX - x) >= DISTANCE_THRESHOLD || Math.abs(event.clientY - y) >= DISTANCE_THRESHOLD) {\n\t\t\t\t\tcancel();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar cancel = function () {\n\t\t\t\t_this.node.removeEventListener(\"MSPointerUp\", handleMouseup, false);\n\t\t\t\tdocument.removeEventListener(\"MSPointerMove\", handleMousemove, false);\n\t\t\t\tdocument.removeEventListener(\"MSPointerCancel\", cancel, false);\n\t\t\t\t_this.node.removeEventListener(\"pointerup\", handleMouseup, false);\n\t\t\t\tdocument.removeEventListener(\"pointermove\", handleMousemove, false);\n\t\t\t\tdocument.removeEventListener(\"pointercancel\", cancel, false);\n\t\t\t\t_this.node.removeEventListener(\"click\", handleMouseup, false);\n\t\t\t\tdocument.removeEventListener(\"mousemove\", handleMousemove, false);\n\t\t\t};\n\n\t\t\tif (window.navigator.pointerEnabled) {\n\t\t\t\tthis.node.addEventListener(\"pointerup\", handleMouseup, false);\n\t\t\t\tdocument.addEventListener(\"pointermove\", handleMousemove, false);\n\t\t\t\tdocument.addEventListener(\"pointercancel\", cancel, false);\n\t\t\t} else if (window.navigator.msPointerEnabled) {\n\t\t\t\tthis.node.addEventListener(\"MSPointerUp\", handleMouseup, false);\n\t\t\t\tdocument.addEventListener(\"MSPointerMove\", handleMousemove, false);\n\t\t\t\tdocument.addEventListener(\"MSPointerCancel\", cancel, false);\n\t\t\t} else {\n\t\t\t\tthis.node.addEventListener(\"click\", handleMouseup, false);\n\t\t\t\tdocument.addEventListener(\"mousemove\", handleMousemove, false);\n\t\t\t}\n\n\t\t\tsetTimeout(cancel, TIME_THRESHOLD);\n\t\t},\n\n\t\ttouchdown: function touchdown() {\n\t\t\tvar _this = this;\n\n\t\t\tvar touch = event.touches[0];\n\n\t\t\tvar x = touch.clientX;\n\t\t\tvar y = touch.clientY;\n\n\t\t\tvar finger = touch.identifier;\n\n\t\t\tvar handleTouchup = function (event) {\n\t\t\t\tvar touch = event.changedTouches[0];\n\n\t\t\t\tif (touch.identifier !== finger) {\n\t\t\t\t\tcancel();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tevent.preventDefault(); // prevent compatibility mouse event\n\n\t\t\t\t// for the benefit of mobile Firefox and old Android browsers, we need this absurd hack.\n\t\t\t\t_this.preventMousedownEvents = true;\n\t\t\t\tclearTimeout(_this.preventMousedownTimeout);\n\n\t\t\t\t_this.preventMousedownTimeout = setTimeout(function () {\n\t\t\t\t\t_this.preventMousedownEvents = false;\n\t\t\t\t}, 400);\n\n\t\t\t\t_this.fire(event, x, y);\n\t\t\t\tcancel();\n\t\t\t};\n\n\t\t\tvar handleTouchmove = function (event) {\n\t\t\t\tvar touch;\n\n\t\t\t\tif (event.touches.length !== 1 || event.touches[0].identifier !== finger) {\n\t\t\t\t\tcancel();\n\t\t\t\t}\n\n\t\t\t\ttouch = event.touches[0];\n\t\t\t\tif (Math.abs(touch.clientX - x) >= DISTANCE_THRESHOLD || Math.abs(touch.clientY - y) >= DISTANCE_THRESHOLD) {\n\t\t\t\t\tcancel();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar cancel = function () {\n\t\t\t\t_this.node.removeEventListener(\"touchend\", handleTouchup, false);\n\t\t\t\twindow.removeEventListener(\"touchmove\", handleTouchmove, false);\n\t\t\t\twindow.removeEventListener(\"touchcancel\", cancel, false);\n\t\t\t};\n\n\t\t\tthis.node.addEventListener(\"touchend\", handleTouchup, false);\n\t\t\twindow.addEventListener(\"touchmove\", handleTouchmove, false);\n\t\t\twindow.addEventListener(\"touchcancel\", cancel, false);\n\n\t\t\tsetTimeout(cancel, TIME_THRESHOLD);\n\t\t},\n\n\t\tteardown: function teardown() {\n\t\t\tvar node = this.node;\n\n\t\t\tnode.removeEventListener(\"pointerdown\", handleMousedown, false);\n\t\t\tnode.removeEventListener(\"MSPointerDown\", handleMousedown, false);\n\t\t\tnode.removeEventListener(\"mousedown\", handleMousedown, false);\n\t\t\tnode.removeEventListener(\"touchstart\", handleTouchstart, false);\n\t\t\tnode.removeEventListener(\"focus\", handleFocus, false);\n\t\t}\n\t};\n\n\tfunction handleMousedown(event) {\n\t\tthis.__tap_handler__.mousedown(event);\n\t}\n\n\tfunction handleTouchstart(event) {\n\t\tthis.__tap_handler__.touchdown(event);\n\t}\n\n\tfunction handleFocus() {\n\t\tthis.addEventListener(\"keydown\", handleKeydown, false);\n\t\tthis.addEventListener(\"blur\", handleBlur, false);\n\t}\n\n\tfunction handleBlur() {\n\t\tthis.removeEventListener(\"keydown\", handleKeydown, false);\n\t\tthis.removeEventListener(\"blur\", handleBlur, false);\n\t}\n\n\tfunction handleKeydown(event) {\n\t\tif (event.which === 32) {\n\t\t\t// space key\n\t\t\tthis.__tap_handler__.fire();\n\t\t}\n\t}\n\n\treturn ractive_events_tap;\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ractive-events-tap/dist/ractive-events-tap.js\n// module id = 75\n// module chunks = 0"],"sourceRoot":""}